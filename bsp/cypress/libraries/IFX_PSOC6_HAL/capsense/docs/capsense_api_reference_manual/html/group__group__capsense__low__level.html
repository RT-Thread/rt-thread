<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAPSENSE&trade; Middleware Library 3.0: Low-level Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAPSENSE&trade; Middleware Library 3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__capsense__low__level.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Low-level Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The Low-level functions represent the lower layer of abstraction in support of <a class="el" href="group__group__capsense__high__level.html">High-level Functions</a>. </p>
<p>These functions also enable implementation of special case designs requiring performance optimization and non-typical functionalities.</p>
<p>All functions are general to all sensing methods. Some of the functions detect the sensing method used by the widget and execute tasks as appropriate. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafbfe743a98bd2c24a623a2c734c03f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e">Cy_CapSense_ProcessWidgetExt</a> (uint32_t widgetId, uint32_t mode, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gafbfe743a98bd2c24a623a2c734c03f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs customized data processing on the selected widget.  <a href="#gafbfe743a98bd2c24a623a2c734c03f0e">More...</a><br /></td></tr>
<tr class="separator:gafbfe743a98bd2c24a623a2c734c03f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d3f6e7d7fbef845ab4eb575e653dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec">Cy_CapSense_ProcessSensorExt</a> (uint32_t widgetId, uint32_t sensorId, uint32_t mode, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga05d3f6e7d7fbef845ab4eb575e653dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs customized data processing on the selected sensor.  <a href="#ga05d3f6e7d7fbef845ab4eb575e653dec">More...</a><br /></td></tr>
<tr class="separator:ga05d3f6e7d7fbef845ab4eb575e653dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55216d9c145b2ab42d7cec23960fb31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga55216d9c145b2ab42d7cec23960fb31e">Cy_CapSense_InitializeAllBaselines</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga55216d9c145b2ab42d7cec23960fb31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the baselines of all the sensors of all the widgets.  <a href="#ga55216d9c145b2ab42d7cec23960fb31e">More...</a><br /></td></tr>
<tr class="separator:ga55216d9c145b2ab42d7cec23960fb31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae217c3d40eff007bf28add89814f17d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gae217c3d40eff007bf28add89814f17d2">Cy_CapSense_InitializeWidgetBaseline</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gae217c3d40eff007bf28add89814f17d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the baselines of all the sensors in a specific widget.  <a href="#gae217c3d40eff007bf28add89814f17d2">More...</a><br /></td></tr>
<tr class="separator:gae217c3d40eff007bf28add89814f17d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695fc72a3809224e52c8a0212835d4f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga695fc72a3809224e52c8a0212835d4f7">Cy_CapSense_InitializeSensorBaseline</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga695fc72a3809224e52c8a0212835d4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the baseline of a sensor in a widget specified by the input parameters.  <a href="#ga695fc72a3809224e52c8a0212835d4f7">More...</a><br /></td></tr>
<tr class="separator:ga695fc72a3809224e52c8a0212835d4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fcb002d0216bb96ab818276954606e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga1fcb002d0216bb96ab818276954606e7">Cy_CapSense_InitializeAllFilters</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1fcb002d0216bb96ab818276954606e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes (or re-initializes) all the firmware filter history, except the baseline.  <a href="#ga1fcb002d0216bb96ab818276954606e7">More...</a><br /></td></tr>
<tr class="separator:ga1fcb002d0216bb96ab818276954606e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga101174469c4b6a2df8d44bddb0e33fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga101174469c4b6a2df8d44bddb0e33fcf">Cy_CapSense_InitializeWidgetFilter</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga101174469c4b6a2df8d44bddb0e33fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified by the input parameter.  <a href="#ga101174469c4b6a2df8d44bddb0e33fcf">More...</a><br /></td></tr>
<tr class="separator:ga101174469c4b6a2df8d44bddb0e33fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d2e232d2e5247954a15a45de62d235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga76d2e232d2e5247954a15a45de62d235">Cy_CapSense_UpdateAllBaselines</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga76d2e232d2e5247954a15a45de62d235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the baseline for all the sensors in all the widgets.  <a href="#ga76d2e232d2e5247954a15a45de62d235">More...</a><br /></td></tr>
<tr class="separator:ga76d2e232d2e5247954a15a45de62d235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53420b198a6de128b82b3edb31f250c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga53420b198a6de128b82b3edb31f250c6">Cy_CapSense_UpdateWidgetBaseline</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga53420b198a6de128b82b3edb31f250c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the baselines for all the sensors in a widget specified by the input parameter.  <a href="#ga53420b198a6de128b82b3edb31f250c6">More...</a><br /></td></tr>
<tr class="separator:ga53420b198a6de128b82b3edb31f250c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2ceb23fa0e3731878ad777f39474d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga4d2ceb23fa0e3731878ad777f39474d2">Cy_CapSense_UpdateSensorBaseline</a> (uint32_t widgetId, uint32_t sensorId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga4d2ceb23fa0e3731878ad777f39474d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the baseline for a sensor in a widget specified by the input parameters.  <a href="#ga4d2ceb23fa0e3731878ad777f39474d2">More...</a><br /></td></tr>
<tr class="separator:ga4d2ceb23fa0e3731878ad777f39474d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a42bc8b8c045d4c4fa3ea9b4411c247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga1a42bc8b8c045d4c4fa3ea9b4411c247">Cy_CapSense_InitializeWidgetGestures</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1a42bc8b8c045d4c4fa3ea9b4411c247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs initialization of all gestures for the specified widget.  <a href="#ga1a42bc8b8c045d4c4fa3ea9b4411c247">More...</a><br /></td></tr>
<tr class="separator:ga1a42bc8b8c045d4c4fa3ea9b4411c247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d3ccdc21ed235f4e3b61a0a583c7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga91d3ccdc21ed235f4e3b61a0a583c7a1">Cy_CapSense_InitializeAllStatuses</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga91d3ccdc21ed235f4e3b61a0a583c7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs initialization of all statuses and related modules including debounce counters and touch positions of all the widgets.  <a href="#ga91d3ccdc21ed235f4e3b61a0a583c7a1">More...</a><br /></td></tr>
<tr class="separator:ga91d3ccdc21ed235f4e3b61a0a583c7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd8087cced318d7a2ddd0aabe5d0b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga0cd8087cced318d7a2ddd0aabe5d0b65">Cy_CapSense_InitializeWidgetStatus</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0cd8087cced318d7a2ddd0aabe5d0b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs initialization of all statuses, debounce counters, and touch positions of the specified widget.  <a href="#ga0cd8087cced318d7a2ddd0aabe5d0b65">More...</a><br /></td></tr>
<tr class="separator:ga0cd8087cced318d7a2ddd0aabe5d0b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga200f346a4973b003640adad8dfca0748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga200f346a4973b003640adad8dfca0748">Cy_CapSense_ProcessWidgetMptxDeconvolution</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga200f346a4973b003640adad8dfca0748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs raw count deconvolution for the specified CSX widget when Multi-phase Tx is enabled.  <a href="#ga200f346a4973b003640adad8dfca0748">More...</a><br /></td></tr>
<tr class="separator:ga200f346a4973b003640adad8dfca0748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0772250c35cb3f630a8522b0b156692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692">Cy_CapSense_PreProcessWidget</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gad0772250c35cb3f630a8522b0b156692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the pre-processing of scan raw data for specified widgets.  <a href="#gad0772250c35cb3f630a8522b0b156692">More...</a><br /></td></tr>
<tr class="separator:gad0772250c35cb3f630a8522b0b156692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf58d5ee3d30799c52819dccecad6730b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaf58d5ee3d30799c52819dccecad6730b">Cy_CapSense_PreProcessSensor</a> (uint32_t widgetId, uint32_t sensorId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf58d5ee3d30799c52819dccecad6730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the pre-processing of scan raw data for specified sensor.  <a href="#gaf58d5ee3d30799c52819dccecad6730b">More...</a><br /></td></tr>
<tr class="separator:gaf58d5ee3d30799c52819dccecad6730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0226119d718185acba8bfb8098682ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga0226119d718185acba8bfb8098682ec7">Cy_CapSense_RunMfsMedian</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0226119d718185acba8bfb8098682ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the median filter to the specified multi-frequency widget and updates the specified widget diff counts.  <a href="#ga0226119d718185acba8bfb8098682ec7">More...</a><br /></td></tr>
<tr class="separator:ga0226119d718185acba8bfb8098682ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8266fcf05ad962580844a2c9c01f2fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga8266fcf05ad962580844a2c9c01f2fb8">Cy_CapSense_CheckCRCWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga8266fcf05ad962580844a2c9c01f2fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the stored CRC of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> data structure of the specified widget.  <a href="#ga8266fcf05ad962580844a2c9c01f2fb8">More...</a><br /></td></tr>
<tr class="separator:ga8266fcf05ad962580844a2c9c01f2fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617c2c407a13538ca6662314402e3f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga617c2c407a13538ca6662314402e3f61">Cy_CapSense_CheckIntegritySensorRawcount</a> (uint32_t widgetId, uint32_t sensorId, uint16_t rawcountHighLimit, uint16_t rawcountLowLimit, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga617c2c407a13538ca6662314402e3f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the raw count of the specified widget/sensor is within the specified range.  <a href="#ga617c2c407a13538ca6662314402e3f61">More...</a><br /></td></tr>
<tr class="separator:ga617c2c407a13538ca6662314402e3f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5574b4c085f9cf891457cbf835e6ca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gab5574b4c085f9cf891457cbf835e6ca1">Cy_CapSense_CheckIntegritySensorBaseline</a> (uint32_t widgetId, uint32_t sensorId, uint16_t baselineHighLimit, uint16_t baselineLowLimit, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gab5574b4c085f9cf891457cbf835e6ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the baseline of the specified sensor is not corrupted by comparing it with its inverse copy and checks if the baseline is within the specified range.  <a href="#gab5574b4c085f9cf891457cbf835e6ca1">More...</a><br /></td></tr>
<tr class="separator:gab5574b4c085f9cf891457cbf835e6ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc9fa570b4c5aa91c66570f5c6f57d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gadcc9fa570b4c5aa91c66570f5c6f57d4">Cy_CapSense_CheckIntegritySensorPins</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gadcc9fa570b4c5aa91c66570f5c6f57d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the specified widget/sensor for shorts to GND, VDD or other sensors.  <a href="#gadcc9fa570b4c5aa91c66570f5c6f57d4">More...</a><br /></td></tr>
<tr class="separator:gadcc9fa570b4c5aa91c66570f5c6f57d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ad1c421ea794bd493bb37e76c48a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga80ad1c421ea794bd493bb37e76c48a2b">Cy_CapSense_MeasureCapacitanceCap</a> (<a class="el" href="group__group__capsense__enums.html#ga07f6f8cbe8fa1cebb08e2bd44e9de29b">cy_en_capsense_bist_external_cap_id_t</a> integrationCapId, uint32_t *ptrValue, uint32_t maxCapacitance, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga80ad1c421ea794bd493bb37e76c48a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the capacitance in picofarads of the specified CAPSENSE&trade; integration (external) capacitor.  <a href="#ga80ad1c421ea794bd493bb37e76c48a2b">More...</a><br /></td></tr>
<tr class="separator:ga80ad1c421ea794bd493bb37e76c48a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0214428f5737ef46a2f755620c4e7316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga0214428f5737ef46a2f755620c4e7316">Cy_CapSense_MeasureVdda</a> (uint32_t *ptrValue, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0214428f5737ef46a2f755620c4e7316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures a VDDA voltage, returns the measured voltage in millivolts through the ptrValue argument and stores it to the .vddaVoltage field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.  <a href="#ga0214428f5737ef46a2f755620c4e7316">More...</a><br /></td></tr>
<tr class="separator:ga0214428f5737ef46a2f755620c4e7316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bf9894c313d4ffce1be841141d6b8e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga3bf9894c313d4ffce1be841141d6b8e5">Cy_CapSense_MeasureCapacitanceSensor</a> (uint32_t widgetId, uint32_t sensorId, uint32_t *ptrValue, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga3bf9894c313d4ffce1be841141d6b8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the specified CSD sensor / CSX electrode capacitance in femtofarads.  <a href="#ga3bf9894c313d4ffce1be841141d6b8e5">More...</a><br /></td></tr>
<tr class="separator:ga3bf9894c313d4ffce1be841141d6b8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9c800180cd40a8ca3e53321d6a249b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gacc9c800180cd40a8ca3e53321d6a249b">Cy_CapSense_MeasureCapacitanceShield</a> (uint32_t *ptrValue, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gacc9c800180cd40a8ca3e53321d6a249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures shield electrode capacitance in femtofarads.  <a href="#gacc9c800180cd40a8ca3e53321d6a249b">More...</a><br /></td></tr>
<tr class="separator:gacc9c800180cd40a8ca3e53321d6a249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f23f4e684b25788f999851f20aa58c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga23f23f4e684b25788f999851f20aa58c">Cy_CapSense_MeasureCapacitanceSensorElectrode</a> (uint32_t widgetId, uint32_t eltdId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga23f23f4e684b25788f999851f20aa58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the specified CSD sensor / CSX electrode capacitance in femtofarads.  <a href="#ga23f23f4e684b25788f999851f20aa58c">More...</a><br /></td></tr>
<tr class="separator:ga23f23f4e684b25788f999851f20aa58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb467c284dc3fea4c7347a25c5ff57df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gadb467c284dc3fea4c7347a25c5ff57df">Cy_CapSense_MeasureCapacitanceSlotSensors</a> (uint32_t slotId, uint32_t skipChMask, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gadb467c284dc3fea4c7347a25c5ff57df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the specified slot sensor capacitance in femtofarads.  <a href="#gadb467c284dc3fea4c7347a25c5ff57df">More...</a><br /></td></tr>
<tr class="separator:gadb467c284dc3fea4c7347a25c5ff57df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff014dbf80fc7824a7e6e3e377d2942f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaff014dbf80fc7824a7e6e3e377d2942f">Cy_CapSense_MeasureCapacitanceShieldElectrode</a> (uint32_t skipChMask, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaff014dbf80fc7824a7e6e3e377d2942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures shield electrode capacitances in femtofarads.  <a href="#gaff014dbf80fc7824a7e6e3e377d2942f">More...</a><br /></td></tr>
<tr class="separator:gaff014dbf80fc7824a7e6e3e377d2942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a30f2e4cdef59eab57f589b0091d937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga3a30f2e4cdef59eab57f589b0091d937">Cy_CapSense_CalibrateAllWidgets</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga3a30f2e4cdef59eab57f589b0091d937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the CapDAC/IDAC calibration for all the sensors in all widgets in the middleware to default target value.  <a href="#ga3a30f2e4cdef59eab57f589b0091d937">More...</a><br /></td></tr>
<tr class="separator:ga3a30f2e4cdef59eab57f589b0091d937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889e60b9ca2470b37b37c772558f44ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga889e60b9ca2470b37b37c772558f44ad">Cy_CapSense_CalibrateWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga889e60b9ca2470b37b37c772558f44ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the CapDAC/IDAC calibration for all the sensors in the specified widget to the default target value.  <a href="#ga889e60b9ca2470b37b37c772558f44ad">More...</a><br /></td></tr>
<tr class="separator:ga889e60b9ca2470b37b37c772558f44ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3f80b48c2596c149ca0b392a9a3da62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gae3f80b48c2596c149ca0b392a9a3da62">Cy_CapSense_ScanSensor</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gae3f80b48c2596c149ca0b392a9a3da62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the scanning of the selected sensor in the widget.  <a href="#gae3f80b48c2596c149ca0b392a9a3da62">More...</a><br /></td></tr>
<tr class="separator:gae3f80b48c2596c149ca0b392a9a3da62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51fd91df09631045f83396237395777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777">Cy_CapSense_SetPinState</a> (uint32_t widgetId, uint32_t sensorElement, uint32_t state, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf51fd91df09631045f83396237395777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor.  <a href="#gaf51fd91df09631045f83396237395777">More...</a><br /></td></tr>
<tr class="separator:gaf51fd91df09631045f83396237395777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760c8b9c8e17b5c9689bf9305a34e393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393">Cy_CapSense_SetInactiveElectrodeState</a> (uint32_t inactiveState, uint32_t sensingGroup, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga760c8b9c8e17b5c9689bf9305a34e393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a desired state for all inactive CAPSENSE&trade;-related electrodes for CSD or CSX scans.  <a href="#ga760c8b9c8e17b5c9689bf9305a34e393">More...</a><br /></td></tr>
<tr class="separator:ga760c8b9c8e17b5c9689bf9305a34e393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43c0cf61a95f11a5981f82f5b0d4e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86">Cy_CapSense_SetupWidgetExt</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf43c0cf61a95f11a5981f82f5b0d4e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs extended initialization for the specified widget and also performs initialization required for a specific sensor in the widget.  <a href="#gaf43c0cf61a95f11a5981f82f5b0d4e86">More...</a><br /></td></tr>
<tr class="separator:gaf43c0cf61a95f11a5981f82f5b0d4e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31834a3fce1f5b57c72107b419626bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab">Cy_CapSense_ScanExt</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga31834a3fce1f5b57c72107b419626bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a conversion on the pre-configured sensor.  <a href="#ga31834a3fce1f5b57c72107b419626bab">More...</a><br /></td></tr>
<tr class="separator:ga31834a3fce1f5b57c72107b419626bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1130ee418f843fce4e68832efa37e28f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f">Cy_CapSense_CalibrateAllSlots</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1130ee418f843fce4e68832efa37e28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes CapDAC auto-calibration for all relevant widgets if enabled.  <a href="#ga1130ee418f843fce4e68832efa37e28f">More...</a><br /></td></tr>
<tr class="separator:ga1130ee418f843fce4e68832efa37e28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a87df9f6b6810a12465149f451fd64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga2a87df9f6b6810a12465149f451fd64f">Cy_CapSense_SetCalibrationTargets</a> (uint32_t csdCalibrTarget, uint32_t csxCalibrTarget, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga2a87df9f6b6810a12465149f451fd64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CapDAC auto-calibration raw count targets for CSD and/or CSX widgets.  <a href="#ga2a87df9f6b6810a12465149f451fd64f">More...</a><br /></td></tr>
<tr class="separator:ga2a87df9f6b6810a12465149f451fd64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8f778457e13ccfa3f34239aef25f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga5d8f778457e13ccfa3f34239aef25f47">Cy_CapSense_SlotPinState</a> (uint32_t slotId, const <a class="el" href="structcy__stc__capsense__electrode__config__t.html">cy_stc_capsense_electrode_config_t</a> *ptrEltdCfg, uint32_t pinState, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga5d8f778457e13ccfa3f34239aef25f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the desired electrode to the specified state by updating the CAPSENSE&trade; configuration.  <a href="#ga5d8f778457e13ccfa3f34239aef25f47">More...</a><br /></td></tr>
<tr class="separator:ga5d8f778457e13ccfa3f34239aef25f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264c6bafda78c56a0d620a7c88363269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga264c6bafda78c56a0d620a7c88363269">Cy_CapSense_ScanAbort</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga264c6bafda78c56a0d620a7c88363269"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sequencer to the idle state by resetting the hardware, it can be used to abort current scan.  <a href="#ga264c6bafda78c56a0d620a7c88363269">More...</a><br /></td></tr>
<tr class="separator:ga264c6bafda78c56a0d620a7c88363269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89c8ed15cddd778c2232c85300eb02d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaa89c8ed15cddd778c2232c85300eb02d">Cy_CapSense_GetParam</a> (uint32_t paramId, uint32_t *value, const void *ptrTuner, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaa89c8ed15cddd778c2232c85300eb02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value of the specified parameter from the cy_capsense_tuner structure.  <a href="#gaa89c8ed15cddd778c2232c85300eb02d">More...</a><br /></td></tr>
<tr class="separator:gaa89c8ed15cddd778c2232c85300eb02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6049654627a08e866ebe5e93ac414177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga6049654627a08e866ebe5e93ac414177">Cy_CapSense_SetParam</a> (uint32_t paramId, uint32_t value, void *ptrTuner, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga6049654627a08e866ebe5e93ac414177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new value for the specified parameter in cy_capsense_tuner structure.  <a href="#ga6049654627a08e866ebe5e93ac414177">More...</a><br /></td></tr>
<tr class="separator:ga6049654627a08e866ebe5e93ac414177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de812825cd421ee05fec733206e157a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga2de812825cd421ee05fec733206e157a">Cy_CapSense_GetCRC</a> (const uint8_t *ptrData, uint32_t len)</td></tr>
<tr class="memdesc:ga2de812825cd421ee05fec733206e157a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates CRC for the specified buffer and length.  <a href="#ga2de812825cd421ee05fec733206e157a">More...</a><br /></td></tr>
<tr class="separator:ga2de812825cd421ee05fec733206e157a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafbfe743a98bd2c24a623a2c734c03f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbfe743a98bd2c24a623a2c734c03f0e">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessWidgetExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessWidgetExt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs customized data processing on the selected widget. </p>
<p>This function performs customized data processing specified by the mode parameter on a widget. This function can be used with any of the available scan functions. This function should be called only after all the sensors in the specified widget are scanned. Calling this function multiple times with the same mode without new sensor scan causes unexpected behavior. This function ignores the value of the wdgtEnable register.</p>
<p>The CY_CAPSENSE_PROCESS_CALC_NOISE and CY_CAPSENSE_PROCESS_THRESHOLDS masks for mode parameter are supported only when smart sensing algorithm is enabled for CSD widgets.</p>
<p>The execution order of processing tasks starts from LSB to MSB of the mode parameter. To implement a different order of execution, call this function multiple times with the required mode parameter.</p>
<p>For more details, refer to function usage example below.</p>
<dl class="section note"><dt>Note</dt><dd>For the the fifth-generation CAPSENSE&trade; an extra processing should be performed prior a call of this function:<ul>
<li>A raw count pre-processing calling either the <a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692" title="Executes the pre-processing of scan raw data for specified widgets. ">Cy_CapSense_PreProcessWidget()</a> or <a class="el" href="group__group__capsense__low__level.html#gaf58d5ee3d30799c52819dccecad6730b" title="Executes the pre-processing of scan raw data for specified sensor. ">Cy_CapSense_PreProcessSensor()</a> functions.</li>
<li>A deconvolution for widgets with multi-phase Tx calling the <a class="el" href="group__group__capsense__low__level.html#ga200f346a4973b003640adad8dfca0748" title="Performs raw count deconvolution for the specified CSX widget when Multi-phase Tx is enabled...">Cy_CapSense_ProcessWidgetMptxDeconvolution()</a> function. In this case a full processing flow consists of the following:</li>
<li><a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692" title="Executes the pre-processing of scan raw data for specified widgets. ">Cy_CapSense_PreProcessWidget()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga200f346a4973b003640adad8dfca0748" title="Performs raw count deconvolution for the specified CSX widget when Multi-phase Tx is enabled...">Cy_CapSense_ProcessWidgetMptxDeconvolution()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies the type of widget processing to be executed for the specified widget:<ol type="1">
<li>Bits [31..7] - Reserved.</li>
<li>Bits [6..0] - CY_CAPSENSE_PROCESS_ALL - Execute all of the below tasks.</li>
<li>Bit [6] - CY_CAPSENSE_PROCESS_MFS_FILTER - Run the firmware filters for MFS on sensor rawcounts (applicable only for fifth-generation CAPSENSE&trade;).</li>
<li>Bit [5] - CY_CAPSENSE_PROCESS_STATUS - Update the status (on/off, centroid position).</li>
<li>Bit [4] - CY_CAPSENSE_PROCESS_THRESHOLDS - Update the thresholds (only in CSD auto-tuning mode).</li>
<li>Bit [3] - CY_CAPSENSE_PROCESS_CALC_NOISE - Calculate the noise (only in CSD auto-tuning mode).</li>
<li>Bit [2] - CY_CAPSENSE_PROCESS_DIFFCOUNTS - Update the difference counts of each sensor.</li>
<li>Bit [1] - CY_CAPSENSE_PROCESS_BASELINE - Update the baselines for all sensor.</li>
<li>Bit [0] - CY_CAPSENSE_PROCESS_FILTER - Run the firmware filters on sensor rawcounts.</li>
</ol>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget processing operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The processing is successfully performed.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The processing failed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of customized data processing, changed processing order: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    <span class="comment">/* Standard execution order (smart sensing algorithm is disabled):</span></div><div class="line"><span class="comment">    * - Filtering</span></div><div class="line"><span class="comment">    * - Baselining</span></div><div class="line"><span class="comment">    * - Difference calculation</span></div><div class="line"><span class="comment">    * - Status / Position calculation</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * An example below makes a different order:</span></div><div class="line"><span class="comment">    * - filtering is executed as a last task</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <a class="code" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e">Cy_CapSense_ProcessWidgetExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID,</div><div class="line">                                <a class="code" href="group__group__capsense__macros__process.html#ga459185fc700d0afc4556d995730f6052">CY_CAPSENSE_PROCESS_BASELINE</a> |</div><div class="line">                                <a class="code" href="group__group__capsense__macros__process.html#ga69cbf309ed5306c0845fbef6d31ba3e8">CY_CAPSENSE_PROCESS_DIFFCOUNTS</a> |</div><div class="line">                                <a class="code" href="group__group__capsense__macros__process.html#ga1575721ebbdd600b13f843e068dbf282">CY_CAPSENSE_PROCESS_STATUS</a>,</div><div class="line">                                &amp;cy_capsense_context);</div><div class="line">    <a class="code" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e">Cy_CapSense_ProcessWidgetExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID,</div><div class="line">                                <a class="code" href="group__group__capsense__macros__process.html#gaa3b890d5a6646b1c990093614f904b7c">CY_CAPSENSE_PROCESS_FILTER</a>,</div><div class="line">                                &amp;cy_capsense_context);</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="ga05d3f6e7d7fbef845ab4eb575e653dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d3f6e7d7fbef845ab4eb575e653dec">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessSensorExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessSensorExt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs customized data processing on the selected sensor. </p>
<p>This function performs customized data processing specified by the mode parameter on a sensor. This function performs the exact same task of the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> function but only on the specified sensor instead of all sensors in the widget.</p>
<p>The pipeline scan method (i.e. during scanning of a sensor, processing of a previously scanned sensor is performed) can be implemented using this function and it may reduce the total scan/process time, increase the refresh rate, and decrease the power consumption. For more details, refer to function usage example below.</p>
<dl class="section note"><dt>Note</dt><dd>For the the fifth CAPSENSE&trade; HW generation an extra processing should be performed prior a call of this function:<ul>
<li>A raw count pre-processing calling either the <a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692" title="Executes the pre-processing of scan raw data for specified widgets. ">Cy_CapSense_PreProcessWidget()</a> or <a class="el" href="group__group__capsense__low__level.html#gaf58d5ee3d30799c52819dccecad6730b" title="Executes the pre-processing of scan raw data for specified sensor. ">Cy_CapSense_PreProcessSensor()</a> functions.</li>
<li>A deconvolution for widgets with multi-phase Tx calling the <a class="el" href="group__group__capsense__low__level.html#ga200f346a4973b003640adad8dfca0748" title="Performs raw count deconvolution for the specified CSX widget when Multi-phase Tx is enabled...">Cy_CapSense_ProcessWidgetMptxDeconvolution()</a> function. In this case a full processing flow consists of the following:</li>
<li><a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692" title="Executes the pre-processing of scan raw data for specified widgets. ">Cy_CapSense_PreProcessWidget()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga200f346a4973b003640adad8dfca0748" title="Performs raw count deconvolution for the specified CSX widget when Multi-phase Tx is enabled...">Cy_CapSense_ProcessWidgetMptxDeconvolution()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> - each sensor</li>
<li><a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies the type of the sensor processing that must be executed for the specified sensor:<ol type="1">
<li>Bits [31..5] - Reserved</li>
<li>Bits [4..0] - CY_CAPSENSE_PROCESS_ALL - Executes all the tasks</li>
<li>Bit [4] - CY_CAPSENSE_PROCESS_THRESHOLDS - Updates the thresholds (only in auto-tuning mode)</li>
<li>Bit [3] - CY_CAPSENSE_PROCESS_CALC_NOISE - Calculates the noise (only in auto-tuning mode)</li>
<li>Bit [2] - CY_CAPSENSE_PROCESS_DIFFCOUNTS - Updates the diff count</li>
<li>Bit [1] - CY_CAPSENSE_PROCESS_BASELINE - Updates the baseline</li>
<li>Bit [0] - CY_CAPSENSE_PROCESS_FILTER - Runs the firmware filters</li>
</ol>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the sensor process operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The processing is successfully performed.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The processing failed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example demonstrates pipeline implementation of sensor scanning and processing: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    snsIndex = 0u;</div><div class="line"></div><div class="line">        <a class="code" href="group__group__capsense__low__level.html#gae3f80b48c2596c149ca0b392a9a3da62">Cy_CapSense_ScanSensor</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, snsIndex, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">        {</div><div class="line">            snsIndex++;</div><div class="line">            <span class="keywordflow">if</span> (snsIndex &lt; cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].numSns)</div><div class="line">            {</div><div class="line">                <a class="code" href="group__group__capsense__low__level.html#gae3f80b48c2596c149ca0b392a9a3da62">Cy_CapSense_ScanSensor</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, snsIndex, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">                <a class="code" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec">Cy_CapSense_ProcessSensorExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, snsIndex, <a class="code" href="group__group__capsense__macros__process.html#gaa84b286a4e106b5eeed0141339f7ab6b">CY_CAPSENSE_PROCESS_ALL</a>, &amp;cy_capsense_context);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="comment">/* The last sensor is scanned already */</span></div><div class="line">                <a class="code" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec">Cy_CapSense_ProcessSensorExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, snsIndex, <a class="code" href="group__group__capsense__macros__process.html#gaa84b286a4e106b5eeed0141339f7ab6b">CY_CAPSENSE_PROCESS_ALL</a>, &amp;cy_capsense_context);</div><div class="line">                <span class="comment">/* All sensors processed, therefore process only widget-related task */</span></div><div class="line">                <a class="code" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e">Cy_CapSense_ProcessWidgetExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, <a class="code" href="group__group__capsense__macros__process.html#ga1575721ebbdd600b13f843e068dbf282">CY_CAPSENSE_PROCESS_STATUS</a>, &amp;cy_capsense_context);</div><div class="line">                <span class="comment">/* Reset sensor index to start from the first sensor */</span></div><div class="line">                snsIndex = 0u;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="ga55216d9c145b2ab42d7cec23960fb31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55216d9c145b2ab42d7cec23960fb31e">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeAllBaselines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeAllBaselines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the baselines of all the sensors of all the widgets. </p>
<p>This function initializes baselines for all sensors and widgets in the project. It can also be used to re-initialize baselines at any time, however, note that all sensor data history information and sensor status shall be reset along with re-initialization of baseline.</p>
<p>Following functions to initialize sensor and widgets and filter history should be called after initializing baseline for proper operation of the CAPSENSE&trade; middleware:</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga91d3ccdc21ed235f4e3b61a0a583c7a1" title="Performs initialization of all statuses and related modules including debounce counters and touch pos...">Cy_CapSense_InitializeAllStatuses()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga1fcb002d0216bb96ab818276954606e7" title="Initializes (or re-initializes) all the firmware filter history, except the baseline. ">Cy_CapSense_InitializeAllFilters()</a></li>
</ul>
<p>These functions are called by the CapSense_Enable() function, hence it is not required to use this function if above function is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae217c3d40eff007bf28add89814f17d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae217c3d40eff007bf28add89814f17d2">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeWidgetBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeWidgetBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the baselines of all the sensors in a specific widget. </p>
<p>This function initializes baselines for all sensors in a specific widget in the project. It can also be used to re-initialize baselines at any time, however, note that all sensor data history information and sensor status should be reset along with re-initialization of baseline.</p>
<p>The following functions to initialize sensor and widgets and filter history should be called after initializing baselines for proper operation of middleware.</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga0cd8087cced318d7a2ddd0aabe5d0b65" title="Performs initialization of all statuses, debounce counters, and touch positions of the specified widg...">Cy_CapSense_InitializeWidgetStatus()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga101174469c4b6a2df8d44bddb0e33fcf" title="Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified...">Cy_CapSense_InitializeWidgetFilter()</a></li>
</ul>
<p>These functions are called by CapSense_Enable() function, hence it is not required to use this function is above function is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga695fc72a3809224e52c8a0212835d4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga695fc72a3809224e52c8a0212835d4f7">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeSensorBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeSensorBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the baseline of a sensor in a widget specified by the input parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1fcb002d0216bb96ab818276954606e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fcb002d0216bb96ab818276954606e7">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeAllFilters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeAllFilters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes (or re-initializes) all the firmware filter history, except the baseline. </p>
<p>Calling this function is accompanied by</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga91d3ccdc21ed235f4e3b61a0a583c7a1" title="Performs initialization of all statuses and related modules including debounce counters and touch pos...">Cy_CapSense_InitializeAllStatuses()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga55216d9c145b2ab42d7cec23960fb31e" title="Initializes the baselines of all the sensors of all the widgets. ">Cy_CapSense_InitializeAllBaselines()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga101174469c4b6a2df8d44bddb0e33fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga101174469c4b6a2df8d44bddb0e33fcf">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeWidgetFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeWidgetFilter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified by the input parameter. </p>
<p>Calling this function is accompanied by</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga0cd8087cced318d7a2ddd0aabe5d0b65" title="Performs initialization of all statuses, debounce counters, and touch positions of the specified widg...">Cy_CapSense_InitializeWidgetStatus()</a>.</li>
<li><a class="el" href="group__group__capsense__low__level.html#gae217c3d40eff007bf28add89814f17d2" title="Initializes the baselines of all the sensors in a specific widget. ">Cy_CapSense_InitializeWidgetBaseline()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76d2e232d2e5247954a15a45de62d235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d2e232d2e5247954a15a45de62d235">&#9670;&nbsp;</a></span>Cy_CapSense_UpdateAllBaselines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_UpdateAllBaselines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the baseline for all the sensors in all the widgets. </p>
<p>Baselines must be updated after sensor scan to ignore low frequency changes in the sensor data caused by environment changes such as temperature from sensor status decision.</p>
<p>This function ignores the widget enable bit in the widget status register. Calling this function multiple times without a new sensor scan leads to unexpected behavior and should be avoided.</p>
<p>This function is called by <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> and <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a>, hence the application program need not use this function if any of the above functions is already used. This function can be used for custom application implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the update baseline operation of all the widgets:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The baseline processing failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga53420b198a6de128b82b3edb31f250c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53420b198a6de128b82b3edb31f250c6">&#9670;&nbsp;</a></span>Cy_CapSense_UpdateWidgetBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_UpdateWidgetBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the baselines for all the sensors in a widget specified by the input parameter. </p>
<p>This function performs exactly the same tasks as <a class="el" href="group__group__capsense__low__level.html#ga76d2e232d2e5247954a15a45de62d235" title="Updates the baseline for all the sensors in all the widgets. ">Cy_CapSense_UpdateAllBaselines()</a> but only for a specified widget.</p>
<p>Calling this function multiple times without a new sensor scan leads to unexpected behavior and should be avoided. The application program need not use this function if the <a class="el" href="group__group__capsense__low__level.html#ga76d2e232d2e5247954a15a45de62d235" title="Updates the baseline for all the sensors in all the widgets. ">Cy_CapSense_UpdateAllBaselines()</a>, <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> or <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions are already used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the specified widget update baseline operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The baseline processing failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4d2ceb23fa0e3731878ad777f39474d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2ceb23fa0e3731878ad777f39474d2">&#9670;&nbsp;</a></span>Cy_CapSense_UpdateSensorBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_UpdateSensorBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the baseline for a sensor in a widget specified by the input parameters. </p>
<p>This function performs exactly the same tasks as <a class="el" href="group__group__capsense__low__level.html#ga76d2e232d2e5247954a15a45de62d235" title="Updates the baseline for all the sensors in all the widgets. ">Cy_CapSense_UpdateAllBaselines()</a> and <a class="el" href="group__group__capsense__low__level.html#ga53420b198a6de128b82b3edb31f250c6" title="Updates the baselines for all the sensors in a widget specified by the input parameter. ">Cy_CapSense_UpdateWidgetBaseline()</a> but only for a specified sensor.</p>
<p>Calling this function multiple times without a new sensor scan leads to unexpected behavior and should be avoided. The application need not use this function if the Cy_CapSense_UpdateWidgetBaseline (), Cy_CapSense_UpdateAllBaselines (), <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a>, or <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions are already used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the specified sensor update baseline operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The baseline processing failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1a42bc8b8c045d4c4fa3ea9b4411c247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a42bc8b8c045d4c4fa3ea9b4411c247">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeWidgetGestures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeWidgetGestures </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs initialization of all gestures for the specified widget. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga91d3ccdc21ed235f4e3b61a0a583c7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91d3ccdc21ed235f4e3b61a0a583c7a1">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeAllStatuses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeAllStatuses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs initialization of all statuses and related modules including debounce counters and touch positions of all the widgets. </p>
<p>The initialization includes the following tasks:</p><ul>
<li>Reset the debounce counters of all the widgets.</li>
<li>Reset the number of touches.</li>
<li>Reset the position filter history for slider and touchpad widgets.</li>
<li>Clear all status of widgets and sensors.</li>
<li>Enable all the widgets.</li>
</ul>
<p>Calling this function is accompanied by</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga55216d9c145b2ab42d7cec23960fb31e" title="Initializes the baselines of all the sensors of all the widgets. ">Cy_CapSense_InitializeAllBaselines()</a>.</li>
<li><a class="el" href="group__group__capsense__low__level.html#ga1fcb002d0216bb96ab818276954606e7" title="Initializes (or re-initializes) all the firmware filter history, except the baseline. ">Cy_CapSense_InitializeAllFilters()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0cd8087cced318d7a2ddd0aabe5d0b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cd8087cced318d7a2ddd0aabe5d0b65">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeWidgetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeWidgetStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs initialization of all statuses, debounce counters, and touch positions of the specified widget. </p>
<p>The initialization includes:</p><ul>
<li>Resets the debounce counter of the widget.</li>
<li>Resets the number of touches.</li>
<li>Resets the position filter history for slider and touchpad widgets.</li>
<li>Clears widget and sensor statuses.</li>
<li>Enables the widget.</li>
</ul>
<p>The Button and Matrix Button widgets have individual debounce counters per sensor for the CSD widgets and per node for the CSX widgets.</p>
<p>The Slider and Touchpad widgets have a single debounce counter per widget.</p>
<p>The Proximity widget has two debounce counters per sensor. One is for the proximity event and the second is for the touch event.</p>
<p>All debounce counters during initialization are set to the value of the onDebounce widget parameter.</p>
<p>Calling this function is accompanied by</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#gae217c3d40eff007bf28add89814f17d2" title="Initializes the baselines of all the sensors in a specific widget. ">Cy_CapSense_InitializeWidgetBaseline()</a>.</li>
<li><a class="el" href="group__group__capsense__low__level.html#ga101174469c4b6a2df8d44bddb0e33fcf" title="Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified...">Cy_CapSense_InitializeWidgetFilter()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga200f346a4973b003640adad8dfca0748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga200f346a4973b003640adad8dfca0748">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessWidgetMptxDeconvolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessWidgetMptxDeconvolution </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs raw count deconvolution for the specified CSX widget when Multi-phase Tx is enabled. </p>
<p>This function decodes raw counts received after scanning into normal view by performing deconvolution algorithm. If the function is called for a widget with disabled Multi-phase Tx, the function returns CY_CAPSENSE_STATUS_BAD_DATA.</p>
<p>No need to call this function from application layer since the <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> and <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions calls deconvolution automatically.</p>
<p>DAC auto-calibration when enabled performs sensor auto-calibration without performing deconvolution. The deconvolution algorithm for even number of TX electrodes decreases raw count level twice (keeping the signal on the same level).</p>
<p>If specific processing is implemented using the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> and <a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> function then a call of this function is required prior doing the specific processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the processing operation. </dd></dl>

</div>
</div>
<a id="gad0772250c35cb3f630a8522b0b156692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0772250c35cb3f630a8522b0b156692">&#9670;&nbsp;</a></span>Cy_CapSense_PreProcessWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_PreProcessWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the pre-processing of scan raw data for specified widgets. </p>
<p>This function is called prior any other processing function for the fifth CAPSENSE&trade; HW generation. The pre-processing routine implements the following operations:</p><ul>
<li>Executes the CIC2 pre-processing if the filter mode is set to CIC2.</li>
<li>Limits raw count to maximum value.</li>
<li>Executes the raw data inversion for the CSX sensors.</li>
</ul>
<p>No need to call this function from application layer since the <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> and <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions calls it automatically.</p>
<p>If specific processing is implemented using the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> and <a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> function then a call of this function is required prior doing the specific processing. If Multi-phase TX is enabled then deconvolution should be executed after call of this function using the <a class="el" href="group__group__capsense__low__level.html#ga200f346a4973b003640adad8dfca0748" title="Performs raw count deconvolution for the specified CSX widget when Multi-phase Tx is enabled...">Cy_CapSense_ProcessWidgetMptxDeconvolution()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>The widget ID, for which the pre-processing should be executed.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf58d5ee3d30799c52819dccecad6730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf58d5ee3d30799c52819dccecad6730b">&#9670;&nbsp;</a></span>Cy_CapSense_PreProcessSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_PreProcessSensor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the pre-processing of scan raw data for specified sensor. </p>
<p>This function is called prior any other processing function for the fifth CAPSENSE&trade; HW generation. The pre-processing routine implements the following operations:</p><ul>
<li>Executes the CIC2 pre-processing if the filter mode is set to CIC2.</li>
<li>Limits raw count to maximum value.</li>
<li>Executes the raw data inversion for the CSX sensors.</li>
</ul>
<p>No need to call this function from application layer since the <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> and <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions calls it automatically.</p>
<p>If specific processing is implemented using the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> and <a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> function then a call of this function is required prior doing the specific processing. If Multi-phase TX is enabled then deconvolution should be executed after pre-processing of all sensors of the specified widget using the <a class="el" href="group__group__capsense__low__level.html#ga200f346a4973b003640adad8dfca0748" title="Performs raw count deconvolution for the specified CSX widget when Multi-phase Tx is enabled...">Cy_CapSense_ProcessWidgetMptxDeconvolution()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>The widget ID, for which the pre-processing should be executed.</td></tr>
    <tr><td class="paramname">sensorId</td><td>The sensor ID, for which the pre-processing should be executed.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0226119d718185acba8bfb8098682ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0226119d718185acba8bfb8098682ec7">&#9670;&nbsp;</a></span>Cy_CapSense_RunMfsMedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_RunMfsMedian </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the median filter to the specified multi-frequency widget and updates the specified widget diff counts. </p>
<p>This function is a low-level function and is called automatically by high-level processing functions like <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> and <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a>.</p>
<p>It is not recommended to use this function directly on application level.</p>
<p>The function applies the median filter to diff count of each sensor of the specified widget (with enabled multi-frequency feature) and update the diff count of the specified main widget.</p>
<p>This function is needed to implement customer-specific use cases.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget processing:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid either widgetId is not valid or multi-frequency is not enabled for this widget or the specified widgetId is derivative of the main widget. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8266fcf05ad962580844a2c9c01f2fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8266fcf05ad962580844a2c9c01f2fb8">&#9670;&nbsp;</a></span>Cy_CapSense_CheckCRCWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_CheckCRCWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the stored CRC of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> data structure of the specified widget. </p>
<p>This function validates the data integrity of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> data structure of the specified widget by calculating the CRC and comparing it with the stored CRC value of the specified widget.</p>
<p>Initially, after the device power up, the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE firmware modules. ">Cy_CapSense_Enable()</a> function calculates CRC for each widget and stores them in the .ptrWdgtCrc[] array of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure. The test execution compares this stored CRC value with the newly calculated and if the stored and calculated CRC values differ:</p><ol type="1">
<li>The calculated CRC is stored to the .wdgtCrcCalc field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> data structure.</li>
<li>The widget ID is stored to the .crcWdgtId field.</li>
<li>The CY_CAPSENSE_BIST_CRC_WDGT_MASK bit is set in the .testResultMask field.</li>
</ol>
<p>The function never clears the CY_CAPSENSE_BIST_CRC_WDGT_MASK bit. If the CY_CAPSENSE_BIST_CRC_WDGT_MASK bit is set, the wdgtCrcCalc and .crcWdgtId fields are not updated.</p>
<p>It is recommended to use the <a class="el" href="group__group__capsense__low__level.html#ga6049654627a08e866ebe5e93ac414177" title="Sets a new value for the specified parameter in cy_capsense_tuner structure. ">Cy_CapSense_SetParam()</a> function to change the value of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> data structure elements as the CRC is updated by <a class="el" href="group__group__capsense__low__level.html#ga6049654627a08e866ebe5e93ac414177" title="Sets a new value for the specified parameter in cy_capsense_tuner structure. ">Cy_CapSense_SetParam()</a> function.</p>
<p>You can initiate this test by the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function with the CY_CAPSENSE_BIST_CRC_WDGT_MASK mask as an input.</p>
<p>The function clears the CY_CAPSENSE_WD_WORKING_MASK bit of the .status field in <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> structure if the calculated CRC value differs to the stored CRC value. Those non-working widgets are skipped by the high-level scanning and processing functions. Restoring a widget to its working state should be done by the application level.</p>
<p>For details of the used CRC algorithm, refer to the <a class="el" href="group__group__capsense__low__level.html#ga2de812825cd421ee05fec733206e157a" title="Calculates CRC for the specified buffer and length. ">Cy_CapSense_GetCRC()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The stored CRC matches the calculated CRC.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - The widget CRC differs to the stored CRC.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameters are invalid. The test was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga617c2c407a13538ca6662314402e3f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga617c2c407a13538ca6662314402e3f61">&#9670;&nbsp;</a></span>Cy_CapSense_CheckIntegritySensorRawcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_CheckIntegritySensorRawcount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rawcountHighLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rawcountLowLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the raw count of the specified widget/sensor is within the specified range. </p>
<p>The raw count is within a specific range (based on the calibration target) for good units. The function checks whether or not the raw count is within the user-defined limits in the ranges function arguments. If the raw count is out of limits, this function sets the CY_CAPSENSE_BIST_RAW_INTEGRITY_MASK bit in the .testResultMask field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</p>
<p>This function does not update the CY_CAPSENSE_WD_WORKING_MASK bit of the .status field in <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> structure and is not available in the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function.</p>
<p>Use this function to verify the uniformity of sensors, for example, at mass-production or during an operation phase together with the <a class="el" href="group__group__capsense__low__level.html#gab5574b4c085f9cf891457cbf835e6ca1" title="Checks if the baseline of the specified sensor is not corrupted by comparing it with its inverse copy...">Cy_CapSense_CheckIntegritySensorBaseline()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</td></tr>
    <tr><td class="paramname">rawcountHighLimit</td><td>Specifies the upper limit for the widget/sensor raw count.</td></tr>
    <tr><td class="paramname">rawcountLowLimit</td><td>Specifies the lower limit for the widget/sensor raw count.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The raw count is within the specified range.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - The test failed and raw count is out of the specified limits.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The test was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab5574b4c085f9cf891457cbf835e6ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5574b4c085f9cf891457cbf835e6ca1">&#9670;&nbsp;</a></span>Cy_CapSense_CheckIntegritySensorBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_CheckIntegritySensorBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baselineHighLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baselineLowLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the baseline of the specified sensor is not corrupted by comparing it with its inverse copy and checks if the baseline is within the specified range. </p>
<p>The function checks whether or not the baseline binary inverted to its inverse copy is saved to the self-test baseline-inverse structure and is within the user-defined limits. If the baseline does not match its inverse copy or if the baseline is out of the user-defined limits, the function sets the CY_CAPSENSE_BIST_BSLN_INTEGRITY_MASK bit in the .testResultMask field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</p>
<p>The test is integrated into the CAPSENSE&trade; Middleware. All CAPSENSE&trade; processing functions like <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> or <a class="el" href="group__group__capsense__low__level.html#ga4d2ceb23fa0e3731878ad777f39474d2" title="Updates the baseline for a sensor in a widget specified by the input parameters. ">Cy_CapSense_UpdateSensorBaseline()</a> automatically verify the baseline value before using it and update its inverse copy after processing. If a baseline update fails, a CY_CAPSENSE_STATUS_BAD_DATA result is returned. The baseline initialization functions do not verify the baseline and update the baseline inverse copy.</p>
<p>This function does not update the CY_CAPSENSE_WD_WORKING_MASK bit of the .status field in <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> structure and is not available in the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function.</p>
<p>Use this function to verify the uniformity of sensors, for example, at mass-production or during an operation phase together with the <a class="el" href="group__group__capsense__low__level.html#ga617c2c407a13538ca6662314402e3f61" title="Checks the raw count of the specified widget/sensor is within the specified range. ">Cy_CapSense_CheckIntegritySensorRawcount()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</td></tr>
    <tr><td class="paramname">baselineHighLimit</td><td>Specifies the upper limit for a baseline.</td></tr>
    <tr><td class="paramname">baselineLowLimit</td><td>Specifies the lower limit for a baseline.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The baseline is within the specified range.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - The test failed and the baseline is not binary inverted to its inverse copy or is out of the specified limits.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The test was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadcc9fa570b4c5aa91c66570f5c6f57d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcc9fa570b4c5aa91c66570f5c6f57d4">&#9670;&nbsp;</a></span>Cy_CapSense_CheckIntegritySensorPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_CheckIntegritySensorPins </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the specified widget/sensor for shorts to GND, VDD or other sensors. </p>
<p>This function performs several sub-tests to verify the specified sensor is not electrically shorted and is in a good condition to reliably detect user interactions.</p>
<p>This function performs tests to check if the specified sensor is shorted to:</p><ul>
<li>GND</li>
<li>VDD</li>
<li>Other GPIOs used by CAPSENSE&trade; (such as sensors, Tx, Rx, shield electrodes, and external capacitors)</li>
<li>Other non-CAPSENSE&trade; GPIOs (only if they are configured in a strong high or low state during the test execution).</li>
</ul>
<p>The absolute resistance of an electrical short must be less than 1500 Ohm including all series resistors on a sensor for a short to be detected to GND, VDD or GPIOs. For example, if a series resistor on a sensor is 560 Ohm (as recommended) and the sensor is shorted with another sensor, the function can detect a short with a short resistance up to 380 Ohm as there are two 560 ohm resistors between the shorted sensor GPIOs.</p>
<p>The function executes the following flow to detect a short:</p><ul>
<li>Configures all CAPSENSE&trade; controlled GPIOs to strong-drive-high, and the specified sensor GPIO to resistive pull down mode.</li>
<li>Waits for a delay (defined by .snsIntgShortSettlingTime field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure) to get established all transient processes.</li>
<li>Checks the status of the specified sensor for the expected state (logic low).</li>
<li>Configures all CAPSENSE&trade; controlled GPIOs to strong-drive-low, and the specified sensor GPIO to resistive pull up mode.</li>
<li>Waits for the above mentioned delay.</li>
<li>Checks the status of the specified sensor for the expected state (logic high).</li>
<li>Stores the test result in the CAPSENSE&trade; Data Structure. A short is reported only when the sensor status check returns an unexpected state.</li>
</ul>
<p>Due to the sensor parasitic capacitance and internal pull-up/down resistance, logic high-to-low (and vice versa) transitions require a settling time before checking the sensor status. A 2us delay is used as a settling time and can be changed using the .snsIntgShortSettlingTime field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html" title="Declares BIST Context Data Structure. ">cy_stc_capsense_bist_context_t</a> structure.</p>
<p>If a short is detected this function updates the following statuses:</p><ul>
<li>The widget ID is stored to the .shortedWdId field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</li>
<li>The sensor ID is stored to the .shortedSnsId field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</li>
<li>The CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK bit is set in the .testResultMask field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</li>
<li>If CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK is already set due to a previously detected fault on any of the sensor, this function does not update the .shortedWdId and .shortedSnsId fields. For this reason, clear the CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK bit prior calling this function.</li>
<li>The widget is disabled by clearing the CY_CAPSENSE_WD_WORKING_MASK bit in the .status field of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> structure of the specified widget. The disabled widget is ignored by high-level functions of scanning / data processing. To restore the widget operation the application layer should manually set the CY_CAPSENSE_WD_WORKING_MASK bit.</li>
</ul>
<p>To check all the project sensors at once, use the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function with the CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK mask.</p>
<p>To detect an electrical short or fault condition with resistance higher than 1500 ohm, the <a class="el" href="group__group__capsense__low__level.html#ga3bf9894c313d4ffce1be841141d6b8e5" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensor()</a> (4th Generation) or <a class="el" href="group__group__capsense__low__level.html#ga23f23f4e684b25788f999851f20aa58c" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensorElectrode()</a> (5th Generation) function can be used as the fault condition affects the measured sensor capacitance.</p>
<p>This test can be executed only if the CAPSENSE&trade; Middleware is in the IDLE state. This function must not be called while CAPSENSE&trade; Middleware is busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID of the sensor (electrode for CSX widgets) within the widget to be tested.</td></tr>
  </table>
  </dd>
</dl>
<p>For the CSD widgets, a macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</p>
<p>For the CSX widgets, sensorId is an electrode ID and is defined as Rx ID or Tx ID. The first Rx in a widget corresponds to electrodeId = 0, the second Rx in a widget corresponds to electrodeId = 1, and so on. The last Tx in a widget corresponds to electrodeId = (RxNum + TxNum - 1). Macros for Rx and Tx IDs can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as:</p><ul>
<li>CapSense_&lt;WidgetName&gt;_RX&lt;RXNumber&gt;_ID</li>
<li>CapSense_&lt;WidgetName&gt;_TX&lt;TXNumber&gt;_ID.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The sensor pin(s) are valid for CAPSENSE&trade; operations.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - A short is detected on the specified sensor.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The test was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The function was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga80ad1c421ea794bd493bb37e76c48a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ad1c421ea794bd493bb37e76c48a2b">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceCap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__capsense__enums.html#ga07f6f8cbe8fa1cebb08e2bd44e9de29b">cy_en_capsense_bist_external_cap_id_t</a>&#160;</td>
          <td class="paramname"><em>integrationCapId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxCapacitance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the capacitance in picofarads of the specified CAPSENSE&trade; integration (external) capacitor. </p>
<p>The function measures the capacitance of the specified external capacitor such as Cmod and returns the result through ptrValue, alternatively the measurement result is stored in the corresponding field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure (either .cModCap, .cIntACap, .cIntBCap, or .cShieldCap).</p>
<p>The maximum measurement capacitance is 25nF. The measurement accuracy is up to 15%. The measurement resolution is 10 bit which corresponds to the maximum capacitance specified by the maxCapacitance parameter. The bigger specified maximum capacitance is, the bigger capacitance value is for one measured count. It is recommended to specify the maximum capacitance twice bigger as the nominal capacitor capacitance. For example, if the nominal Cmod value is 2.2nF, the maxCapacitance parameter is set to 4nF-5nF.</p>
<p>The function configures all CAPSENSE&trade; pins to Strong-drive-low mode that allows detecting a short of the measured capacitor to other pins.</p>
<p>To measure all the available capacitors, the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function can be used with the CY_CAPSENSE_BIST_EXTERNAL_CAP_MASK mask. The measured results are stored in the corresponding field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</p>
<p>Measurement can be done only if the CAPSENSE&trade; Middleware is in the IDLE state. This function must not be called while the CAPSENSE&trade; Middleware is busy. The function is blocking, i.e. waits for the measurement to be completed prior to returning to the caller.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integrationCapId</td><td>Indexes of external capacitors to measure their capacitance. There are macros for each of them, namely:<ul>
<li>CY_CAPSENSE_BIST_CMOD_ID for the CSD method Cmod capacitor</li>
<li>CY_CAPSENSE_BIST_CINTA_ID for the CSX method CintA capacitor</li>
<li>CY_CAPSENSE_BIST_CINTB_ID for the CSX method CintB capacitor</li>
<li>CY_CAPSENSE_BIST_CSH_ID for the CSD method Csh capacitor</li>
</ul>
</td></tr>
    <tr><td class="paramname">ptrValue</td><td>The pointer to the result of the measurement. The result is calculated as a specified capacitor capacitance value in picofarads. The user declares a variable of the uint32_t type and passes the pointer to this variable as the function parameter. If the ptrValue parameter is NULL then the capacitance value is not returned through the parameter but stored to the corresponding field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</td></tr>
    <tr><td class="paramname">maxCapacitance</td><td>An expected by the user maximum value of the measured capacitance in nanofarads in the range from 1 to 25 nF.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_LOW_LIMIT_E - The measurement was performed but the scanning result is below the minimum possible value. The measurement result could be invalid. The capacitor might be shorted to VDD or a PCB track is broken (open capacitor).</li>
<li>CY_CAPSENSE_BIST_HIGH_LIMIT_E - The measurement was performed but the scanning result is above the maximum possible value. The measurement result could be invalid. The capacitor might be shorted to GND.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0214428f5737ef46a2f755620c4e7316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0214428f5737ef46a2f755620c4e7316">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureVdda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureVdda </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures a VDDA voltage, returns the measured voltage in millivolts through the ptrValue argument and stores it to the .vddaVoltage field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure. </p>
<p>This function measures the device analog supply voltage (VDDA) without need of explicitly connecting VDDA to any additional GPIO input. This capability can be used in variate cases, for example to monitor the battery voltage.</p>
<p>A measurement can be done only if the CAPSENSE&trade; middleware is in the IDLE state. This function must not be called while the CAPSENSE&trade; middleware is busy. The function is blocking, i.e. waits for the conversion to be completed prior to returning to the caller.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrValue</td><td>The pointer to the uint32_t to store measured VDDA voltage value. If the ptrValue parameter is NULL then VDDA voltage value is not returned through the parameter and is stored in the .vddaVoltage field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement executed successfully.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3bf9894c313d4ffce1be841141d6b8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bf9894c313d4ffce1be841141d6b8e5">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceSensor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. </p>
<p>This function measures the capacitance of the sensor (electrode for CSX widgets) and returns the measurement status. For a CSX sensor, the measurement is done on either Rx or Tx electrode. For a CSD sensor, measurement is done on a sensor (refer to the sensorId parameter description). If the specified sensor (electrode) is a ganged sensor, the capacitance is measured for all the pins ganged together that belong to this sensor (electrode).</p>
<p>The measured capacitance is stored in the .eltdCap[] array. The .ptrEltdCapacitance field of the <a class="el" href="structcy__stc__capsense__widget__config__t.html">cy_stc_capsense_widget_config_t</a> structure contains a pointer to the first widget sensor (electrode) element within the .eltdCap[] array.</p>
<p>In addition to the measuring sensor (electrode) capacitance, this function is used to identify various fault conditions with sensors such as electrically-opened or -shorted sensors. For example, the PCB track is broken or shorted to other nodes in the system - in all of these conditions, this function returns changed capacitance which can be compared against predetermined capacitance for the sensor to detect a fault condition.</p>
<p>The sensor capacitance is measured independently of the sensor scan configuration. For the capacitance measurement, the CSD sensing method is used. The measurements consists of up to four scans with different IDAC current. The IDAC current of the first measurement is 6 uA and each next measurement the IDAC current increase by four times. The default scanning parameters are the following:</p><ul>
<li>I (6 uA) is the current equal to IDAC Gain * IDAC Code (Compensation IDAC is disabled).</li>
<li>Res (12 bits) is the scanning resolution.</li>
<li>Vref (1.2 V) is the reference voltage.</li>
<li>SnsClk (375 kHz) is the sensor clock frequency.</li>
</ul>
<p>If the scanning raw count is within 7.5% to 45% range of a maximum raw count the raw count is converted into capacitance using the following equation:</p>
<p>Cs = Rawcount * I / ((2^Res - 1) * Vref * SnsClk)</p>
<p>where:</p><ul>
<li>Cs is the sensor capacitance.</li>
<li>Rawcount is the measured raw count value.</li>
</ul>
<p>If the raw count is less than 7.5% of the maximum limit (2^Res - 1), the function stops scanning the sequence and returns the CY_CAPSENSE_BIST_LOW_LIMIT_E status.</p>
<p>If the raw count is between 7.5% and 45% of the maximum, the function calculates the sensor capacitance, updates the register map and returns CY_CAPSENSE_BIST_SUCCESS_E status.</p>
<p>If the raw count is above 45% of the maximum, the function repeats scanning with a 4x increased IDAC current (up to four scans in total).</p>
<p>The minimum measurable input by this function is 1pF and the maximum is either 384pF or limited by the RC time constant (Cs &lt; 1 / (2*5*SnsClk*R), where R is the total sensor series resistance that includes on-chip GPIO resistance ~500 Ohm and external series resistance). The measurement accuracy is about 15%.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) that are not being measured are set to the GND state for CSD measured electrodes (sensors) and to the HIGH-Z state for CSX measured electrodes (Rx and Tx). Shield electrodes are also configured to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE-related electrodes for CSD or CSX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function.</p>
<p>By default, the Cmod capacitor is used for the measurement. If a dedicated Cmod is not available (e.g. the design has CSX widgets only), CintA and CintB capacitors are combined together by the firmware to form a single integration capacitor for the measurement.</p>
<p>The sensor measurement can be done on all the sensors using the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function along with the CY_CAPSENSE_BIST_SNS_CAP_MASK mask.</p>
<p>This function must not be called while the CSD HW block is busy by another state.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID of the sensor (electrode for CSX widgets) within the widget to be measured.</td></tr>
  </table>
  </dd>
</dl>
<p>For the CSD widgets, a macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</p>
<p>For the CSX widgets, sensorId is an electrode ID and is defined as Rx ID or Tx ID. The first Rx in a widget corresponds to electrodeId = 0, the second Rx in a widget corresponds to electrodeId = 1, and so on. The last Tx in a widget corresponds to electrodeId = (RxNum + TxNum - 1). Macros for Rx and Tx IDs can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as:</p><ul>
<li>CapSense_&lt;WidgetName&gt;_RX&lt;RXNumber&gt;_ID</li>
<li>CapSense_&lt;WidgetName&gt;_TX&lt;TXNumber&gt;_ID.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrValue</td><td>The pointer to the measured capacitance in femtofarads. The user declares a variable of the uint32_t type and passes the variable pointer as the function parameter. If the ptrValue parameter is NULL, the capacitance value is not returned through the parameter but still stored in the corresponding field of the data structure.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_LOW_LIMIT_E - The measurement was executed and the scanning result is below the minimum possible value. The measurement result could be invalid. The sensor might be shorted to VDD or a sensor PCB track was broken (open sensor).</li>
<li>CY_CAPSENSE_BIST_HIGH_LIMIT_E - The measurement was executed and the scanning result is above the maximum possible value. The measurement result could be invalid. The sensor might be shorted to GND.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacc9c800180cd40a8ca3e53321d6a249b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9c800180cd40a8ca3e53321d6a249b">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceShield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceShield </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures shield electrode capacitance in femtofarads. </p>
<p>This function measures the capacitance of the shield electrode and returns a status of this measurement. The measurement result in femtofarads is stored in the .shieldCap field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure. If the shield consists of several electrodes, the total capacitance of all shield electrodes is reported.</p>
<p>This function uses an algorithm identical to the sensor capacitance measurement. Refer to the <a class="el" href="group__group__capsense__low__level.html#ga3bf9894c313d4ffce1be841141d6b8e5" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensor()</a> function for more details.</p>
<p>In addition to measuring shield capacitance, this function is used to identify various fault conditions with a shield electrode such as an electrically-open or -short shield electrode, e.g. the PCB track is broken or shorted to other nodes in the system - in all of these conditions, this function returns changed capacitance that can be compared against pre-determined capacitance for the shield electrode to detect a fault condition.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) that are not being measured are set to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE-related electrodes for CSD or CSX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function. When the inactive sensor (electrode) connection is set to the CY_CAPSENSE_SNS_CONNECTION_SHIELD state, all the CAPSENSE&trade; electrodes are connected to the shield and the total capacitance are measured.</p>
<p>By default, the Cmod capacitor is used for the measurement. If a dedicated Cmod is not available (e.g. the design has CSX widgets only), CintA and CintB capacitors are combined together by the firmware to form a single integration capacitor which is used for measurement.</p>
<p>This test can be executed using the CapSense_RunSelfTest() function with the CY_CAPSENSE_BIST_SHIELD_CAP_MASK mask.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrValue</td><td>The pointer to the variable the measured capacitance is stored. The user should declare a variable of uint32_t type and pass the variable pointer as the function parameter. If the ptrValue parameter is NULL then the shield capacitance value is not returned through the parameter but is still stored in the .shieldCap field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_LOW_LIMIT_E - The measurement was executed but the measured raw count is below the minimum possible value. The measurement result could be invalid. The shield might be shorted to VDD or a shield PCB track is broken (the open shield electrode).</li>
<li>CY_CAPSENSE_BIST_HIGH_LIMIT_E - The measurement was executed but the measured raw count is above the maximum possible value. The measurement result is invalid. The sensor might be shorted to GND.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga23f23f4e684b25788f999851f20aa58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23f23f4e684b25788f999851f20aa58c">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceSensorElectrode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceSensorElectrode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eltdId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. </p>
<p>This function measures the sensor capacitance for CSD widgets or the electrode capacitance for CSX widgets and returns the measurement status. For a CSX sensor, the measurement is done on either Rx or Tx electrode. For a CSD sensor, measurement is done on a sensor (refer to the eltdId parameter description). If the specified sensor (electrode) is a ganged sensor, the capacitance is measured for all the pins ganged together that belong to this sensor (electrode).</p>
<p>The measured capacitance is stored in the .eltdCap[] array. The .ptrEltdCapacitance field of the <a class="el" href="structcy__stc__capsense__widget__config__t.html">cy_stc_capsense_widget_config_t</a> structure contains a pointer to the first widget sensor (electrode) element within the .eltdCap[] array.</p>
<p>In addition to the measuring sensor (electrode) capacitance, this function is used to identify various fault conditions with sensors such as electrically-opened or -shorted sensors. For example, the PCB track is broken or shorted to other nodes in the system - in all of these conditions, this function returns changed capacitance which can be compared against predetermined capacitance for the sensor to detect a fault condition.</p>
<p>The sensor capacitance is measured independently of the sensor scan configuration. For the capacitance measurement, the CSD sensing method is used. The default scanning parameters are the following:</p><ul>
<li>SnsClk divider (256) is the divider for the sensor clock frequency.</li>
<li>NumConv (100) is the number of sub-conversions.</li>
<li>The reference CDAC capacitance (886 fF) is equivalent to CDAC Code of 100u.</li>
<li>The compensation CDAC is disabled.</li>
<li>The CIC2 filter is disabled.</li>
<li>The dithering is disabled.</li>
<li>The chopping is disabled.</li>
</ul>
<p>The raw count is converted into capacitance using the following equation:</p>
<p>Cs = Rawcount * RefCDAC capacitance / NumConv</p>
<p>where:</p><ul>
<li>Cs is the sensor capacitance.</li>
<li>Rawcount is the measured raw count value.</li>
</ul>
<p>The minimum measurable input by this function is 1pF and the maximum is either 200pF or limited by the RC time constant (Cs &lt; 1 / (2*5*SnsClk*R), where R is the total sensor series resistance that includes on-chip GPIO resistance ~500 Ohm and external series resistance). The measurement accuracy is about 30% and is defined by the RefCDAC tolerance.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) that are not being measured are set to the GND state for CSD measured electrodes (sensors) and to the HIGH-Z state for CSX measured electrodes (Rx and Tx). Shield electrodes are also configured to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE-related electrodes for CSD or CSX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function.</p>
<p>By default, the both Cmod1 and Cmod2 capacitors are used for the measurement.</p>
<p>The sensor measurement can be done on all the electrodes using the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function along with the CY_CAPSENSE_BIST_ELTD_CAP_MASK mask.</p>
<p>This function must not be called while the CAPSENSE&trade; MW is busy by another scan.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">eltdId</td><td>Specifies the ID of the electrode within the widget (sensorID for CSD widgets and Rx or Tx electrode ID for CSX widgets).</td></tr>
  </table>
  </dd>
</dl>
<p>For the CSD widgets, a macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</p>
<p>For the CSX widgets, eltdId is an electrode ID and is defined as Rx ID or Tx ID. The first Rx in a widget corresponds to eltdId = 0, the second Rx in a widget corresponds to eltdId = 1, and so on. The last Tx in a widget corresponds to eltdId = (RxNum + TxNum - 1). Macros for Rx and Tx IDs can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as:</p><ul>
<li>CapSense_&lt;WidgetName&gt;_RX&lt;RXNumber&gt;_ID</li>
<li>CapSense_&lt;WidgetName&gt;_TX&lt;TXNumber&gt;_ID.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The measurement was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadb467c284dc3fea4c7347a25c5ff57df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb467c284dc3fea4c7347a25c5ff57df">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceSlotSensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceSlotSensors </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>skipChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the specified slot sensor capacitance in femtofarads. </p>
<p>The function measures the Cp capacitance for CSD widgets and the Cm capacitance for CSX widgets.</p>
<p>This function performs BIST slot scan with predefined parameters, back-calculates the slot sensor capacitances (Cp for CSD and Cm for CSX) by using the raw-count equation, stores the calculated capacitances to the sensor context structure, and returns the measurement status. If the specified slot has a ganged sensor, the capacitance is measured for all the pins ganged together that belong to this sensor.</p>
<p>Besides the sensor capacitance measuring, this function could be used to identify various fault conditions with sensors such as electrically-opened or -shorted sensors. For example, the PCB track is broken or shorted to other nodes in the system - in all of these conditions, the function returns changed capacitance which can be compared against predetermined capacitance for the sensor to detect a fault condition.</p>
<p>The sensor capacitance is measured independently of the sensor regular scan configuration. For the capacitance measurement, the BIST specific scan parameters are used. They can be found in the Electrode capacitance measurement macros group. The CDAC code for the CSD sensors is 100u and that provides about 0.886 pF of the CDAC value and for CSX sensors the CDAC code is 50u (0.443 pF). Compensation CDAC is disabled during the BIST scan. Another default scanning parameters are the following:</p><ul>
<li>NumConv (100) is the number of sub-conversions.</li>
<li>SnsClk divider (256) is the divider for the sensor clock frequency.</li>
</ul>
<p>The raw count is converted into capacitance using the following equation:</p>
<p>Cs = Rawcount * CDAC / 2 / NumConv / 2</p>
<p>where:</p><ul>
<li>Cs is the sensor capacitance.</li>
<li>Rawcount is the measured raw count value.</li>
<li>The first divider of 2 is determined by the divided ref_clk frequency usage.</li>
<li>The second divider of 2 is used only for CSX sensors.</li>
</ul>
<p>The minimum measurable input by this function is 0.5 pF and the maximum is either 200pF or limited by the RC time constant (Cs &lt; 1 / (2*10*SnsClk*R), where R is the total sensor series resistance that includes on-chip pin resistance ~500 Ohm and external series resistance). The measurement accuracy is about 30%.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) that are not being measured are set to the GND state for CSD measured electrodes (sensors) and to the HIGH-Z state for CSX measured electrodes (Rx and Tx). Shield electrodes are also configured to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE-related electrodes for CSD or CSX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function.</p>
<p>By default, the both Cmod1 and Cmod2 capacitors are used for the measurement.</p>
<p>Measured capacitance values (Cp for CSD widgets and Cm for CSX widgets) are stored in the .snsCap field of the <a class="el" href="structcy__stc__capsense__sensor__context__t.html">cy_stc_capsense_sensor_context_t</a> structure.</p>
<p>The all sensor measurement can be done on all the sensors using the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function along with the CY_CAPSENSE_BIST_SNS_CAP_MASK mask.</p>
<p>This function must not be called while the CAPSENSE&trade; MW is busy by another scan.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotId</td><td>Specifies the ID number of the slot to measure sensor capacitance. The slot ID should be in the admissible range.</td></tr>
    <tr><td class="paramname">skipChMask</td><td>Specifies the mask to skip some channels during the slot sensor capacitance measurement. If the bit N in the skipChMask is set to 1, the channel N will be excluded from measuring and all its pins will be set to the inactive sensor connection state (see the .eltdCapCsdISC field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure for CSD widgets and the .eltdCapCsxISC field respectively for CSX widgets).</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaff014dbf80fc7824a7e6e3e377d2942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff014dbf80fc7824a7e6e3e377d2942f">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceShieldElectrode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceShieldElectrode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>skipChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures shield electrode capacitances in femtofarads. </p>
<p>This function measures the capacitances of all shield electrodes for all enabled MSCv3 channels and returns a status of this measurement. The function checks if there is any CSD widget in the project and if the shield is enabled. The measurement results in femtofarads are stored in the chShieldCap[CY_MSC_ENABLED_CH_NUMBER] array. The pointer to the array is in the .ptrChShieldCap field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure, the CY_MSC_ENABLED_CH_NUMBER define is in the cycfg_peripherals.h file. If the any channel shield consists of several electrodes, the total capacitance of all the shield electrodes is measured.</p>
<p>This function uses an algorithm identical to the electrode capacitance measurement. Refer to the <a class="el" href="group__group__capsense__low__level.html#ga23f23f4e684b25788f999851f20aa58c" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensorElectrode()</a> function for more details.</p>
<p>In addition to measuring shield capacitance, this function is used to identify various fault conditions with shield electrodes such as an electrically-open or -short shield electrodes, e.g. the PCB track is broken or shorted to other nodes in the system - in all of these conditions, this function returns changed capacitance that can be compared against pre-determined capacitance for the shield electrode to detect a hardware fault.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) that are not being measured are set to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE-related electrodes for CSD or CSX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function. When the inactive sensor (electrode) connection is set to the CY_CAPSENSE_SNS_CONNECTION_SHIELD state, all the CAPSENSE&trade; electrodes are connected to the shield and the total capacitance are measured.</p>
<p>By default, the both Cmod1 and Cmod2 capacitors are used for the measurement.</p>
<p>This test can be executed using the CapSense_RunSelfTest() function with the CY_CAPSENSE_BIST_SHIELD_CAP_MASK mask.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipChMask</td><td>Specifies the mask to skip some channels during the shield electrode capacitance measurement. If the bit N in the skipChMask is set to 1, the channel N will be excluded from measuring and all its shield pins will be set to the shield inactive sensor connection state (see the .shieldCapISC field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure).</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_BAD_CONFIG_E - The shield is disabled. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3a30f2e4cdef59eab57f589b0091d937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a30f2e4cdef59eab57f589b0091d937">&#9670;&nbsp;</a></span>Cy_CapSense_CalibrateAllWidgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_CalibrateAllWidgets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the CapDAC/IDAC calibration for all the sensors in all widgets in the middleware to default target value. </p>
<p>This function detects the sensing method used by each widget and performs a successive approximation search algorithm to find the appropriate modulator and compensation CapDAC/IDAC (if enabled) values for all sensors in CSD widgets and/or IDAC values for all sensors in CSX widgets to make sensor raw count to the default value level.</p>
<p>This function could be used only if Enable auto-calibration parameter is enabled for CSD and/or CSX widgets.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; this function is available in single-channel solution. It is recommended to use the <a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f" title="Executes CapDAC auto-calibration for all relevant widgets if enabled. ">Cy_CapSense_CalibrateAllSlots()</a> function instead for compatibility with further CAPSENSE&trade; middleware versions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga889e60b9ca2470b37b37c772558f44ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga889e60b9ca2470b37b37c772558f44ad">&#9670;&nbsp;</a></span>Cy_CapSense_CalibrateWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_CalibrateWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the CapDAC/IDAC calibration for all the sensors in the specified widget to the default target value. </p>
<p>This function performs exactly the same tasks as <a class="el" href="group__group__capsense__low__level.html#ga3a30f2e4cdef59eab57f589b0091d937" title="Executes the CapDAC/IDAC calibration for all the sensors in all widgets in the middleware to default ...">Cy_CapSense_CalibrateAllWidgets()</a>, but only for a specified widget.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; this function is available in single-channel solution. It is recommended to use the <a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f" title="Executes CapDAC auto-calibration for all relevant widgets if enabled. ">Cy_CapSense_CalibrateAllSlots()</a> function instead for compatibility with further CAPSENSE&trade; middleware versions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="gae3f80b48c2596c149ca0b392a9a3da62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f80b48c2596c149ca0b392a9a3da62">&#9670;&nbsp;</a></span>Cy_CapSense_ScanSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanSensor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the scanning of the selected sensor in the widget. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSE middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; this function is available in single-channel solution. It is recommended to use the <a class="el" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b" title="Initiates the non-blocking scan of specified slots. ">Cy_CapSense_ScanSlots()</a> function instead for compatibility with further CAPSENSE&trade; middleware versions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="gaf51fd91df09631045f83396237395777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf51fd91df09631045f83396237395777">&#9670;&nbsp;</a></span>Cy_CapSense_SetPinState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetPinState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. </p>
<p>The possible states are GND, Shield, High-Z, Tx, Negative Tx, Rx, and Sensor. If the sensor specified in the input parameter is a ganged sensor, then the state of all GPIOs associated with the ganged sensor is updated.</p>
<p>To access a sensor of CSD of button or slider widgets, use the sensor ID. To access a sensor of CSD matrix button or touchpad widgets, use either row ID or column ID as appropriate. To access sensor CSX widgets, use either Rx ID or Tx ID as appropriate.</p>
<p>This function accepts the CY_CAPSENSE_SHIELD and CY_CAPSENSE_SENSOR states as an input only if there is at least one CSD widget in the project. Similarly, this function accepts the CY_CAPSENSE_TX_PIN and CY_CAPSENSE_RX_PIN states as an input only if there is at least one CSX widget in the project.</p>
<p>This function must not be called while the middleware is in the busy state. Calling this function directly from the application program is not recommended. This function is used to implement only the custom-specific use cases.</p>
<p>Functions that perform a setup and scan of a sensor/widget automatically set the required pin states for a sensor as required and overwrite changes made by this function to a sensor that are going to be scanned. Therefore the <a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777" title="Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. ">Cy_CapSense_SetPinState()</a> function should be called in StartSample callback (see the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section for details) or with low-level functions that perform a single-sensor scanning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorElement</td><td>Specifies the ID of the sensor element within the widget to change its pin state.<ul>
<li>For the CSD widgets use the sensor ID. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</li>
<li>For the CSX widgets use either Rx ID or Tx ID. The first Rx in a widget corresponds to sensorElement = 0; the second Rx in a widget corresponds to sensorElement = 1, and so on. The last Tx in a widget corresponds to sensorElement = (RxNum + TxNum - 1). A macro for the Rx ID or Tx ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_&lt;TX/RX&gt;&lt;TX/RX_NUMBER&gt;_ID.</li>
</ul>
</td></tr>
    <tr><td class="paramname">state</td><td>Specifies the state of the sensor to be set:<ol type="1">
<li>CY_CAPSENSE_GROUND - The pin is connected to the ground.</li>
<li>CY_CAPSENSE_HIGHZ - The drive mode of the pin is set to High-Z Analog.</li>
<li>CY_CAPSENSE_SHIELD - The shield signal is routed to the pin (available only if CSD sensing method with shield electrode is enabled).</li>
<li>CY_CAPSENSE_SENSOR - The pin is connected to the scanning bus (available only if CSD sensing method is enabled).</li>
<li>CY_CAPSENSE_TX_PIN - The Tx signal is routed to the sensor (available only if CSX sensing method is enabled).</li>
<li>CY_CAPSENSE_RX_PIN - The pin is connected to the scanning bus (available only if CSX sensing method is enabled).</li>
<li>CY_CAPSENSE_NEGATIVE_TX_PIN - The Negative Tx signal is routed to the sensor (available only if CSD sensing method is enabled).</li>
</ol>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Returns the operation status:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - Indicates the successful electrode setting.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - 1) widgetID, sensorElement or state are not valid; 2) the CSD sensing method is disabled for desired CY_CAPSENSE_SHIELD or CY_CAPSENSE_SENSOR states; 3) the CSX sensing method is disabled for desired CY_CAPSENSE_TX_PIN, CY_CAPSENSE_NEGATIVE_TX_PIN or CY_CAPSENSE_RX_PIN states. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga760c8b9c8e17b5c9689bf9305a34e393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760c8b9c8e17b5c9689bf9305a34e393">&#9670;&nbsp;</a></span>Cy_CapSense_SetInactiveElectrodeState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetInactiveElectrodeState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inactiveState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensingGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a desired state for all inactive CAPSENSE&trade;-related electrodes for CSD or CSX scans. </p>
<p>Use the function to set/change the desired state of all CAPSENSE&trade;-related electrodes which are not scanned during regular scans or BIST capacitance measurements. There are separate states for the CSX sensing method group, the CSD sensing method group, the BIST CSD sensor (electrode) capacitance measurement, the BIST CSX sensor (electrode) capacitance measurement, and the BIST shield electrode capacitance measurement. For instance, it can be configured the GND state for all inactive sensors for CSX scanning and the High-Z state for CSD scanning and the Shield state for BIST CSD sensor (electrode) capacitance measurement. The function updates some corresponding parameters in the CAPSENSE&trade; Data Structure to provide the desired state and not changes pin state immediately. The desired state will be applied to all inactive electrodes during the CSD or CSX scans or BIST capacitance measurements. It is not recommended to update the Data Structure registers directly. Additionally (only for fifth-generation CAPSENSE&trade;), the function recalculates sensor frames in a case of the CTRLMUX sensor connection method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inactiveState</td><td>Specifies the inactive CAPSENSE&trade; electrode state:<ul>
<li>CY_CAPSENSE_SNS_CONNECTION_HIGHZ</li>
<li>CY_CAPSENSE_SNS_CONNECTION_SHIELD (only for CSD scan)</li>
<li>CY_CAPSENSE_SNS_CONNECTION_GROUND</li>
</ul>
</td></tr>
    <tr><td class="paramname">sensingGroup</td><td>Specifies the sensing group:<ul>
<li>CY_CAPSENSE_CSD_GROUP</li>
<li>CY_CAPSENSE_CSX_GROUP</li>
<li>CY_CAPSENSE_BIST_CSD_GROUP</li>
<li>CY_CAPSENSE_BIST_CSX_GROUP</li>
<li>CY_CAPSENSE_BIST_SHIELD_GROUP</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="gaf43c0cf61a95f11a5981f82f5b0d4e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf43c0cf61a95f11a5981f82f5b0d4e86">&#9670;&nbsp;</a></span>Cy_CapSense_SetupWidgetExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetupWidgetExt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs extended initialization for the specified widget and also performs initialization required for a specific sensor in the widget. </p>
<p>This function requires using the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function to initiate a scan.</p>
<p>This function does the same as <a class="el" href="group__group__capsense__high__level.html#ga9f798069c57bf91f7ce2bc19bb086191" title="Performs the initialization required to scan the specified widget. ">Cy_CapSense_SetupWidget()</a> and also does the following tasks:</p><ol type="1">
<li>Connects the specified sensor of the widget.</li>
<li>Configures the CSD HW block to perform a scan of the specified sensor.</li>
</ol>
<p>Once this function is called to initialize a widget and a sensor, the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function is called to scan the sensor.</p>
<p>This function is called when no scanning is in progress. I.e. <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSE middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> returns a non-busy status.</p>
<p>Calling this function directly from the application program is not recommended. This function is used to implement only the user's specific use cases (for faster execution time or pipeline scanning, for example).</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31834a3fce1f5b57c72107b419626bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31834a3fce1f5b57c72107b419626bab">&#9670;&nbsp;</a></span>Cy_CapSense_ScanExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a conversion on the pre-configured sensor. </p>
<p>This function requires using the <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> function to set up the a widget.</p>
<p>This function performs single scanning of one sensor in the widget configured by the <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> function.</p>
<p>Calling this function directly from the application program is not recommended. This function is used to implement only the user's specific use cases (for faster execution time or pipeline scanning, for example). This function is called when no scanning is in progress. I.e. <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSE middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> returns a non-busy status.</p>
<p>The sensor must be pre-configured by using the <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> prior to calling this function. The sensor remains ready for the next scan if a previous scan was triggered by using the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function. In this case, calling <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> is not required every time before the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function. If a previous scan was triggered in any other way - <a class="el" href="group__group__capsense__high__level.html#ga6473761292c2696bdea571b8bb10b308" title="Initiates scanning of all the sensors in the widget initialized by Cy_CapSense_SetupWidget(), if no scan is in progress. ">Cy_CapSense_Scan()</a>, <a class="el" href="group__group__capsense__high__level.html#ga50e6ef42f2834083715abe86d8a85b48" title="Initiates scanning of all enabled widgets (and sensors) in the project. ">Cy_CapSense_ScanAllWidgets()</a>, or <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CAPSENSE Middleware and the CAPSENSE Tuner tool...">Cy_CapSense_RunTuner()</a> - (see the <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CAPSENSE Middleware and the CAPSENSE Tuner tool...">Cy_CapSense_RunTuner()</a> function description for more details), the sensor must be pre-configured again by using the <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> prior to calling the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1130ee418f843fce4e68832efa37e28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1130ee418f843fce4e68832efa37e28f">&#9670;&nbsp;</a></span>Cy_CapSense_CalibrateAllSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_CalibrateAllSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes CapDAC auto-calibration for all relevant widgets if enabled. </p>
<p>Having enabled the CDAC auto-calibration algorithm is the most common use case. It helps to tune your system considering board-to-board variation, temperature drift, etc. CDAC auto-calibration is enabled by default.</p>
<p>The function performs searching of Reference CDAC code, Compensation CDAC code Compensation Divider (whichever is enabled) by using a successive approximation method to make the sensor's raw count closest to the defined targets. The auto-calibration target values are defined (by default) as:</p><ul>
<li>85% of the maximum raw count for CSD widgets</li>
<li>40% of the maximum raw count for CSX widgets.</li>
</ul>
<p>To change calibration targets use the Cy_CapSense_SetCalibrTarget() function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_FAIL - The calibration is failed due to the issues with scanning (either watchdog timer, interrupt breaking, etc.).</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_CHECK_FAIL - The calibration is failed because of rawcount is out of the defined range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2a87df9f6b6810a12465149f451fd64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a87df9f6b6810a12465149f451fd64f">&#9670;&nbsp;</a></span>Cy_CapSense_SetCalibrationTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetCalibrationTargets </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csdCalibrTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csxCalibrTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the CapDAC auto-calibration raw count targets for CSD and/or CSX widgets. </p>
<p>The function sets the specified raw count targets if CSD and/or CSX widgets are in the project and the auto-calibration is enabled for them. These targets will be used instead the configured ones by <a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f" title="Executes CapDAC auto-calibration for all relevant widgets if enabled. ">Cy_CapSense_CalibrateAllSlots()</a>, <a class="el" href="group__group__capsense__low__level.html#ga3a30f2e4cdef59eab57f589b0091d937" title="Executes the CapDAC/IDAC calibration for all the sensors in all widgets in the middleware to default ...">Cy_CapSense_CalibrateAllWidgets()</a> and <a class="el" href="group__group__capsense__low__level.html#ga889e60b9ca2470b37b37c772558f44ad" title="Executes the CapDAC/IDAC calibration for all the sensors in the specified widget to the default targe...">Cy_CapSense_CalibrateWidget()</a> functions.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csdCalibrTarget</td><td>The specified raw counts target for CSD widgets in percentage. It should be more than 0u and less than 100u. If the specified target is outside the range, then the configured target value will be used for the auto-calibration.</td></tr>
    <tr><td class="paramname">csxCalibrTarget</td><td>The specified raw counts target for CSX widgets in percentage. It should be more than 0u and less than 100u. If the specified target is outside the range, then the configured target value will be used for the auto-calibration.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - At least one of the input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_BAD_CONFIG - The configuration parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5d8f778457e13ccfa3f34239aef25f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d8f778457e13ccfa3f34239aef25f47">&#9670;&nbsp;</a></span>Cy_CapSense_SlotPinState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SlotPinState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__electrode__config__t.html">cy_stc_capsense_electrode_config_t</a> *&#160;</td>
          <td class="paramname"><em>ptrEltdCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the desired electrode to the specified state by updating the CAPSENSE&trade; configuration. </p>
<p>This function changes / overwrites configuration of an electrode (several pins in case the electrode is ganged to more pins) with a state provided by pinState parameter. The function does this only for the mentioned slot ID. If a pin should have the desired state during several scans, the function should be called multiple times for the each desired slot.</p>
<p>The re-configuration is possible when parameter Sensor connection method = CTRLMUX. If parameter Sensor connection method = AMUXBUS, then the function returns CY_CAPSENSE_STATUS_BAD_CONFIG. In next releases the <a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777" title="Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. ">Cy_CapSense_SetPinState()</a> function will be provided for the AMUXBUS configuration.</p>
<p>The function changes the configuration of an electrode without storing the default state. A user is responsible to keep the default state to revert to the default settings if needed. Also, the default settings can be configured again by calling <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE firmware modules. ">Cy_CapSense_Enable()</a> function that leads to repeating CAPSENSE&trade; Data Structure initialization, repeating DAC auto-calibration and repeating base-lining.</p>
<p>Using this function is not recommended. This function is used to implement only the user's specific use cases (as changing the CAPSENSE&trade; default configuration).</p>
<p>Call this function from CAPSENSE&trade; Data Structure Initialization Callback ptrEODsInitCallback. For details of how to register callback see the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section. That avoids repeating of DAC auto-calibration and base-lining since the callback is called after CAPSENSE&trade; Data Structure initialization but before the first initialization scan.</p>
<p>The function is a low-level function and does not perform verification of input parameters (like slot ID, pointers, etc.). For example, CY_CAPSENSE_CTRLMUX_PIN_STATE_SHIELD is not available if shield is not configured in the project.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotId</td><td>The desired slot ID.</td></tr>
    <tr><td class="paramname">ptrEltdCfg</td><td>The pointer to an electrode the all pins states of which will be configured as pinState parameter.</td></tr>
    <tr><td class="paramname">pinState</td><td>The desired pins state for CSX widget electrodes:<ul>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_RX - Rx electrode.</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_TX - Tx electrode.</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_GND - Grounded.</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_TX_NEGATIVE - Negative Tx electrode (for multi-phase TX method).</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_HIGH_Z - Unconnected (high-z).</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_VDDA2 - Connected to VDDA/2. The desired pins state for CSD widget electrodes:</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_SNS - Self-cap sensor.</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_HIGH_Z - Unconnected (high-z).</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_GND - Grounded.</li>
<li>CY_CAPSENSE_CTRLMUX_PIN_STATE_SHIELD - Shield is routed to the pin.</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_CONFIG - The function does not suppose to be called with the current CAPSENSE&trade; configuration. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga264c6bafda78c56a0d620a7c88363269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga264c6bafda78c56a0d620a7c88363269">&#9670;&nbsp;</a></span>Cy_CapSense_ScanAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sequencer to the idle state by resetting the hardware, it can be used to abort current scan. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd>
<dd>
If this function is called from ISR during initialization or auto-calibration the operation of these functions will be corrupted.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="gaa89c8ed15cddd778c2232c85300eb02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa89c8ed15cddd778c2232c85300eb02d">&#9670;&nbsp;</a></span>Cy_CapSense_GetParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_GetParam </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>paramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptrTuner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a value of the specified parameter from the cy_capsense_tuner structure. </p>
<p>This function gets the value of the specified parameter by the paramId argument. The paramId for each register of cy_capsense_tuner is available in the cycfg_capsense.h file as CY_CAPSENSE_&lt;ParameterName&gt;_PARAM_ID. The paramId is a special enumerated value generated by the CAPSENSE&trade; Configurator. The format of paramId is as follows:</p><ol type="1">
<li>[ byte 3 byte 2 byte 1 byte 0 ]</li>
<li>[ RRRRRUTT IIIIIIII MMMMMMMM LLLLLLLL ]</li>
<li>U - indicates if the parameter affects the RAM Widget Object CRC.</li>
<li>T - encodes the parameter type:<ul>
<li>01b: uint8_t</li>
<li>10b: uint16_t</li>
<li>11b: uint32_t</li>
</ul>
</li>
<li>I - specifies that the widgetId parameter belongs to.</li>
<li>M,L - the parameter offset MSB and LSB accordingly in cy_capsense_tuner.</li>
<li>R - reserved</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramId</td><td>Specifies the ID of parameter to get its value. A macro for the parameter ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;ParameterName&gt;_PARAM_ID.</td></tr>
    <tr><td class="paramname">value</td><td>The pointer to a variable to be updated with the obtained value.</td></tr>
    <tr><td class="paramname">ptrTuner</td><td>The pointer to the cy_capsense_tuner variable of cy_stc_capsense_tuner_t. The cy_capsense_tuner is declared in CAPSENSE&trade; Configurator generated files:<ul>
<li>cycfg_capsense.c/h</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation. If CY_CAPSENSE_STATUS_SUCCESS is not received, either paramId is invalid or ptrTuner is null. </dd></dl>

</div>
</div>
<a id="ga6049654627a08e866ebe5e93ac414177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6049654627a08e866ebe5e93ac414177">&#9670;&nbsp;</a></span>Cy_CapSense_SetParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetParam </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>paramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptrTuner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a new value for the specified parameter in cy_capsense_tuner structure. </p>
<p>This function sets the value of the specified parameter by the paramId argument. The paramId for each register of cy_capsense_tuner is available in the cycfg_capsense.h file as CY_CAPSENSE_&lt;ParameterName&gt;_PARAM_ID. The paramId is a special enumerated value generated by the CAPSENSE&trade; Configurator. The format of paramId is as follows:</p><ol type="1">
<li>[ byte 3 byte 2 byte 1 byte 0 ]</li>
<li>[ RRRRRUTT IIIIIIII MMMMMMMM LLLLLLLL ]</li>
<li>U - indicates if the parameter affects the RAM Widget Object CRC.</li>
<li>T - encodes the parameter type:<ul>
<li>01b: uint8_t</li>
<li>10b: uint16_t</li>
<li>11b: uint32_t</li>
</ul>
</li>
<li>I - specifies that the widgetId parameter belongs to</li>
<li>M,L - the parameter offset MSB and LSB accordingly in cy_capsense_tuner.</li>
<li>R - reserved</li>
</ol>
<p>This function writes specified value into the desired register without other registers update. It is application layer responsibility to keep all the data structure registers aligned. Repeated call of <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE firmware modules. ">Cy_CapSense_Enable()</a> function helps aligning dependent register values.</p>
<p>This function updates also the widget CRC field if Built-in Self-test is enabled and paramId requires that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramId</td><td>Specifies the ID of parameter to set its value. A macro for the parameter ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;ParameterName&gt;_PARAM_ID.</td></tr>
    <tr><td class="paramname">value</td><td>Specifies the new parameter's value.</td></tr>
    <tr><td class="paramname">ptrTuner</td><td>The pointer to the cy_capsense_tuner variable of cy_stc_capsense_tuner_t. The cy_capsense_tuner is declared in CAPSENSE&trade; Configurator generated files:<ul>
<li>cycfg_capsense.c/h</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation. If CY_CAPSENSE_STATUS_SUCCESS is not received, the parameter was not updated with the new value, either paramId is invalid or ptrTuner is null. </dd></dl>

</div>
</div>
<a id="ga2de812825cd421ee05fec733206e157a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de812825cd421ee05fec733206e157a">&#9670;&nbsp;</a></span>Cy_CapSense_GetCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_CapSense_GetCRC </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ptrData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates CRC for the specified buffer and length. </p>
<p>This API is used for the CRC protection of a packet received from the CAPSENSE&trade; Tuner tool and for BIST operations. CRC polynomial is 0xAC9A. It has a Hamming distance 5 for data words up to 241 bits.</p>
<p>Reference: "P. Koopman, T. Chakravarthy,
"Cyclic Redundancy Code (CRC) Polynomial Selection for Embedded Networks",
The International Conference on Dependable Systems and Networks, DSN-2004"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrData</td><td>The pointer to the data.</td></tr>
    <tr><td class="paramname">len</td><td>The length of the data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a calculated CRC-16 value. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAPSENSE&trade; Middleware Library 3.0</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
