/**************************************************************************//**
 * @file     NUC472_442.h
 * @version  V1.00
 * $Revision: 173 $
 * $Date: 16/06/07 11:24a $
 * @brief    NUC472/NUC442 peripheral access layer header file.
 *           This file contains all the peripheral register's definitions,
 *           bits definitions and memory mapping for NuMicro NUC472/NUC442 MCU.
 * @note
 * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
 *****************************************************************************/
/**
   \mainpage NuMicro NUC472/NUC442 MCU Driver Reference Guide
   *
   * <b>Introduction</b>
   *
   * This user manual describes the usage of NUC472/NUC442 MCU device driver
   *
   * <b>Disclaimer</b>
   *
   * The Software is furnished "AS IS", without warranty as to performance or results, and
   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
   * warranties, express, implied or otherwise, with regard to the Software, its use, or
   * operation, including without limitation any and all warranties of merchantability, fitness
   * for a particular purpose, and non-infringement of intellectual property rights.
   *
   * <b>Important Notice</b>
   *
   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
   * property damage. Such applications are deemed, "Insecure Usage".
   *
   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
   * atomic energy control instruments, airplane or spaceship instruments, the control or
   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
   * instruments, all types of safety devices, and other applications intended to support or
   * sustain life.
   *
   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
   * the damages and liabilities thus incurred by Nuvoton.
   *
   * Please note that all data and specifications are subject to change without notice. All the
   * trademarks of products and companies mentioned in this document belong to their respective
   * owners.
   *
   * <b>Copyright Notice</b>
   *
   * Copyright (C) 2015~2017 Nuvoton Technology Corp. All rights reserved.
   */

#ifndef __NUC472_442_H__
#define __NUC472_442_H__

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************************/
/*                Processor and Core Peripherals                              */
/******************************************************************************/
/** @addtogroup NUC472_442_CMSIS NUC472/NUC442 Device CMSIS Definitions
  Configuration of the Cortex-M4 Processor and Core Peripherals
  @{
*/

/**
 * @details  Interrupt Number Definition.
 */
typedef enum IRQn {
    /******  Cortex-M4 Processor Exceptions Numbers ***************************************************/
    NonMaskableInt_IRQn           = -14,      /*!<  2 Non Maskable Interrupt                        */
    MemoryManagement_IRQn         = -12,      /*!<  4 Memory Management Interrupt                   */
    BusFault_IRQn                 = -11,      /*!<  5 Bus Fault Interrupt                           */
    UsageFault_IRQn               = -10,      /*!<  6 Usage Fault Interrupt                         */
    SVCall_IRQn                   = -5,       /*!< 11 SV Call Interrupt                             */
    DebugMonitor_IRQn             = -4,       /*!< 12 Debug Monitor Interrupt                       */
    PendSV_IRQn                   = -2,       /*!< 14 Pend SV Interrupt                             */
    SysTick_IRQn                  = -1,       /*!< 15 System Tick Interrupt                         */

    /******  NUC472/NUC442 Specific Interrupt Numbers ********************************************************/

    BOD_IRQn                      = 0,        /*!< Brown Out detection Interrupt                    */
    IRC_IRQn                      = 1,        /*!< Internal RC Interrupt                            */
    PWRWU_IRQn                    = 2,        /*!< Power Down Wake Up Interrupt                     */
    SRAMF_IRQn                    = 3,        /*!< SRAM Parity Check Failed Interrupt               */
    CLKF_IRQn                     = 4,        /*!< Clock Detection Failed Interrupt                 */
    RTC_IRQn                      = 6,        /*!< Real Time Clock Interrupt                        */
    TAMPER_IRQn                   = 7,        /*!< Tamper detection Interrupt                       */
    EINT0_IRQn                    = 8,        /*!< External Input 0 Interrupt                       */
    EINT1_IRQn                    = 9,        /*!< External Input 1 Interrupt                       */
    EINT2_IRQn                    = 10,       /*!< External Input 2 Interrupt                       */
    EINT3_IRQn                    = 11,       /*!< External Input 3 Interrupt                       */
    EINT4_IRQn                    = 12,       /*!< External Input 4 Interrupt                       */
    EINT5_IRQn                    = 13,       /*!< External Input 5 Interrupt                       */
    EINT6_IRQn                    = 14,       /*!< External Input 6 Interrupt                       */
    EINT7_IRQn                    = 15,       /*!< External Input 7 Interrupt                       */
    GPA_IRQn                      = 16,       /*!< GPIO Port A Interrupt                            */
    GPB_IRQn                      = 17,       /*!< GPIO Port B Interrupt                            */
    GPC_IRQn                      = 18,       /*!< GPIO Port C Interrupt                            */
    GPD_IRQn                      = 19,       /*!< GPIO Port D Interrupt                            */
    GPE_IRQn                      = 20,       /*!< GPIO Port E Interrupt                            */
    GPF_IRQn                      = 21,       /*!< GPIO Port F Interrupt                            */
    GPG_IRQn                      = 22,       /*!< GPIO Port G Interrupt                            */
    GPH_IRQn                      = 23,       /*!< GPIO Port H Interrupt                            */
    GPI_IRQn                      = 24,       /*!< GPIO Port I Interrupt                            */
    TMR0_IRQn                     = 32,       /*!< Timer 0 Interrupt                                */
    TMR1_IRQn                     = 33,       /*!< Timer 1 Interrupt                                */
    TMR2_IRQn                     = 34,       /*!< Timer 2 Interrupt                                */
    TMR3_IRQn                     = 35,       /*!< Timer 3 Interrupt                                */
    PDMA_IRQn                     = 40,       /*!< Peripheral DMA Interrupt                         */
    ADC_IRQn                      = 42,       /*!< ADC Interrupt                                    */
    WDT_IRQn                      = 46,       /*!< Watch Dog Timer Interrupt                        */
    WWDT_IRQn                     = 47,       /*!< Window Watch Dog Timer Interrupt                 */
    EADC0_IRQn                    = 48,       /*!< Enhanced ADC 0 Interrupt                         */
    EADC1_IRQn                    = 49,       /*!< Enhanced ADC 1 Interrupt                         */
    EADC2_IRQn                    = 50,       /*!< Enhanced ADC 2 Interrupt                         */
    EADC3_IRQn                    = 51,       /*!< Enhanced ADC 3 Interrupt                         */
    ACMP_IRQn                     = 56,       /*!< Analog Comparator Interrupt                      */
    OPA0_IRQn                     = 60,       /*!< OPA 0 Interrupt                                  */
    OPA1_IRQn                     = 61,       /*!< OPA 1 Interrupt                                  */
    ICAP0_IRQn                    = 62,       /*!< Input Capture 0 Interrupt                        */
    ICAP1_IRQn                    = 63,       /*!< Input Capture 1 Interrupt                        */
    PWM0CH0_IRQn                  = 64,       /*!< PWM 0 Channel 0 Interrupt                        */
    PWM0CH1_IRQn                  = 65,       /*!< PWM 0 Channel 1 Interrupt                        */
    PWM0CH2_IRQn                  = 66,       /*!< PWM 0 Channel 2 Interrupt                        */
    PWM0CH3_IRQn                  = 67,       /*!< PWM 0 Channel 3 Interrupt                        */
    PWM0CH4_IRQn                  = 68,       /*!< PWM 0 Channel 4 Interrupt                        */
    PWM0CH5_IRQn                  = 69,       /*!< PWM 0 Channel 5 Interrupt                        */
    PWM0_BRK_IRQn                 = 70,       /*!< PWM 0 Brake Interrupt                            */
    QEI0_IRQn                     = 71,       /*!< QEI 0  Interrupt                                 */
    PWM1CH0_IRQn                  = 72,       /*!< PWM 1 Channel 0 Interrupt                        */
    PWM1CH1_IRQn                  = 73,       /*!< PWM 1 Channel 1 Interrupt                        */
    PWM1CH2_IRQn                  = 74,       /*!< PWM 1 Channel 2 Interrupt                        */
    PWM1CH3_IRQn                  = 75,       /*!< PWM 1 Channel 3 Interrupt                        */
    PWM1CH4_IRQn                  = 76,       /*!< PWM 1 Channel 4 Interrupt                        */
    PWM1CH5_IRQn                  = 77,       /*!< PWM 1 Channel 5 Interrupt                        */
    PWM1BRK_IRQn                 = 78,        /*!< PWM 1 Brake Interrupt                            */
    QEI1_IRQn                     = 79,       /*!< QEI 1  Interrupt                                 */
    EPWM0_IRQn                    = 80,       /*!< Enhanced PWM 0 Interrupt                         */
    EPWM0BRK_IRQn                 = 81,       /*!< Enhanced PWM 0 Brake Interrupt                   */
    EPWM1_IRQn                    = 82,       /*!< Enhanced PWM 1 Interrupt                         */
    EPWM1BRK_IRQn                 = 83,       /*!< Enhanced PWM 1 Brake Interrupt                   */
    USBD_IRQn                     = 88,       /*!< USB FS Device Interrupt                          */
    USBH_IRQn                     = 89,       /*!< USB FS Host Interrupt                            */
    USB_OTG_IRQn                  = 90,       /*!< USB OTG Interrupt                                */
    EMAC_TX_IRQn                  = 92,       /*!< Ethernet MAC TX Interrupt                        */
    EMAC_RX_IRQn                  = 93,       /*!< Ethernet MAC RX Interrupt                        */
    SPI0_IRQn                     = 96,       /*!< SPI 0 Interrupt                                  */
    SPI1_IRQn                     = 97,       /*!< SPI 1 Interrupt                                  */
    SPI2_IRQn                     = 98,       /*!< SPI 2 Interrupt                                  */
    SPI3_IRQn                     = 99,       /*!< SPI 3 Interrupt                                  */
    UART0_IRQn                    = 104,      /*!< UART 0 Interrupt                                 */
    UART1_IRQn                    = 105,      /*!< UART 1 Interrupt                                 */
    UART2_IRQn                    = 106,      /*!< UART 2 Interrupt                                 */
    UART3_IRQn                    = 107,      /*!< UART 3 Interrupt                                 */
    UART4_IRQn                    = 108,      /*!< UART 4 Interrupt                                 */
    UART5_IRQn                    = 109,      /*!< UART 5 Interrupt                                 */
    I2C0_IRQn                     = 112,      /*!< I2C 0 Interrupt                                  */
    I2C1_IRQn                     = 113,      /*!< I2C 1 Interrupt                                  */
    I2C2_IRQn                     = 114,      /*!< I2C 2 Interrupt                                  */
    I2C3_IRQn                     = 115,      /*!< I2C 3 Interrupt                                  */
    I2C4_IRQn                     = 116,      /*!< I2C 4 Interrupt                                  */
    SC0_IRQn                      = 120,      /*!< Smart Card 0 Interrupt                           */
    SC1_IRQn                      = 121,      /*!< Smart Card 1 Interrupt                           */
    SC2_IRQn                      = 122,      /*!< Smart Card 2 Interrupt                           */
    SC3_IRQn                      = 123,      /*!< Smart Card 3 Interrupt                           */
    SC4_IRQn                      = 124,      /*!< Smart Card 4 Interrupt                           */
    SC5_IRQn                      = 125,      /*!< Smart Card 5 Interrupt                           */
    CAN0_IRQn                     = 128,      /*!< CAN 0 Interrupt                                  */
    CAN1_IRQn                     = 129,      /*!< CAN 1 Interrupt                                  */
    I2S0_IRQn                     = 132,      /*!< I2S 0 Interrupt                                  */
    I2S1_IRQn                     = 133,      /*!< I2S 1 Interrupt                                  */
    SD_IRQn                       = 136,      /*!< SD Host Interrupt                                */
    PS2D_IRQn                     = 138,      /*!< PS/2 device Interrupt                            */
    CAP_IRQn                      = 139,      /*!< VCAP Interrupt                                   */
    CRPT_IRQn                     = 140,      /*!< Cryptographic Accelerator Interrupt                                 */
    CRC_IRQn                      = 141,      /*!< CRC Interrupt                                    */
}
IRQn_Type;


/*
 * ==========================================================================
 * ----------- Processor and Core Peripheral Section ------------------------
 * ==========================================================================
 */

/* Configuration of the Cortex-M# Processor and Core Peripherals */
#define __CM4_REV                 0x0201    /*!< Core Revision r2p1                               */
#define __NVIC_PRIO_BITS          4         /*!< Number of Bits used for Priority Levels          */
#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
#define __MPU_PRESENT             1         /*!< MPU present or not                               */
#define __FPU_PRESENT             1         /*!< FPU present or not                               */

/*@}*/ /* end of group NUC472_442_CMSIS */


#include "core_cm4.h"                       /* Cortex-M4 processor and core peripherals           */
#include "system_NUC472_442.h"            /* NUC472/NUC442 System include file                         */
#include <stdint.h>

/******************************************************************************/
/*                Device Specific Peripheral registers structures             */
/******************************************************************************/
/** @addtogroup NUC472_442_Peripherals NUC472/NUC442 Control Register
  NUC472/NUC442 Device Specific Peripheral registers structures
  @{
*/

#if defined ( __CC_ARM   )
#pragma anon_unions
#endif


/*---------------------- Analog Comparator Controller -------------------------*/
/**
    @addtogroup ACMP Analog Comparator Controller(ACMP)
    Memory Mapped Structure for ACMP Controller
@{ */

typedef struct {


    /**
     * CTL0, CTL1, CTL2
     * ===================================================================================================
     * Offset: 0x00~0x08 Analog Comparator 0/1/2 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ACMPEN    |Comparator x Enable Control
     * |        |          |0 = Comparator x Disabled.
     * |        |          |1 = Comparator x Enabled.
     * |        |          |Note: The comparator output needs to wait 2 us stable time after ACMPEN is set.
     * |[1]     |ACMPIE    |Comparator x Interrupt Enable Control
     * |        |          |0 = Comparator x interrupt Disabled.
     * |        |          |1 = Comparator x interrupt Enabled.
     * |[2]     |HYSEN     |Comparator x Hysteresis Enable Control
     * |        |          |0 = Comparator x hysteresis Disabled (Default).
     * |        |          |1 = Comparator x hysteresis Enabled (typical range is 20 mV).
     * |[3]     |ACMPOINV  |Comparator x Output Inverse
     * |        |          |0 = Comparator x output inverse Disabled.
     * |        |          |1 = Comparator x output inverse Enabled.
     * |[4]     |NEGSEL    |Comparator x Negative Input Selection
     * |        |          |0 = The source of comparator x negative input is from ACMP0_N pin.
     * |        |          |1 = The internal comparator reference voltage (Band-gap voltage or CRV) is selected as the source of comparator x negative input.
     * |[5:7]   |POSSEL    |Comparator x Positive Input Selection
     * |        |          |000= Input from ACMPx_P0.
     * |        |          |001= Input from ACMPx_P1.
     * |        |          |010= Input from ACMPx_P2.
     * |        |          |011= Input from ACMPx_P3.
     * |        |          |100= Input from OPA0x. (Reserved for ACMP2)
     * |        |          |The other options are reserved.
    */
    __IO uint32_t CTL[3];

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x0C  Analog Comparator Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ACMPIF0   |Comparator 0 Flag
     * |        |          |This bit is set by hardware whenever the comparator 0 output changes state.
     * |        |          |This will cause an interrupt if ACMP_CTL0[1] is set to 1.
     * |        |          |Write 1 to clear this bit to 0.
     * |[1]     |ACMPIF1   |Comparator 1 Flag
     * |        |          |This bit is set by hardware whenever the comparator 1 output changes state.
     * |        |          |This will cause an interrupt if ACMP_CTL1[1] is set to 1.
     * |        |          |Write 1 to clear this bit to 0.
     * |[2]     |ACMPIF2   |Comparator 2 Flag
     * |        |          |This bit is set by hardware whenever the comparator 2 output changes state.
     * |        |          |This will cause an interrupt if ACMP_CTL2[1] is set to 1.
     * |        |          |Write 1 to clear this bit to 0.
     * |[3]     |ACMPO0    |Comparator 0 Output
     * |        |          |Synchronized to the APB clock to allow reading by software.
     * |        |          |Cleared when the comparator 0 is disabled (ACMP_CTL0[0] = 0).
     * |[4]     |ACMPO1    |Comparator 1 Output
     * |        |          |Synchronized to the APB clock to allow reading by software.
     * |        |          |Cleared when the comparator 1 is disabled (ACMP_CTL1[0] = 0).
     * |[5]     |ACMPO2    |Comparator 2 Output
     * |        |          |Synchronized to the APB clock to allow reading by software.
     * |        |          |Cleared when the comparator 2 is disabled (ACMP_CTL2[0] = 0).
    */
    __IO uint32_t STATUS;

    /**
     * VREF
     * ===================================================================================================
     * Offset: 0x10  Analog Comparator Reference Voltage Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CRVCTL    |Comparator Reference Voltage Setting
     * |        |          |CRV = CRV source voltage * (1/6+VREF[3:0]/24).
     * |[6]     |CRVSSEL   |CRV Source Voltage Selection
     * |        |          |0 = VDDA is selected as CRV source voltage.
     * |        |          |1 = Internal reference voltage is selected as CRV source voltage.
     * |[7]     |IREFSEL   |Internal Reference Selection
     * |        |          |0 = Band-gap voltage is selected as internal reference.
     * |        |          |1 = CRV is selected as internal reference.
    */
    __IO uint32_t VREF;

} ACMP_T;

/**
    @addtogroup ACMP_CONST ACMP Bit Field Definition
    Constant Definitions for ACMP Controller
@{ */

#define ACMP_CTL_ACMPEN_Pos              (0)                                               /*!< ACMP_T::CTL: ACMPEN Position              */
#define ACMP_CTL_ACMPEN_Msk              (0x1ul << ACMP_CTL_ACMPEN_Pos)                    /*!< ACMP_T::CTL: ACMPEN Mask                  */

#define ACMP_CTL_ACMPIE_Pos              (1)                                               /*!< ACMP_T::CTL: ACMPIE Position              */
#define ACMP_CTL_ACMPIE_Msk              (0x1ul << ACMP_CTL_ACMPIE_Pos)                    /*!< ACMP_T::CTL: ACMPIE Mask                  */

#define ACMP_CTL_HYSEN_Pos               (2)                                               /*!< ACMP_T::CTL: HYSEN Position               */
#define ACMP_CTL_HYSEN_Msk               (0x1ul << ACMP_CTL_HYSEN_Pos)                     /*!< ACMP_T::CTL: HYSEN Mask                   */

#define ACMP_CTL_ACMPOINV_Pos            (3)                                               /*!< ACMP_T::CTL: ACMPOINV Position            */
#define ACMP_CTL_ACMPOINV_Msk            (0x1ul << ACMP_CTL_ACMPOINV_Pos)                  /*!< ACMP_T::CTL: ACMPOINV Mask                */

#define ACMP_CTL_NEGSEL_Pos              (4)                                               /*!< ACMP_T::CTL: NEGSEL Position              */
#define ACMP_CTL_NEGSEL_Msk              (0x1ul << ACMP_CTL_NEGSEL_Pos)                    /*!< ACMP_T::CTL: NEGSEL Mask                  */

#define ACMP_CTL_POSSEL_Pos              (5)                                               /*!< ACMP_T::CTL: POSSEL Position              */
#define ACMP_CTL_POSSEL_Msk              (0x7ul << ACMP_CTL_POSSEL_Pos)                    /*!< ACMP_T::CTL: POSSEL Mask                  */

#define ACMP_STATUS_ACMPIF0_Pos          (0)                                               /*!< ACMP_T::STATUS: ACMPIF0 Position          */
#define ACMP_STATUS_ACMPIF0_Msk          (0x1ul << ACMP_STATUS_ACMPIF0_Pos)                /*!< ACMP_T::STATUS: ACMPIF0 Mask              */

#define ACMP_STATUS_ACMPIF1_Pos          (1)                                               /*!< ACMP_T::STATUS: ACMPIF1 Position          */
#define ACMP_STATUS_ACMPIF1_Msk          (0x1ul << ACMP_STATUS_ACMPIF1_Pos)                /*!< ACMP_T::STATUS: ACMPIF1 Mask              */

#define ACMP_STATUS_ACMPIF2_Pos          (2)                                               /*!< ACMP_T::STATUS: ACMPIF2 Position          */
#define ACMP_STATUS_ACMPIF2_Msk          (0x1ul << ACMP_STATUS_ACMPIF2_Pos)                /*!< ACMP_T::STATUS: ACMPIF2 Mask              */

#define ACMP_STATUS_ACMPO0_Pos           (3)                                               /*!< ACMP_T::STATUS: ACMPO0 Position           */
#define ACMP_STATUS_ACMPO0_Msk           (0x1ul << ACMP_STATUS_ACMPO0_Pos)                 /*!< ACMP_T::STATUS: ACMPO0 Mask               */

#define ACMP_STATUS_ACMPO1_Pos           (4)                                               /*!< ACMP_T::STATUS: ACMPO1 Position           */
#define ACMP_STATUS_ACMPO1_Msk           (0x1ul << ACMP_STATUS_ACMPO1_Pos)                 /*!< ACMP_T::STATUS: ACMPO1 Mask               */

#define ACMP_STATUS_ACMPO2_Pos           (5)                                               /*!< ACMP_T::STATUS: ACMPO2 Position           */
#define ACMP_STATUS_ACMPO2_Msk           (0x1ul << ACMP_STATUS_ACMPO2_Pos)                 /*!< ACMP_T::STATUS: ACMPO2 Mask               */

#define ACMP_VREF_CRVCTL_Pos             (0)                                               /*!< ACMP_T::VREF: CRVCTL Position             */
#define ACMP_VREF_CRVCTL_Msk             (0xful << ACMP_VREF_CRVCTL_Pos)                   /*!< ACMP_T::VREF: CRVCTL Mask                 */

#define ACMP_VREF_CRVSSEL_Pos            (6)                                               /*!< ACMP_T::VREF: CRVSSEL Position            */
#define ACMP_VREF_CRVSSEL_Msk            (0x1ul << ACMP_VREF_CRVSSEL_Pos)                  /*!< ACMP_T::VREF: CRVSSEL Mask                */

#define ACMP_VREF_IREFSEL_Pos            (7)                                               /*!< ACMP_T::VREF: IREFSEL Position            */
#define ACMP_VREF_IREFSEL_Msk            (0x1ul << ACMP_VREF_IREFSEL_Pos)                  /*!< ACMP_T::VREF: IREFSEL Mask                */

/**@}*/ /* ACMP_CONST */
/**@}*/ /* end of ACMP register group */


/*---------------------- Analog to Digital Converter -------------------------*/
/**
    @addtogroup ADC Analog to Digital Converter(ADC)
    Memory Mapped Structure for ADC Controller
@{ */

typedef struct {


    /**
     * DAT
     * ===================================================================================================
     * Offset: 0x00~0x34 ADC Data Register 0~13
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains conversion result of ADC.
     * |        |          |When DMOF (ADC_CTL[31]) bit is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
     * |        |          |When DMOF (ADC_CTL[31]) bit set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
     * |[16]    |OV        |Overrun Flag (Read Only)
     * |        |          |0 = Data in RESULT (ADC_DATx[15:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (ADC_DATx[15:0]) is overwrite.
     * |        |          |If converted data in RESULT[15:0] has not been read before new conversion result is loaded to this register, OV is set to 1 and previous conversion result is gone.
     * |        |          |It is cleared by hardware after ADC_DAT register is read.
     * |[17]    |VALID     |Valid Flag (Read Only)
     * |        |          |0 = Data in RESULT (ADC_DATx[15:0]) bits is not valid.
     * |        |          |1 = Data in RESULT (ADC_DATx[15:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADC_DAT register is read.
    */
    __I  uint32_t DAT[14];

    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[2];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x40  ADC Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ADCEN     |ADC Enable Control
     * |        |          |0 = ADC analog circuit Disabled.
     * |        |          |1 = ADC analog circuit Enabled.
     * |        |          |Before disabling ADC clock, this bit should be cleared to 0 by software.
     * |[1]     |ADCIEN    |ADC Interrupt Enable Control
     * |        |          |0 = ADC interrupt function Disabled.
     * |        |          |1 = ADC interrupt function Enabled.
     * |        |          |A/D conversion end interrupt request is generated if ADCIEN (ADC_CTL[1]) bit is set to 1.
     * |[2:3]   |OPMODE    |ADC Operation Mode
     * |        |          |00 = Single conversion.
     * |        |          |01 = Reserved.
     * |        |          |10 = Single-cycle scan.
     * |        |          |11 = Continuous scan.
     * |        |          |When changing the operation mode, software should disable SWTRG (ADC_CTL[11]) bit firstly.
     * |[4:5]   |HWTRGSEL  |External Hardware Trigger Source
     * |        |          |00 = A/D conversion is started by external pin (STADC).
     * |        |          |01 = Reserved.
     * |        |          |10 = Reserved.
     * |        |          |11 = PWM0 or PWM1 trigger condition is matched.
     * |        |          |Software should disable HWTRGCOND (ADC_CTL[8]) and SWTRG (ADC_CTL[11]) before changing HWTRGSEL (ADC_CTL[5:4]).
     * |        |          |In hardware trigger mode, the SWTRG (ADC_CTL[11]) bit is set by hardware trigger source.
     * |[6:7]   |HWTRGCOND |External Pin Trigger Conditions
     * |        |          |These two bits decide external pin (STADC) trigger event.
     * |        |          |The signal must be kept at stable state at least 8 system clocks for level trigger and 4 system clocks at high and low state for edge trigger.
     * |        |          |00 = Low level.
     * |        |          |01 = High level.
     * |        |          |10 = Falling edge.
     * |        |          |11 = Rising edge.
     * |[8]     |HWTRGEN   |External Hardware Trigger Enable Control
     * |        |          |Enable or disable hardware triggering of A/D conversion.
     * |        |          |The hardware trigger source include external pin (STADC) or PWM trigger which is controlled by HWTRGSEL (ADC_CTL[5:4]) register.
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |        |          |ADC hardware trigger function is only supported in single-cycle scan mode.
     * |[9]     |PDMAEN    |PDMA Transfer Enable Control
     * |        |          |0 = PDMA data transfer Disabled.
     * |        |          |1 = PDMA data transfer in ADC_DATx Enabled.
     * |        |          |When A/D conversion is completed, the converted data is loaded into ADC_DATx, software can enable this bit to generate a PDMA data transfer request.
     * |        |          |When PDMAEN (ADC_CTL[9]) is set to 1, software must set ADCIEN (ADC_CTL[1]) bit to 0 to disable interrupt.
     * |[10]    |DIFFEN    |Differential Input Mode Enable Control
     * |        |          |0 = Single-end analog input mode.
     * |        |          |1 = Differential analog input mode.
     * |        |          |The A/D analog input ADC0_CH0/ADC0_CH1 consists of a differential pair.
     * |        |          |So as ADC0_CH2/ADC0_CH3, ADC0_CH4/ADC0_CH5, ADC0_CH6/ADC0_CH7, ADC0_CH8/ADC0_CH9 and ADC0_CH10/ADC0_CH11.
     * |        |          |The even channel defines as plus analog input voltage (Vplus) and the odd channel defines as minus analog input voltage (Vminus).
     * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus, where Vplus
     * |        |          |is the analog input; Vminus is the inverted analog input.
     * |        |          |In differential input mode, only the even number of the two corresponding channels needs to be enabled in ADCHER (ADC_CHEN[11:0]).
     * |        |          |The conversion result will be placed to the corresponding data register of the enabled channel.
     * |[11]    |SWTRG     |A/D Conversion Start
     * |        |          |0 = Conversion stopped and A/D converter enter idle state.
     * |        |          |1 = Conversion start.
     * |        |          |The SWTRG (ADC_CTL[11]) bit can be set to 1 from two sources: software and hardware trigger.
     * |        |          |The SWTRG (ADC_CTL[11]) bit will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode.
     * |        |          |In continuous scan mode, A/D conversion is continuously performed until software write 0 to this bit or chip reset.
     * |[16:23] |PWMTRGDLY |PWM Trigger Delay Time
     * |        |          |Setting this field will delay ADC start conversion time after PWM trigger comes.
     * |        |          |PWM trigger delay time is 4 * system clock * PWMTRGDLY (ADC_CTL[23:16])
     * |[31]    |DMOF      |ADC Differential Input Mode Output Format
     * |        |          |0 = A/D conversion result will be filled in RESULT (ADC_DATx[15:0]) registers with unsigned format.
     * |        |          |1 = A/D conversion result will be filled in RESULT (ADC_DATx[15:0]) registers with 2'complement format.
    */
    __IO uint32_t CTL;

    /**
     * CHEN
     * ===================================================================================================
     * Offset: 0x44  ADC Channel Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |CHEN      |Analog Input Channel Enable Control
     * |        |          |Set CHEN (ADC_CHEN[11:0]) to enable the corresponding analog input channel (ADC0_CH1 ~ ADC0_CH11).
     * |        |          |If DIFFEN bit is set to 1, only the even number channels need to be enabled.
     * |        |          |0 = ADC input channel Disabled.
     * |        |          |1 = ADC input channel Enabled.
     * |[16]    |ADTSEN    |Internal Temperature Sensor Selection
     * |        |          |0 = Internal temperature sensor is not selected to be the analog input source of ADC.
     * |        |          |1 = Internal temperature sensor is selected to be the analog input source of ADC.
     * |        |          |ADC can only work at Single mode when software selects the temperature sensor voltage as the analog input source of ADC
     * |[17]    |ADBGEN    |Internal Band-Gap Selection
     * |        |          |0 = Internal band-gap is not selected to be the analog input source of ADC.
     * |        |          |1 = Internal band-gap is selected to be the analog input source of ADC.
     * |        |          |ADC can only work at Single mode when software selects the band-gap voltage as the analog input source of ADC
    */
    __IO uint32_t CHEN;

    /**
     * CMP
     * ===================================================================================================
     * Offset: 0x48  ADC Compare Register 0/1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ADCMPEN   |Compare Enable Control
     * |        |          |0 = Compare function Disabled.
     * |        |          |1 = Compare function Enabled.
     * |        |          |Set this bit to 1 to enable ADC controller to compare CMPDAT (ADC_CMPx[27:16]) with the conversion result of the channel specified by CMPCH (ADC_CMPx[6:3]) when the conversion data of the specified channel is loaded into ADC_DATx register.
     * |[1]     |ADCMPIE   |Compare Interrupt Enable Control
     * |        |          |0 = Compare function interrupt Disabled.
     * |        |          |1 = Compare function interrupt Enabled.
     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (ADC_CMPx[2]) and CMPMCNT(ADC_CMPx[11:8]), ADCMPFx (ADC_STATUS0[2:1]) bit will be asserted, in the meanwhile, if ADCMPIE (ADC_CMPx[1])is set to 1, a compare interrupt request is generated.
     * |[2]     |CMPCOND   |Compare Condition
     * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPDAT (ADC_CMPx[27:16]), the internal match counter will increase one.
     * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPDAT (ADC_CMPx[27:16]), the internal match counter will increase one.
     * |        |          |Note: When the internal counter reaches the value to CMPMCNT (ADC_CMPx[11:8]) + 1, the ADCMPFx (ADC_STATUS0[2:1]) bit will be set.
     * |[3:6]   |CMPCH     |Compare Channel Selection
     * |        |          |0000 = Channel 0 conversion result is selected to be compared.
     * |        |          |0001 = Channel 1 conversion result is selected to be compared.
     * |        |          |0010 = Channel 2 conversion result is selected to be compared.
     * |        |          |0011 = Channel 3 conversion result is selected to be compared.
     * |        |          |0100 = Channel 4 conversion result is selected to be compared.
     * |        |          |0101 = Channel 5 conversion result is selected to be compared.
     * |        |          |0110 = Channel 6 conversion result is selected to be compared.
     * |        |          |0111 = Channel 7 conversion result is selected to be compared.
     * |        |          |1000 = Channel 8 conversion result is selected to be compared.
     * |        |          |1001 = Channel 9 conversion result is selected to be compared.
     * |        |          |1010 = Channel 10 conversion result is selected to be compared.
     * |        |          |1011 = Channel 11 conversion result is selected to be compared.
     * |        |          |1100 = band-gap voltage result is selected to be compared.
     * |        |          |1101 = temperature sensor conversion result is selected to be compared.
     * |        |          |Others = reserved.
     * |[8:11]  |CMPMCNT   |Compare Match Count
     * |        |          |When the specified ADC channel analog conversion result matches the compare condition defined by CMPCOND (ADC_CMPx[2]), the internal match counter will increase 1.
     * |        |          |When the internal counter reaches the value to CMPMCNT (ADC_CMPx[11:8]) + 1, the ADCMPFx (ADC_STATUS0[2:1]) bit will be set.
     * |[16:27] |CMPDAT    |Compared Data
     * |        |          |When DMOF (ADC_CTL[31]) bit is set to 0, ADC comparator compares CMPDAT (ADC_CTL[27:16]) with conversion result with unsigned format.
     * |        |          |CMPDAT (ADC_CTL[27:16]) should be filled in unsigned format.
     * |        |          |When DMOF (ADC_CTL[31]) bit is set to 1, ADC comparator compares CMPDAT (ADC_CTL[27:16]) with conversion result with 2'complement format.
     * |        |          |CMPDAT (ADC_CTL[27:16]) should be filled in 2'complement format.
    */
    __IO uint32_t CMP[2];

    /**
     * STATUS0
     * ===================================================================================================
     * Offset: 0x50  ADC Status Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ADIF      |ADC Interrupt Flag
     * |        |          |A status flag that indicates the end of A/D conversion.
     * |        |          |ADIF (ADC_STATUS0[0]) is set to 1 at these two conditions:
     * |        |          |1. When A/D conversion ends in Single mode
     * |        |          |2. When A/D conversion ends on all specified channels in Scan mode
     * |        |          |Note: This flag can be cleared by writing 1 to it.
     * |[1]     |ADCMPF0   |Compare Flag
     * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1.
     * |        |          |And it is cleared by writing 1 to self.
     * |        |          |0 = Conversion result in ADC_DATx does not meet ADCMPR0 setting.
     * |        |          |1 = Conversion result in ADC_DATx meets ADCMPR0 setting.
     * |[2]     |ADCMPF1   |Compare Flag
     * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1.
     * |        |          |And it is cleared by writing 1 to self.
     * |        |          |0 = Conversion result in ADC_DATx does not meet ADCMPR1 setting.
     * |        |          |1 = Conversion result in ADC_DATx meets ADCMPR1 setting.
     * |[3]     |BUSY      |BUSY/IDLE (Read Only)
     * |        |          |0 = ADC is in idle state.
     * |        |          |1 = ADC is doing conversion.
     * |        |          |This bit is mirror of as SWTRG (ADC_CTL[11]) bit.
     * |[4:7]   |CHANNEL   |Current Conversion Channel (Read Only)
     * |        |          |This field reflects the current conversion channel when BUSY (ADC_STATUS0[3]) = 1.
     * |        |          |When BUSY (ADC_STATUS0[3]) = 0, it shows the number of the next converted channel.
    */
    __IO uint32_t STATUS0;

    /**
     * STATUS1
     * ===================================================================================================
     * Offset: 0x54  ADC Status Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:13]  |VALID     |Data Valid Flag (Read Only)
     * |        |          |It is a mirror of VALID (ADC_DATx[17]) bit.
     * |[16:29] |OV        |Overrun Flag (Read Only)
     * |        |          |It is a mirror to OV (ADC_DATx[16]) bit.
    */
    __I  uint32_t STATUS1;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[2];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * CURDAT
     * ===================================================================================================
     * Offset: 0x60  ADC PDMA Current Transfer Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:17]  |CURDAT    |ADC PDMA Current Transfer Data Bit (Read Only)
     * |        |          |When PDMA transferring, read this register can monitor current PDMA transfer data.
    */
    __I  uint32_t CURDAT;

} ADC_T;

/**
    @addtogroup ADC_CONST ADC Bit Field Definition
    Constant Definitions for ADC Controller
@{ */

#define ADC_DAT0_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT0_RESULT_Msk              (0xfffful << ADC_DAT0_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT0_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT0_OV_Msk                  (0x1ul << ADC_DAT0_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT0_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT0_VALID_Msk               (0x1ul << ADC_DAT0_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT1_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT1_RESULT_Msk              (0xfffful << ADC_DAT1_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT1_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT1_OV_Msk                  (0x1ul << ADC_DAT1_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT1_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT1_VALID_Msk               (0x1ul << ADC_DAT1_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT2_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT2_RESULT_Msk              (0xfffful << ADC_DAT2_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT2_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT2_OV_Msk                  (0x1ul << ADC_DAT2_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT2_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT2_VALID_Msk               (0x1ul << ADC_DAT2_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT3_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT3_RESULT_Msk              (0xfffful << ADC_DAT3_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT3_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT3_OV_Msk                  (0x1ul << ADC_DAT3_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT3_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT3_VALID_Msk               (0x1ul << ADC_DAT3_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT4_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT4_RESULT_Msk              (0xfffful << ADC_DAT4_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT4_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT4_OV_Msk                  (0x1ul << ADC_DAT4_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT4_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT4_VALID_Msk               (0x1ul << ADC_DAT4_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT5_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT5_RESULT_Msk              (0xfffful << ADC_DAT5_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT5_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT5_OV_Msk                  (0x1ul << ADC_DAT5_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT5_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT5_VALID_Msk               (0x1ul << ADC_DAT5_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT6_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT6_RESULT_Msk              (0xfffful << ADC_DAT6_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT6_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT6_OV_Msk                  (0x1ul << ADC_DAT6_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT6_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT6_VALID_Msk               (0x1ul << ADC_DAT6_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT7_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT7_RESULT_Msk              (0xfffful << ADC_DAT7_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT7_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT7_OV_Msk                  (0x1ul << ADC_DAT7_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT7_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT7_VALID_Msk               (0x1ul << ADC_DAT7_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT8_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT8_RESULT_Msk              (0xfffful << ADC_DAT8_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT8_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT8_OV_Msk                  (0x1ul << ADC_DAT8_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT8_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT8_VALID_Msk               (0x1ul << ADC_DAT8_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT9_RESULT_Pos              (0)                                               /*!< ADC_T::DAT: RESULT Position              */
#define ADC_DAT9_RESULT_Msk              (0xfffful << ADC_DAT9_RESULT_Pos)                 /*!< ADC_T::DAT: RESULT Mask                  */

#define ADC_DAT9_OV_Pos                  (16)                                              /*!< ADC_T::DAT: OV Position                  */
#define ADC_DAT9_OV_Msk                  (0x1ul << ADC_DAT9_OV_Pos)                        /*!< ADC_T::DAT: OV Mask                      */

#define ADC_DAT9_VALID_Pos               (17)                                              /*!< ADC_T::DAT: VALID Position               */
#define ADC_DAT9_VALID_Msk               (0x1ul << ADC_DAT9_VALID_Pos)                     /*!< ADC_T::DAT: VALID Mask                   */

#define ADC_DAT10_RESULT_Pos             (0)                                               /*!< ADC_T::DAT: RESULT Position             */
#define ADC_DAT10_RESULT_Msk             (0xfffful << ADC_DAT10_RESULT_Pos)                /*!< ADC_T::DAT: RESULT Mask                 */

#define ADC_DAT10_OV_Pos                 (16)                                              /*!< ADC_T::DAT: OV Position                 */
#define ADC_DAT10_OV_Msk                 (0x1ul << ADC_DAT10_OV_Pos)                       /*!< ADC_T::DAT: OV Mask                     */

#define ADC_DAT10_VALID_Pos              (17)                                              /*!< ADC_T::DAT: VALID Position              */
#define ADC_DAT10_VALID_Msk              (0x1ul << ADC_DAT10_VALID_Pos)                    /*!< ADC_T::DAT: VALID Mask                  */

#define ADC_DAT11_RESULT_Pos             (0)                                               /*!< ADC_T::DAT: RESULT Position             */
#define ADC_DAT11_RESULT_Msk             (0xfffful << ADC_DAT11_RESULT_Pos)                /*!< ADC_T::DAT: RESULT Mask                 */

#define ADC_DAT11_OV_Pos                 (16)                                              /*!< ADC_T::DAT: OV Position                 */
#define ADC_DAT11_OV_Msk                 (0x1ul << ADC_DAT11_OV_Pos)                       /*!< ADC_T::DAT: OV Mask                     */

#define ADC_DAT11_VALID_Pos              (17)                                              /*!< ADC_T::DAT: VALID Position              */
#define ADC_DAT11_VALID_Msk              (0x1ul << ADC_DAT11_VALID_Pos)                    /*!< ADC_T::DAT: VALID Mask                  */

#define ADC_DAT12_RESULT_Pos             (0)                                               /*!< ADC_T::DAT: RESULT Position             */
#define ADC_DAT12_RESULT_Msk             (0xfffful << ADC_DAT12_RESULT_Pos)                /*!< ADC_T::DAT: RESULT Mask                 */

#define ADC_DAT12_OV_Pos                 (16)                                              /*!< ADC_T::DAT: OV Position                 */
#define ADC_DAT12_OV_Msk                 (0x1ul << ADC_DAT12_OV_Pos)                       /*!< ADC_T::DAT: OV Mask                     */

#define ADC_DAT12_VALID_Pos              (17)                                              /*!< ADC_T::DAT: VALID Position              */
#define ADC_DAT12_VALID_Msk              (0x1ul << ADC_DAT12_VALID_Pos)                    /*!< ADC_T::DAT: VALID Mask                  */

#define ADC_DAT13_RESULT_Pos             (0)                                               /*!< ADC_T::DAT: RESULT Position             */
#define ADC_DAT13_RESULT_Msk             (0xfffful << ADC_DAT13_RESULT_Pos)                /*!< ADC_T::DAT: RESULT Mask                 */

#define ADC_DAT13_OV_Pos                 (16)                                              /*!< ADC_T::DAT: OV Position                 */
#define ADC_DAT13_OV_Msk                 (0x1ul << ADC_DAT13_OV_Pos)                       /*!< ADC_T::DAT: OV Mask                     */

#define ADC_DAT13_VALID_Pos              (17)                                              /*!< ADC_T::DAT: VALID Position              */
#define ADC_DAT13_VALID_Msk              (0x1ul << ADC_DAT13_VALID_Pos)                    /*!< ADC_T::DAT: VALID Mask                  */

#define ADC_CTL_ADCEN_Pos                (0)                                               /*!< ADC_T::CTL: ADCEN Position                */
#define ADC_CTL_ADCEN_Msk                (0x1ul << ADC_CTL_ADCEN_Pos)                      /*!< ADC_T::CTL: ADCEN Mask                    */

#define ADC_CTL_ADCIEN_Pos               (1)                                               /*!< ADC_T::CTL: ADCIEN Position               */
#define ADC_CTL_ADCIEN_Msk               (0x1ul << ADC_CTL_ADCIEN_Pos)                     /*!< ADC_T::CTL: ADCIEN Mask                   */

#define ADC_CTL_OPMODE_Pos               (2)                                               /*!< ADC_T::CTL: OPMODE Position               */
#define ADC_CTL_OPMODE_Msk               (0x3ul << ADC_CTL_OPMODE_Pos)                     /*!< ADC_T::CTL: OPMODE Mask                   */

#define ADC_CTL_HWTRGSEL_Pos             (4)                                               /*!< ADC_T::CTL: HWTRGSEL Position             */
#define ADC_CTL_HWTRGSEL_Msk             (0x3ul << ADC_CTL_HWTRGSEL_Pos)                   /*!< ADC_T::CTL: HWTRGSEL Mask                 */

#define ADC_CTL_HWTRGCOND_Pos            (6)                                               /*!< ADC_T::CTL: HWTRGCOND Position            */
#define ADC_CTL_HWTRGCOND_Msk            (0x3ul << ADC_CTL_HWTRGCOND_Pos)                  /*!< ADC_T::CTL: HWTRGCOND Mask                */

#define ADC_CTL_HWTRGEN_Pos              (8)                                               /*!< ADC_T::CTL: HWTRGEN Position              */
#define ADC_CTL_HWTRGEN_Msk              (0x1ul << ADC_CTL_HWTRGEN_Pos)                    /*!< ADC_T::CTL: HWTRGEN Mask                  */

#define ADC_CTL_PDMAEN_Pos               (9)                                               /*!< ADC_T::CTL: PDMAEN Position               */
#define ADC_CTL_PDMAEN_Msk               (0x1ul << ADC_CTL_PDMAEN_Pos)                     /*!< ADC_T::CTL: PDMAEN Mask                   */

#define ADC_CTL_DIFFEN_Pos               (10)                                              /*!< ADC_T::CTL: DIFFEN Position               */
#define ADC_CTL_DIFFEN_Msk               (0x1ul << ADC_CTL_DIFFEN_Pos)                     /*!< ADC_T::CTL: DIFFEN Mask                   */

#define ADC_CTL_SWTRG_Pos                (11)                                              /*!< ADC_T::CTL: SWTRG Position                */
#define ADC_CTL_SWTRG_Msk                (0x1ul << ADC_CTL_SWTRG_Pos)                      /*!< ADC_T::CTL: SWTRG Mask                    */

#define ADC_CTL_PWMTRGDLY_Pos            (16)                                              /*!< ADC_T::CTL: PWMTRGDLY Position            */
#define ADC_CTL_PWMTRGDLY_Msk            (0xfful << ADC_CTL_PWMTRGDLY_Pos)                 /*!< ADC_T::CTL: PWMTRGDLY Mask                */

#define ADC_CTL_DMOF_Pos                 (31)                                              /*!< ADC_T::CTL: DMOF Position                 */
#define ADC_CTL_DMOF_Msk                 (0x1ul << ADC_CTL_DMOF_Pos)                       /*!< ADC_T::CTL: DMOF Mask                     */

#define ADC_CHEN_CHEN_Pos                (0)                                               /*!< ADC_T::CHEN: CHEN Position                */
#define ADC_CHEN_CHEN_Msk                (0xffful << ADC_CHEN_CHEN_Pos)                    /*!< ADC_T::CHEN: CHEN Mask                    */

#define ADC_CHEN_ADTSEN_Pos              (16)                                              /*!< ADC_T::CHEN: ADTSEN Position              */
#define ADC_CHEN_ADTSEN_Msk              (0x1ul << ADC_CHEN_ADTSEN_Pos)                    /*!< ADC_T::CHEN: ADTSEN Mask                  */

#define ADC_CHEN_ADBGEN_Pos              (17)                                              /*!< ADC_T::CHEN: ADBGEN Position              */
#define ADC_CHEN_ADBGEN_Msk              (0x1ul << ADC_CHEN_ADBGEN_Pos)                    /*!< ADC_T::CHEN: ADBGEN Mask                  */

#define ADC_CMP0_ADCMPEN_Pos             (0)                                               /*!< ADC_T::CMP: ADCMPEN Position             */
#define ADC_CMP0_ADCMPEN_Msk             (0x1ul << ADC_CMP0_ADCMPEN_Pos)                   /*!< ADC_T::CMP: ADCMPEN Mask                 */

#define ADC_CMP0_ADCMPIE_Pos             (1)                                               /*!< ADC_T::CMP: ADCMPIE Position             */
#define ADC_CMP0_ADCMPIE_Msk             (0x1ul << ADC_CMP0_ADCMPIE_Pos)                   /*!< ADC_T::CMP: ADCMPIE Mask                 */

#define ADC_CMP0_CMPCOND_Pos             (2)                                               /*!< ADC_T::CMP: CMPCOND Position             */
#define ADC_CMP0_CMPCOND_Msk             (0x1ul << ADC_CMP0_CMPCOND_Pos)                   /*!< ADC_T::CMP: CMPCOND Mask                 */

#define ADC_CMP0_CMPCH_Pos               (3)                                               /*!< ADC_T::CMP: CMPCH Position               */
#define ADC_CMP0_CMPCH_Msk               (0xful << ADC_CMP0_CMPCH_Pos)                     /*!< ADC_T::CMP: CMPCH Mask                   */

#define ADC_CMP0_CMPMCNT_Pos             (8)                                               /*!< ADC_T::CMP: CMPMCNT Position             */
#define ADC_CMP0_CMPMCNT_Msk             (0xful << ADC_CMP0_CMPMCNT_Pos)                   /*!< ADC_T::CMP: CMPMCNT Mask                 */

#define ADC_CMP0_CMPDAT_Pos              (16)                                              /*!< ADC_T::CMP: CMPDAT Position              */
#define ADC_CMP0_CMPDAT_Msk              (0xffful << ADC_CMP0_CMPDAT_Pos)                  /*!< ADC_T::CMP: CMPDAT Mask                  */

#define ADC_CMP1_ADCMPEN_Pos             (0)                                               /*!< ADC_T::CMP: ADCMPEN Position             */
#define ADC_CMP1_ADCMPEN_Msk             (0x1ul << ADC_CMP1_ADCMPEN_Pos)                   /*!< ADC_T::CMP: ADCMPEN Mask                 */

#define ADC_CMP1_ADCMPIE_Pos             (1)                                               /*!< ADC_T::CMP: ADCMPIE Position             */
#define ADC_CMP1_ADCMPIE_Msk             (0x1ul << ADC_CMP1_ADCMPIE_Pos)                   /*!< ADC_T::CMP: ADCMPIE Mask                 */

#define ADC_CMP1_CMPCOND_Pos             (2)                                               /*!< ADC_T::CMP: CMPCOND Position             */
#define ADC_CMP1_CMPCOND_Msk             (0x1ul << ADC_CMP1_CMPCOND_Pos)                   /*!< ADC_T::CMP: CMPCOND Mask                 */

#define ADC_CMP1_CMPCH_Pos               (3)                                               /*!< ADC_T::CMP: CMPCH Position               */
#define ADC_CMP1_CMPCH_Msk               (0xful << ADC_CMP1_CMPCH_Pos)                     /*!< ADC_T::CMP: CMPCH Mask                   */

#define ADC_CMP1_CMPMCNT_Pos             (8)                                               /*!< ADC_T::CMP: CMPMCNT Position             */
#define ADC_CMP1_CMPMCNT_Msk             (0xful << ADC_CMP1_CMPMCNT_Pos)                   /*!< ADC_T::CMP: CMPMCNT Mask                 */

#define ADC_CMP1_CMPDAT_Pos              (16)                                              /*!< ADC_T::CMP: CMPDAT Position              */
#define ADC_CMP1_CMPDAT_Msk              (0xffful << ADC_CMP1_CMPDAT_Pos)                  /*!< ADC_T::CMP: CMPDAT Mask                  */

#define ADC_STATUS0_ADIF_Pos             (0)                                               /*!< ADC_T::STATUS0: ADIF Position             */
#define ADC_STATUS0_ADIF_Msk             (0x1ul << ADC_STATUS0_ADIF_Pos)                   /*!< ADC_T::STATUS0: ADIF Mask                 */

#define ADC_STATUS0_ADCMPF0_Pos          (1)                                               /*!< ADC_T::STATUS0: ADCMPF0 Position          */
#define ADC_STATUS0_ADCMPF0_Msk          (0x1ul << ADC_STATUS0_ADCMPF0_Pos)                /*!< ADC_T::STATUS0: ADCMPF0 Mask              */

#define ADC_STATUS0_ADCMPF1_Pos          (2)                                               /*!< ADC_T::STATUS0: ADCMPF1 Position          */
#define ADC_STATUS0_ADCMPF1_Msk          (0x1ul << ADC_STATUS0_ADCMPF1_Pos)                /*!< ADC_T::STATUS0: ADCMPF1 Mask              */

#define ADC_STATUS0_BUSY_Pos             (3)                                               /*!< ADC_T::STATUS0: BUSY Position             */
#define ADC_STATUS0_BUSY_Msk             (0x1ul << ADC_STATUS0_BUSY_Pos)                   /*!< ADC_T::STATUS0: BUSY Mask                 */

#define ADC_STATUS0_CHANNEL_Pos          (4)                                               /*!< ADC_T::STATUS0: CHANNEL Position          */
#define ADC_STATUS0_CHANNEL_Msk          (0xful << ADC_STATUS0_CHANNEL_Pos)                /*!< ADC_T::STATUS0: CHANNEL Mask              */

#define ADC_STATUS1_VALID_Pos            (0)                                               /*!< ADC_T::STATUS1: VALID Position            */
#define ADC_STATUS1_VALID_Msk            (0x3ffful << ADC_STATUS1_VALID_Pos)               /*!< ADC_T::STATUS1: VALID Mask                */

#define ADC_STATUS1_OV_Pos               (16)                                              /*!< ADC_T::STATUS1: OV Position               */
#define ADC_STATUS1_OV_Msk               (0x3ffful << ADC_STATUS1_OV_Pos)                  /*!< ADC_T::STATUS1: OV Mask                   */

#define ADC_CURDAT_CURDAT_Pos            (0)                                               /*!< ADC_T::CURDAT: CURDAT Position            */
#define ADC_CURDAT_CURDAT_Msk            (0x3fffful << ADC_CURDAT_CURDAT_Pos)              /*!< ADC_T::CURDAT: CURDAT Mask                */

/**@}*/ /* ADC_CONST */
/**@}*/ /* end of ADC register group */


/*---------------------- Controller Area Network Controller -------------------------*/
/**
    @addtogroup CAN Controller Area Network Controller(CAN)
    Memory Mapped Structure for CAN Controller
@{ */

typedef struct {

    /**
     * CAN_IFn_CREQ
     * ===================================================================================================
     * Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |MessageNumber|Message Number
     * |        |          |0x01-0x20: Valid Message Number, the Message Object in the Message
     * |        |          |RAM is selected for data transfer.
     * |        |          |0x00: Not a valid Message Number, interpreted as 0x20.
     * |        |          |0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.
     * |[15]    |Busy      |Busy Flag
     * |        |          |0 = Read/write action has finished.
     * |        |          |1 = Writing to the IFn Command Request Register is in progress.
     * |        |          |This bit can only be read by the software.
    */
    __IO uint32_t CREQ;

    /**
     * CAN_IFn_CMASK
     * ===================================================================================================
     * Offset: 0x24, 0x84  IFn Command Mask Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DAT_B     |Access Data Bytes [7:4]
     * |        |          |Write Operation:
     * |        |          |0 = Data Bytes [7:4] unchanged.
     * |        |          |1 = Transfer Data Bytes [7:4] to Message Object.
     * |        |          |Read Operation:
     * |        |          |0 = Data Bytes [7:4] unchanged.
     * |        |          |1 = Transfer Data Bytes [7:4] to IFn Message Buffer Register.
     * |[1]     |DAT_A     |Access Data Bytes [3:0]
     * |        |          |Write Operation:
     * |        |          |0 = Data Bytes [3:0] unchanged.
     * |        |          |1 = Transfer Data Bytes [3:0] to Message Object.
     * |        |          |Read Operation:
     * |        |          |0 = Data Bytes [3:0] unchanged.
     * |        |          |1 = Transfer Data Bytes [3:0] to IFn Message Buffer Register.
     * |[2]     |TxRqst_NewDat|Access Transmission Request Bit When Write Operation
     * |        |          |0 = TxRqst bit unchanged.
     * |        |          |1 = Set TxRqst bit.
     * |        |          |Note: If a transmission is requested by programming bit TxRqst/NewDat in the IFn Command Mask Register, bit TxRqst in the IFn Message Control Register will be ignored.
     * |        |          |Access New Data Bit when Read Operation.
     * |        |          |0 = NewDat bit remains unchanged.
     * |        |          |1 = Clear NewDat bit in the Message Object.
     * |        |          |Note: A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat.
     * |        |          |The values of these bits transferred to the IFn Message Control Register always reflect the status before resetting these bits.
     * |[3]     |ClrIntPnd |Clear Interrupt Pending Bit
     * |        |          |Write Operation:
     * |        |          |When writing to a Message Object, this bit is ignored.
     * |        |          |Read Operation:
     * |        |          |0 = IntPnd bit (CAN_IFn_MCON[13]) remains unchanged.
     * |        |          |1 = Clear IntPnd bit in the Message Object.
     * |[4]     |Control   |Control Access Control Bits
     * |        |          |Write Operation:
     * |        |          |0 = Control Bits unchanged.
     * |        |          |1 = Transfer Control Bits to Message Object.
     * |        |          |Read Operation:
     * |        |          |0 = Control Bits unchanged.
     * |        |          |1 = Transfer Control Bits to IFn Message Buffer Register.
     * |[5]     |Arb       |Access Arbitration Bits
     * |        |          |Write Operation:
     * |        |          |0 = Arbitration bits unchanged.
     * |        |          |1 = Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal (CAN_IFn_APB2[15]) to Message Object.
     * |        |          |Read Operation:
     * |        |          |0 = Arbitration bits unchanged.
     * |        |          |1 = Transfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register.
     * |[6]     |Mask      |Access Mask Bits
     * |        |          |Write Operation:
     * |        |          |0 = Mask bits unchanged.
     * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
     * |        |          |Read Operation:
     * |        |          |0 = Mask bits unchanged.
     * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register.
     * |[7]     |WR_RD     |Write / Read Mode
     * |        |          |0 = Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers.
     * |        |          |1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register.
    */
    __IO uint32_t CMASK;

    /**
     * CAN_IFn_MASK1
     * ===================================================================================================
     * Offset: 0x28, 0x88  IFn Mask 1 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |Msk150    |Identifier Mask 15-0
     * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
     * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
    */
    __IO uint32_t MASK1;

    /**
     * CAN_IFn_MASK2
     * ===================================================================================================
     * Offset: 0x2C, 0x8C  IFn Mask 2 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:12]  |Msk2816   |Identifier Mask 28-16
     * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
     * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
     * |[14]    |MDir      |Mask Message Direction
     * |        |          |0 = The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance filtering.
     * |        |          |1 = The message direction bit (Dir) is used for acceptance filtering.
     * |[15]    |MXtd      |Mask Extended Identifier
     * |        |          |0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
     * |        |          |1 = The extended identifier bit (IDE) is used for acceptance filtering.
     * |        |          |Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]).
     * |        |          |For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 (CAN_IFn_MASK2[12:2]) are considered.
    */
    __IO uint32_t MASK2;

    /**
     * CAN_IFn_ARB1
     * ===================================================================================================
     * Offset: 0x30, 0x90  IFn Arbitration 1 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |ID150     |Message Identifier 15-0
     * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
     * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
    */
    __IO uint32_t ARB1;

    /**
     * CAN_IFn_ARB2
     * ===================================================================================================
     * Offset: 0x34, 0x94  IFn Arbitration 2 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:12]  |ID2816    |Message Identifier 28-16
     * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
     * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
     * |[13]    |Dir       |Message Direction
     * |        |          |0 = Direction is receive.
     * |        |          |On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted.
     * |        |          |On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
     * |        |          |1 = Direction is transmit.
     * |        |          |On TxRqst, the respective Message Object is transmitted as a Data Frame.
     * |        |          |On reception of a Remote Frame with matching identifier, the TxRqst bit (CAN_IFn_CMASK[2]) of this Message Object is set (if RmtEn (CAN_IFn_MCON[9]) = one).
     * |[14]    |Xtd       |Extended Identifier
     * |        |          |0 = The 11-bit ("standard") Identifier will be used for this Message Object.
     * |        |          |1 = The 29-bit ("extended") Identifier will be used for this Message Object.
     * |[15]    |MsgVal    |Message Valid
     * |        |          |0 = The Message Object is ignored by the Message Handler.
     * |        |          |1 = The Message Object is configured and should be considered by the Message Handler.
     * |        |          |Note: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init (CAN_CON[0]).
     * |        |          |This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd (CAN_IFn_ARB2[14]), Dir (CAN_IFn_APB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0]) are modified, or if the Messages Object is no longer required.
    */
    __IO uint32_t ARB2;

    /**
     * CAN_IFn_MCON
     * ===================================================================================================
     * Offset: 0x38, 0x98  IFn Message Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |DLC       |Data Length Code
     * |        |          |0-8: Data Frame has 0-8 data bytes.
     * |        |          |9-15: Data Frame has 8 data bytes
     * |        |          |Note: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes.
     * |        |          |When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.
     * |        |          |Data 0: 1st data byte of a CAN Data Frame
     * |        |          |Data 1: 2nd data byte of a CAN Data Frame
     * |        |          |Data 2: 3rd data byte of a CAN Data Frame
     * |        |          |Data 3: 4th data byte of a CAN Data Frame
     * |        |          |Data 4: 5th data byte of a CAN Data Frame
     * |        |          |Data 5: 6th data byte of a CAN Data Frame
     * |        |          |Data 6: 7th data byte of a CAN Data Frame
     * |        |          |Data 7 : 8th data byte of a CAN Data Frame
     * |        |          |Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last.
     * |        |          |When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object.
     * |        |          |If the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.
     * |[7]     |EoB       |End Of Buffer
     * |        |          |0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer.
     * |        |          |1 = Single Message Object or last Message Object of a FIFO Buffer.
     * |        |          |Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer.
     * |        |          |For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.
     * |[8]     |TxRqst    |Transmit Request
     * |        |          |0 = This Message Object is not waiting for transmission.
     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
     * |[9]     |RmtEn     |Remote Enable Control
     * |        |          |0 = At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged.
     * |        |          |1 = At the reception of a Remote Frame, TxRqst is set.
     * |[10]    |RxIE      |Receive Interrupt Enable Control
     * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame.
     * |        |          |1 = IntPnd will be set after a successful reception of a frame.
     * |[11]    |TxIE      |Transmit Interrupt Enable Control
     * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a frame.
     * |        |          |1 = IntPnd will be set after a successful transmission of a frame.
     * |[12]    |UMask     |Use Acceptance Mask
     * |        |          |0 = Mask ignored.
     * |        |          |1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
     * |        |          |Note: If the UMask bit is set to one, the Message Object's mask bits have to be programmed during initialization of the Message Object before MsgVal bit (CAN_IFn_APB2[15]) is set to one.
     * |[13]    |IntPnd    |Interrupt Pending
     * |        |          |0 = This message object is not the source of an interrupt.
     * |        |          |1 = This message object is the source of an interrupt.
     * |        |          |The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
     * |[14]    |MsgLst    |Message Lost (only valid for Message Objects with direction = receive).
     * |        |          |0 = No message lost since last time this bit was reset by the CPU.
     * |        |          |1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message.
     * |[15]    |NewDat    |New Data
     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software.
     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
    */
    __IO uint32_t MCON;

    /**
     * CAN_IFn_DAT_A1
     * ===================================================================================================
     * Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |Data0     |Data Byte 0
     * |        |          |1st data byte of a CAN Data Frame
     * |[8:15]  |Data1     |Data Byte 1
     * |        |          |2nd data byte of a CAN Data Frame
    */
    __IO uint32_t DAT_A1;

    /**
     * CAN_IFn_DAT_A2
     * ===================================================================================================
     * Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |Data2     |Data Byte 2
     * |        |          |3rd data byte of CAN Data Frame
     * |[8:15]  |Data3     |Data Byte 3
     * |        |          |4th data byte of CAN Data Frame
    */
    __IO uint32_t DAT_A2;

    /**
     * CAN_IFn_DAT_B1
     * ===================================================================================================
     * Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |Data4     |Data Byte 4
     * |        |          |5th data byte of CAN Data Frame
     * |[8:15]  |Data5     |Data Byte 5
     * |        |          |6th data byte of CAN Data Frame
    */
    __IO uint32_t DAT_B1;

    /**
     * CAN_IFn_DAT_B2
     * ===================================================================================================
     * Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |Data6     |Data Byte 6
     * |        |          |7th data byte of CAN Data Frame.
     * |[8:15]  |Data7     |Data Byte 7
     * |        |          |8th data byte of CAN Data Frame.
    */
    __IO uint32_t DAT_B2;
    /// @cond HIDDEN_SYMBOLS
    __I uint32_t RESERVE0[13];
    /// @endcond //HIDDEN_SYMBOLS
} CAN_IF_T;

typedef struct {

    /**
     * CAN_CON
     * ===================================================================================================
     * Offset: 0x00  Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |Init      |Init Initialization
     * |        |          |0 = Normal Operation.
     * |        |          |1 = Initialization is started.
     * |[1]     |IE        |Module Interrupt Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |SIE       |Status Change Interrupt Enable Control
     * |        |          |0 = Disabled - No Status Change Interrupt will be generated.
     * |        |          |1 = Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
     * |[3]     |EIE       |Error Interrupt Enable Control
     * |        |          |0 = Disabled - No Error Status Interrupt will be generated.
     * |        |          |1 = Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status Register will generate an interrupt.
     * |[5]     |DAR       |Automatic Re-Transmission Disable Control
     * |        |          |0 = Automatic Retransmission of disturbed messages enabled.
     * |        |          |1 = Automatic Retransmission disabled.
     * |[6]     |CCE       |Configuration Change Enable Control
     * |        |          |0 = No write access to the Bit Timing Register.
     * |        |          |1 = Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1).
     * |[7]     |Test      |Test Mode Enable Control
     * |        |          |0 = Normal Operation.
     * |        |          |1 = Test Mode.
    */
    __IO uint32_t   CON;

    /**
     * CAN_STATUS
     * ===================================================================================================
     * Offset: 0x04  Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |LEC       |Last Error Code (Type Of The Last Error To Occur On The CAN Bus)
     * |        |          |The LEC field holds a code, which indicates the type of the last error to occur on the CAN bus.
     * |        |          |This field will be cleared to '0' when a message has been transferred (reception or transmission) without error.
     * |        |          |The unused code '7' may be written by the CPU to check for updates.
     * |        |          |The following table describes the error code.
     * |[3]     |TxOK      |Transmitted A Message Successfully
     * |        |          |0 = Since this bit was reset by the CPU, no message has been successfully transmitted.
     * |        |          |This bit is never reset by the CAN Core.
     * |        |          |1 = Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted.
     * |[4]     |RxOK      |Received A Message Successfully
     * |        |          |0 = No message has been successfully received since this bit was last reset by the CPU.
     * |        |          |This bit is never reset by the CAN Core.
     * |        |          |1 = A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering).
     * |[5]     |EPass     |Error Passive (Read Only)
     * |        |          |0 = The CAN Core is error active.
     * |        |          |1 = The CAN Core is in the error passive state as defined in the CAN Specification.
     * |[6]     |EWarn     |Error Warning Status (Read Only)
     * |        |          |0 = Both error counters are below the error warning limit of 96.
     * |        |          |1 = At least one of the error counters in the EML has reached the error warning limit of 96.
     * |[7]     |BOff      |Bus-Off Status (Read Only)
     * |        |          |0 = The CAN module is not in bus-off state.
     * |        |          |1 = The CAN module is in bus-off state.
    */
    __IO uint32_t   STATUS;

    /**
     * CAN_ERR
     * ===================================================================================================
     * Offset: 0x08  Error Counter Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |TEC       |Transmit Error Counter
     * |        |          |Actual state of the Transmit Error Counter. Values between 0 and 255.
     * |[8:14]  |REC       |Receive Error Counter
     * |        |          |Actual state of the Receive Error Counter. Values between 0 and 127.
     * |[15]    |RP        |Receive Error Passive
     * |        |          |0 = The Receive Error Counter is below the error passive level.
     * |        |          |1 = The Receive Error Counter has reached the error passive level as defined in the CAN Specification.
    */
    __IO uint32_t   ERR;

    /**
     * CAN_BTIME
     * ===================================================================================================
     * Offset: 0x0C  Bit Timing Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |BRP       |Baud Rate Prescaler
     * |        |          |0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta.
     * |        |          |The bit time is built up from a multiple of this quanta.
     * |        |          |Valid values for the Baud Rate Prescaler are [ 0 ... 63 ].
     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
     * |[6:7]   |SJW       |(Re)Synchronization Jump Width
     * |        |          |0x0-0x3: Valid programmed values are [0 ... 3].
     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
     * |[8:11]  |TSeg1     |Time Segment Before The Sample Point Minus Sync_Seg
     * |        |          |0x01-0x0F: valid values for TSeg1 are [1 ... 15].
     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed is used.
     * |[12:14] |TSeg2     |Time Segment After Sample Point
     * |        |          |0x0-0x7: Valid values for TSeg2 are [0 ... 7].
     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
    */
    __IO uint32_t   BTIME;

    /**
     * CAN_IIDR
     * ===================================================================================================
     * Offset: 0x10  Interrupt Identifier Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |IntId     |Interrupt Identifier (Indicates The Source Of The Interrupt)
     * |        |          |If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order.
     * |        |          |An interrupt remains pending until the application software has cleared it.
     * |        |          |If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to the EIC is active.
     * |        |          |The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.
     * |        |          |The Status Interrupt has the highest priority.
     * |        |          |Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.
     * |        |          |A message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]).
     * |        |          |The Status Interrupt is cleared by reading the Status Register.
    */
    __IO uint32_t   IIDR;

    /**
     * CAN_TEST
     * ===================================================================================================
     * Offset: 0x14  Test Register (Register Map Note 1)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |Res       |Reserved
     * |        |          |There are reserved bits.
     * |        |          |These bits are always read as '0' and must always be written with '0'.
     * |[2]     |Basic     |Basic Mode
     * |        |          |0 = Basic Mode disabled.
     * |        |          |1= IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer.
     * |[3]     |Silent    |Silent Mode
     * |        |          |0 = Normal operation.
     * |        |          |1 = The module is in Silent Mode.
     * |[4]     |LBack     |Loop Back Mode Enable Control
     * |        |          |0 = Loop Back Mode is disabled.
     * |        |          |1 = Loop Back Mode is enabled.
     * |[5:6]   |Tx10      |Tx[1:0]: Control Of CAN_TX Pin
     * |        |          |00 = Reset value, CAN_TX pin is controlled by the CAN Core.
     * |        |          |01 = Sample Point can be monitored at CAN_TX pin.
     * |        |          |10 = CAN_TX pin drives a dominant ('0') value.
     * |        |          |11 = CAN_TX pin drives a recessive ('1') value.
     * |[7]     |Rx        |Monitors The Actual Value Of CAN_RX Pin (Read Only)
     * |        |          |0 = The CAN bus is dominant (CAN_RX = '0').
     * |        |          |1 = The CAN bus is recessive (CAN_RX = '1').
    */
    __IO uint32_t   TEST;

    /**
     * CAN_BRPE
     * ===================================================================================================
     * Offset: 0x18  Baud Rate Prescaler Extension Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |BRPE      |BRPE: Baud Rate Prescaler Extension
     * |        |          |0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023.
     * |        |          |The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.
    */
    __IO uint32_t   BRPE;

    __I uint32_t    RESERVE0[1];

    __IO CAN_IF_T   IF[2];

    __I uint32_t    RESERVE1[8];

    /**
     * CAN_TXREQ1
     * ===================================================================================================
     * Offset: 0x100  Transmission Request Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |TxRqst161 |Transmission Request Bits 16-1 (Of All Message Objects)
     * |        |          |0 = This Message Object is not waiting for transmission.
     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
     * |        |          |These bits are read only.
    */
    __IO uint32_t   TXREQ1;

    /**
     * CAN_TXREQ2
     * ===================================================================================================
     * Offset: 0x104  Transmission Request Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |TxRqst3217|Transmission Request Bits 32-17 (Of All Message Objects)
     * |        |          |0 = This Message Object is not waiting for transmission.
     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
     * |        |          |These bits are read only.
    */
    __IO uint32_t   TXREQ2;

    __I uint32_t    RESERVE2[6];

    /**
     * CAN_NDAT1
     * ===================================================================================================
     * Offset: 0x120  New Data Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |NewData161|New Data Bits 16-1 (Of All Message Objects)
     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
    */
    __IO uint32_t   NDAT1;

    /**
     * CAN_NDAT2
     * ===================================================================================================
     * Offset: 0x124  New Data Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |NewData3217|New Data Bits 32-17 (Of All Message Objects)
     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
    */
    __IO uint32_t   NDAT2;

    __I uint32_t    RESERVE3[6];

    /**
     * CAN_IPND1
     * ===================================================================================================
     * Offset: 0x140  Interrupt Pending Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |IntPnd161 |Interrupt Pending Bits 16-1 (Of All Message Objects)
     * |        |          |0 = This message object is not the source of an interrupt.
     * |        |          |1 = This message object is the source of an interrupt.
    */
    __IO uint32_t   IPND1;

    /**
     * CAN_IPND2
     * ===================================================================================================
     * Offset: 0x144  Interrupt Pending Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |IntPnd3217|Interrupt Pending Bits 32-17(Of All Message Objects)
     * |        |          |0 = This message object is not the source of an interrupt.
     * |        |          |1 = This message object is the source of an interrupt.
    */
    __IO uint32_t   IPND2;

    __I uint32_t    RESERVE4[6];

    /**
     * CAN_MVLD1
     * ===================================================================================================
     * Offset: 0x160  Message Valid Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |MsgVal161 |Message Valid Bits 16-1 (Of All Message Objects) (Read Only)
     * |        |          |0 = This Message Object is ignored by the Message Handler.
     * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
     * |        |          |Ex.
     * |        |          |CAN_MVLD1[0] means Message object No.1 is valid or not.
     * |        |          |If CAN_MVLD1[0] is set, message object No.1 is configured.
    */
    __IO uint32_t   MVLD1;

    /**
     * CAN_MVLD2
     * ===================================================================================================
     * Offset: 0x164  Message Valid Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |MsgVal3217|Message Valid Bits 32-17 (Of All Message Objects) (Read Only)
     * |        |          |0 = This Message Object is ignored by the Message Handler.
     * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
     * |        |          |Ex.CAN_MVLD2[15] means Message object No.32 is valid or not.
     * |        |          |If CAN_MVLD2[15] is set, message object No.32 is configured.
    */
    __IO uint32_t   MVLD2;

    /**
     * CAN_WU_EN
     * ===================================================================================================
     * Offset: 0x168  Wake-up Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |WAKUP_EN  |Wake-Up Enable Control
     * |        |          |0 = The wake-up function Disabled.
     * |        |          |1 = The wake-up function Enabled.
     * |        |          |Note: User can wake-up system when there is a falling edge in the CAN_Rx pin.
    */
    __IO uint32_t WU_EN;

    /**
     * CAN_WU_STATUS
     * ===================================================================================================
     * Offset: 0x16C  Wake-up Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |WAKUP_STS |Wake-Up Status
     * |        |          |0 = No wake-up event occurred.
     * |        |          |1 = Wake-up event occurred.
     * |        |          |Note: This bit can be cleared by writing '0'.
    */
    __IO uint32_t WU_STATUS;
} CAN_T;

/**
    @addtogroup CAN_CONST CAN Bit Field Definition
    Constant Definitions for CAN Controller
@{ */

#define CAN_CON_TEST_Pos           7                                    /*!< CAN_T::CON: TEST Position */
#define CAN_CON_TEST_Msk           (1ul << CAN_CON_TEST_Pos)            /*!< CAN_T::CON: TEST Mask     */

#define CAN_CON_CCE_Pos            6                                    /*!< CAN_T::CON: CCE Position  */
#define CAN_CON_CCE_Msk            (1ul << CAN_CON_CCE_Pos)             /*!< CAN_T::CON: CCE Mask      */

#define CAN_CON_DAR_Pos            5                                    /*!< CAN_T::CON: DAR Position  */
#define CAN_CON_DAR_Msk            (1ul << CAN_CON_DAR_Pos)             /*!< CAN_T::CON: DAR Mask      */

#define CAN_CON_EIE_Pos            3                                    /*!< CAN_T::CON: EIE Position  */
#define CAN_CON_EIE_Msk            (1ul << CAN_CON_EIE_Pos)             /*!< CAN_T::CON: EIE Mask      */

#define CAN_CON_SIE_Pos            2                                    /*!< CAN_T::CON: SIE Position  */
#define CAN_CON_SIE_Msk            (1ul << CAN_CON_SIE_Pos)             /*!< CAN_T::CON: SIE Mask      */

#define CAN_CON_IE_Pos             1                                    /*!< CAN_T::CON: IE Position   */
#define CAN_CON_IE_Msk             (1ul << CAN_CON_IE_Pos)              /*!< CAN_T::CON: IE Mask       */

#define CAN_CON_INIT_Pos           0                                    /*!< CAN_T::CON: INIT Position */
#define CAN_CON_INIT_Msk           (1ul << CAN_CON_INIT_Pos)            /*!< CAN_T::CON: INIT Mask     */

#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN_T::STATUS: BOFF Position  */
#define CAN_STATUS_BOFF_Msk        (1ul << CAN_STATUS_BOFF_Pos)         /*!< CAN_T::STATUS: BOFF Mask      */

#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN_T::STATUS: EWARN Position */
#define CAN_STATUS_EWARN_Msk       (1ul << CAN_STATUS_EWARN_Pos)        /*!< CAN_T::STATUS: EWARN Mask     */

#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN_T::STATUS: EPASS Position */
#define CAN_STATUS_EPASS_Msk       (1ul << CAN_STATUS_EPASS_Pos)        /*!< CAN_T::STATUS: EPASS Mask     */

#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN_T::STATUS: RXOK Position  */
#define CAN_STATUS_RXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN_T::STATUS: RXOK Mask      */

#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN_T::STATUS: TXOK Position  */
#define CAN_STATUS_TXOK_Msk        (1ul << CAN_STATUS_TXOK_Pos)         /*!< CAN_T::STATUS: TXOK Mask      */

#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN_T::STATUS: LEC Position   */
#define CAN_STATUS_LEC_Msk         (0x7ul << CAN_STATUS_LEC_Pos)        /*!< CAN_T::STATUS: LEC Mask       */

#define CAN_ERR_RP_Pos             15                                   /*!< CAN_T::ERR: RP Position       */
#define CAN_ERR_RP_Msk             (1ul << CAN_ERR_RP_Pos)              /*!< CAN_T::ERR: RP Mask           */

#define CAN_ERR_REC_Pos            8                                    /*!< CAN_T::ERR: REC Position      */
#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN_T::ERR: REC Mask          */

#define CAN_ERR_TEC_Pos            0                                    /*!< CAN_T::ERR: TEC Position      */
#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN_T::ERR: TEC Mask          */

#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN_T::BTIME: TSEG2 Position  */
#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN_T::BTIME: TSEG2 Mask      */

#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN_T::BTIME: TSEG1 Position  */
#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN_T::BTIME: TSEG1 Mask      */

#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN_T::BTIME: SJW Position    */
#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN_T::BTIME: SJW Mask        */

#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN_T::BTIME: BRP Position    */
#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN_T::BTIME: BRP Mask        */

#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN_T::IIDR: INTID Position   */
#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN_T::IIDR: INTID Mask       */

#define CAN_TEST_RX_Pos            7                                    /*!< CAN_T::TEST: RX Position      */
#define CAN_TEST_RX_Msk            (1ul << CAN_TEST_RX_Pos)             /*!< CAN_T::TEST: RX Mask          */

#define CAN_TEST_TX_Pos            5                                    /*!< CAN_T::TEST: TX Position      */
#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN_T::TEST: TX Mask          */

#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN_T::TEST: LBACK Position   */
#define CAN_TEST_LBACK_Msk         (1ul << CAN_TEST_LBACK_Pos)          /*!< CAN_T::TEST: LBACK Mask       */

#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN_T::TEST: Silent Position  */
#define CAN_TEST_SILENT_Msk        (1ul << CAN_TEST_SILENT_Pos)         /*!< CAN_T::TEST: Silent Mask      */

#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN_T::TEST: Basic Position   */
#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)          /*!< CAN_T::TEST: Basic Mask       */

#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN_T::BRPE: BRPE Position    */
#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN_T::BRPE: BRPE Mask        */

#define CAN_IF_CREQ_BUSY_Pos       15                                   /*!< CAN_IF_T::CREQ: BUSY Position */
#define CAN_IF_CREQ_BUSY_Msk       (1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN_IF_T::CREQ: BUSY Mask     */

#define CAN_IF_CREQ_MSGNUM_Pos     0                                    /*!< CAN_IF_T::CREQ: MSGNUM Position */
#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)   /*!< CAN_IF_T::CREQ: MSGNUM Mask     */

#define CAN_IF_CMASK_WRRD_Pos      7                                    /*!< CAN_IF_T::CMASK: WRRD Position */
#define CAN_IF_CMASK_WRRD_Msk      (1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN_IF_T::CMASK: WRRD Mask     */

#define CAN_IF_CMASK_MASK_Pos      6                                    /*!< CAN_IF_T::CMASK: MASK Position */
#define CAN_IF_CMASK_MASK_Msk      (1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN_IF_T::CMASK: MASK Mask     */

#define CAN_IF_CMASK_ARB_Pos       5                                    /*!< CAN_IF_T::CMASK: ARB Position  */
#define CAN_IF_CMASK_ARB_Msk       (1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN_IF_T::CMASK: ARB Mask      */

#define CAN_IF_CMASK_CONTROL_Pos   4                                    /*!< CAN_IF_T::CMASK: CONTROL Position */
#define CAN_IF_CMASK_CONTROL_Msk   (1ul << CAN_IF_CMASK_CONTROL_Pos)    /*!< CAN_IF_T::CMASK: CONTROL Mask */

#define CAN_IF_CMASK_CLRINTPND_Pos 3                                    /*!< CAN_IF_T::CMASK: CLRINTPND Position */
#define CAN_IF_CMASK_CLRINTPND_Msk (1ul << CAN_IF_CMASK_CLRINTPND_Pos)  /*!< CAN_IF_T::CMASK: CLRINTPND Mask */

#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Position */
#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)    /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Mask     */

#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN_IF_T::CMASK: DATAA Position */
#define CAN_IF_CMASK_DATAA_Msk     (1ul << CAN_IF_CMASK_DATAA_Pos)      /*!< CAN_IF_T::CMASK: DATAA Mask     */

#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN_IF_T::CMASK: DATAB Position */
#define CAN_IF_CMASK_DATAB_Msk     (1ul << CAN_IF_CMASK_DATAB_Pos)      /*!< CAN_IF_T::CMASK: DATAB Mask     */

#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN_IF_T::MASK1: MSK Position   */
#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN_IF_T::MASK1: MSK Mask       */

#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN_IF_T::MASK2: MXTD Position */
#define CAN_IF_MASK2_MXTD_Msk      (1ul << CAN_IF_MASK2_MXTD_Pos)       /*!< CAN_IF_T::MASK2: MXTD Mask     */

#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN_IF_T::MASK2: MDIR Position */
#define CAN_IF_MASK2_MDIR_Msk      (1ul << CAN_IF_MASK2_MDIR_Pos)       /*!< CAN_IF_T::MASK2: MDIR Mask     */

#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN_IF_T::MASK2: MSK Position */
#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN_IF_T::MASK2: MSK Mask     */

#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN_IF_T::ARB1: ID Position   */
#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN_IF_T::ARB1: ID Mask       */

#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN_IF_T::ARB2: MSGVAL Position */
#define CAN_IF_ARB2_MSGVAL_Msk     (1ul << CAN_IF_ARB2_MSGVAL_Pos)      /*!< CAN_IF_T::ARB2: MSGVAL Mask     */

#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN_IF_T::ARB2: XTD Position    */
#define CAN_IF_ARB2_XTD_Msk        (1ul << CAN_IF_ARB2_XTD_Pos)         /*!< CAN_IF_T::ARB2: XTD Mask        */

#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN_IF_T::ARB2: DIR Position    */
#define CAN_IF_ARB2_DIR_Msk        (1ul << CAN_IF_ARB2_DIR_Pos)         /*!< CAN_IF_T::ARB2: DIR Mask        */

#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN_IF_T::ARB2: ID Position     */
#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN_IF_T::ARB2: ID Mask         */

#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN_IF_T::MCON: NEWDAT Position */
#define CAN_IF_MCON_NEWDAT_Msk     (1ul << CAN_IF_MCON_NEWDAT_Pos)      /*!< CAN_IF_T::MCON: NEWDAT Mask     */

#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN_IF_T::MCON: MSGLST Position */
#define CAN_IF_MCON_MSGLST_Msk     (1ul << CAN_IF_MCON_MSGLST_Pos)      /*!< CAN_IF_T::MCON: MSGLST Mask     */

#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN_IF_T::MCON: INTPND Position */
#define CAN_IF_MCON_INTPND_Msk     (1ul << CAN_IF_MCON_INTPND_Pos)      /*!< CAN_IF_T::MCON: INTPND Mask     */

#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN_IF_T::MCON: UMASK Position  */
#define CAN_IF_MCON_UMASK_Msk      (1ul << CAN_IF_MCON_UMASK_Pos)       /*!< CAN_IF_T::MCON: UMASK Mask      */

#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN_IF_T::MCON: TXIE Position   */
#define CAN_IF_MCON_TXIE_Msk       (1ul << CAN_IF_MCON_TXIE_Pos)        /*!< CAN_IF_T::MCON: TXIE Mask       */

#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN_IF_T::MCON: RXIE Position   */
#define CAN_IF_MCON_RXIE_Msk       (1ul << CAN_IF_MCON_RXIE_Pos)        /*!< CAN_IF_T::MCON: RXIE Mask       */

#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN_IF_T::MCON: RMTEN Position  */
#define CAN_IF_MCON_RMTEN_Msk      (1ul << CAN_IF_MCON_RMTEN_Pos)       /*!< CAN_IF_T::MCON: RMTEN Mask      */

#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN_IF_T::MCON: TXRQST Position */
#define CAN_IF_MCON_TXRQST_Msk     (1ul << CAN_IF_MCON_TXRQST_Pos)      /*!< CAN_IF_T::MCON: TXRQST Mask     */

#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN_IF_T::MCON: EOB Position    */
#define CAN_IF_MCON_EOB_Msk        (1ul << CAN_IF_MCON_EOB_Pos)         /*!< CAN_IF_T::MCON: EOB Mask        */

#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN_IF_T::MCON: DLC Position    */
#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN_IF_T::MCON: DLC Mask        */

#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN_IF_T::DAT_A1: DATA1 Position */
#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN_IF_T::DAT_A1: DATA1 Mask     */

#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN_IF_T::DAT_A1: DATA0 Position */
#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN_IF_T::DAT_A1: DATA0 Mask     */

#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN_IF_T::DAT_A2: DATA3 Position */
#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN_IF_T::DAT_A2: DATA3 Mask     */

#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN_IF_T::DAT_A2: DATA2 Position */
#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN_IF_T::DAT_A2: DATA2 Mask     */

#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN_IF_T::DAT_B1: DATA5 Position */
#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN_IF_T::DAT_B1: DATA5 Mask */

#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN_IF_T::DAT_B1: DATA4 Position */
#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN_IF_T::DAT_B1: DATA4 Mask */

#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN_IF_T::DAT_B2: DATA7 Position */
#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN_IF_T::DAT_B2: DATA7 Mask     */

#define CAN_IF_DAT_B2_DATA6_Pos    0                                    /*!< CAN_IF_T::DAT_B2: DATA6 Position */
#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN_IF_T::DAT_B2: DATA6 Mask     */

#define CAN_IF_TXRQST1_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST1: TXRQST Position */
#define CAN_IF_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST1_TXRQST_Pos)  /*!< CAN_T::TXRQST1: TXRQST Mask     */

#define CAN_IF_TXRQST2_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST2: TXRQST Position  */
#define CAN_IF_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST2_TXRQST_Pos)  /*!< CAN_T::TXRQST2: TXRQST Mask      */

#define CAN_IF_NDAT1_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT1: NEWDATA Position */
#define CAN_IF_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT1_NEWDATA_Pos)   /*!< CAN_T::NDAT1: NEWDATA Mask     */

#define CAN_IF_NDAT2_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT2: NEWDATA Position */
#define CAN_IF_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT2_NEWDATA_Pos)   /*!< CAN_T::NDAT2: NEWDATA Mask     */

#define CAN_IF_IPND1_INTPND_Pos   0                                         /*!< CAN_T::IPND1: INTPND Position */
#define CAN_IF_IPND1_INTPND_Msk   (0xFFFFul << CAN_IF_IPND1_INTPND_Pos)     /*!< CAN_T::IPND1: INTPND Mask     */

#define CAN_IF_IPND2_INTPND_Pos   0                                         /*!< CAN_T::IPND2: INTPND Position */
#define CAN_IF_IPND2_INTPND_Msk   (0xFFFFul << CAN_IF_IPND2_INTPND_Pos)     /*!< CAN_T::IPND2: INTPND Mask     */

#define CAN_IF_MVLD1_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD1: MSGVAL Position */
#define CAN_IF_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD1_MSGVAL_Pos)     /*!< CAN_T::MVLD1: MSGVAL Mask     */

#define CAN_IF_MVLD2_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD2: MSGVAL Position */
#define CAN_IF_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD2_MSGVAL_Pos)     /*!< CAN_T::MVLD2: MSGVAL Mask     */

#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN_T::WU_EN: WAKUP_EN Position */
#define CAN_WUEN_WAKUP_EN_Msk    (1ul << CAN_WUEN_WAKUP_EN_Pos)             /*!< CAN_T::WU_EN: WAKUP_EN Mask     */

#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                    /*!< CAN_T::WU_STATUS: WAKUP_STS Position */
#define CAN_WUSTATUS_WAKUP_STS_Msk    (1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN_T::WU_STATUS: WAKUP_STS Mask     */

/**@}*/ /* CAN_CONST */
/**@}*/ /* end of CAN register group */


/*---------------------- Capture Engine -------------------------*/
/**
    @addtogroup CAP Capture Engine(CAP)
    Memory Mapped Structure for CAP Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  Image Capture Interface Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CAPEN     |Image Capture Interface Enable
     * |        |          |0 = Image Capture Interface Disabled.
     * |        |          |1 = Image Capture Interface Enabled.
     * |[3]     |ADDRSW    |Packet Buffer Address Switch
     * |        |          |0 = Packet buffer address switch Disabled.
     * |        |          |1 = Packet buffer address switch Enabled.
     * |[5]     |PLNEN     |Planar Output Enable
     * |        |          |0 = Planar output Disabled.
     * |        |          |1 = Planar output Enabled.
     * |[6]     |PKTEN     |Packet Output Enable
     * |        |          |0 = Packet output Disabled.
     * |        |          |1 = Packet output Enabled.
     * |[16]    |SHUTTER   |Image Capture Interface Automatically Disable The Capture Interface After A Frame Had Been Captured
     * |        |          |0 = Shutter Disabled.
     * |        |          |1 = Shutter Enabled.
     * |[20]    |UPDATE    |Update Register At New Frame
     * |        |          |0 = Update register at new frame Disabled.
     * |        |          |1 = Update register at new frame Enabled (Auto clear to 0 when register updated).
     * |[24]    |VPRST     |Capture Interface Reset
     * |        |          |0 = Capture interface reset Disabled.
     * |        |          |1 = Capture interface reset Enabled.
    */
    __IO uint32_t CTL;

    /**
     * PAR
     * ===================================================================================================
     * Offset: 0x04  Image Capture Interface Parameter Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |INFMT     |Sensor Input Data Format
     * |        |          |0 = YCbCr422.
     * |        |          |1 = RGB565.
     * |[1]     |SENTYPE   |Sensor Input Type
     * |        |          |0 = CCIR601.
     * |        |          |1 = CCIR656, VSync & Hsync embedded in the data signal.
     * |[2:3]   |INDATORD  |Sensor Input Data Order
     * |        |          |If INFMT = 0 (YCbCr),.
     * |        |          | Byte 0 1 2 3
     * |        |          |00 = Y0 U0 Y1 V0.
     * |        |          |01 = Y0 V0 Y1 U0.
     * |        |          |10 = U0 Y0 V0 Y1.
     * |        |          |11 = V0 Y0 U0 Y1.
     * |        |          |If INFMT = 1 (RGB565),.
     * |        |          |00 = Byte0[R[4:0] G[5:3]] Byte1[G[2:0] B[4:0]]
     * |        |          |01 = Byte0[B[4:0] G[5:3]] Byte1[G[2:0] R[4:0]]
     * |        |          |10 = Byte0[G[2:0] B[4:0]] Byte1[R[4:0] G[5:3]]
     * |        |          |11 = Byte0[G[2:0] R[4:0]] Byte1[B[4:0] G[5:3]]
     * |[4:5]   |OUTFMT    |Image Data Format Output To System Memory
     * |        |          |00 = YCbCr422.
     * |        |          |01 = Only output Y.
     * |        |          |10 = RGB555.
     * |        |          |11 = RGB565.
     * |[6]     |RANGE     |Scale Input YUV CCIR601 Color Range To Full Range
     * |        |          |0 = default.
     * |        |          |1 = Scale to full range.
     * |[7]     |PLNFMT    |Planar Output YUV Format
     * |        |          |0 = YUV422.
     * |        |          |1 = YUV420.
     * |[8]     |PCLKP     |Sensor Pixel Clock Polarity
     * |        |          |0 = Input video data and signals are latched by falling edge of Pixel Clock.
     * |        |          |1 = Input video data and signals are latched by rising edge of Pixel Clock.
     * |[9]     |HSP       |Sensor Hsync Polarity
     * |        |          |0 = Sync Low.
     * |        |          |1 = Sync High.
     * |[10]    |VSP       |Sensor Vsync Polarity
     * |        |          |0 = Sync Low.
     * |        |          |1 = Sync High.
     * |[11:12] |COLORCTL  |Special COLORCTL Processing
     * |        |          |00 = Normal Color.
     * |        |          |01 = Sepia effect, corresponding U,V component value is set at register CAP_SEPIA.
     * |        |          |10 = Negative picture.
     * |        |          |11 = Posterize image, the Y, U, V components posterizing factor are set at register CAP_POSTERIZE.
     * |[18]    |FBB       |Field By Blank
     * |        |          |Hardware will tag field0 or field1 by vertical blanking instead of FIELD flag in CCIR-656 mode.
     * |        |          |0 = Field by blank Disabled.
     * |        |          |1 = Field by blank Enabled.
    */
    __IO uint32_t PAR;

    /**
     * INT
     * ===================================================================================================
     * Offset: 0x08  Image Capture Interface Interrupt Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |VINTF     |Video Frame End Interrupt
     * |        |          |If this bit shows 1, receiving a frame completed.
     * |        |          |Write 1 to clear it.
     * |[1]     |MEINTF    |Bus Master Transfer Error Interrupt
     * |        |          |If this bit shows 1, Transfer Error occurred. Write 1 to clear it.
     * |[3]     |ADDRMINTF |Memory Address Match Interrupt
     * |        |          |If this bit shows 1, Memory Address Match Interrupt occurred.
     * |        |          |Write 1 to clear it.
     * |[4]     |MDINTF    |Motion Detection Output Finish Interrupt
     * |        |          |If this bit shows 1, Motion Detection Output Finish Interrupt occurred.
     * |        |          |Write 1 to clear it.
     * |[16]    |VIEN      |Video Frame End Interrupt Enable
     * |        |          |0 = Video frame end interrupt Disabled.
     * |        |          |1 = Video frame end interrupt Enabled.
     * |[17]    |MEIEN     |System Memory Error Interrupt Enable
     * |        |          |0 = System memory error interrupt Disabled.
     * |        |          |1 = System memory error interrupt Enabled.
     * |[19]    |ADDRMIEN  |Address Match Interrupt Enable
     * |        |          |0 = Address match interrupt Disabled.
     * |        |          |1 = Address match interrupt Enabled.
     * |[20]    |MDIEN     |Motion Detection Output Finish Interrupt Enable
     * |        |          |0 = CAP_MD finish interrupt Disabled.
     * |        |          |1 = CAP_MD finish interrupt Enabled.
    */
    __IO uint32_t INT;

    /**
     * POSTERIZE
     * ===================================================================================================
     * Offset: 0x0C  YUV Component Posterizing Factor Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |VCOMP     |V Component Posterizing Factor
     * |        |          |Final_V_Out = Original_V[7:0] & V_Posterizing_Factor.
     * |[8:15]  |UCOMP     |U Component Posterizing Factor
     * |        |          |Final_U_Out = Original_U[7:0] & U_Posterizing_Factor.
     * |[16:23] |YCOMP     |Y Component Posterizing Factor
     * |        |          |Final_Y_Out = Original_Y[7:0] & Y_Posterizing_Factor.
    */
    __IO uint32_t POSTERIZE;

    /**
     * MD
     * ===================================================================================================
     * Offset: 0x10  Motion Detection Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |MDEN      |Motion Detection Enable
     * |        |          |0 = CAP_MD Disabled.
     * |        |          |1 = CAP_MD Enabled.
     * |[8]     |MDBS      |Motion Detection Block Size
     * |        |          |0 = 16x16.
     * |        |          |1 = 8x8.
     * |[9]     |MDSM      |Motion Detection Save Mode
     * |        |          |0 = 1 bit DIFF + 7 bit Y Differential.
     * |        |          |1 = 1 bit DIFF only.
     * |[10:11] |MDDF      |Motion Detection Detect Frequency
     * |        |          |00 = Each frame.
     * |        |          |01 = Every 2 frame.
     * |        |          |10 = Every 3 frame.
     * |        |          |11 = Every 4 frame.
     * |[16:20] |MDTHR     |Motion Detection Differential Threshold
    */
    __IO uint32_t MD;

    /**
     * MDADDR
     * ===================================================================================================
     * Offset: 0x14  Motion Detection Output Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |MDADDR    |Motion Detection Output Address Register (Word Alignment)
    */
    __IO uint32_t MDADDR;

    /**
     * MDYADDR
     * ===================================================================================================
     * Offset: 0x18  Motion Detection Temp Y Output Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |MDYADDR   |Motion Detection Temp Y Output Address Register (Word Alignment)
    */
    __IO uint32_t MDYADDR;

    /**
     * SEPIA
     * ===================================================================================================
     * Offset: 0x1C  Sepia Effect Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |VCOMP     |Define the constant V component while Sepia color effect is turned on.
     * |[8:15]  |UCOMP     |Define the constant U component while Sepia color effect is turned on.
    */
    __IO uint32_t SEPIA;

    /**
     * CWSP
     * ===================================================================================================
     * Offset: 0x20  Cropping Window Starting Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |CWSADDRH  |Cropping Window Horizontal Starting Address
     * |[16:26] |CWSADDRV  |Cropping Window Vertical Starting Address
    */
    __IO uint32_t CWSP;

    /**
     * CWS
     * ===================================================================================================
     * Offset: 0x24  Cropping Window Size Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |CIWW      |Cropping Image Window Width
     * |[16:26] |CIWH      |Cropping Image Window Height
    */
    __IO uint32_t CWS;

    /**
     * PKTSL
     * ===================================================================================================
     * Offset: 0x28  Packet Scaling Vertical/Horizontal Factor Register (LSB)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |PKTSHML   |Packet Scaling Horizontal Factor M (Lower 8-Bit)
     * |        |          |Specifies the lower 8-bit of denominator part (M) of the horizontal scaling factor.
     * |        |          |The lower 8-bit will be cascaded with higher 8-bit (PKDSHMH) to form a 16-bit denominator (M) of vertical factor.
     * |        |          |The output image width will be equal to the image width * N/M.
     * |        |          |Note: The value of N must be equal to or less than M.
     * |[8:15]  |PKTSHNL   |Packet Scaling Horizontal Factor N (Lower 8-Bit)
     * |        |          |Specify the lower 8-bit of numerator part (N) of the horizontal scaling factor.
     * |        |          |The lower 8-bit will be cascaded with higher 8-bit (PKDSHNH) to form a 16-bit numerator of horizontal factor.
     * |[16:23] |PKTSVML   |Packet Scaling Vertical Factor M (Lower 8-Bit)
     * |        |          |Specify the lower 8-bit of denominator part (M) of the vertical scaling factor.
     * |        |          |The lower 8-bit will be cascaded with higher 8-bit (PKDSVMH) to form a 16-bit denominator (M) of vertical factor.
     * |        |          |The output image width will be equal to the image height * N/M.
     * |        |          |Note: The value of N must be equal to or less than M.
     * |[24:31] |PKTSVNL   |Packet Scaling Vertical Factor N (Lower 8-Bit)
     * |        |          |Specify the lower 8-bit of numerator part (N) of the vertical scaling factor.
     * |        |          |The lower 8-bit will be cascaded with higher 8-bit (PKDSVNH) to form a 16-bit numerator of vertical factor
    */
    __IO uint32_t PKTSL;

    /**
     * PLNSL
     * ===================================================================================================
     * Offset: 0x2C  Planar Scaling Vertical/Horizontal Factor Register (LSB)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |PLNSHML   |Planar Scaling Horizontal Factor M (Lower 8-Bit)
     * |        |          |Specify the lower 8-bit of denominator part (M) of the horizontal scaling factor.
     * |        |          |The lower 8-bit will be cascaded with higher 8-bit (PNDSHMH) to form a 16-bit denominator (M) of vertical factor.
     * |        |          |The output image width will be equal to the image width * N/M.
     * |        |          |Note: The value of N must be equal to or less than M.
     * |[8:15]  |PLNSHNL   |Planar Scaling Horizontal Factor N (Lower 8-Bit)
     * |        |          |Specify the lower 8-bit of numerator part (N) of the horizontal scaling factor.
     * |        |          |The lower 8-bit will be cascaded with higher 8-bit (PNDSHNH) to form a 16-bit numerator of horizontal factor.
     * |[16:23] |PLNSVML   |Planar Scaling Vertical Factor M (Lower 8-Bit)
     * |        |          |Specify the lower 8-bit of denominator part (M) of the vertical scaling factor.
     * |        |          |The lower 8-bit will be cascaded with higher 8-bit (PNDSVMH) to form a 16-bit denominator (M) of vertical factor.
     * |        |          |The output image width will be equal to the image height * N/M.
     * |        |          |Note: The value of N must be equal to or less than M.
     * |[24:31] |PLNSVNL   |Planar Scaling Vertical Factor N (Lower 8-Bit)
     * |        |          |Specify the lower 8-bit of numerator part (N) of the vertical scaling factor.
     * |        |          |The lower 8-bit will be cascaded with higher 8-bit (PNDSVNH) to form a 16-bit numerator of vertical factor.
    */
    __IO uint32_t PLNSL;

    /**
     * FRCTL
     * ===================================================================================================
     * Offset: 0x30  Scaling Frame Rate Factor Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |FRM       |Scaling Frame Rate Factor M
     * |        |          |Specify the denominator part (M) of the frame rate scaling factor.
     * |        |          |The output image frame rate will be equal to input image frame rate * (N/M).
     * |        |          |Note: The value of N must be equal to or less than M.
     * |[8:13]  |FRN       |Scaling Frame Rate Factor N
     * |        |          |Specify the denominator part (N) of the frame rate scaling factor.
    */
    __IO uint32_t FRCTL;

    /**
     * STRIDE
     * ===================================================================================================
     * Offset: 0x34  Frame Output Pixel Stride Width Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:13]  |PKTSTRIDE |Packet Frame Output Pixel Stride Width
     * |        |          |The output pixel stride size of packet pipe.
     * |[16:29] |PLNSTRIDE |Planar Frame Output Pixel Stride Width
     * |        |          |The output pixel stride size of planar pipe.
    */
    __IO uint32_t STRIDE;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * FIFOTH
     * ===================================================================================================
     * Offset: 0x3C  FIFO Threshold Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PLNVFTH   |Planar V FIFO Threshold
     * |[8:11]  |PLNUFTH   |Planar U FIFO Threshold
     * |[16:20] |PLNYFTH   |Planar Y FIFO Threshold
     * |[24:28] |PKTFTH    |Packet FIFO Threshold
     * |[31]    |OVF       |FIFO Overflow Flag
    */
    __IO uint32_t FIFOTH;

    /**
     * CMPADDR
     * ===================================================================================================
     * Offset: 0x40  Compare Memory Base Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CMPADDR   |Compare Memory Base Address
     * |        |          |Word aligns address; ignore the bits [1:0].
    */
    __IO uint32_t CMPADDR;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * PKTSM
     * ===================================================================================================
     * Offset: 0x48  Packet Scaling Vertical/Horizontal Factor Register (MSB)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |PKTSHMH   |Packet Scaling Horizontal Factor M (Higher 8-Bit)
     * |        |          |Specify the lower 8-bit of denominator part (M) of the horizontal scaling factor.
     * |        |          |Please refer to the register CAP_PKTSL?for the detailed operation.
     * |[8:15]  |PKTSHNH   |Packet Scaling Horizontal Factor N (Higher 8-Bit)
     * |        |          |Specify the lower 8-bit of numerator part (N) of the horizontal scaling factor.
     * |        |          |Please refer to the register CAP_PKTSL for the detailed operation.
     * |[16:23] |PKTSVMH   |Packet Scaling Vertical Factor M (Higher 8-Bit)
     * |        |          |Specify the lower 8-bit of denominator part (M) of the vertical scaling factor.
     * |        |          |Please refer to the register CAP_PKTSL to check the cooperation between these two registers.
     * |[24:31] |PKTSVNH   |Packet Scaling Vertical Factor N (Higher 8-Bit)
     * |        |          |Specify the higher 8-bit of numerator part (N) of the vertical scaling factor.
     * |        |          |Please refer to the register CAP_PKTSL?to check the cooperation between these two registers.
    */
    __IO uint32_t PKTSM;

    /**
     * PLNSM
     * ===================================================================================================
     * Offset: 0x4C  Planar Scaling Vertical/Horizontal Factor Register (MSB)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |PLNSHMH   |Planar Scaling Horizontal Factor M (Higher 8-Bit)
     * |        |          |Specifies the higher 8-bit of denominator part (M) of the horizontal scaling factor
     * |        |          |For detailed programming, please refer to the register CAP_PLNSL?
     * |[8:15]  |PLNSHNH   |Planar Scaling Horizontal Factor N (Higher 8-Bit)
     * |        |          |Specifies the higher 8-bit of numerator part (N) of the horizontal scaling factor.
     * |        |          |For detailed programming, please refer to the register CAP_PLNSL?
     * |[16:23] |PLNSVMH   |Planar Scaling Vertical Factor M (Higher 8-Bit)
     * |        |          |Specifies the lower 8-bit of denominator part (M) of the vertical scaling factor.
     * |        |          |For detailed programming, please refer to the register CAP_PLNSL?
     * |[24:31] |PLNSVNH   |Planar Scaling Vertical Factor N (Higher 8-Bit)
     * |        |          |Specifies the higher 8-bit of numerator part (N) of the vertical scaling factor.
     * |        |          |For detailed programming, please refer to the register CAP_PLNSL?
    */
    __IO uint32_t PLNSM;

    /**
     * CURADDRP
     * ===================================================================================================
     * Offset: 0x50  Current Packet System Memory Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CURADDR   |Current Packet Output Memory Address
    */
    __I  uint32_t CURADDRP;

    /**
     * CURADDRY
     * ===================================================================================================
     * Offset: 0x54  Current Planar Y System Memory Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CURADDR   |Current Planar Y Output Memory Address
    */
    __I  uint32_t CURADDRY;

    /**
     * CURADDRU
     * ===================================================================================================
     * Offset: 0x58  Current Planar U System Memory Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CURADDR   |Current Planar U Output Memory Address
    */
    __I  uint32_t CURADDRU;

    /**
     * CURVADDR
     * ===================================================================================================
     * Offset: 0x5C  Current Planar V System Memory Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CURADDR   |Current Planar V Output Memory Address
    */
    __I  uint32_t CURVADDR;

    /**
     * PKTBA0
     * ===================================================================================================
     * Offset: 0x60  System Memory Packet Base Address 0 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |BASEADDR  |System Memory Packet Base Address 0
     * |        |          |Word aligns address; ignore the bits [1:0].
    */
    __IO uint32_t PKTBA0;

    /**
     * PKTBA1
     * ===================================================================================================
     * Offset: 0x64  System Memory Packet Base Address 1 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |BASEADDR  |System Memory Packet Base Address 1
     * |        |          |Word aligns address; ignore the bits [1:0].
    */
    __IO uint32_t PKTBA1;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[6];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * YBA
     * ===================================================================================================
     * Offset: 0x80  System Memory Planar Y Base Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |BASEADDR  |System Memory Planar Y Base Address
     * |        |          |Word aligns address; ignore the bits [1:0].
    */
    __IO uint32_t YBA;

    /**
     * UBA
     * ===================================================================================================
     * Offset: 0x84  System Memory Planar U Base Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |BASEADDR  |System Memory Planar U Base Address
     * |        |          |Word aligns address; ignore the bits [1:0].
    */
    __IO uint32_t UBA;

    /**
     * VBA
     * ===================================================================================================
     * Offset: 0x88  System Memory Planar V Base Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |BASEADDR  |System Memory Planar V Base Address
     * |        |          |Word aligns address; ignore the bits [1:0].
    */
    __IO uint32_t VBA;

} CAP_T;

/**
    @addtogroup CAP_CONST CAP Bit Field Definition
    Constant Definitions for CAP Controller
@{ */

#define CAP_CTL_CAPEN_Pos                (0)                                               /*!< CAP_T::CTL: CAPEN Position                */
#define CAP_CTL_CAPEN_Msk                (0x1ul << CAP_CTL_CAPEN_Pos)                      /*!< CAP_T::CTL: CAPEN Mask                    */

#define CAP_CTL_ADDRSW_Pos               (3)                                               /*!< CAP_T::CTL: ADDRSW Position               */
#define CAP_CTL_ADDRSW_Msk               (0x1ul << CAP_CTL_ADDRSW_Pos)                     /*!< CAP_T::CTL: ADDRSW Mask                   */

#define CAP_CTL_PLNEN_Pos                (5)                                               /*!< CAP_T::CTL: PLNEN Position                */
#define CAP_CTL_PLNEN_Msk                (0x1ul << CAP_CTL_PLNEN_Pos)                      /*!< CAP_T::CTL: PLNEN Mask                    */

#define CAP_CTL_PKTEN_Pos                (6)                                               /*!< CAP_T::CTL: PKTEN Position                */
#define CAP_CTL_PKTEN_Msk                (0x1ul << CAP_CTL_PKTEN_Pos)                      /*!< CAP_T::CTL: PKTEN Mask                    */

#define CAP_CTL_SHUTTER_Pos              (16)                                              /*!< CAP_T::CTL: SHUTTER Position              */
#define CAP_CTL_SHUTTER_Msk              (0x1ul << CAP_CTL_SHUTTER_Pos)                    /*!< CAP_T::CTL: SHUTTER Mask                  */

#define CAP_CTL_UPDATE_Pos               (20)                                              /*!< CAP_T::CTL: UPDATE Position               */
#define CAP_CTL_UPDATE_Msk               (0x1ul << CAP_CTL_UPDATE_Pos)                     /*!< CAP_T::CTL: UPDATE Mask                   */

#define CAP_CTL_VPRST_Pos                (24)                                              /*!< CAP_T::CTL: VPRST Position                */
#define CAP_CTL_VPRST_Msk                (0x1ul << CAP_CTL_VPRST_Pos)                      /*!< CAP_T::CTL: VPRST Mask                    */

#define CAP_PAR_INFMT_Pos                (0)                                               /*!< CAP_T::PAR: INFMT Position                */
#define CAP_PAR_INFMT_Msk                (0x1ul << CAP_PAR_INFMT_Pos)                      /*!< CAP_T::PAR: INFMT Mask                    */

#define CAP_PAR_SENTYPE_Pos              (1)                                               /*!< CAP_T::PAR: SENTYPE Position              */
#define CAP_PAR_SENTYPE_Msk              (0x1ul << CAP_PAR_SENTYPE_Pos)                    /*!< CAP_T::PAR: SENTYPE Mask                  */

#define CAP_PAR_INDATORD_Pos             (2)                                               /*!< CAP_T::PAR: INDATORD Position             */
#define CAP_PAR_INDATORD_Msk             (0x3ul << CAP_PAR_INDATORD_Pos)                   /*!< CAP_T::PAR: INDATORD Mask                 */

#define CAP_PAR_OUTFMT_Pos               (4)                                               /*!< CAP_T::PAR: OUTFMT Position               */
#define CAP_PAR_OUTFMT_Msk               (0x3ul << CAP_PAR_OUTFMT_Pos)                     /*!< CAP_T::PAR: OUTFMT Mask                   */

#define CAP_PAR_RANGE_Pos                (6)                                               /*!< CAP_T::PAR: RANGE Position                */
#define CAP_PAR_RANGE_Msk                (0x1ul << CAP_PAR_RANGE_Pos)                      /*!< CAP_T::PAR: RANGE Mask                    */

#define CAP_PAR_PLNFMT_Pos               (7)                                               /*!< CAP_T::PAR: PLNFMT Position               */
#define CAP_PAR_PLNFMT_Msk               (0x1ul << CAP_PAR_PLNFMT_Pos)                     /*!< CAP_T::PAR: PLNFMT Mask                   */

#define CAP_PAR_PCLKP_Pos                (8)                                               /*!< CAP_T::PAR: PCLKP Position                */
#define CAP_PAR_PCLKP_Msk                (0x1ul << CAP_PAR_PCLKP_Pos)                      /*!< CAP_T::PAR: PCLKP Mask                    */

#define CAP_PAR_HSP_Pos                  (9)                                               /*!< CAP_T::PAR: HSP Position                  */
#define CAP_PAR_HSP_Msk                  (0x1ul << CAP_PAR_HSP_Pos)                        /*!< CAP_T::PAR: HSP Mask                      */

#define CAP_PAR_VSP_Pos                  (10)                                              /*!< CAP_T::PAR: VSP Position                  */
#define CAP_PAR_VSP_Msk                  (0x1ul << CAP_PAR_VSP_Pos)                        /*!< CAP_T::PAR: VSP Mask                      */

#define CAP_PAR_COLORCTL_Pos             (11)                                              /*!< CAP_T::PAR: COLORCTL Position             */
#define CAP_PAR_COLORCTL_Msk             (0x3ul << CAP_PAR_COLORCTL_Pos)                   /*!< CAP_T::PAR: COLORCTL Mask                 */

#define CAP_PAR_FBB_Pos                  (18)                                              /*!< CAP_T::PAR: FBB Position                  */
#define CAP_PAR_FBB_Msk                  (0x1ul << CAP_PAR_FBB_Pos)                        /*!< CAP_T::PAR: FBB Mask                      */

#define CAP_INT_VINTF_Pos                (0)                                               /*!< CAP_T::INT: VINTF Position                */
#define CAP_INT_VINTF_Msk                (0x1ul << CAP_INT_VINTF_Pos)                      /*!< CAP_T::INT: VINTF Mask                    */

#define CAP_INT_MEINTF_Pos               (1)                                               /*!< CAP_T::INT: MEINTF Position               */
#define CAP_INT_MEINTF_Msk               (0x1ul << CAP_INT_MEINTF_Pos)                     /*!< CAP_T::INT: MEINTF Mask                   */

#define CAP_INT_ADDRMINTF_Pos            (3)                                               /*!< CAP_T::INT: ADDRMINTF Position            */
#define CAP_INT_ADDRMINTF_Msk            (0x1ul << CAP_INT_ADDRMINTF_Pos)                  /*!< CAP_T::INT: ADDRMINTF Mask                */

#define CAP_INT_MDINTF_Pos               (4)                                               /*!< CAP_T::INT: MDINTF Position               */
#define CAP_INT_MDINTF_Msk               (0x1ul << CAP_INT_MDINTF_Pos)                     /*!< CAP_T::INT: MDINTF Mask                   */

#define CAP_INT_VIEN_Pos                 (16)                                              /*!< CAP_T::INT: VIEN Position                 */
#define CAP_INT_VIEN_Msk                 (0x1ul << CAP_INT_VIEN_Pos)                       /*!< CAP_T::INT: VIEN Mask                     */

#define CAP_INT_MEIEN_Pos                (17)                                              /*!< CAP_T::INT: MEIEN Position                */
#define CAP_INT_MEIEN_Msk                (0x1ul << CAP_INT_MEIEN_Pos)                      /*!< CAP_T::INT: MEIEN Mask                    */

#define CAP_INT_ADDRMIEN_Pos             (19)                                              /*!< CAP_T::INT: ADDRMIEN Position             */
#define CAP_INT_ADDRMIEN_Msk             (0x1ul << CAP_INT_ADDRMIEN_Pos)                   /*!< CAP_T::INT: ADDRMIEN Mask                 */

#define CAP_INT_MDIEN_Pos                (20)                                              /*!< CAP_T::INT: MDIEN Position                */
#define CAP_INT_MDIEN_Msk                (0x1ul << CAP_INT_MDIEN_Pos)                      /*!< CAP_T::INT: MDIEN Mask                    */

#define CAP_POSTERIZE_VCOMP_Pos          (0)                                               /*!< CAP_T::POSTERIZE: VCOMP Position          */
#define CAP_POSTERIZE_VCOMP_Msk          (0xfful << CAP_POSTERIZE_VCOMP_Pos)               /*!< CAP_T::POSTERIZE: VCOMP Mask              */

#define CAP_POSTERIZE_UCOMP_Pos          (8)                                               /*!< CAP_T::POSTERIZE: UCOMP Position          */
#define CAP_POSTERIZE_UCOMP_Msk          (0xfful << CAP_POSTERIZE_UCOMP_Pos)               /*!< CAP_T::POSTERIZE: UCOMP Mask              */

#define CAP_POSTERIZE_YCOMP_Pos          (16)                                              /*!< CAP_T::POSTERIZE: YCOMP Position          */
#define CAP_POSTERIZE_YCOMP_Msk          (0xfful << CAP_POSTERIZE_YCOMP_Pos)               /*!< CAP_T::POSTERIZE: YCOMP Mask              */

#define CAP_MD_MDEN_Pos                  (0)                                               /*!< CAP_T::MD: MDEN Position                  */
#define CAP_MD_MDEN_Msk                  (0x1ul << CAP_MD_MDEN_Pos)                        /*!< CAP_T::MD: MDEN Mask                      */

#define CAP_MD_MDBS_Pos                  (8)                                               /*!< CAP_T::MD: MDBS Position                  */
#define CAP_MD_MDBS_Msk                  (0x1ul << CAP_MD_MDBS_Pos)                        /*!< CAP_T::MD: MDBS Mask                      */

#define CAP_MD_MDSM_Pos                  (9)                                               /*!< CAP_T::MD: MDSM Position                  */
#define CAP_MD_MDSM_Msk                  (0x1ul << CAP_MD_MDSM_Pos)                        /*!< CAP_T::MD: MDSM Mask                      */

#define CAP_MD_MDDF_Pos                  (10)                                              /*!< CAP_T::MD: MDDF Position                  */
#define CAP_MD_MDDF_Msk                  (0x3ul << CAP_MD_MDDF_Pos)                        /*!< CAP_T::MD: MDDF Mask                      */

#define CAP_MD_MDTHR_Pos                 (16)                                              /*!< CAP_T::MD: MDTHR Position                 */
#define CAP_MD_MDTHR_Msk                 (0x1ful << CAP_MD_MDTHR_Pos)                      /*!< CAP_T::MD: MDTHR Mask                     */

#define CAP_MDADDR_MDADDR_Pos            (0)                                               /*!< CAP_T::MDADDR: MDADDR Position            */
#define CAP_MDADDR_MDADDR_Msk            (0xfffffffful << CAP_MDADDR_MDADDR_Pos)           /*!< CAP_T::MDADDR: MDADDR Mask                */

#define CAP_MDYADDR_MDYADDR_Pos          (0)                                               /*!< CAP_T::MDYADDR: MDYADDR Position          */
#define CAP_MDYADDR_MDYADDR_Msk          (0xfffffffful << CAP_MDYADDR_MDYADDR_Pos)         /*!< CAP_T::MDYADDR: MDYADDR Mask              */

#define CAP_SEPIA_VCOMP_Pos              (0)                                               /*!< CAP_T::SEPIA: VCOMP Position              */
#define CAP_SEPIA_VCOMP_Msk              (0xfful << CAP_SEPIA_VCOMP_Pos)                   /*!< CAP_T::SEPIA: VCOMP Mask                  */

#define CAP_SEPIA_UCOMP_Pos              (8)                                               /*!< CAP_T::SEPIA: UCOMP Position              */
#define CAP_SEPIA_UCOMP_Msk              (0xfful << CAP_SEPIA_UCOMP_Pos)                   /*!< CAP_T::SEPIA: UCOMP Mask                  */

#define CAP_CWSP_CWSADDRH_Pos            (0)                                               /*!< CAP_T::CWSP: CWSADDRH Position            */
#define CAP_CWSP_CWSADDRH_Msk            (0xffful << CAP_CWSP_CWSADDRH_Pos)                /*!< CAP_T::CWSP: CWSADDRH Mask                */

#define CAP_CWSP_CWSADDRV_Pos            (16)                                              /*!< CAP_T::CWSP: CWSADDRV Position            */
#define CAP_CWSP_CWSADDRV_Msk            (0x7fful << CAP_CWSP_CWSADDRV_Pos)                /*!< CAP_T::CWSP: CWSADDRV Mask                */

#define CAP_CWS_CWW_Pos                  (0)                                               /*!< CAP_T::CWS: CWW Position                 */
#define CAP_CWS_CWW_Msk                  (0xffful << CAP_CWS_CWW_Pos)                      /*!< CAP_T::CWS: CWW Mask                     */

#define CAP_CWS_CWH_Pos                  (16)                                              /*!< CAP_T::CWS: CIWH Position                 */
#define CAP_CWS_CWH_Msk                  (0x7fful << CAP_CWS_CWH_Pos)                      /*!< CAP_T::CWS: CIWH Mask                     */

#define CAP_PKTSL_PKTSHML_Pos            (0)                                               /*!< CAP_T::PKTSL: PKTSHML Position            */
#define CAP_PKTSL_PKTSHML_Msk            (0xfful << CAP_PKTSL_PKTSHML_Pos)                 /*!< CAP_T::PKTSL: PKTSHML Mask                */

#define CAP_PKTSL_PKTSHNL_Pos            (8)                                               /*!< CAP_T::PKTSL: PKTSHNL Position            */
#define CAP_PKTSL_PKTSHNL_Msk            (0xfful << CAP_PKTSL_PKTSHNL_Pos)                 /*!< CAP_T::PKTSL: PKTSHNL Mask                */

#define CAP_PKTSL_PKTSVML_Pos            (16)                                              /*!< CAP_T::PKTSL: PKTSVML Position            */
#define CAP_PKTSL_PKTSVML_Msk            (0xfful << CAP_PKTSL_PKTSVML_Pos)                 /*!< CAP_T::PKTSL: PKTSVML Mask                */

#define CAP_PKTSL_PKTSVNL_Pos            (24)                                              /*!< CAP_T::PKTSL: PKTSVNL Position            */
#define CAP_PKTSL_PKTSVNL_Msk            (0xfful << CAP_PKTSL_PKTSVNL_Pos)                 /*!< CAP_T::PKTSL: PKTSVNL Mask                */

#define CAP_PLNSL_PLNSHML_Pos            (0)                                               /*!< CAP_T::PLNSL: PLNSHML Position            */
#define CAP_PLNSL_PLNSHML_Msk            (0xfful << CAP_PLNSL_PLNSHML_Pos)                 /*!< CAP_T::PLNSL: PLNSHML Mask                */

#define CAP_PLNSL_PLNSHNL_Pos            (8)                                               /*!< CAP_T::PLNSL: PLNSHNL Position            */
#define CAP_PLNSL_PLNSHNL_Msk            (0xfful << CAP_PLNSL_PLNSHNL_Pos)                 /*!< CAP_T::PLNSL: PLNSHNL Mask                */

#define CAP_PLNSL_PLNSVML_Pos            (16)                                              /*!< CAP_T::PLNSL: PLNSVML Position            */
#define CAP_PLNSL_PLNSVML_Msk            (0xfful << CAP_PLNSL_PLNSVML_Pos)                 /*!< CAP_T::PLNSL: PLNSVML Mask                */

#define CAP_PLNSL_PLNSVNL_Pos            (24)                                              /*!< CAP_T::PLNSL: PLNSVNL Position            */
#define CAP_PLNSL_PLNSVNL_Msk            (0xfful << CAP_PLNSL_PLNSVNL_Pos)                 /*!< CAP_T::PLNSL: PLNSVNL Mask                */

#define CAP_FRCTL_FRM_Pos                (0)                                               /*!< CAP_T::FRCTL: FRM Position                */
#define CAP_FRCTL_FRM_Msk                (0x3ful << CAP_FRCTL_FRM_Pos)                     /*!< CAP_T::FRCTL: FRM Mask                    */

#define CAP_FRCTL_FRN_Pos                (8)                                               /*!< CAP_T::FRCTL: FRN Position                */
#define CAP_FRCTL_FRN_Msk                (0x3ful << CAP_FRCTL_FRN_Pos)                     /*!< CAP_T::FRCTL: FRN Mask                    */

#define CAP_STRIDE_PKTSTRIDE_Pos         (0)                                               /*!< CAP_T::STRIDE: PKTSTRIDE Position         */
#define CAP_STRIDE_PKTSTRIDE_Msk         (0x3ffful << CAP_STRIDE_PKTSTRIDE_Pos)            /*!< CAP_T::STRIDE: PKTSTRIDE Mask             */

#define CAP_STRIDE_PLNSTRIDE_Pos         (16)                                              /*!< CAP_T::STRIDE: PLNSTRIDE Position         */
#define CAP_STRIDE_PLNSTRIDE_Msk         (0x3ffful << CAP_STRIDE_PLNSTRIDE_Pos)            /*!< CAP_T::STRIDE: PLNSTRIDE Mask             */

#define CAP_FIFOTH_PLNVFTH_Pos           (0)                                               /*!< CAP_T::FIFOTH: PLNVFTH Position           */
#define CAP_FIFOTH_PLNVFTH_Msk           (0xful << CAP_FIFOTH_PLNVFTH_Pos)                 /*!< CAP_T::FIFOTH: PLNVFTH Mask               */

#define CAP_FIFOTH_PLNUFTH_Pos           (8)                                               /*!< CAP_T::FIFOTH: PLNUFTH Position           */
#define CAP_FIFOTH_PLNUFTH_Msk           (0xful << CAP_FIFOTH_PLNUFTH_Pos)                 /*!< CAP_T::FIFOTH: PLNUFTH Mask               */

#define CAP_FIFOTH_PLNYFTH_Pos           (16)                                              /*!< CAP_T::FIFOTH: PLNYFTH Position           */
#define CAP_FIFOTH_PLNYFTH_Msk           (0x1ful << CAP_FIFOTH_PLNYFTH_Pos)                /*!< CAP_T::FIFOTH: PLNYFTH Mask               */

#define CAP_FIFOTH_PKTFTH_Pos            (24)                                              /*!< CAP_T::FIFOTH: PKTFTH Position            */
#define CAP_FIFOTH_PKTFTH_Msk            (0x1ful << CAP_FIFOTH_PKTFTH_Pos)                 /*!< CAP_T::FIFOTH: PKTFTH Mask                */

#define CAP_FIFOTH_OVF_Pos               (31)                                              /*!< CAP_T::FIFOTH: OVF Position               */
#define CAP_FIFOTH_OVF_Msk               (0x1ul << CAP_FIFOTH_OVF_Pos)                     /*!< CAP_T::FIFOTH: OVF Mask                   */

#define CAP_CMPADDR_CMPADDR_Pos          (0)                                               /*!< CAP_T::CMPADDR: CMPADDR Position          */
#define CAP_CMPADDR_CMPADDR_Msk          (0xfffffffful << CAP_CMPADDR_CMPADDR_Pos)         /*!< CAP_T::CMPADDR: CMPADDR Mask              */

#define CAP_PKTSM_PKTSHMH_Pos            (0)                                               /*!< CAP_T::PKTSM: PKTSHMH Position            */
#define CAP_PKTSM_PKTSHMH_Msk            (0xfful << CAP_PKTSM_PKTSHMH_Pos)                 /*!< CAP_T::PKTSM: PKTSHMH Mask                */

#define CAP_PKTSM_PKTSHNH_Pos            (8)                                               /*!< CAP_T::PKTSM: PKTSHNH Position            */
#define CAP_PKTSM_PKTSHNH_Msk            (0xfful << CAP_PKTSM_PKTSHNH_Pos)                 /*!< CAP_T::PKTSM: PKTSHNH Mask                */

#define CAP_PKTSM_PKTSVMH_Pos            (16)                                              /*!< CAP_T::PKTSM: PKTSVMH Position            */
#define CAP_PKTSM_PKTSVMH_Msk            (0xfful << CAP_PKTSM_PKTSVMH_Pos)                 /*!< CAP_T::PKTSM: PKTSVMH Mask                */

#define CAP_PKTSM_PKTSVNH_Pos            (24)                                              /*!< CAP_T::PKTSM: PKTSVNH Position            */
#define CAP_PKTSM_PKTSVNH_Msk            (0xfful << CAP_PKTSM_PKTSVNH_Pos)                 /*!< CAP_T::PKTSM: PKTSVNH Mask                */

#define CAP_PLNSM_PLNSHMH_Pos            (0)                                               /*!< CAP_T::PLNSM: PLNSHMH Position            */
#define CAP_PLNSM_PLNSHMH_Msk            (0xfful << CAP_PLNSM_PLNSHMH_Pos)                 /*!< CAP_T::PLNSM: PLNSHMH Mask                */

#define CAP_PLNSM_PLNSHNH_Pos            (8)                                               /*!< CAP_T::PLNSM: PLNSHNH Position            */
#define CAP_PLNSM_PLNSHNH_Msk            (0xfful << CAP_PLNSM_PLNSHNH_Pos)                 /*!< CAP_T::PLNSM: PLNSHNH Mask                */

#define CAP_PLNSM_PLNSVMH_Pos            (16)                                              /*!< CAP_T::PLNSM: PLNSVMH Position            */
#define CAP_PLNSM_PLNSVMH_Msk            (0xfful << CAP_PLNSM_PLNSVMH_Pos)                 /*!< CAP_T::PLNSM: PLNSVMH Mask                */

#define CAP_PLNSM_PLNSVNH_Pos            (24)                                              /*!< CAP_T::PLNSM: PLNSVNH Position            */
#define CAP_PLNSM_PLNSVNH_Msk            (0xfful << CAP_PLNSM_PLNSVNH_Pos)                 /*!< CAP_T::PLNSM: PLNSVNH Mask                */

#define CAP_CURADDRP_CURADDR_Pos         (0)                                               /*!< CAP_T::CURADDRP: CURADDR Position         */
#define CAP_CURADDRP_CURADDR_Msk         (0xfffffffful << CAP_CURADDRP_CURADDR_Pos)        /*!< CAP_T::CURADDRP: CURADDR Mask             */

#define CAP_CURADDRY_CURADDR_Pos         (0)                                               /*!< CAP_T::CURADDRY: CURADDR Position         */
#define CAP_CURADDRY_CURADDR_Msk         (0xfffffffful << CAP_CURADDRY_CURADDR_Pos)        /*!< CAP_T::CURADDRY: CURADDR Mask             */

#define CAP_CURADDRU_CURADDR_Pos         (0)                                               /*!< CAP_T::CURADDRU: CURADDR Position         */
#define CAP_CURADDRU_CURADDR_Msk         (0xfffffffful << CAP_CURADDRU_CURADDR_Pos)        /*!< CAP_T::CURADDRU: CURADDR Mask             */

#define CAP_CURVADDR_CURADDR_Pos         (0)                                               /*!< CAP_T::CURVADDR: CURADDR Position         */
#define CAP_CURVADDR_CURADDR_Msk         (0xfffffffful << CAP_CURVADDR_CURADDR_Pos)        /*!< CAP_T::CURVADDR: CURADDR Mask             */

#define CAP_PKTBA0_BASEADDR_Pos          (0)                                               /*!< CAP_T::PKTBA0: BASEADDR Position          */
#define CAP_PKTBA0_BASEADDR_Msk          (0xfffffffful << CAP_PKTBA0_BASEADDR_Pos)         /*!< CAP_T::PKTBA0: BASEADDR Mask              */

#define CAP_PKTBA1_BASEADDR_Pos          (0)                                               /*!< CAP_T::PKTBA1: BASEADDR Position          */
#define CAP_PKTBA1_BASEADDR_Msk          (0xfffffffful << CAP_PKTBA1_BASEADDR_Pos)         /*!< CAP_T::PKTBA1: BASEADDR Mask              */

#define CAP_YBA_BASEADDR_Pos             (0)                                               /*!< CAP_T::YBA: BASEADDR Position             */
#define CAP_YBA_BASEADDR_Msk             (0xfffffffful << CAP_YBA_BASEADDR_Pos)            /*!< CAP_T::YBA: BASEADDR Mask                 */

#define CAP_UBA_BASEADDR_Pos             (0)                                               /*!< CAP_T::UBA: BASEADDR Position             */
#define CAP_UBA_BASEADDR_Msk             (0xfffffffful << CAP_UBA_BASEADDR_Pos)            /*!< CAP_T::UBA: BASEADDR Mask                 */

#define CAP_VBA_BASEADDR_Pos             (0)                                               /*!< CAP_T::VBA: BASEADDR Position             */
#define CAP_VBA_BASEADDR_Msk             (0xfffffffful << CAP_VBA_BASEADDR_Pos)            /*!< CAP_T::VBA: BASEADDR Mask                 */

/**@}*/ /* CAP_CONST */
/**@}*/ /* end of CAP register group */


/*---------------------- Enhanced Input Capture Timer -------------------------*/
/**
    @addtogroup ECAP Enhanced Input Capture Timer(ECAP)
    Memory Mapped Structure for ECAP Controller
@{ */

typedef struct {


    /**
     * CNT
     * ===================================================================================================
     * Offset: 0x00  Input Capture Counter (24-bit up counter)
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |VAL       |Input Capture Timer/Counter
     * |        |          |The input Capture Timer/Counter is a 24-bit up-counting counter.
     * |        |          |The clock source for the counter is from the clock divider output which the CAP_CLK is software optionally divided by 1,4,16 or 32.
    */
    __IO uint32_t CNT;

    /**
     * HOLD0
     * ===================================================================================================
     * Offset: 0x04  Input Capture Counter Hold Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |VAL       |Input Capture Counter Hold Register
     * |        |          |When an active input capture channel detects a valid edge signal change, the ECAP_CNT value is latched into the corresponding holding register.
     * |        |          |Each input channel has itself holding register named by ECAP_HOLDx where x is from 0 to 2 to indicate inputs from IC0 to IC2, respectively.
    */
    __IO uint32_t HOLD0;

    /**
     * HOLD1
     * ===================================================================================================
     * Offset: 0x08  Input Capture Counter Hold Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |VAL       |Input Capture Counter Hold Register
     * |        |          |When an active input capture channel detects a valid edge signal change, the ECAP_CNT value is latched into the corresponding holding register.
     * |        |          |Each input channel has itself holding register named by ECAP_HOLDx where x is from 0 to 2 to indicate inputs from IC0 to IC2, respectively.
    */
    __IO uint32_t HOLD1;

    /**
     * HOLD2
     * ===================================================================================================
     * Offset: 0x0C  Input Capture Counter Hold Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |VAL       |Input Capture Counter Hold Register
     * |        |          |When an active input capture channel detects a valid edge signal change, the ECAP_CNT value is latched into the corresponding holding register.
     * |        |          |Each input channel has itself holding register named by ECAP_HOLDx where x is from 0 to 2 to indicate inputs from IC0 to IC2, respectively.
    */
    __IO uint32_t HOLD2;

    /**
     * CNTCMP
     * ===================================================================================================
     * Offset: 0x10  Input Capture Counter Compare Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |VAL       |Input Capture Counter Compare Register
     * |        |          |If the compare function is enabled (CMPEN = 1), the compare register is loaded with the value that the compare function compares the capture counter (ECAP_CNT) with.
     * |        |          |If the reload control is enabled (RLDEN = 1), an overflow event or capture events will trigger the hardware to reload ECAP_CNTCMP into ECAP_CNT.
    */
    __IO uint32_t CNTCMP;

    /**
     * CTL0
     * ===================================================================================================
     * Offset: 0x14  Input Capture Control Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |NFDIS     |Noise Filter Clock Pre-Divide Selection
     * |        |          |To determine the sampling frequency of the Noise Filter clock
     * |        |          |00 = CAP_CLK.
     * |        |          |01 = CAP_CLK/2.
     * |        |          |10 = CAP_CLK/4.
     * |        |          |11 = CAP_CLK/16.
     * |[3]     |CAPNF_DIS |Input Capture Noise Filter Disable Control
     * |        |          |0 = Noise filter of Input Capture Enabled.
     * |        |          |1 = Noise filter of Input Capture Disabled.
     * |[4]     |CAPEN0    |Port Pin IC0 Input To Input Capture Unit Enable Control
     * |        |          |0 = IC0 input to Input Capture Unit Disabled.
     * |        |          |1 = IC0 input to Input Capture Unit Enabled.
     * |[5]     |CAPEN1    |Port Pin IC1 Input To Input Capture Unit Enable Control
     * |        |          |0 = IC1 input to Input Capture Unit Disabled.
     * |        |          |1 = IC1 input to Input Capture Unit Enabled.
     * |[6]     |CAPEN2    |Port Pin IC2 Input To Input Capture Unit Enable Control
     * |        |          |0 = IC2 input to Input Capture Unit Disabled.
     * |        |          |1 = IC2 input to Input Capture Unit Enabled.
     * |[8:9]   |CAPSEL0   |CAP0 Input Source Selection
     * |        |          |00 = CAP0 input is from port pin IC0.
     * |        |          |01 = CAP0 input is from signal CPO0 (Analog comparator 0 output).
     * |        |          |10 = CAP0 input is from signal CHA of QEI controller unit x.
     * |        |          |11 = CAP0 input is from signal OPDO0 (OP0 digital output).
     * |        |          |Note: Input capture unit n matches QEI or comparator unit x, where x = 0~1.
     * |[10:11] |CAPSEL1   |CAP1 Input Source Selection
     * |        |          |00 = CAP1 input is from port pin IC1.
     * |        |          |01 = CAP1 input is from signal CPO1 (Analog comparator 1 output).
     * |        |          |10 = CAP1 input is from signal CHB of QEI controller unit x.
     * |        |          |11 = CAP1 input is from signal OPDO1 (OP1 digital output).
     * |        |          |Note: Input capture unit n matches QEI or comparator unit x, where x = 0~1.
     * |[12:13] |CAPSEL2   |CAP2 Input Source Selection
     * |        |          |00 = CAP2 input is from port pin IC2.
     * |        |          |01 = CAP2 input is from signal CPO2 (Analog comparator 2 output).
     * |        |          |10 = CAP2 input is from signal CHX of QEI controller unit x.
     * |        |          |11 = CAP2 input is from signal ADCMPOx (ADC compare output x).
     * |        |          |Note: Input capture unit n matches QEI or comparator unit x, where x = 0~1.
     * |[16]    |CAPIEN0   |Input Capture Channel 0 Interrupt Enable Control
     * |        |          |0 = The flag CAPF0 can trigger Input Capture interrupt Disabled.
     * |        |          |1 = The flag CAPF0 can trigger Input Capture interrupt Enabled.
     * |[17]    |CAPIEN1   |Input Capture Channel 1 Interrupt Enable Control
     * |        |          |0 = The flag CAPF1 can trigger Input Capture interrupt Disabled.
     * |        |          |1 = The flag CAPF1 can trigger Input Capture interrupt Enabled.
     * |[18]    |CAPIEN2   |Input Capture Channel 2 Interrupt Enable Control
     * |        |          |0 = The flag CAPF2 can trigger Input Capture interrupt Disabled.
     * |        |          |1 = The flag CAPF2 can trigger Input Capture interrupt Enabled.
     * |[20]    |OVIEN     |OVF Trigger Input Capture Interrupt Enable Control
     * |        |          |0 = The flag OVUNF can trigger Input Capture interrupt Disabled.
     * |        |          |1 = The flag OVUNF can trigger Input Capture interrupt Enabled.
     * |[21]    |CMPIEN    |CMPF Trigger Input Capture Interrupt Enable Control
     * |        |          |0 = The flag CMPF can trigger Input Capture interrupt Disabled.
     * |        |          |1 = The flag CMPF can trigger Input Capture interrupt Enabled.
     * |[24]    |CNTEN     |Input Capture Counter Start
     * |        |          |Setting this bit to 1, the capture counter (ECAP_CNT) starts up-counting synchronously with capture clock input (CAP_CLK).
     * |        |          |0 = ECAP_CNT stop counting.
     * |        |          |1 = ECAP_CNT starts up-counting.
     * |[25]    |CMPCLR    |Input Capture Counter Cleared By Compare-Match Control
     * |        |          |If this bit is set to 1, the capture counter (ECAP_CNT) will be cleared to 0 when the compare-match event (CAMCMPF = 1) occurs.
     * |        |          |0 = Compare-match event (CAMCMPF) can clear capture counter (ECAP_CNT) Disabled.
     * |        |          |1 = Compare-match event (CAMCMPF) can clear capture counter (ECAP_CNT) Enabled.
     * |[26]    |CPTCLR    |Input Capture Counter Cleared By Capture Events Control
     * |        |          |If this bit is set to 1, the capture counter (ECAP_CNT) will be cleared to zero when any one of capture events (CAPF0~3) occurs.
     * |        |          |0 = Capture events (CAPF0~3) can clear capture counter (ECAP_CNT) Disabled.
     * |        |          |1 = Capture events (CAPF0~3) can clear capture counter (ECAP_CNT) Enabled.
     * |[27]    |RLDEN     |Reload Function Enable Control
     * |        |          |Setting this bit to enable the reload function.
     * |        |          |If the reload control is enabled, an overflow event (OVF) or capture events (CAPFx) will trigger the hardware to reload ECAP_CNTCMP into ECAP_CNT.
     * |        |          |0 = The reload function Disabled.
     * |        |          |1 = The reload function Enabled.
     * |[28]    |CMPEN     |Compare Function Enable Control
     * |        |          |The compare function in input capture timer/counter is to compare the dynamic counting ECAP_CNT with the compare register ECAP_CNTCMP, if ECAP_CNT value reaches ECAP_CNTCMP, the flag CMPF will be set.
     * |        |          |0 = The compare function Disabled.
     * |        |          |1 = The compare function Enabled.
     * |[29]    |CAPEN     |Input Capture Timer/Counter Enable Control
     * |        |          |0 = Input Capture function Disabled.
     * |        |          |1 = Input Capture function Enabled.
    */
    __IO uint32_t CTL0;

    /**
     * CTL1
     * ===================================================================================================
     * Offset: 0x18  Input Capture Control Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |EDGESEL0  |Channel 0 Captured Edge Selection
     * |        |          |Input capture can detect falling edge change only, rising edge change only or one of both edge change
     * |        |          |00 = Detect rising edge.
     * |        |          |01 = Detect falling edge.
     * |        |          |1x = Detect either rising or falling edge.
     * |[2:3]   |EDGESEL1  |Channel 1 Captured Edge Selection
     * |        |          |Input capture can detect falling edge change only, rising edge change only or one of both edge change
     * |        |          |00 = Detect rising edge.
     * |        |          |01 = Detect falling edge.
     * |        |          |1x = Detect either rising or falling edge.
     * |[4:5]   |EDGESEL2  |Channel 2 Captured Edge Selection
     * |        |          |Input capture can detect falling edge change or rising edge change only, or one of both edge changes.
     * |        |          |00 = Detect rising edge.
     * |        |          |01 = Detect falling edge.
     * |        |          |1x = Detect either rising or falling edge.
     * |[8:10]  |RLDSEL    |ECAP_CNT Reload Trigger Source Selection
     * |        |          |If the reload function is enabled RLDEN (ECAP_CTL0[27]) = 1, when a reload trigger event comes, the ECAP_CNT is reloaded with ECAP_CNTCMP.
     * |        |          |RLDSEL[2:0] determines the ECAP_CNT reload trigger source
     * |        |          |000 = CAPF0.
     * |        |          |001 = CAPF1.
     * |        |          |010 = CAPF2.
     * |        |          |100 = OVF.
     * |        |          |Others = Reserved.
     * |[12:14] |CLKSEL    |Capture Timer Clock Divide Selection
     * |        |          |The capture timer clock has a pre-divider with four divided options controlled by CLKSEL[1:0].
     * |        |          |000 = CAP_CLK/1.
     * |        |          |001 = CAP_CLK/4.
     * |        |          |010 = CAP_CLK/16.
     * |        |          |011 = CAP_CLK/32.
     * |        |          |100 = CAP_CLK/64.
     * |        |          |101 = CAP_CLK/96.
     * |        |          |110 = CAP_CLK/112.
     * |        |          |111 = CAP_CLK/128.
     * |[16:17] |SRCSEL    |Capture Timer/Counter Clock Source Selection
     * |        |          |Select the capture timer/counter clock source.
     * |        |          |00 = CAP_CLK (default).
     * |        |          |01 = CAP0.
     * |        |          |10 = CAP1.
     * |        |          |11 = CAP2.
    */
    __IO uint32_t CTL1;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x1C  Input Capture Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CAPF0     |Input Capture Channel 0 Captured Flag
     * |        |          |When the input capture channel 0 detects a valid edge change at CAP0 input, it will set flag CAPF0 to high.
     * |        |          |0 = No valid edge change is detected at CAP0 input.
     * |        |          |1 = A valid edge change is detected at CAP0 input.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
     * |[1]     |CAPF1     |Input Capture Channel 1 Captured Flag
     * |        |          |When the input capture channel 1 detects a valid edge change at CAP1 input, it will set flag CAPF1 to high.
     * |        |          |0 = No valid edge change is detected at CAP1 input.
     * |        |          |1 = A valid edge change is detected at CAP1 input.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
     * |[2]     |CAPF2     |Input Capture Channel 2 Captured Flag
     * |        |          |When the input capture channel 2 detects a valid edge change at CAP2 input, it will set flag CAPF2 to high.
     * |        |          |0 = No valid edge change is detected at CAP2 input.
     * |        |          |1 = A valid edge change is detected at CAP2 input.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
     * |[4]     |CMPF      |Input Capture Compare-Match Flag
     * |        |          |If the input capture compare function is enabled, the flag is set by hardware while capture counter (ECAP_CNT) up counts and reach to the ECAP_CNTCMP value.
     * |        |          |0 = ECAP_CNT does not match with ECAP_CNTCMP value.
     * |        |          |1 = ECAP_CNT counts to the same as ECAP_CNTCMP value.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
     * |[5]     |OVF       |Input Capture Counter Overflow Flag
     * |        |          |Flag is set by hardware when input capture up counter (ECAP_CNT) overflows from 0x00FF_FFFF to zero.
     * |        |          |0 = No overflow occurs in ECAP_CNT.
     * |        |          |1 = ECAP_CNT overflows.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
    */
    __IO uint32_t STATUS;

} ECAP_T;

/**
    @addtogroup ECAP_CONST ECAP Bit Field Definition
    Constant Definitions for ECAP Controller
@{ */

#define ECAP_CNT_VAL_Pos                 (0)                                               /*!< ECAP_T::CNT: VAL Position                 */
#define ECAP_CNT_VAL_Msk                 (0xfffffful << ECAP_CNT_VAL_Pos)                  /*!< ECAP_T::CNT: VAL Mask                     */

#define ECAP_HOLD0_VAL_Pos               (0)                                               /*!< ECAP_T::HOLD0: VAL Position               */
#define ECAP_HOLD0_VAL_Msk               (0xfffffful << ECAP_HOLD0_VAL_Pos)                /*!< ECAP_T::HOLD0: VAL Mask                   */

#define ECAP_HOLD1_VAL_Pos               (0)                                               /*!< ECAP_T::HOLD1: VAL Position               */
#define ECAP_HOLD1_VAL_Msk               (0xfffffful << ECAP_HOLD1_VAL_Pos)                /*!< ECAP_T::HOLD1: VAL Mask                   */

#define ECAP_HOLD2_VAL_Pos               (0)                                               /*!< ECAP_T::HOLD2: VAL Position               */
#define ECAP_HOLD2_VAL_Msk               (0xfffffful << ECAP_HOLD2_VAL_Pos)                /*!< ECAP_T::HOLD2: VAL Mask                   */

#define ECAP_CNTCMP_VAL_Pos              (0)                                               /*!< ECAP_T::CNTCMP: VAL Position              */
#define ECAP_CNTCMP_VAL_Msk              (0xfffffful << ECAP_CNTCMP_VAL_Pos)               /*!< ECAP_T::CNTCMP: VAL Mask                  */

#define ECAP_CTL0_NFDIS_Pos              (0)                                               /*!< ECAP_T::CTL0: NFDIS Position              */
#define ECAP_CTL0_NFDIS_Msk              (0x3ul << ECAP_CTL0_NFDIS_Pos)                    /*!< ECAP_T::CTL0: NFDIS Mask                  */

#define ECAP_CTL0_CAPNF_DIS_Pos          (3)                                               /*!< ECAP_T::CTL0: CAPNF_DIS Position          */
#define ECAP_CTL0_CAPNF_DIS_Msk          (0x1ul << ECAP_CTL0_CAPNF_DIS_Pos)                /*!< ECAP_T::CTL0: CAPNF_DIS Mask              */

#define ECAP_CTL0_CAPEN0_Pos             (4)                                               /*!< ECAP_T::CTL0: CAPEN0 Position             */
#define ECAP_CTL0_CAPEN0_Msk             (0x1ul << ECAP_CTL0_CAPEN0_Pos)                   /*!< ECAP_T::CTL0: CAPEN0 Mask                 */

#define ECAP_CTL0_CAPEN1_Pos             (5)                                               /*!< ECAP_T::CTL0: CAPEN1 Position             */
#define ECAP_CTL0_CAPEN1_Msk             (0x1ul << ECAP_CTL0_CAPEN1_Pos)                   /*!< ECAP_T::CTL0: CAPEN1 Mask                 */

#define ECAP_CTL0_CAPEN2_Pos             (6)                                               /*!< ECAP_T::CTL0: CAPEN2 Position             */
#define ECAP_CTL0_CAPEN2_Msk             (0x1ul << ECAP_CTL0_CAPEN2_Pos)                   /*!< ECAP_T::CTL0: CAPEN2 Mask                 */

#define ECAP_CTL0_CAPSEL0_Pos            (8)                                               /*!< ECAP_T::CTL0: CAPSEL0 Position            */
#define ECAP_CTL0_CAPSEL0_Msk            (0x3ul << ECAP_CTL0_CAPSEL0_Pos)                  /*!< ECAP_T::CTL0: CAPSEL0 Mask                */

#define ECAP_CTL0_CAPSEL1_Pos            (10)                                              /*!< ECAP_T::CTL0: CAPSEL1 Position            */
#define ECAP_CTL0_CAPSEL1_Msk            (0x3ul << ECAP_CTL0_CAPSEL1_Pos)                  /*!< ECAP_T::CTL0: CAPSEL1 Mask                */

#define ECAP_CTL0_CAPSEL2_Pos            (12)                                              /*!< ECAP_T::CTL0: CAPSEL2 Position            */
#define ECAP_CTL0_CAPSEL2_Msk            (0x3ul << ECAP_CTL0_CAPSEL2_Pos)                  /*!< ECAP_T::CTL0: CAPSEL2 Mask                */

#define ECAP_CTL0_CAPIEN0_Pos            (16)                                              /*!< ECAP_T::CTL0: CAPIEN0 Position            */
#define ECAP_CTL0_CAPIEN0_Msk            (0x1ul << ECAP_CTL0_CAPIEN0_Pos)                  /*!< ECAP_T::CTL0: CAPIEN0 Mask                */

#define ECAP_CTL0_CAPIEN1_Pos            (17)                                              /*!< ECAP_T::CTL0: CAPIEN1 Position            */
#define ECAP_CTL0_CAPIEN1_Msk            (0x1ul << ECAP_CTL0_CAPIEN1_Pos)                  /*!< ECAP_T::CTL0: CAPIEN1 Mask                */

#define ECAP_CTL0_CAPIEN2_Pos            (18)                                              /*!< ECAP_T::CTL0: CAPIEN2 Position            */
#define ECAP_CTL0_CAPIEN2_Msk            (0x1ul << ECAP_CTL0_CAPIEN2_Pos)                  /*!< ECAP_T::CTL0: CAPIEN2 Mask                */

#define ECAP_CTL0_OVIEN_Pos              (20)                                              /*!< ECAP_T::CTL0: OVIEN Position              */
#define ECAP_CTL0_OVIEN_Msk              (0x1ul << ECAP_CTL0_OVIEN_Pos)                    /*!< ECAP_T::CTL0: OVIEN Mask                  */

#define ECAP_CTL0_CMPIEN_Pos             (21)                                              /*!< ECAP_T::CTL0: CMPIEN Position             */
#define ECAP_CTL0_CMPIEN_Msk             (0x1ul << ECAP_CTL0_CMPIEN_Pos)                   /*!< ECAP_T::CTL0: CMPIEN Mask                 */

#define ECAP_CTL0_CNTEN_Pos              (24)                                              /*!< ECAP_T::CTL0: CNTEN Position              */
#define ECAP_CTL0_CNTEN_Msk              (0x1ul << ECAP_CTL0_CNTEN_Pos)                    /*!< ECAP_T::CTL0: CNTEN Mask                  */

#define ECAP_CTL0_CMPCLR_Pos             (25)                                              /*!< ECAP_T::CTL0: CMPCLR Position             */
#define ECAP_CTL0_CMPCLR_Msk             (0x1ul << ECAP_CTL0_CMPCLR_Pos)                   /*!< ECAP_T::CTL0: CMPCLR Mask                 */

#define ECAP_CTL0_CPTCLR_Pos             (26)                                              /*!< ECAP_T::CTL0: CPTCLR Position             */
#define ECAP_CTL0_CPTCLR_Msk             (0x1ul << ECAP_CTL0_CPTCLR_Pos)                   /*!< ECAP_T::CTL0: CPTCLR Mask                 */

#define ECAP_CTL0_RLDEN_Pos              (27)                                              /*!< ECAP_T::CTL0: RLDEN Position              */
#define ECAP_CTL0_RLDEN_Msk              (0x1ul << ECAP_CTL0_RLDEN_Pos)                    /*!< ECAP_T::CTL0: RLDEN Mask                  */

#define ECAP_CTL0_CMPEN_Pos              (28)                                              /*!< ECAP_T::CTL0: CMPEN Position              */
#define ECAP_CTL0_CMPEN_Msk              (0x1ul << ECAP_CTL0_CMPEN_Pos)                    /*!< ECAP_T::CTL0: CMPEN Mask                  */

#define ECAP_CTL0_CAPEN_Pos              (29)                                              /*!< ECAP_T::CTL0: CAPEN Position              */
#define ECAP_CTL0_CAPEN_Msk              (0x1ul << ECAP_CTL0_CAPEN_Pos)                    /*!< ECAP_T::CTL0: CAPEN Mask                  */

#define ECAP_CTL1_EDGESEL0_Pos           (0)                                               /*!< ECAP_T::CTL1: EDGESEL0 Position           */
#define ECAP_CTL1_EDGESEL0_Msk           (0x3ul << ECAP_CTL1_EDGESEL0_Pos)                 /*!< ECAP_T::CTL1: EDGESEL0 Mask               */

#define ECAP_CTL1_EDGESEL1_Pos           (2)                                               /*!< ECAP_T::CTL1: EDGESEL1 Position           */
#define ECAP_CTL1_EDGESEL1_Msk           (0x3ul << ECAP_CTL1_EDGESEL1_Pos)                 /*!< ECAP_T::CTL1: EDGESEL1 Mask               */

#define ECAP_CTL1_EDGESEL2_Pos           (4)                                               /*!< ECAP_T::CTL1: EDGESEL2 Position           */
#define ECAP_CTL1_EDGESEL2_Msk           (0x3ul << ECAP_CTL1_EDGESEL2_Pos)                 /*!< ECAP_T::CTL1: EDGESEL2 Mask               */

#define ECAP_CTL1_RLDSEL_Pos             (8)                                               /*!< ECAP_T::CTL1: RLDSEL Position             */
#define ECAP_CTL1_RLDSEL_Msk             (0x7ul << ECAP_CTL1_RLDSEL_Pos)                   /*!< ECAP_T::CTL1: RLDSEL Mask                 */

#define ECAP_CTL1_CLKSEL_Pos             (12)                                              /*!< ECAP_T::CTL1: CLKSEL Position             */
#define ECAP_CTL1_CLKSEL_Msk             (0x7ul << ECAP_CTL1_CLKSEL_Pos)                   /*!< ECAP_T::CTL1: CLKSEL Mask                 */

#define ECAP_CTL1_SRCSEL_Pos             (16)                                              /*!< ECAP_T::CTL1: SRCSEL Position             */
#define ECAP_CTL1_SRCSEL_Msk             (0x3ul << ECAP_CTL1_SRCSEL_Pos)                   /*!< ECAP_T::CTL1: SRCSEL Mask                 */

#define ECAP_STATUS_CAPF0_Pos            (0)                                               /*!< ECAP_T::STATUS: CAPF0 Position            */
#define ECAP_STATUS_CAPF0_Msk            (0x1ul << ECAP_STATUS_CAPF0_Pos)                  /*!< ECAP_T::STATUS: CAPF0 Mask                */

#define ECAP_STATUS_CAPF1_Pos            (1)                                               /*!< ECAP_T::STATUS: CAPF1 Position            */
#define ECAP_STATUS_CAPF1_Msk            (0x1ul << ECAP_STATUS_CAPF1_Pos)                  /*!< ECAP_T::STATUS: CAPF1 Mask                */

#define ECAP_STATUS_CAPF2_Pos            (2)                                               /*!< ECAP_T::STATUS: CAPF2 Position            */
#define ECAP_STATUS_CAPF2_Msk            (0x1ul << ECAP_STATUS_CAPF2_Pos)                  /*!< ECAP_T::STATUS: CAPF2 Mask                */

#define ECAP_STATUS_CMPF_Pos             (4)                                               /*!< ECAP_T::STATUS: CMPF Position             */
#define ECAP_STATUS_CMPF_Msk             (0x1ul << ECAP_STATUS_CMPF_Pos)                   /*!< ECAP_T::STATUS: CMPF Mask                 */

#define ECAP_STATUS_OVF_Pos              (5)                                               /*!< ECAP_T::STATUS: OVF Position              */
#define ECAP_STATUS_OVF_Msk              (0x1ul << ECAP_STATUS_OVF_Pos)                    /*!< ECAP_T::STATUS: OVF Mask                  */

/**@}*/ /* ECAP_CONST */
/**@}*/ /* end of ECAP register group */


/*---------------------- System Clock Controller -------------------------*/
/**
    @addtogroup CLK System Clock Controller(CLK)
    Memory Mapped Structure for CLK Controller
@{ */

typedef struct {


    /**
     * PWRCTL
     * ===================================================================================================
     * Offset: 0x00  System Power-down Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |HXTEN     |4~24 MHz External High-Speed Crystal Enable Control (Write Protect)
     * |        |          |The bit default value is set by flash controller user configuration register config0 [26:24].
     * |        |          |When the default clock source is from 4~24 MHz external high-speed crystal, this bit is set to 1 automatically
     * |        |          |0 = HXT Disabled.
     * |        |          |1 = HXT Enabled.
     * |[1]     |LXTEN     |LXT Enable Control (Write Protect)
     * |        |          |0 = LXT Disabled.
     * |        |          |1 = LXT (Normal operation) Enabled.
     * |[2]     |HIRCEN    |HIRC Enable Control (Write Protect)
     * |        |          |0 = HIRC Disabled.
     * |        |          |1 = HIRC Enabled.
     * |[3]     |LIRCEN    |10 KHz Internal Low-Speed Oscillator Enable Control (Write Protect)
     * |        |          |0 = LIRC Disabled.
     * |        |          |1 = LIRC Enabled (default 1).
     * |[4]     |PDWKDLY   |Wake-Up Delay Counter Enable Control (Write Protect)
     * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
     * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at HXT, and 256 clock cycles when chip works at HIRC.
     * |        |          |0 = Clock cycles delay Disabled.
     * |        |          |1 = Clock cycles delay Enabled.
     * |[5]     |PDWKIEN   |Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)
     * |        |          |0 = Power-down Mode Wake-up Interrupt Disabled.
     * |        |          |1 = Power-down Mode Wake-up Interrupt Enabled.
     * |        |          |Note: The interrupt will occur when both PDWKIF and PDWKIEN are high.
     * |[6]     |PDWKIF    |Power-Down Mode Wake-Up Interrupt Status
     * |        |          |Set by "power-down wake-up event", it indicates that resume from Power-down mode"
     * |        |          |The flag is set if the GPIO, USB, UART, WDT, CAN, ACMP, BOD, RTC or SDHOST wake-up occurred
     * |        |          |Note1: Write 1 to clear the bit to 0.
     * |        |          |Note2: This bit works only if PDWKIEN (CLK_PWRCTL[5]) set to 1.
     * |[7]     |PDEN      |System Power-Down Enable Control (Write Protect)
     * |        |          |When this bit is set to 1, Power-down mode is enabled and chip power-down behavior will depend on the PDEN bit.
     * |        |          |(a) If the PDEN is 0, then the chip enters Power-down mode immediately after
     * |        |          |the PWR_DOWN_EN bit set. ( default)
     * |        |          |(b) if the PDEN is 1, then the chip keeps active till the CPU sleep mode is also
     * |        |          |active and then the chip enters Power-down mode
     * |        |          |When chip wakes up from Power-down mode, this bit is auto cleared. Users need to set
     * |        |          |this bit again for next power-down.
     * |        |          |In Power-down mode, HXT and the HIRC will be disabled in this mode, but the LXT and
     * |        |          |LIRC are not controlled by Power-down mode.
     * |        |          |In Power-down mode, the PLL and system clock are disabled, and ignored the clock
     * |        |          |source selection. The clocks of peripheral are not controlled by Power-down mode, if the
     * |        |          |peripheral clock source is from LXT or the LIRC.
     * |        |          |0 = Chip operating normally or chip in idle mode by WFI command.
     * |        |          |1 = Chip enters Power-down mode instant or waits CPU sleep command WFI.
     * |[8]     |PDWTCPU   |This Bit Control The Power-Down Entry Condition (Write Protect)
     * |        |          |0 = Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1.
     * |        |          |1 = Chip enters Power-down mode when the both PDEN and PWR_DOWN_EN bits are set to 1 and CPU run WFI instruction.
     * |[9]     |DBPDEN    |Chip Entering Power-Down Even ICE Connected
     * |        |          |0 = Chip enters power-down disabled in Debug mode.
     * |        |          |1 = Chip enters power-down enabled in Debug mode.
    */
    __IO uint32_t PWRCTL;

    /**
     * AHBCLK
     * ===================================================================================================
     * Offset: 0x04  AHB Devices Clock Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1]     |PDMACKEN  |PDMA Controller Clock Enable Control
     * |        |          |0 = PDMA engine clock Disabled.
     * |        |          |1 = PDMA engine clock Enabled.
     * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Control
     * |        |          |0 = Flash ISP engine clock Disabled.
     * |        |          |1 = Flash ISP engine clock Enabled.
     * |[3]     |EBICKEN   |EBI Controller Clock Enable Control
     * |        |          |0 = EBI engine clock Disabled.
     * |        |          |1 = EBI engine clock Enabled.
     * |[4]     |USBHCKEN  |USB HOST Controller Clock Enable Control
     * |        |          |0 = USB HOST engine clock Disabled.
     * |        |          |1 = USB HOST engine clock Enabled.
     * |[5]     |EMACCKEN  |Ethernet Controller Clock Enable Control (NUC472 Only)
     * |        |          |0 = Ethernet Controller engine clock Disabled.
     * |        |          |1 = Ethernet Controller engine clock Enabled.
     * |[6]     |SDHCKEN   |SDHOST Controller Clock Enable Control
     * |        |          |0 = SDHOST engine clock Disabled.
     * |        |          |1 = SDHOST engine clock Enabled.
     * |[7]     |CRCCKEN   |CRC Generator Controller Clock Enable Control
     * |        |          |0 = CRC engine clock Disabled.
     * |        |          |1 = CRC engine clock Enabled.
     * |[8]     |CAPCKEN   |Image Capture Interface Controller Clock Enable Control
     * |        |          |0 = CAP controller's clock Disabled.
     * |        |          |1 = CAP controller's clock Enabled.
     * |[9]     |SENCKEN   |Sensor Clock Enable Control
     * |        |          |0 = Sensor clock Disabled.
     * |        |          |1 = Sensor clock Enabled.
     * |[10]    |USBDCKEN  |USB 2.0 Device Clock Enable Control
     * |        |          |0 = USB device controller's clock Disabled.
     * |        |          |1 = USB device controller's clock Enabled.
     * |[12]    |CRPTCKEN  |Cryptographic Accelerator Clock Enable Control
     * |        |          |0 = Cryptographic Accelerator clock Disabled.
     * |        |          |1 = Cryptographic Accelerator clock Enabled.
    */
    __IO uint32_t AHBCLK;

    /**
     * APBCLK0
     * ===================================================================================================
     * Offset: 0x08  APB Devices Clock Enable Control Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |WDTCKEN   |Watchdog Timer Clock Enable Control (Write Protect)
     * |        |          |This bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
     * |        |          |0 = Watchdog Timer Clock Disabled.
     * |        |          |1 = Watchdog Timer Clock Enabled.
     * |[1]     |RTCCKEN   |Real-Time-Clock APB Interface Clock Enable Control
     * |        |          |This bit is used to control the RTC APB clock only, The RTC engine clock source is from the 32.768 kHz external low-speed crystal.
     * |        |          |0 = RTC Clock Disabled.
     * |        |          |1 = RTC Clock Enabled.
     * |[2]     |TMR0CKEN  |Timer0 Clock Enable Control
     * |        |          |0 = Timer0 Clock Disabled.
     * |        |          |1 = Timer0 Clock Enabled.
     * |[3]     |TMR1CKEN  |Timer1 Clock Enable Control
     * |        |          |0 = Timer1 Clock Disabled.
     * |        |          |1 = Timer1 Clock Enabled.
     * |[4]     |TMR2CKEN  |Timer2 Clock Enable Control
     * |        |          |0 = Timer2 Clock Disabled.
     * |        |          |1 = Timer2 Clock Enabled.
     * |[5]     |TMR3CKEN  |Timer3 Clock Enable Control
     * |        |          |0 = Timer3 Clock Disabled.
     * |        |          |1 = Timer3 Clock Enabled.
     * |[6]     |CLKOCKEN  |Clock Output Enable Control
     * |        |          |0 = Clock Output Disabled.
     * |        |          |1 = Clock Output Enabled.
     * |[7]     |ACMPCKEN  |Analog Comparator Clock Enable Control
     * |        |          |0 = Analog Comparator Clock Disabled.
     * |        |          |1 = Analog Comparator Clock Enabled.
     * |[8]     |I2C0CKEN  |I2C0 Clock Enable Control
     * |        |          |0 = I2C0 Clock Disabled.
     * |        |          |1 = I2C0 Clock Enabled.
     * |[9]     |I2C1CKEN  |I2C1 Clock Enable Control
     * |        |          |0 = I2C1 Clock Disabled.
     * |        |          |1 = I2C1 Clock Enabled.
     * |[10]    |I2C2CKEN  |I2C2 Clock Enable Control
     * |        |          |0 = I2C2 Clock Disabled.
     * |        |          |1 = I2C2 Clock Enabled.
     * |[11]    |I2C3CKEN  |I2C3 Clock Enable Control
     * |        |          |0 = I2C3 Clock Disabled.
     * |        |          |1 = I2C3 Clock Enabled.
     * |[12]    |SPI0CKEN  |SPI0 Clock Enable Control
     * |        |          |0 = SPI0 Clock Disabled.
     * |        |          |1= SPI0 Clock Enabled.
     * |[13]    |SPI1CKEN  |SPI1 Clock Enable Control
     * |        |          |0 = SPI1 Clock Disabled.
     * |        |          |1 = SPI1 Clock Enabled.
     * |[14]    |SPI2CKEN  |SPI2 Clock Enable Control
     * |        |          |0 = SPI2 Clock Disabled.
     * |        |          |1 = SPI2 Clock Enabled.
     * |[15]    |SPI3CKEN  |SPI3 Clock Enable Control
     * |        |          |0 = SPI3 Clock Disabled.
     * |        |          |1 = SPI3 Clock Enabled.
     * |[16]    |UART0CKEN |UART0 Clock Enable Control
     * |        |          |0 = UART0 clock Disabled.
     * |        |          |1 = UART0 clock Enabled.
     * |[17]    |UART1CKEN |UART1 Clock Enable Control
     * |        |          |0 = UART1 clock Disabled.
     * |        |          |1 = UART1 clock Enabled.
     * |[18]    |UART2CKEN |UART2 Clock Enable Control
     * |        |          |0 = UART2 clock Disabled.
     * |        |          |1 = UART2 clock Enabled.
     * |[19]    |UART3CKEN |UART3 Clock Enable Control
     * |        |          |0 = UART3 clock Disabled.
     * |        |          |1 = UART3 clock Enabled.
     * |[20]    |UART4CKEN |UART4 Clock Enable Control
     * |        |          |0 = UART4 clock Disabled.
     * |        |          |1 = UART4 clock Enabled.
     * |[21]    |UART5CKEN |UART5 Clock Enable Control
     * |        |          |0 = UART5 clock Disabled.
     * |        |          |1 = UART5 clock Enabled.
     * |[24]    |CAN0CKEN  |CAN Bus Controller-0 Clock Enable Control
     * |        |          |0 = CAN0 clock Disabled.
     * |        |          |1 = CAN0 clock Enabled.
     * |[25]    |CAN1CKEN  |CAN Bus Controller-1 Clock Enable Control
     * |        |          |0 = CAN1 clock Disabled.
     * |        |          |1 = CAN1 clock Enabled.
     * |[26]    |OTGCKEN   |USB 2.0 OTG Device Controller Clock Enable Control
     * |        |          |0 = OTG clock Disabled.
     * |        |          |1 = OTG clock Enabled.
     * |[28]    |ADCCKEN   |Analog-Digital-Converter (ADC) Clock Enable Control
     * |        |          |0 = ADC clock Disabled.
     * |        |          |1 = ADC clock Enabled.
     * |[29]    |I2S0CKEN  |I2S0 Clock Enable Control
     * |        |          |0 = I2S Clock Disabled.
     * |        |          |1 = I2S Clock Enabled.
     * |[30]    |I2S1CKEN  |I2S1 Clock Enable Control
     * |        |          |0 = I2S1 Clock Disabled.
     * |        |          |1 = I2S1 Clock Enabled.
     * |[31]    |PS2CKEN   |PS/2 Clock Enable Control
     * |        |          |0 = PS/2 clock Disabled.
     * |        |          |1 = PS/2 clock Enabled.
    */
    __IO uint32_t APBCLK0;

    /**
     * APBCLK1
     * ===================================================================================================
     * Offset: 0x0C  APB Devices Clock Enable Control Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SC0CKEN   |SC0 Clock Enable Control
     * |        |          |0 = SC0 Clock Disabled.
     * |        |          |1 = SC0 Clock Enabled.
     * |[1]     |SC1CKEN   |SC1 Clock Enable Control
     * |        |          |0 = SC1 Clock Disabled.
     * |        |          |1 = SC1 Clock Enabled.
     * |[2]     |SC2CKEN   |SC2 Clock Enable Control
     * |        |          |0 = SC2 Clock Disabled.
     * |        |          |1 = SC2 Clock Enabled.
     * |[3]     |SC3CKEN   |SC3 Clock Enable Control
     * |        |          |0 = SC3 Clock Disabled.
     * |        |          |1 = SC3 Clock Enabled.
     * |[4]     |SC4CKEN   |SC4 Clock Enable Control
     * |        |          |0 = SC4 Clock Disabled.
     * |        |          |1 = SC4 Clock Enabled.
     * |[5]     |SC5CKEN   |SC5 Clock Enable Control
     * |        |          |0 = SC5 Clock Disabled.
     * |        |          |1 = SC5 Clock Enabled.
     * |[8]     |I2C4CKEN  |I2C4 Clock Enable Control
     * |        |          |0 = I2C4 Clock Disabled.
     * |        |          |1 = I2C4 Clock Enabled.
     * |[16]    |PWM0CH01CKEN|PWM0_01 Clock Enable Control
     * |        |          |0 = PWM0_01 Clock Disabled.
     * |        |          |1 = PWM0_01 Clock Enabled.
     * |[17]    |PWM0CH23CKEN|PWM0_23 Clock Enable Control
     * |        |          |0 = PWM0_23 Clock Disabled.
     * |        |          |1 = PWM0_23 Clock Enabled.
     * |[18]    |PWM0CH45CKEN|PWM0_45 Clock Enable Control
     * |        |          |0 = PWM0_45 Clock Disabled.
     * |        |          |1 = PWM0_45 Clock Enabled.
     * |[19]    |PWM1CH01CKEN|PWM1_01 Clock Enable Control
     * |        |          |0 = PWM1_01 Clock Disabled.
     * |        |          |1 = PWM1_01 Clock Enabled.
     * |[21]    |PWM1CH2345CKEN|PWM1_2345 Clock Enable Control
     * |        |          |0 = PWM1_2345 Clock Disabled.
     * |        |          |1 = PWM1_2345 Clock Enabled.
     * |[22]    |QEI0CKEN  |Quadrature Encoder Interface (QEI0) Clock Enable Control
     * |        |          |0 = QEI0 clock Disabled.
     * |        |          |1 = QEI0 clock Enabled.
     * |[23]    |QEI1CKEN  |Quadrature Encoder Interface (QEI1) Clock Enable Control
     * |        |          |0 = QEI1 clock Disabled.
     * |        |          |1 = QEI1 clock Enabled.
     * |[26]    |ECAP0CKEN |Enhance CAP (ECAP0) Clock Enable Control
     * |        |          |0 = ECAP0 clock Disabled.
     * |        |          |1 = ECAP0 clock Enabled.
     * |[27]    |ECAP1CKEN |Enhance CAP (ECAP1) Clock Enable Control
     * |        |          |0 = ECAP1 clock Disabled.
     * |        |          |1 = ECAP1 clock Enabled.
     * |[28]    |EPWM0CKEN |Enhance PWM0 (EPWM) Clock Enable Control
     * |        |          |0 = EPWM0 clock Disabled.
     * |        |          |1 = EPWM0 clock Enabled.
     * |[29]    |EPWM1CKEN |Enhance PWM1 (EPWM) Clock Enable Control
     * |        |          |0 = EPWM1 clock Disabled.
     * |        |          |1 = EPWM1 clock Enabled.
     * |[30]    |OPACKEN   |OP Amplifier (OPA) Clock Enable Control
     * |        |          |0 = OPA clock Disabled.
     * |        |          |1 = OPA clock Enabled.
     * |[31]    |EADCCKEN  |Enhance Analog-Digital-Converter (E ADC) Clock Enable Control
     * |        |          |0 = EADC clock Disabled.
     * |        |          |1 = EADC clock Enabled.
    */
    __IO uint32_t APBCLK1;

    /**
     * CLKSEL0
     * ===================================================================================================
     * Offset: 0x10  Clock Source Select Control Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |HCLKSEL   |HCLK Clock Source Selection (Write Protect)
     * |        |          |Before clock switching, the related clock sources (both pre-select and new-select) must be turned on
     * |        |          |1.
     * |        |          |The 3-bit default value is reloaded from the value of CFOSC (Config0[26:24]) in user configuration register of Flash controller by any reset.
     * |        |          |Therefore the default value is either 000b or 111b.
     * |        |          |2.
     * |        |          |These bits are protected bit, it means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PLL clock.
     * |        |          |011 = Clock source from LIRC clock.
     * |        |          |100 = Clock source from PLL2 clock.
     * |        |          |111 = Clock source from HIRC clock.
     * |        |          |Other = Reserved.
     * |[3:5]   |STCLKSEL  |Cortex(TM)-M4 SysTick Clock Source Selection (Write Protect)
     * |        |          |If SYST_CSR[2]=0, SysTick uses listed clock source below.
     * |        |          |These bits are protected bit.
     * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from HXT clock/2.
     * |        |          |011 = Clock source from HCLK/2.
     * |        |          |111 = Clock source from HIRC clock/2.
     * |[6]     |PCLKSEL   |PCLK Clock Source Selection (Write Protect)
     * |        |          |These bits are protected bit.
     * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
     * |        |          |0 = Clock source from HCLK.
     * |        |          |1 = Clock source from HCLK/2.
     * |[8]     |USBHSEL   |USB Host Clock Source Selection (Write Protect)
     * |        |          |These bits are protected bit.
     * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
     * |        |          |0 = Clock source from PLL2.
     * |        |          |1 = Clock source from PLL.
     * |[16:17] |CAPSEL    |Image Capture Interface Clock Source Selection
     * |        |          |These bits are protected bit.
     * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = Clock source from HCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[20:21] |SDHSEL    |SDHOST Engine Clock Source Selection
     * |        |          |These bits are protected bit.
     * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = Clock source from HCLK.
     * |        |          |11 = Clock source from HIRC clock.
    */
    __IO uint32_t CLKSEL0;

    /**
     * CLKSEL1
     * ===================================================================================================
     * Offset: 0x14  Clock Source Select Control Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |WDTSEL    |Watchdog Timer Clock Source Selection (Write Protect)
     * |        |          |These bits are protected bit,and programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
     * |        |          |00 = Clock source from 4~24 MHz external high-speed crystal clock.
     * |        |          |01 = Clock source from LXT clock.
     * |        |          |10 = Clock source from HCLK/2048 clock.
     * |        |          |11 = Clock source from LIRC clock.
     * |[2:3]   |EADCSEL   |ADC Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = Clock source from PCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[4]     |SPI0SEL   |SPI0 Clock Source Selection
     * |        |          |0 = Clock source from PLL clock.
     * |        |          |1 = Clock source from PCLK.
     * |[5]     |SPI1SEL   |SPI1 Clock Source Selection
     * |        |          |0 = Clock source from PLL clock.
     * |        |          |1 = Clock source from PCLK.
     * |[6]     |SPI2SEL   |SPI2 Clock Source Selection
     * |        |          |0 = Clock source from PLL clock.
     * |        |          |1 = Clock source from PCLK.
     * |[7]     |SPI3SEL   |SPI3 Clock Source Selection
     * |        |          |0 = Clock source from PLL clock.
     * |        |          |1 = Clock source from PCLK.
     * |[8:10]  |TMR0SEL   |TIMER0 Clock Source Selection
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from external trigger.
     * |        |          |101 = Clock source from LIRC clock.
     * |        |          |111 = Clock source from HIRC clock.
     * |        |          |Others = reserved.
     * |[12:14] |TMR1SEL   |TIMER1 Clock Source Selection
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from external trigger.
     * |        |          |101 = Clock source from LIRC clock.
     * |        |          |111 = Clock source from HIRC clock.
     * |        |          |Others = reserved.
     * |[16:18] |TMR2SEL   |TIMER2 Clock Source Selection
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from external trigger.
     * |        |          |101 = Clock source from LIRC clock.
     * |        |          |111 = Clock source from HIRC clock.
     * |        |          |Others = reserved.
     * |[20:22] |TMR3SEL   |TIMER3 Clock Source Selection
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from external trigger.
     * |        |          |101 = Clock source from LIRC clock.
     * |        |          |111 = Clock source from HIRC clock.
     * |        |          |Others = reserved.
     * |[24:25] |UARTSEL   |UART Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10/11 = Clock source from HIRC clock.
     * |[28:29] |CLKOSEL   |Clock Divider Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from LXT clock.
     * |        |          |10 = Clock source from HCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[30:31] |WWDTSEL   |Window Watchdog Timer Clock Source Selection
     * |        |          |00 = Reserved.
     * |        |          |01 = Reserved.
     * |        |          |10 = Clock source from HCLK/2048 clock.
     * |        |          |11 = Clock source from LIRC clock.
    */
    __IO uint32_t CLKSEL1;

    /**
     * CLKSEL2
     * ===================================================================================================
     * Offset: 0x18  Clock Source Select Control Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |PWM0CH01SEL|PWM0_0 And PWM0_1 Clock Source Selection
     * |        |          |PWM0_0 and PWM0_1 uses the same Engine clock source, both of them use the same prescaler.
     * |        |          |The Engine clock source of PWM0_0 and PWM0_1 is defined by PWM0CH01SEL[2:0].
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from HIRC clock.
     * |        |          |100 = Clock source from LIRC clock.
     * |        |          |Other = Reserved.
     * |[4:6]   |PPWM0CH23SEL|PWM0_2 And PWM0_3 Clock Source Selection
     * |        |          |PWM0_2 and PWM0_3 uses the same Engine clock source, both of them use the same prescaler.
     * |        |          |The Engine clock source of PWM0_2 and PWM0_3 is defined by PPWM0CH23SEL[2:0].
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from HIRC clock.
     * |        |          |100 = Clock source from LIRC clock.
     * |        |          |Other = Reserved.
     * |[8:10]  |PWM0CH45SEL|PWM0_4 And PWM0_5 Clock Source Selection
     * |        |          |PWM0_4 and PWM0_5 used the same Engine clock source; both of them use the same prescaler.
     * |        |          |The Engine clock source of PWM0_4 and PWM0_5 is defined by PWM0CH45SEL[2:0].
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from HIRC clock.
     * |        |          |100 = Clock source from LIRC clock.
     * |        |          |Other = Reserved.
     * |[12:14] |PWM1CH01SEL|PWM1_0 And PWM1_1 Clock Source Selection
     * |        |          |PWM1_0 and PWM1_1 uses the same Engine clock source, both of them use the same prescaler.
     * |        |          |The Engine clock source of PWM1_0 and PWM1_1 is defined by PWM1CH01SEL[2:0].
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from HIRC clock.
     * |        |          |100 = Clock source from LIRC clock.
     * |        |          |Other = Reserved.
     * |[16:18] |PWM1CH23SEL|PWM1_2 And PWM1_3 Clock Source Selection
     * |        |          |PWM1_2 and PWM1_3 uses the same Engine clock source, both of them use the same prescaler.
     * |        |          |The Engine clock source of PWM1_2 and PWM1_3 is defined by PWM1CH23SEL[2:0].
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from HIRC clock.
     * |        |          |100= Clock source from LIRC clock.
     * |        |          |Other = Reserved.
     * |[20:22] |PWM1CH45SEL|PWM1_4 And PWM1_5 Clock Source Selection
     * |        |          |PWM1_4 and PWM1_5 used the same Engine clock source; both of them use the same prescaler.
     * |        |          |The Engine clock source of PWM1_4 and PWM1_5 is defined by PWM1CH45SEL[2:0].
     * |        |          |000 = Clock source from HXT clock.
     * |        |          |001 = Clock source from LXT clock.
     * |        |          |010 = Clock source from PCLK.
     * |        |          |011 = Clock source from HIRC clock.
     * |        |          |100 = Clock source from LIRC clock.
     * |        |          |Other = Reserved.
    */
    __IO uint32_t CLKSEL2;

    /**
     * CLKSEL3
     * ===================================================================================================
     * Offset: 0x1C  Clock Source Select Control Register 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |SC0SEL    |SC0 Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = PCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[2:3]   |SC1SEL    |SC1 Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = PCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[4:5]   |SC2SEL    |SC2 Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = PCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[6:7]   |SC3SEL    |SC3 Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = PCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[8:9]   |SC4SEL    |SC4 Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = PCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[10:11] |SC5SEL    |SC5 Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = PCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[16:17] |I2S0SEL   |I2S0 Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = Clock source from PCLK.
     * |        |          |11 = Clock source from HIRC clock.
     * |[18:19] |I2S1SEL   |I2S1 Clock Source Selection
     * |        |          |00 = Clock source from HXT clock.
     * |        |          |01 = Clock source from PLL clock.
     * |        |          |10 = Clock source from PCLK.
     * |        |          |11 = Clock source from HIRC clock.
    */
    __IO uint32_t CLKSEL3;

    /**
     * CLKDIV0
     * ===================================================================================================
     * Offset: 0x20  Clock Divider Number Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
     * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1).
     * |[4:7]   |USBHDIV   |USB Host Clock Divide Number From PLL Clock
     * |        |          |USB Host clock frequency = (PLL frequency) / (USBHDIV + 1).
     * |[8:11]  |UARTDIV   |UART Clock Divide Number From UART Clock Source
     * |        |          |UART clock frequency = (UART clock source frequency) / (UARTDIV + 1).
     * |[16:23] |ADCDIV    |ADC Clock Divide Number From ADC Clock Source
     * |        |          |ADC clock frequency = (ADC clock source frequency) / (ADCDIV + 1).
     * |[24:31] |SDHDIV    |SDHOST Clock Divide Number From SDHOST Clock Source
     * |        |          |SDHOST clock frequency = (SDHOST clock source frequency) / (SDHDIV + 1).
    */
    __IO uint32_t CLKDIV0;

    /**
     * CLKDIV1
     * ===================================================================================================
     * Offset: 0x24  Clock Divider Number Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |SC0DIV    |SC0 Clock Divide Number From SC0 Clock Source
     * |        |          |SC0 clock frequency = (SC0 clock source frequency ) / (SC0DIV+ 1).
     * |[8:15]  |SC1DIV    |SC1 Clock Divide Number From SC1 Clock Source
     * |        |          |SC1 clock frequency = (SC1 clock source frequency ) / (SC1DIV + 1).
     * |[16:23] |SC2DIV    |SC2 Clock Divide Number From SC2 Clock Source
     * |        |          |SC2 clock frequency = (SC2 clock source frequency ) / (SC2DIV + 1).
     * |[24:31] |SC3DIV    |SC3 Clock Divide Number From SC3 Clock Source
     * |        |          |SC3 clock frequency = (SC3 clock source frequency ) / (SC3DIV+ 1).
    */
    __IO uint32_t CLKDIV1;

    /**
     * CLKDIV2
     * ===================================================================================================
     * Offset: 0x28  Clock Divider Number Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |SC4DIV    |SC4 Clock Divide Number From SC4 Clock Source
     * |        |          |SC4 clock frequency = (SC4 clock source frequency ) / (SC4DIV + 1).
     * |[8:15]  |SC5DIV    |SC5 Clock Divide Number From SC5 Clock Source
     * |        |          |SC5 clock frequency = (SC5 clock source frequency ) / (SC5DIV + 1).
    */
    __IO uint32_t CLKDIV2;

    /**
     * CLKDIV3
     * ===================================================================================================
     * Offset: 0x2C  Clock Divider Number Register 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |CAPDIV    |Image Capture Sensor Clock Divide Number From ICAP Clock Source
     * |        |          |Image sensor clock frequency = (ICAP clock source frequency) / (ICAPDIV + 1).
     * |[8:15]  |VSENSEDIV |Video Pixel Clock Divide Number From ICAP Clock Source
     * |        |          |Video pixel clock frequency = (ICAP clock source frequency) / (VSENSEDIV + 1).
     * |[16:23] |EMACDIV   |Ethernet Clock Divide Number Form HCLK (NUC472 Only)
     * |        |          |EMAC MDCLK clock frequency = (HCLK) / (EMACDIV + 1).
    */
    __IO uint32_t CLKDIV3;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[4];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * PLLCTL
     * ===================================================================================================
     * Offset: 0x40  PLL Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:8]   |FBDIV     |PLL Feedback Divider Control Pins
     * |        |          |Refer to the formulas below the table.
     * |[9:13]  |INDIV     |PLL Input Divider Control Pins
     * |        |          |Refer to the formulas below the table.
     * |[14:15] |OUTDV     |PLL Output Divider Control Pins
     * |        |          |Refer to the formulas below the table.
     * |[16]    |PD        |Power-Down Mode
     * |        |          |If set the PWR_DOWN_EN bit to 1 in CLK_PWRCTL register, the PLL will enter Power-down mode, too.
     * |        |          |0 = PLL is in normal mode.
     * |        |          |1 = PLL is in Power-down mode (default).
     * |[17]    |BP        |PLL Bypass Control
     * |        |          |0 = PLL is in normal mode (default).
     * |        |          |1 = PLL clock output is same as clock input (XTALin).
     * |[18]    |OE        |PLL OE (FOUT Enable) Pin Control
     * |        |          |0 = PLL FOUT Enabled.
     * |        |          |1 = PLL FOUT is fixed low.
     * |[19]    |PLLSRC    |PLL Source Clock Selection
     * |        |          |0 = PLL source clock from HXT.
     * |        |          |1 = PLL source clock from HIRC.
     * |[20]    |PLLREMAP  |PLL Remap Enable Bit
     * |        |          |0 = PLL remap enable.
     * |        |          |1 = PLL remap disable.
    */
    __IO uint32_t PLLCTL;

    /**
     * PLL2CTL
     * ===================================================================================================
     * Offset: 0x44  PLL2 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |PLL2DIV   |PLL2 Divider Control
     * |        |          |PLL2 clock frequency = (480 MHz) / 2 / (PLL2DIV + 1).
     * |        |          |Note: Max. PLL frequency 240 MHz when XTL12M.
     * |[8]     |PLL2CKEN  |USB OHY 480 MHz Enable Control
     * |        |          |This bit enables USB PHY PLL (480 MHz), and user needs to care extend 12 MHz source.
     * |        |          |0 = USB PHY PLL (480 MHz) Disabled.
     * |        |          |1 = USB PHY PLL (480 MHz) Enabled.
    */
    __IO uint32_t PLL2CTL;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[2];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x50  Clock Status Monitor Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |HXTSTB    |4~24 MHz External High-Speed Crystal Clock(HXT) Source Stable Flag
     * |        |          |0 = HXT clock is not stable or disabled.
     * |        |          |1 = HXT clock is stable.
     * |        |          |Note: This bit is read only.
     * |[1]     |LXTSTB    |32.768 KHz External Low-Speed Crystal Clock(LXT) Source Stable Flag
     * |        |          |0 = LXT clock is not stable or disabled.
     * |        |          |1 = LXT clock is stabled.
     * |        |          |Note: This is read only.
     * |[2]     |PLLSTB    |Internal PLL Clock Source Stable Flag
     * |        |          |0 = Internal PLL clock is not stable or disabled.
     * |        |          |1 = Internal PLL clock is stable.
     * |        |          |Note: This bit is read only.
     * |[3]     |LIRCSTB   |10 KHz Internal Low-Speed Oscillator Clock (LIRC)Source Stable Flag
     * |        |          |0 = LIRC clock is not stable or disabled.
     * |        |          |1 = LIRC clock is stable.
     * |        |          |Note: This bit is read only.
     * |[4]     |HIRCSTB   |22.1184 MHz Internal High-Speed Oscillator Clock (HIRC) Clock Source Stable Flag
     * |        |          |0 = HIRC clock is not stable or disabled.
     * |        |          |1 = HIRC clock is stable.
     * |        |          |Note: This bit is read only.
     * |[5]     |PLL2STB   |Internal PLL2 Clock Source Stable Flag
     * |        |          |0 = Internal PLL2 clock is not stable or disabled.
     * |        |          |1 = Internal PLL2 clock is stable.
     * |        |          |Note: This bit is read only.
     * |[7]     |CLKSFAIL  |Clock Switching Fail Flag
     * |        |          |0 = Clock switching success.
     * |        |          |1 = Clock switching failure.
     * |        |          |Note1: This bit is updated when software switches system clock source.
     * |        |          |If switch target clock is stable, this bit will be set to 0.
     * |        |          |If switch target clock is not stable, this bit will be set to 1.
     * |        |          |Note2: Write 1 to clear the bit to 0.
    */
    __IO uint32_t STATUS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * CLKOCTL
     * ===================================================================================================
     * Offset: 0x60  Frequency Divider Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |FSEL      |Divider Output Frequency Selection
     * |        |          |The formula of output frequency is:
     * |        |          |Fout = Fin/2(N+1).
     * |        |          |Fin is the input clock frequency.
     * |        |          |Fout is the frequency of divider output clock.
     * |        |          |N is the 4-bit value of FSEL[3:0].
     * |[4]     |CLKOEN    |Clock Output Enable Control
     * |        |          |0 = Clock Output disabled.
     * |        |          |1 = Clock Output enabled.
     * |[5]     |DIV1EN    |Frequency Divider 1 Enable Control
     * |        |          |0 = Divider output frequency is dependent on FSEL value when FDIVEN is enabled.
     * |        |          |1 = Divider output frequency is input clock frequency.
    */
    __IO uint32_t CLKOCTL;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE3[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * CLKDCTL
     * ===================================================================================================
     * Offset: 0x70  Clock Fail Detector Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SYSFDEN   |System Clock Detector Enable Control
     * |        |          |0 = system clock fail interrupt disabled.
     * |        |          |1 = system clock fail interrupt enabled.
     * |[1]     |SYSFIEN   |System Clock Detector Interrupt Enable Control
     * |        |          |0 = system clock fail interrupt disabled.
     * |        |          |1 = system clock fail interrupt enabled.
     * |[2]     |SYSFIF    |System Clock Detect Fail Flag
     * |        |          |0 = System clock normal.
     * |        |          |1 = System clock abnormal (write " 1" to clear).
     * |[8]     |IRCDEN    |Internal RC Clock Detector Enable Control
     * |        |          |0 = IRC clock fail interrupt disabled.
     * |        |          |1 = IRC clock fail interrupt enabled.
     * |[9]     |IRCFIEN   |Internal RC Clock Detector Interrupt Enable Control
     * |        |          |0 = IRC clock fail interrupt disabled.
     * |        |          |1 = IRC clock fail interrupt enabled.
     * |[10]    |IRCFIF    |Internal RC Clock Fail Flag
     * |        |          |0 = IRC clock normal.
     * |        |          |1 = IRC abnormal (write "1" to clear) .
    */
    __IO uint32_t CLKDCTL;

} CLK_T;

/**
    @addtogroup CLK_CONST CLK Bit Field Definition
    Constant Definitions for CLK Controller
@{ */

#define CLK_PWRCTL_HXTEN_Pos             (0)                                               /*!< CLK_T::PWRCTL: HXTEN Position             */
#define CLK_PWRCTL_HXTEN_Msk             (0x1ul << CLK_PWRCTL_HXTEN_Pos)                   /*!< CLK_T::PWRCTL: HXTEN Mask                 */

#define CLK_PWRCTL_LXTEN_Pos             (1)                                               /*!< CLK_T::PWRCTL: LXTEN Position             */
#define CLK_PWRCTL_LXTEN_Msk             (0x1ul << CLK_PWRCTL_LXTEN_Pos)                   /*!< CLK_T::PWRCTL: LXTEN Mask                 */

#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK_T::PWRCTL: HIRCEN Position            */
#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK_T::PWRCTL: HIRCEN Mask                */

#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK_T::PWRCTL: LIRCEN Position            */
#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK_T::PWRCTL: LIRCEN Mask                */

#define CLK_PWRCTL_PDWKDLY_Pos           (4)                                               /*!< CLK_T::PWRCTL: PDWKDLY Position           */
#define CLK_PWRCTL_PDWKDLY_Msk           (0x1ul << CLK_PWRCTL_PDWKDLY_Pos)                 /*!< CLK_T::PWRCTL: PDWKDLY Mask               */

#define CLK_PWRCTL_PDWKIEN_Pos           (5)                                               /*!< CLK_T::PWRCTL: PDWKIEN Position           */
#define CLK_PWRCTL_PDWKIEN_Msk           (0x1ul << CLK_PWRCTL_PDWKIEN_Pos)                 /*!< CLK_T::PWRCTL: PDWKIEN Mask               */

#define CLK_PWRCTL_PDWKIF_Pos            (6)                                               /*!< CLK_T::PWRCTL: PDWKIF Position            */
#define CLK_PWRCTL_PDWKIF_Msk            (0x1ul << CLK_PWRCTL_PDWKIF_Pos)                  /*!< CLK_T::PWRCTL: PDWKIF Mask                */

#define CLK_PWRCTL_PDEN_Pos              (7)                                               /*!< CLK_T::PWRCTL: PDEN Position              */
#define CLK_PWRCTL_PDEN_Msk              (0x1ul << CLK_PWRCTL_PDEN_Pos)                    /*!< CLK_T::PWRCTL: PDEN Mask                  */

#define CLK_PWRCTL_PDWTCPU_Pos           (8)                                               /*!< CLK_T::PWRCTL: PDWTCPU Position           */
#define CLK_PWRCTL_PDWTCPU_Msk           (0x1ul << CLK_PWRCTL_PDWTCPU_Pos)                 /*!< CLK_T::PWRCTL: PDWTCPU Mask               */

#define CLK_PWRCTL_DBPDEN_Pos            (9)                                               /*!< CLK_T::PWRCTL: DBPDEN Position            */
#define CLK_PWRCTL_DBPDEN_Msk            (0x1ul << CLK_PWRCTL_DBPDEN_Pos)                  /*!< CLK_T::PWRCTL: DBPDEN Mask                */

#define CLK_AHBCLK_PDMACKEN_Pos          (1)                                               /*!< CLK_T::AHBCLK: PDMACKEN Position          */
#define CLK_AHBCLK_PDMACKEN_Msk          (0x1ul << CLK_AHBCLK_PDMACKEN_Pos)                /*!< CLK_T::AHBCLK: PDMACKEN Mask              */

#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK_T::AHBCLK: ISPCKEN Position           */
#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK_T::AHBCLK: ISPCKEN Mask               */

#define CLK_AHBCLK_EBICKEN_Pos           (3)                                               /*!< CLK_T::AHBCLK: EBICKEN Position           */
#define CLK_AHBCLK_EBICKEN_Msk           (0x1ul << CLK_AHBCLK_EBICKEN_Pos)                 /*!< CLK_T::AHBCLK: EBICKEN Mask               */

#define CLK_AHBCLK_USBHCKEN_Pos          (4)                                               /*!< CLK_T::AHBCLK: USBHCKEN Position          */
#define CLK_AHBCLK_USBHCKEN_Msk          (0x1ul << CLK_AHBCLK_USBHCKEN_Pos)                /*!< CLK_T::AHBCLK: USBHCKEN Mask              */

#define CLK_AHBCLK_EMACCKEN_Pos          (5)                                               /*!< CLK_T::AHBCLK: EMACCKEN Position          */
#define CLK_AHBCLK_EMACCKEN_Msk          (0x1ul << CLK_AHBCLK_EMACCKEN_Pos)                /*!< CLK_T::AHBCLK: EMACCKEN Mask              */

#define CLK_AHBCLK_SDHCKEN_Pos           (6)                                               /*!< CLK_T::AHBCLK: SDHCKEN Position           */
#define CLK_AHBCLK_SDHCKEN_Msk           (0x1ul << CLK_AHBCLK_SDHCKEN_Pos)                 /*!< CLK_T::AHBCLK: SDHCKEN Mask               */

#define CLK_AHBCLK_CRCCKEN_Pos           (7)                                               /*!< CLK_T::AHBCLK: CRCCKEN Position           */
#define CLK_AHBCLK_CRCCKEN_Msk           (0x1ul << CLK_AHBCLK_CRCCKEN_Pos)                 /*!< CLK_T::AHBCLK: CRCCKEN Mask               */

#define CLK_AHBCLK_CAPCKEN_Pos           (8)                                               /*!< CLK_T::AHBCLK: CAPCKEN Position          */
#define CLK_AHBCLK_CAPCKEN_Msk           (0x1ul << CLK_AHBCLK_CAPCKEN_Pos)                 /*!< CLK_T::AHBCLK: CAPCKEN Mask              */

#define CLK_AHBCLK_SENCKEN_Pos           (9)                                               /*!< CLK_T::AHBCLK: SENCKEN Position           */
#define CLK_AHBCLK_SENCKEN_Msk           (0x1ul << CLK_AHBCLK_SENCKEN_Pos)                 /*!< CLK_T::AHBCLK: SENCKEN Mask               */

#define CLK_AHBCLK_USBDCKEN_Pos          (10)                                              /*!< CLK_T::AHBCLK: USBDCKEN Position          */
#define CLK_AHBCLK_USBDCKEN_Msk          (0x1ul << CLK_AHBCLK_USBDCKEN_Pos)                /*!< CLK_T::AHBCLK: USBDCKEN Mask              */

#define CLK_AHBCLK_CRPTCKEN_Pos          (12)                                              /*!< CLK_T::AHBCLK: CRPTCKEN Position          */
#define CLK_AHBCLK_CRPTCKEN_Msk          (0x1ul << CLK_AHBCLK_CRPTCKEN_Pos)                /*!< CLK_T::AHBCLK: CRPTCKEN Mask              */

#define CLK_APBCLK0_WDTCKEN_Pos          (0)                                               /*!< CLK_T::APBCLK0: WDTCKEN Position          */
#define CLK_APBCLK0_WDTCKEN_Msk          (0x1ul << CLK_APBCLK0_WDTCKEN_Pos)                /*!< CLK_T::APBCLK0: WDTCKEN Mask              */

#define CLK_APBCLK0_RTCCKEN_Pos          (1)                                               /*!< CLK_T::APBCLK0: RTCCKEN Position          */
#define CLK_APBCLK0_RTCCKEN_Msk          (0x1ul << CLK_APBCLK0_RTCCKEN_Pos)                /*!< CLK_T::APBCLK0: RTCCKEN Mask              */

#define CLK_APBCLK0_TMR0CKEN_Pos         (2)                                               /*!< CLK_T::APBCLK0: TMR0CKEN Position         */
#define CLK_APBCLK0_TMR0CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR0CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR0CKEN Mask             */

#define CLK_APBCLK0_TMR1CKEN_Pos         (3)                                               /*!< CLK_T::APBCLK0: TMR1CKEN Position         */
#define CLK_APBCLK0_TMR1CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR1CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR1CKEN Mask             */

#define CLK_APBCLK0_TMR2CKEN_Pos         (4)                                               /*!< CLK_T::APBCLK0: TMR2CKEN Position         */
#define CLK_APBCLK0_TMR2CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR2CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR2CKEN Mask             */

#define CLK_APBCLK0_TMR3CKEN_Pos         (5)                                               /*!< CLK_T::APBCLK0: TMR3CKEN Position         */
#define CLK_APBCLK0_TMR3CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR3CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR3CKEN Mask             */

#define CLK_APBCLK0_CLKOCKEN_Pos         (6)                                               /*!< CLK_T::APBCLK0: CLKOCKEN Position         */
#define CLK_APBCLK0_CLKOCKEN_Msk         (0x1ul << CLK_APBCLK0_CLKOCKEN_Pos)               /*!< CLK_T::APBCLK0: CLKOCKEN Mask             */

#define CLK_APBCLK0_ACMPCKEN_Pos         (7)                                               /*!< CLK_T::APBCLK0: ACMPCKEN Position         */
#define CLK_APBCLK0_ACMPCKEN_Msk         (0x1ul << CLK_APBCLK0_ACMPCKEN_Pos)               /*!< CLK_T::APBCLK0: ACMPCKEN Mask             */

#define CLK_APBCLK0_I2C0CKEN_Pos         (8)                                               /*!< CLK_T::APBCLK0: I2C0CKEN Position         */
#define CLK_APBCLK0_I2C0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C0CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C0CKEN Mask             */

#define CLK_APBCLK0_I2C1CKEN_Pos         (9)                                               /*!< CLK_T::APBCLK0: I2C1CKEN Position         */
#define CLK_APBCLK0_I2C1CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C1CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C1CKEN Mask             */

#define CLK_APBCLK0_I2C2CKEN_Pos         (10)                                              /*!< CLK_T::APBCLK0: I2C2CKEN Position         */
#define CLK_APBCLK0_I2C2CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C2CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C2CKEN Mask             */

#define CLK_APBCLK0_I2C3CKEN_Pos         (11)                                              /*!< CLK_T::APBCLK0: I2C3CKEN Position         */
#define CLK_APBCLK0_I2C3CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C3CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C3CKEN Mask             */

#define CLK_APBCLK0_SPI0CKEN_Pos         (12)                                              /*!< CLK_T::APBCLK0: SPI0CKEN Position         */
#define CLK_APBCLK0_SPI0CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI0CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI0CKEN Mask             */

#define CLK_APBCLK0_SPI1CKEN_Pos         (13)                                              /*!< CLK_T::APBCLK0: SPI1CKEN Position         */
#define CLK_APBCLK0_SPI1CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI1CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI1CKEN Mask             */

#define CLK_APBCLK0_SPI2CKEN_Pos         (14)                                              /*!< CLK_T::APBCLK0: SPI2CKEN Position         */
#define CLK_APBCLK0_SPI2CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI2CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI2CKEN Mask             */

#define CLK_APBCLK0_SPI3CKEN_Pos         (15)                                              /*!< CLK_T::APBCLK0: SPI3CKEN Position         */
#define CLK_APBCLK0_SPI3CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI3CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI3CKEN Mask             */

#define CLK_APBCLK0_UART0CKEN_Pos        (16)                                              /*!< CLK_T::APBCLK0: UART0CKEN Position        */
#define CLK_APBCLK0_UART0CKEN_Msk        (0x1ul << CLK_APBCLK0_UART0CKEN_Pos)              /*!< CLK_T::APBCLK0: UART0CKEN Mask            */

#define CLK_APBCLK0_UART1CKEN_Pos        (17)                                              /*!< CLK_T::APBCLK0: UART1CKEN Position        */
#define CLK_APBCLK0_UART1CKEN_Msk        (0x1ul << CLK_APBCLK0_UART1CKEN_Pos)              /*!< CLK_T::APBCLK0: UART1CKEN Mask            */

#define CLK_APBCLK0_UART2CKEN_Pos        (18)                                              /*!< CLK_T::APBCLK0: UART2CKEN Position        */
#define CLK_APBCLK0_UART2CKEN_Msk        (0x1ul << CLK_APBCLK0_UART2CKEN_Pos)              /*!< CLK_T::APBCLK0: UART2CKEN Mask            */

#define CLK_APBCLK0_UART3CKEN_Pos        (19)                                              /*!< CLK_T::APBCLK0: UART3CKEN Position        */
#define CLK_APBCLK0_UART3CKEN_Msk        (0x1ul << CLK_APBCLK0_UART3CKEN_Pos)              /*!< CLK_T::APBCLK0: UART3CKEN Mask            */

#define CLK_APBCLK0_UART4CKEN_Pos        (20)                                              /*!< CLK_T::APBCLK0: UART4CKEN Position        */
#define CLK_APBCLK0_UART4CKEN_Msk        (0x1ul << CLK_APBCLK0_UART4CKEN_Pos)              /*!< CLK_T::APBCLK0: UART4CKEN Mask            */

#define CLK_APBCLK0_UART5CKEN_Pos        (21)                                              /*!< CLK_T::APBCLK0: UART5CKEN Position        */
#define CLK_APBCLK0_UART5CKEN_Msk        (0x1ul << CLK_APBCLK0_UART5CKEN_Pos)              /*!< CLK_T::APBCLK0: UART5CKEN Mask            */

#define CLK_APBCLK0_CAN0CKEN_Pos         (24)                                              /*!< CLK_T::APBCLK0: CAN0CKEN Position         */
#define CLK_APBCLK0_CAN0CKEN_Msk         (0x1ul << CLK_APBCLK0_CAN0CKEN_Pos)               /*!< CLK_T::APBCLK0: CAN0CKEN Mask             */

#define CLK_APBCLK0_CAN1CKEN_Pos         (25)                                              /*!< CLK_T::APBCLK0: CAN1CKEN Position         */
#define CLK_APBCLK0_CAN1CKEN_Msk         (0x1ul << CLK_APBCLK0_CAN1CKEN_Pos)               /*!< CLK_T::APBCLK0: CAN1CKEN Mask             */

#define CLK_APBCLK0_OTGCKEN_Pos          (26)                                              /*!< CLK_T::APBCLK0: OTGCKEN Position          */
#define CLK_APBCLK0_OTGCKEN_Msk          (0x1ul << CLK_APBCLK0_OTGCKEN_Pos)                /*!< CLK_T::APBCLK0: OTGCKEN Mask              */

#define CLK_APBCLK0_ADCCKEN_Pos          (28)                                              /*!< CLK_T::APBCLK0: ADCCKEN Position          */
#define CLK_APBCLK0_ADCCKEN_Msk          (0x1ul << CLK_APBCLK0_ADCCKEN_Pos)                /*!< CLK_T::APBCLK0: ADCCKEN Mask              */

#define CLK_APBCLK0_I2S0CKEN_Pos         (29)                                              /*!< CLK_T::APBCLK0: I2S0CKEN Position         */
#define CLK_APBCLK0_I2S0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2S0CKEN_Pos)               /*!< CLK_T::APBCLK0: I2S0CKEN Mask             */

#define CLK_APBCLK0_I2S1CKEN_Pos         (30)                                              /*!< CLK_T::APBCLK0: I2S1CKEN Position         */
#define CLK_APBCLK0_I2S1CKEN_Msk         (0x1ul << CLK_APBCLK0_I2S1CKEN_Pos)               /*!< CLK_T::APBCLK0: I2S1CKEN Mask             */

#define CLK_APBCLK0_PS2CKEN_Pos          (31)                                              /*!< CLK_T::APBCLK0: PS2CKEN Position          */
#define CLK_APBCLK0_PS2CKEN_Msk          (0x1ul << CLK_APBCLK0_PS2CKEN_Pos)                /*!< CLK_T::APBCLK0: PS2CKEN Mask              */

#define CLK_APBCLK1_SC0CKEN_Pos          (0)                                               /*!< CLK_T::APBCLK1: SC0CKEN Position          */
#define CLK_APBCLK1_SC0CKEN_Msk          (0x1ul << CLK_APBCLK1_SC0CKEN_Pos)                /*!< CLK_T::APBCLK1: SC0CKEN Mask              */

#define CLK_APBCLK1_SC1CKEN_Pos          (1)                                               /*!< CLK_T::APBCLK1: SC1CKEN Position          */
#define CLK_APBCLK1_SC1CKEN_Msk          (0x1ul << CLK_APBCLK1_SC1CKEN_Pos)                /*!< CLK_T::APBCLK1: SC1CKEN Mask              */

#define CLK_APBCLK1_SC2CKEN_Pos          (2)                                               /*!< CLK_T::APBCLK1: SC2CKEN Position          */
#define CLK_APBCLK1_SC2CKEN_Msk          (0x1ul << CLK_APBCLK1_SC2CKEN_Pos)                /*!< CLK_T::APBCLK1: SC2CKEN Mask              */

#define CLK_APBCLK1_SC3CKEN_Pos          (3)                                               /*!< CLK_T::APBCLK1: SC3CKEN Position          */
#define CLK_APBCLK1_SC3CKEN_Msk          (0x1ul << CLK_APBCLK1_SC3CKEN_Pos)                /*!< CLK_T::APBCLK1: SC3CKEN Mask              */

#define CLK_APBCLK1_SC4CKEN_Pos          (4)                                               /*!< CLK_T::APBCLK1: SC4CKEN Position          */
#define CLK_APBCLK1_SC4CKEN_Msk          (0x1ul << CLK_APBCLK1_SC4CKEN_Pos)                /*!< CLK_T::APBCLK1: SC4CKEN Mask              */

#define CLK_APBCLK1_SC5CKEN_Pos          (5)                                               /*!< CLK_T::APBCLK1: SC5CKEN Position          */
#define CLK_APBCLK1_SC5CKEN_Msk          (0x1ul << CLK_APBCLK1_SC5CKEN_Pos)                /*!< CLK_T::APBCLK1: SC5CKEN Mask              */

#define CLK_APBCLK1_I2C4CKEN_Pos         (8)                                               /*!< CLK_T::APBCLK1: I2C4CKEN Position         */
#define CLK_APBCLK1_I2C4CKEN_Msk         (0x1ul << CLK_APBCLK1_I2C4CKEN_Pos)               /*!< CLK_T::APBCLK1: I2C4CKEN Mask             */

#define CLK_APBCLK1_PWM0CH01CKEN_Pos     (16)                                              /*!< CLK_T::APBCLK1: PWM0CH01CKEN Position     */
#define CLK_APBCLK1_PWM0CH01CKEN_Msk     (0x1ul << CLK_APBCLK1_PWM0CH01CKEN_Pos)           /*!< CLK_T::APBCLK1: PWM0CH01CKEN Mask         */

#define CLK_APBCLK1_PWM0CH23CKEN_Pos     (17)                                              /*!< CLK_T::APBCLK1: PWM0CH23CKEN Position     */
#define CLK_APBCLK1_PWM0CH23CKEN_Msk     (0x1ul << CLK_APBCLK1_PWM0CH23CKEN_Pos)           /*!< CLK_T::APBCLK1: PWM0CH23CKEN Mask         */

#define CLK_APBCLK1_PWM0CH45CKEN_Pos     (18)                                              /*!< CLK_T::APBCLK1: PWM0CH45CKEN Position     */
#define CLK_APBCLK1_PWM0CH45CKEN_Msk     (0x1ul << CLK_APBCLK1_PWM0CH45CKEN_Pos)           /*!< CLK_T::APBCLK1: PWM0CH45CKEN Mask         */

#define CLK_APBCLK1_PWM1CH01CKEN_Pos     (19)                                              /*!< CLK_T::APBCLK1: PWM1CH01CKEN Position     */
#define CLK_APBCLK1_PWM1CH01CKEN_Msk     (0x1ul << CLK_APBCLK1_PWM1CH01CKEN_Pos)           /*!< CLK_T::APBCLK1: PWM1CH01CKEN Mask         */

#define CLK_APBCLK1_PWM1CH2345CKEN_Pos   (21)                                              /*!< CLK_T::APBCLK1: PWM1CH2345CKEN Position   */
#define CLK_APBCLK1_PWM1CH2345CKEN_Msk   (0x1ul << CLK_APBCLK1_PWM1CH2345CKEN_Pos)         /*!< CLK_T::APBCLK1: PWM1CH2345CKEN Mask       */

#define CLK_APBCLK1_QEI0CKEN_Pos         (22)                                              /*!< CLK_T::APBCLK1: QEI0CKEN Position         */
#define CLK_APBCLK1_QEI0CKEN_Msk         (0x1ul << CLK_APBCLK1_QEI0CKEN_Pos)               /*!< CLK_T::APBCLK1: QEI0CKEN Mask             */

#define CLK_APBCLK1_QEI1CKEN_Pos         (23)                                              /*!< CLK_T::APBCLK1: QEI1CKEN Position         */
#define CLK_APBCLK1_QEI1CKEN_Msk         (0x1ul << CLK_APBCLK1_QEI1CKEN_Pos)               /*!< CLK_T::APBCLK1: QEI1CKEN Mask             */

#define CLK_APBCLK1_ECAP0CKEN_Pos        (26)                                              /*!< CLK_T::APBCLK1: ECAP0CKEN Position        */
#define CLK_APBCLK1_ECAP0CKEN_Msk        (0x1ul << CLK_APBCLK1_ECAP0CKEN_Pos)              /*!< CLK_T::APBCLK1: ECAP0CKEN Mask            */

#define CLK_APBCLK1_ECAP1CKEN_Pos        (27)                                              /*!< CLK_T::APBCLK1: ECAP1CKEN Position        */
#define CLK_APBCLK1_ECAP1CKEN_Msk        (0x1ul << CLK_APBCLK1_ECAP1CKEN_Pos)              /*!< CLK_T::APBCLK1: ECAP1CKEN Mask            */

#define CLK_APBCLK1_EPWM0CKEN_Pos        (28)                                              /*!< CLK_T::APBCLK1: EPWM0CKEN Position        */
#define CLK_APBCLK1_EPWM0CKEN_Msk        (0x1ul << CLK_APBCLK1_EPWM0CKEN_Pos)              /*!< CLK_T::APBCLK1: EPWM0CKEN Mask            */

#define CLK_APBCLK1_EPWM1CKEN_Pos        (29)                                              /*!< CLK_T::APBCLK1: EPWM1CKEN Position        */
#define CLK_APBCLK1_EPWM1CKEN_Msk        (0x1ul << CLK_APBCLK1_EPWM1CKEN_Pos)              /*!< CLK_T::APBCLK1: EPWM1CKEN Mask            */

#define CLK_APBCLK1_OPACKEN_Pos          (30)                                              /*!< CLK_T::APBCLK1: OPACKEN Position          */
#define CLK_APBCLK1_OPACKEN_Msk          (0x1ul << CLK_APBCLK1_OPACKEN_Pos)                /*!< CLK_T::APBCLK1: OPACKEN Mask              */

#define CLK_APBCLK1_EADCCKEN_Pos         (31)                                              /*!< CLK_T::APBCLK1: EADCCKEN Position         */
#define CLK_APBCLK1_EADCCKEN_Msk         (0x1ul << CLK_APBCLK1_EADCCKEN_Pos)               /*!< CLK_T::APBCLK1: EADCCKEN Mask             */

#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK_T::CLKSEL0: HCLKSEL Position          */
#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK_T::CLKSEL0: HCLKSEL Mask              */

#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK_T::CLKSEL0: STCLKSEL Position         */
#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK_T::CLKSEL0: STCLKSEL Mask             */

#define CLK_CLKSEL0_PCLKSEL_Pos          (6)                                               /*!< CLK_T::CLKSEL0: PCLKSEL Position          */
#define CLK_CLKSEL0_PCLKSEL_Msk          (0x1ul << CLK_CLKSEL0_PCLKSEL_Pos)                /*!< CLK_T::CLKSEL0: PCLKSEL Mask              */

#define CLK_CLKSEL0_USBHSEL_Pos          (8)                                               /*!< CLK_T::CLKSEL0: USBHSEL Position          */
#define CLK_CLKSEL0_USBHSEL_Msk          (0x1ul << CLK_CLKSEL0_USBHSEL_Pos)                /*!< CLK_T::CLKSEL0: USBHSEL Mask              */

#define CLK_CLKSEL0_CAPSEL_Pos          (16)                                               /*!< CLK_T::CLKSEL0: CAPSEL Position          */
#define CLK_CLKSEL0_CAPSEL_Msk          (0x3ul << CLK_CLKSEL0_CAPSEL_Pos)                  /*!< CLK_T::CLKSEL0: CAPSEL Mask              */

#define CLK_CLKSEL0_SDHSEL_Pos           (20)                                              /*!< CLK_T::CLKSEL0: SDHSEL Position           */
#define CLK_CLKSEL0_SDHSEL_Msk           (0x3ul << CLK_CLKSEL0_SDHSEL_Pos)                 /*!< CLK_T::CLKSEL0: SDHSEL Mask               */

#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK_T::CLKSEL1: WDTSEL Position           */
#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK_T::CLKSEL1: WDTSEL Mask               */

#define CLK_CLKSEL1_ADCSEL_Pos           (2)                                               /*!< CLK_T::CLKSEL1: ADCSEL Position          */
#define CLK_CLKSEL1_ADCSEL_Msk           (0x3ul << CLK_CLKSEL1_ADCSEL_Pos)                 /*!< CLK_T::CLKSEL1: ADCSEL Mask              */

#define CLK_CLKSEL1_SPI0SEL_Pos          (4)                                               /*!< CLK_T::CLKSEL1: SPI0SEL Position          */
#define CLK_CLKSEL1_SPI0SEL_Msk          (0x1ul << CLK_CLKSEL1_SPI0SEL_Pos)                /*!< CLK_T::CLKSEL1: SPI0SEL Mask              */

#define CLK_CLKSEL1_SPI1SEL_Pos          (5)                                               /*!< CLK_T::CLKSEL1: SPI1SEL Position          */
#define CLK_CLKSEL1_SPI1SEL_Msk          (0x1ul << CLK_CLKSEL1_SPI1SEL_Pos)                /*!< CLK_T::CLKSEL1: SPI1SEL Mask              */

#define CLK_CLKSEL1_SPI2SEL_Pos          (6)                                               /*!< CLK_T::CLKSEL1: SPI2SEL Position          */
#define CLK_CLKSEL1_SPI2SEL_Msk          (0x1ul << CLK_CLKSEL1_SPI2SEL_Pos)                /*!< CLK_T::CLKSEL1: SPI2SEL Mask              */

#define CLK_CLKSEL1_SPI3SEL_Pos          (7)                                               /*!< CLK_T::CLKSEL1: SPI3SEL Position          */
#define CLK_CLKSEL1_SPI3SEL_Msk          (0x1ul << CLK_CLKSEL1_SPI3SEL_Pos)                /*!< CLK_T::CLKSEL1: SPI3SEL Mask              */

#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK_T::CLKSEL1: TMR0SEL Position          */
#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR0SEL Mask              */

#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK_T::CLKSEL1: TMR1SEL Position          */
#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR1SEL Mask              */

#define CLK_CLKSEL1_TMR2SEL_Pos          (16)                                              /*!< CLK_T::CLKSEL1: TMR2SEL Position          */
#define CLK_CLKSEL1_TMR2SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR2SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR2SEL Mask              */

#define CLK_CLKSEL1_TMR3SEL_Pos          (20)                                              /*!< CLK_T::CLKSEL1: TMR3SEL Position          */
#define CLK_CLKSEL1_TMR3SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR3SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR3SEL Mask              */

#define CLK_CLKSEL1_UARTSEL_Pos          (24)                                              /*!< CLK_T::CLKSEL1: UARTSEL Position          */
#define CLK_CLKSEL1_UARTSEL_Msk          (0x3ul << CLK_CLKSEL1_UARTSEL_Pos)                /*!< CLK_T::CLKSEL1: UARTSEL Mask              */

#define CLK_CLKSEL1_CLKOSEL_Pos          (28)                                              /*!< CLK_T::CLKSEL1: CLKOSEL Position          */
#define CLK_CLKSEL1_CLKOSEL_Msk          (0x3ul << CLK_CLKSEL1_CLKOSEL_Pos)                /*!< CLK_T::CLKSEL1: CLKOSEL Mask              */

#define CLK_CLKSEL1_WWDTSEL_Pos          (30)                                              /*!< CLK_T::CLKSEL1: WWDTSEL Position          */
#define CLK_CLKSEL1_WWDTSEL_Msk          (0x3ul << CLK_CLKSEL1_WWDTSEL_Pos)                /*!< CLK_T::CLKSEL1: WWDTSEL Mask              */

#define CLK_CLKSEL2_PWM0CH01SEL_Pos      (0)                                               /*!< CLK_T::CLKSEL2: PWM0CH01SEL Position      */
#define CLK_CLKSEL2_PWM0CH01SEL_Msk      (0x7ul << CLK_CLKSEL2_PWM0CH01SEL_Pos)            /*!< CLK_T::CLKSEL2: PWM0CH01SEL Mask          */

#define CLK_CLKSEL2_PWM0CH23SEL_Pos      (4)                                               /*!< CLK_T::CLKSEL2: PWM0CH23SEL Position     */
#define CLK_CLKSEL2_PWM0CH23SEL_Msk      (0x7ul << CLK_CLKSEL2_PWM0CH23SEL_Pos)            /*!< CLK_T::CLKSEL2: PWM0CH23SEL Mask         */

#define CLK_CLKSEL2_PWM0CH45SEL_Pos      (8)                                               /*!< CLK_T::CLKSEL2: PWM0CH45SEL Position      */
#define CLK_CLKSEL2_PWM0CH45SEL_Msk      (0x7ul << CLK_CLKSEL2_PWM0CH45SEL_Pos)            /*!< CLK_T::CLKSEL2: PWM0CH45SEL Mask          */

#define CLK_CLKSEL2_PWM1CH01SEL_Pos      (12)                                              /*!< CLK_T::CLKSEL2: PWM1CH01SEL Position      */
#define CLK_CLKSEL2_PWM1CH01SEL_Msk      (0x7ul << CLK_CLKSEL2_PWM1CH01SEL_Pos)            /*!< CLK_T::CLKSEL2: PWM1CH01SEL Mask          */

#define CLK_CLKSEL2_PWM1CH23SEL_Pos      (16)                                              /*!< CLK_T::CLKSEL2: PWM1CH23SEL Position      */
#define CLK_CLKSEL2_PWM1CH23SEL_Msk      (0x7ul << CLK_CLKSEL2_PWM1CH23SEL_Pos)            /*!< CLK_T::CLKSEL2: PWM1CH23SEL Mask          */

#define CLK_CLKSEL2_PWM1CH45SEL_Pos      (20)                                              /*!< CLK_T::CLKSEL2: PWM1CH45SEL Position      */
#define CLK_CLKSEL2_PWM1CH45SEL_Msk      (0x7ul << CLK_CLKSEL2_PWM1CH45SEL_Pos)            /*!< CLK_T::CLKSEL2: PWM1CH45SEL Mask          */

#define CLK_CLKSEL3_SC0SEL_Pos           (0)                                               /*!< CLK_T::CLKSEL3: SC0SEL Position           */
#define CLK_CLKSEL3_SC0SEL_Msk           (0x3ul << CLK_CLKSEL3_SC0SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC0SEL Mask               */

#define CLK_CLKSEL3_SC1SEL_Pos           (2)                                               /*!< CLK_T::CLKSEL3: SC1SEL Position           */
#define CLK_CLKSEL3_SC1SEL_Msk           (0x3ul << CLK_CLKSEL3_SC1SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC1SEL Mask               */

#define CLK_CLKSEL3_SC2SEL_Pos           (4)                                               /*!< CLK_T::CLKSEL3: SC2SEL Position           */
#define CLK_CLKSEL3_SC2SEL_Msk           (0x3ul << CLK_CLKSEL3_SC2SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC2SEL Mask               */

#define CLK_CLKSEL3_SC3SEL_Pos           (6)                                               /*!< CLK_T::CLKSEL3: SC3SEL Position           */
#define CLK_CLKSEL3_SC3SEL_Msk           (0x3ul << CLK_CLKSEL3_SC3SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC3SEL Mask               */

#define CLK_CLKSEL3_SC4SEL_Pos           (8)                                               /*!< CLK_T::CLKSEL3: SC4SEL Position           */
#define CLK_CLKSEL3_SC4SEL_Msk           (0x3ul << CLK_CLKSEL3_SC4SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC4SEL Mask               */

#define CLK_CLKSEL3_SC5SEL_Pos           (10)                                              /*!< CLK_T::CLKSEL3: SC5SEL Position           */
#define CLK_CLKSEL3_SC5SEL_Msk           (0x3ul << CLK_CLKSEL3_SC5SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC5SEL Mask               */

#define CLK_CLKSEL3_I2S0SEL_Pos          (16)                                              /*!< CLK_T::CLKSEL3: I2S0SEL Position          */
#define CLK_CLKSEL3_I2S0SEL_Msk          (0x3ul << CLK_CLKSEL3_I2S0SEL_Pos)                /*!< CLK_T::CLKSEL3: I2S0SEL Mask              */

#define CLK_CLKSEL3_I2S1SEL_Pos          (18)                                              /*!< CLK_T::CLKSEL3: I2S1SEL Position          */
#define CLK_CLKSEL3_I2S1SEL_Msk          (0x3ul << CLK_CLKSEL3_I2S1SEL_Pos)                /*!< CLK_T::CLKSEL3: I2S1SEL Mask              */

#define CLK_CLKDIV0_HCLKDIV_Pos          (0)                                               /*!< CLK_T::CLKDIV0: HCLKDIV Position          */
#define CLK_CLKDIV0_HCLKDIV_Msk          (0xful << CLK_CLKDIV0_HCLKDIV_Pos)                /*!< CLK_T::CLKDIV0: HCLKDIV Mask              */

#define CLK_CLKDIV0_USBHDIV_Pos          (4)                                               /*!< CLK_T::CLKDIV0: USBHDIV Position          */
#define CLK_CLKDIV0_USBHDIV_Msk          (0xful << CLK_CLKDIV0_USBHDIV_Pos)                /*!< CLK_T::CLKDIV0: USBHDIV Mask              */

#define CLK_CLKDIV0_UARTDIV_Pos          (8)                                               /*!< CLK_T::CLKDIV0: UARTDIV Position          */
#define CLK_CLKDIV0_UARTDIV_Msk          (0xful << CLK_CLKDIV0_UARTDIV_Pos)                /*!< CLK_T::CLKDIV0: UARTDIV Mask              */

#define CLK_CLKDIV0_ADCDIV_Pos           (16)                                              /*!< CLK_T::CLKDIV0: ADCDIV Position           */
#define CLK_CLKDIV0_ADCDIV_Msk           (0xfful << CLK_CLKDIV0_ADCDIV_Pos)                /*!< CLK_T::CLKDIV0: ADCDIV Mask               */

#define CLK_CLKDIV0_SDHDIV_Pos           (24)                                              /*!< CLK_T::CLKDIV0: SDHDIV Position           */
#define CLK_CLKDIV0_SDHDIV_Msk           (0xfful << CLK_CLKDIV0_SDHDIV_Pos)                /*!< CLK_T::CLKDIV0: SDHDIV Mask               */

#define CLK_CLKDIV1_SC0DIV_Pos           (0)                                               /*!< CLK_T::CLKDIV1: SC0DIV Position           */
#define CLK_CLKDIV1_SC0DIV_Msk           (0xfful << CLK_CLKDIV1_SC0DIV_Pos)                /*!< CLK_T::CLKDIV1: SC0DIV Mask               */

#define CLK_CLKDIV1_SC1DIV_Pos           (8)                                               /*!< CLK_T::CLKDIV1: SC1DIV Position           */
#define CLK_CLKDIV1_SC1DIV_Msk           (0xfful << CLK_CLKDIV1_SC1DIV_Pos)                /*!< CLK_T::CLKDIV1: SC1DIV Mask               */

#define CLK_CLKDIV1_SC2DIV_Pos           (16)                                              /*!< CLK_T::CLKDIV1: SC2DIV Position           */
#define CLK_CLKDIV1_SC2DIV_Msk           (0xfful << CLK_CLKDIV1_SC2DIV_Pos)                /*!< CLK_T::CLKDIV1: SC2DIV Mask               */

#define CLK_CLKDIV1_SC3DIV_Pos           (24)                                              /*!< CLK_T::CLKDIV1: SC3DIV Position           */
#define CLK_CLKDIV1_SC3DIV_Msk           (0xfful << CLK_CLKDIV1_SC3DIV_Pos)                /*!< CLK_T::CLKDIV1: SC3DIV Mask               */

#define CLK_CLKDIV2_SC4DIV_Pos           (0)                                               /*!< CLK_T::CLKDIV2: SC4DIV Position           */
#define CLK_CLKDIV2_SC4DIV_Msk           (0xfful << CLK_CLKDIV2_SC4DIV_Pos)                /*!< CLK_T::CLKDIV2: SC4DIV Mask               */

#define CLK_CLKDIV2_SC5DIV_Pos           (8)                                               /*!< CLK_T::CLKDIV2: SC5DIV Position           */
#define CLK_CLKDIV2_SC5DIV_Msk           (0xfful << CLK_CLKDIV2_SC5DIV_Pos)                /*!< CLK_T::CLKDIV2: SC5DIV Mask               */

#define CLK_CLKDIV3_CAPDIV_Pos           (0)                                               /*!< CLK_T::CLKDIV3: CAPDIV Position          */
#define CLK_CLKDIV3_CAPDIV_Msk           (0xfful << CLK_CLKDIV3_CAPDIV_Pos)                /*!< CLK_T::CLKDIV3: CAPDIV Mask              */

#define CLK_CLKDIV3_VSENSEDIV_Pos        (8)                                               /*!< CLK_T::CLKDIV3: VSENSEDIV Position        */
#define CLK_CLKDIV3_VSENSEDIV_Msk        (0xfful << CLK_CLKDIV3_VSENSEDIV_Pos)             /*!< CLK_T::CLKDIV3: VSENSEDIV Mask            */

#define CLK_CLKDIV3_EMACDIV_Pos          (16)                                              /*!< CLK_T::CLKDIV3: EMACDIV Position          */
#define CLK_CLKDIV3_EMACDIV_Msk          (0xfful << CLK_CLKDIV3_EMACDIV_Pos)               /*!< CLK_T::CLKDIV3: EMACDIV Mask              */

#define CLK_PLLCTL_FBDIV_Pos             (0)                                               /*!< CLK_T::PLLCTL: FBDIV Position             */
#define CLK_PLLCTL_FBDIV_Msk             (0x1fful << CLK_PLLCTL_FBDIV_Pos)                 /*!< CLK_T::PLLCTL: FBDIV Mask                 */

#define CLK_PLLCTL_INDIV_Pos             (9)                                               /*!< CLK_T::PLLCTL: INDIV Position             */
#define CLK_PLLCTL_INDIV_Msk             (0x1ful << CLK_PLLCTL_INDIV_Pos)                  /*!< CLK_T::PLLCTL: INDIV Mask                 */

#define CLK_PLLCTL_OUTDV_Pos             (14)                                              /*!< CLK_T::PLLCTL: OUTDV Position             */
#define CLK_PLLCTL_OUTDV_Msk             (0x3ul << CLK_PLLCTL_OUTDV_Pos)                   /*!< CLK_T::PLLCTL: OUTDV Mask                 */

#define CLK_PLLCTL_PD_Pos                (16)                                              /*!< CLK_T::PLLCTL: PD Position                */
#define CLK_PLLCTL_PD_Msk                (0x1ul << CLK_PLLCTL_PD_Pos)                      /*!< CLK_T::PLLCTL: PD Mask                    */

#define CLK_PLLCTL_BP_Pos                (17)                                              /*!< CLK_T::PLLCTL: BP Position                */
#define CLK_PLLCTL_BP_Msk                (0x1ul << CLK_PLLCTL_BP_Pos)                      /*!< CLK_T::PLLCTL: BP Mask                    */

#define CLK_PLLCTL_OE_Pos                (18)                                              /*!< CLK_T::PLLCTL: OE Position                */
#define CLK_PLLCTL_OE_Msk                (0x1ul << CLK_PLLCTL_OE_Pos)                      /*!< CLK_T::PLLCTL: OE Mask                    */

#define CLK_PLLCTL_PLLSRC_Pos            (19)                                              /*!< CLK_T::PLLCTL: PLLSRC Position            */
#define CLK_PLLCTL_PLLSRC_Msk            (0x1ul << CLK_PLLCTL_PLLSRC_Pos)                  /*!< CLK_T::PLLCTL: PLLSRC Mask                */

#define CLK_PLLCTL_PLLREMAP_Pos          (20)                                              /*!< CLK_T::PLLCTL: PLLREMAP Position          */
#define CLK_PLLCTL_PLLREMAP_Msk          (0x1ul << CLK_PLLCTL_PLLREMAP_Pos)                /*!< CLK_T::PLLCTL: PLLREMAP Mask              */

#define CLK_PLL2CTL_PLL2DIV_Pos          (0)                                               /*!< CLK_T::PLL2CTL: PLL2DIV Position          */
#define CLK_PLL2CTL_PLL2DIV_Msk          (0xfful << CLK_PLL2CTL_PLL2DIV_Pos)               /*!< CLK_T::PLL2CTL: PLL2DIV Mask              */

#define CLK_PLL2CTL_PLL2CKEN_Pos         (8)                                               /*!< CLK_T::PLL2CTL: PLL2CKEN Position         */
#define CLK_PLL2CTL_PLL2CKEN_Msk         (0x1ul << CLK_PLL2CTL_PLL2CKEN_Pos)               /*!< CLK_T::PLL2CTL: PLL2CKEN Mask             */

#define CLK_STATUS_HXTSTB_Pos            (0)                                               /*!< CLK_T::STATUS: HXTSTB Position            */
#define CLK_STATUS_HXTSTB_Msk            (0x1ul << CLK_STATUS_HXTSTB_Pos)                  /*!< CLK_T::STATUS: HXTSTB Mask                */

#define CLK_STATUS_LXTSTB_Pos            (1)                                               /*!< CLK_T::STATUS: LXTSTB Position            */
#define CLK_STATUS_LXTSTB_Msk            (0x1ul << CLK_STATUS_LXTSTB_Pos)                  /*!< CLK_T::STATUS: LXTSTB Mask                */

#define CLK_STATUS_PLLSTB_Pos            (2)                                               /*!< CLK_T::STATUS: PLLSTB Position            */
#define CLK_STATUS_PLLSTB_Msk            (0x1ul << CLK_STATUS_PLLSTB_Pos)                  /*!< CLK_T::STATUS: PLLSTB Mask                */

#define CLK_STATUS_LIRCSTB_Pos           (3)                                               /*!< CLK_T::STATUS: LIRCSTB Position           */
#define CLK_STATUS_LIRCSTB_Msk           (0x1ul << CLK_STATUS_LIRCSTB_Pos)                 /*!< CLK_T::STATUS: LIRCSTB Mask               */

#define CLK_STATUS_HIRCSTB_Pos           (4)                                               /*!< CLK_T::STATUS: HIRCSTB Position           */
#define CLK_STATUS_HIRCSTB_Msk           (0x1ul << CLK_STATUS_HIRCSTB_Pos)                 /*!< CLK_T::STATUS: HIRCSTB Mask               */

#define CLK_STATUS_PLL2STB_Pos           (5)                                               /*!< CLK_T::STATUS: PLL2STB Position           */
#define CLK_STATUS_PLL2STB_Msk           (0x1ul << CLK_STATUS_PLL2STB_Pos)                 /*!< CLK_T::STATUS: PLL2STB Mask               */

#define CLK_STATUS_CLKSFAIL_Pos          (7)                                               /*!< CLK_T::STATUS: CLKSFAIL Position          */
#define CLK_STATUS_CLKSFAIL_Msk          (0x1ul << CLK_STATUS_CLKSFAIL_Pos)                /*!< CLK_T::STATUS: CLKSFAIL Mask              */

#define CLK_CLKOCTL_FSEL_Pos             (0)                                               /*!< CLK_T::CLKOCTL: FSEL Position             */
#define CLK_CLKOCTL_FSEL_Msk             (0xful << CLK_CLKOCTL_FSEL_Pos)                   /*!< CLK_T::CLKOCTL: FSEL Mask                 */

#define CLK_CLKOCTL_CLKOEN_Pos           (4)                                               /*!< CLK_T::CLKOCTL: CLKOEN Position           */
#define CLK_CLKOCTL_CLKOEN_Msk           (0x1ul << CLK_CLKOCTL_CLKOEN_Pos)                 /*!< CLK_T::CLKOCTL: CLKOEN Mask               */

#define CLK_CLKOCTL_DIV1EN_Pos           (5)                                               /*!< CLK_T::CLKOCTL: DIV1EN Position             */
#define CLK_CLKOCTL_DIV1EN_Msk           (0x1ul << CLK_CLKOCTL_DIV1EN_Pos)                 /*!< CLK_T::CLKOCTL: DIV1EN Mask                 */

#define CLK_CLKDCTL_SYSFDEN_Pos          (0)                                               /*!< CLK_T::CLKDCTL: SYSFDEN Position          */
#define CLK_CLKDCTL_SYSFDEN_Msk          (0x1ul << CLK_CLKDCTL_SYSFDEN_Pos)                /*!< CLK_T::CLKDCTL: SYSFDEN Mask              */

#define CLK_CLKDCTL_SYSFIEN_Pos          (1)                                               /*!< CLK_T::CLKDCTL: SYSFIEN Position          */
#define CLK_CLKDCTL_SYSFIEN_Msk          (0x1ul << CLK_CLKDCTL_SYSFIEN_Pos)                /*!< CLK_T::CLKDCTL: SYSFIEN Mask              */

#define CLK_CLKDCTL_SYSFIF_Pos           (2)                                               /*!< CLK_T::CLKDCTL: SYSFIF Position           */
#define CLK_CLKDCTL_SYSFIF_Msk           (0x1ul << CLK_CLKDCTL_SYSFIF_Pos)                 /*!< CLK_T::CLKDCTL: SYSFIF Mask               */

#define CLK_CLKDCTL_IRCDEN_Pos           (8)                                               /*!< CLK_T::CLKDCTL: IRCDEN Position           */
#define CLK_CLKDCTL_IRCDEN_Msk           (0x1ul << CLK_CLKDCTL_IRCDEN_Pos)                 /*!< CLK_T::CLKDCTL: IRCDEN Mask               */

#define CLK_CLKDCTL_IRCFIEN_Pos          (9)                                               /*!< CLK_T::CLKDCTL: IRCFIEN Position          */
#define CLK_CLKDCTL_IRCFIEN_Msk          (0x1ul << CLK_CLKDCTL_IRCFIEN_Pos)                /*!< CLK_T::CLKDCTL: IRCFIEN Mask              */

#define CLK_CLKDCTL_IRCFIF_Pos           (10)                                              /*!< CLK_T::CLKDCTL: IRCFIF Position           */
#define CLK_CLKDCTL_IRCFIF_Msk           (0x1ul << CLK_CLKDCTL_IRCFIF_Pos)                 /*!< CLK_T::CLKDCTL: IRCFIF Mask               */

/**@}*/ /* CLK_CONST */
/**@}*/ /* end of CLK register group */


/*---------------------- Cyclic Redundancy Check Controller -------------------------*/
/**
    @addtogroup CRC Cyclic Redundancy Check Controller(CRC)
    Memory Mapped Structure for CRC Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  CRC Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CRCEN     |CRC Channel Enable Control
     * |        |          |0 = CRC function Disabled.
     * |        |          |1 = CRC function Enabled.
     * |[1]     |CRCRST    |CRC Engine Reset
     * |        |          |0 = No effect.
     * |        |          |1 = Reset the internal CRC state machine and internal buffer.
     * |        |          |The contents of control register will not be cleared.
     * |        |          |This bit will automatically be cleared after few clock cycles.
     * |        |          |Note: Setting this bit will reload the initial seed value.
     * |[24]    |DATREV    |Write Data Order Reverse
     * |        |          |0 = No bit order reversed for CRC write data in.
     * |        |          |1 = Bit order reversed for CRC write data in (per byte).
     * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB
     * |[25]    |CHKSREV   |Checksum Reverse
     * |        |          |0 = No bit order reverse for CRC checksum.
     * |        |          |1 = Bit order reverse for CRC checksum.
     * |        |          |Note: If the checksum data is 0XDD7B0F2E, the bit order reversed for CRC checksum is 0x74F0DEBB.
     * |[26]    |DATFMT    |Write Data Complement
     * |        |          |0 = No bit order reversed for CRC write data in.
     * |        |          |1 = 1's complement for CRC write data in.
     * |[27]    |CHKSFMT   |Checksum Complement
     * |        |          |0 = No bit order reverse for CRC checksum.
     * |        |          |1 = 1's complement for CRC checksum.
     * |[28:29] |DATLEN    |CPU Write Data Length
     * |        |          |This field indicates the write data length.
     * |        |          |00 = Data length is 8-bit mode.
     * |        |          |01 = Data length is 16-bit mode.
     * |        |          |1x = Data length is 32-bit mode.
     * |        |          |Note: When the data length is 8-bit mode, the valid data is DATA [7:0]; if the data length is 16-bit mode, the valid data is DATA [15:0].
     * |[30:31] |CRCMODE   |CRC Polynomial Mode Selection
     * |        |          |00 = CRC-CCITT Polynomial mode.
     * |        |          |01 = CRC-8 Polynomial mode.
     * |        |          |10 = CRC-16 Polynomial mode.
     * |        |          |11 = CRC-32 Polynomial mode.
    */
    __IO uint32_t CTL;

    /**
     * DAT
     * ===================================================================================================
     * Offset: 0x04  CRC Write Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DATA      |CRC Write Data Bits
     * |        |          |Software can write data to this field to perform CRC operation, or uses PDMA function to get the data from memory
     * |        |          |Note1: The CRC_CTL [DATFMT] and CRC_CTL [DATREV] bit setting will affect this field; for example, if DATREV = 1, if the write data in DATA register is 0xAABBCCDD, the read data from DATA register will be 0x55DD33BB.
    */
    __IO uint32_t DAT;

    /**
     * SEED
     * ===================================================================================================
     * Offset: 0x08  CRC Seed Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SEED      |CRC Seed Bits
     * |        |          |This field indicates the CRC seed value.
    */
    __IO uint32_t SEED;

    /**
     * CHECKSUM
     * ===================================================================================================
     * Offset: 0x0C  CRC Checksum Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CHECKSUM  |CRC Checksum Bits
     * |        |          |This field indicates the CRC checksum.
    */
    __I  uint32_t CHECKSUM;

} CRC_T;

/**
    @addtogroup CRC_CONST CRC Bit Field Definition
    Constant Definitions for CRC Controller
@{ */

#define CRC_CTL_CRCEN_Pos                (0)                                               /*!< CRC_T::CTL: CRCEN Position                */
#define CRC_CTL_CRCEN_Msk                (0x1ul << CRC_CTL_CRCEN_Pos)                      /*!< CRC_T::CTL: CRCEN Mask                    */

#define CRC_CTL_CRCRST_Pos               (1)                                               /*!< CRC_T::CTL: CRCRST Position               */
#define CRC_CTL_CRCRST_Msk               (0x1ul << CRC_CTL_CRCRST_Pos)                     /*!< CRC_T::CTL: CRCRST Mask                   */

#define CRC_CTL_DATREV_Pos               (24)                                              /*!< CRC_T::CTL: DATREV Position               */
#define CRC_CTL_DATREV_Msk               (0x1ul << CRC_CTL_DATREV_Pos)                     /*!< CRC_T::CTL: DATREV Mask                   */

#define CRC_CTL_CHKSREV_Pos              (25)                                              /*!< CRC_T::CTL: CHKSREV Position            */
#define CRC_CTL_CHKSREV_Msk              (0x1ul << CRC_CTL_CHKSREV_Pos)                    /*!< CRC_T::CTL: CHKSREV Mask                */

#define CRC_CTL_DATFMT_Pos               (26)                                              /*!< CRC_T::CTL: DATFMT Position               */
#define CRC_CTL_DATFMT_Msk               (0x1ul << CRC_CTL_DATFMT_Pos)                     /*!< CRC_T::CTL: DATFMT Mask                   */

#define CRC_CTL_CHKSFMT_Pos              (27)                                              /*!< CRC_T::CTL: CHKSFMT Position            */
#define CRC_CTL_CHKSFMT_Msk              (0x1ul << CRC_CTL_CHKSFMT_Pos)                    /*!< CRC_T::CTL: CHKSFMT Mask                */

#define CRC_CTL_DATLEN_Pos               (28)                                              /*!< CRC_T::CTL: DATLEN Position               */
#define CRC_CTL_DATLEN_Msk               (0x3ul << CRC_CTL_DATLEN_Pos)                     /*!< CRC_T::CTL: DATLEN Mask                   */

#define CRC_CTL_CRCMODE_Pos              (30)                                              /*!< CRC_T::CTL: CRCMODE Position              */
#define CRC_CTL_CRCMODE_Msk              (0x3ul << CRC_CTL_CRCMODE_Pos)                    /*!< CRC_T::CTL: CRCMODE Mask                  */

#define CRC_DAT_DATA_Pos                 (0)                                               /*!< CRC_T::DAT: DATA Position                 */
#define CRC_DAT_DATA_Msk                 (0xfffffffful << CRC_DAT_DATA_Pos)                /*!< CRC_T::DAT: DATA Mask                     */

#define CRC_SEED_SEED_Pos                (0)                                               /*!< CRC_T::SEED: SEED Position                */
#define CRC_SEED_SEED_Msk                (0xfffffffful << CRC_SEED_SEED_Pos)               /*!< CRC_T::SEED: SEED Mask                    */

#define CRC_CHECKSUM_CHECKSUM_Pos        (0)                                               /*!< CRC_T::CHECKSUM: CHECKSUM Position        */
#define CRC_CHECKSUM_CHECKSUM_Msk        (0xfffffffful << CRC_CHECKSUM_CHECKSUM_Pos)       /*!< CRC_T::CHECKSUM: CHECKSUM Mask            */

/**@}*/ /* CRC_CONST */
/**@}*/ /* end of CRC register group */


/*---------------------- Cryptographic Accelerator -------------------------*/
/**
    @addtogroup CRPT Cryptographic Accelerator(CRPT)
    Memory Mapped Structure for CRPT Controller
@{ */

typedef struct {
    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0x00  Crypto Interrupt Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |AESIEN    |AES Interrupt Enable Control
     * |        |          |0 = AES interrupt Disabled.
     * |        |          |1 = AES interrupt Enabled.
     * |        |          |In DMA mode, an interrupt will be triggered when amount of data set in AES_DMA_CNT is fed into the AES engine.
     * |        |          |In Non-DMA mode, an interrupt will be triggered when the AES engine finishes the operation.
     * |[1]     |AESERRIEN |AES Error Flag Enable Control
     * |        |          |0 = AES error interrupt flag Disabled.
     * |        |          |1 = AES error interrupt flag Enabled.
     * |[8]     |TDESIEN   |TDES/DES Interrupt Enable Control
     * |        |          |0 = TDES/DES interrupt Disabled.
     * |        |          |1 = TDES/DES interrupt Enabled.
     * |        |          |In DMA mode, an interrupt will be triggered when amount of data set in TDES_DMA_CNT is fed into the TDES engine.
     * |        |          |In Non-DMA mode, an interrupt will be triggered when the TDES engine finishes the operation.
     * |[9]     |TDESERRIEN|TDES/DES Error Flag Enable Control
     * |        |          |0 = TDES/DES error interrupt flag Disabled.
     * |        |          |1 = TDES/DES error interrupt flag Enabled.
     * |[16]    |PRNGIEN   |PRNG Interrupt Enable Control
     * |        |          |0 = PRNG interrupt Disabled.
     * |        |          |1 = PRNG interrupt Enabled.
     * |[24]    |SHAIEN    |SHA Interrupt Enable Control
     * |        |          |0 = SHA interrupt Disabled.
     * |        |          |1 = SHA interrupt Enabled.
     * |        |          |In DMA mode, an interrupt will be triggered when amount of data set in SHA _DMA_CNT is fed into the SHA engine.
     * |        |          |In Non-DMA mode, an interrupt will be triggered when the SHA engine finishes the operation.
     * |[25]    |SHAERRIEN |SHA Error Interrupt Enable Control
     * |        |          |0 = SHA error interrupt flag Disabled.
     * |        |          |1 = SHA error interrupt flag Enabled.
    */
    __IO uint32_t INTEN;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x04  Crypto Interrupt Flag
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |AESIF     |AES Finish Interrupt Flag
     * |        |          |This bit is cleared by writing 1, and it has no effect by writing 0.
     * |        |          |0 = No AES interrupt.
     * |        |          |1 = AES encryption/decryption done interrupt.
     * |[1]     |AESERRIF  |AES Error Flag
     * |        |          |This bit is cleared by writing 1, and it has no effect by writing 0.
     * |        |          |0 = No AES error.
     * |        |          |1 = AES encryption/decryption done interrupt.
     * |[8]     |TDESIF    |TDES/DES Finish Interrupt Flag
     * |        |          |This bit is cleared by writing 1, and it has no effect by writing 0.
     * |        |          |0 = No TDES/DES interrupt.
     * |        |          |1 = TDES/DES encryption/decryption done interrupt.
     * |[9]     |TDESERRIF |TDES/DES Error Flag
     * |        |          |This bit includes the operating and setting error.
     * |        |          |The detailed flag is shown in the TDES _FLAG register.
     * |        |          |This includes operating and setting error.
     * |        |          |This bit is cleared by writing 1, and it has no effect by writing 0.
     * |        |          |0 = No TDES/DES error.
     * |        |          |1 = TDES/DES encryption/decryption error interrupt.
     * |[16]    |PRNGIF    |PRNG Finish Interrupt Flag
     * |        |          |This bit is cleared by writing 1, and it has no effect by writing 0.
     * |        |          |0 = No PRNG interrupt.
     * |        |          |1 = PRNG key generation done interrupt.
     * |[24]    |SHAIF     |SHA Finish Interrupt Flag
     * |        |          |This bit is cleared by writing 1, and it has no effect by writing 0.
     * |        |          |0 = No SHA interrupt.
     * |        |          |1 = SHA operation done interrupt.
     * |[25]    |SHAERRIF  |SHA Error Flag
     * |        |          |This register includes operating and setting error. The detail flag is shown in SHA _FLAG register.
     * |        |          |This bit is cleared by writing 1, and it has no effect by writing 0.
     * |        |          |0 = No SHA error.
     * |        |          |1 = SHA error interrupt.
    */
    __IO uint32_t INTSTS;

    /**
     * PRNG_CTL
     * ===================================================================================================
     * Offset: 0x08  PRNG Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |START     |Start PRNG Engine
     * |        |          |0 = Stop PRNG engine.
     * |        |          |1 = Generate new key and store the new key to register CRPT_PRNG_KEYx , which will be cleared when the new key is generated.
     * |[1]     |SEEDRLD   |Reload New Seed For PRNG Engine
     * |        |          |0 = Generating key based on the current seed.
     * |        |          |1 = Reload new seed.
     * |[2:3]   |KEYSZ     |PRNG Generate Key Size
     * |        |          |00 = 64 bits.
     * |        |          |01 = 128 bits.
     * |        |          |10 = 192 bits.
     * |        |          |11 = 256 bits.
     * |[8]     |BUSY      |PRNG Busy (Read Only)
     * |        |          |0 = PRNG engine is idle.
     * |        |          |1 = Indicate that the PRNG engine is generating CRPT_PRNG_KEYx.
    */
    __IO uint32_t PRNG_CTL;

    /**
     * PRNG_SEED
     * ===================================================================================================
     * Offset: 0x0C  Seed for PRNG
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CRPT_PRNG_SEED|Seed For PRNG (Write Only)
     * |        |          |The bits store the seed for PRNG engine.
    */
    __O  uint32_t PRNG_SEED;

    /**
     * PRNG_KEY0
     * ===================================================================================================
     * Offset: 0x10  PRNG Generated Key0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYx      |Store PRNG Generated Key (Read Only)
     * |        |          |The bits store the key that is generated by PRNG.
    */
    __I  uint32_t PRNG_KEY0;

    /**
     * PRNG_KEY1
     * ===================================================================================================
     * Offset: 0x14  PRNG Generated Key1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYx      |Store PRNG Generated Key (Read Only)
     * |        |          |The bits store the key that is generated by PRNG.
    */
    __I  uint32_t PRNG_KEY1;

    /**
     * PRNG_KEY2
     * ===================================================================================================
     * Offset: 0x18  PRNG Generated Key2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYx      |Store PRNG Generated Key (Read Only)
     * |        |          |The bits store the key that is generated by PRNG.
    */
    __I  uint32_t PRNG_KEY2;

    /**
     * PRNG_KEY3
     * ===================================================================================================
     * Offset: 0x1C  PRNG Generated Key3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYx      |Store PRNG Generated Key (Read Only)
     * |        |          |The bits store the key that is generated by PRNG.
    */
    __I  uint32_t PRNG_KEY3;

    /**
     * PRNG_KEY4
     * ===================================================================================================
     * Offset: 0x20  PRNG Generated Key4
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYx      |Store PRNG Generated Key (Read Only)
     * |        |          |The bits store the key that is generated by PRNG.
    */
    __I  uint32_t PRNG_KEY4;

    /**
     * PRNG_KEY5
     * ===================================================================================================
     * Offset: 0x24  PRNG Generated Key5
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYx      |Store PRNG Generated Key (Read Only)
     * |        |          |The bits store the key that is generated by PRNG.
    */
    __I  uint32_t PRNG_KEY5;

    /**
     * PRNG_KEY6
     * ===================================================================================================
     * Offset: 0x28  PRNG Generated Key6
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYx      |Store PRNG Generated Key (Read Only)
     * |        |          |The bits store the key that is generated by PRNG.
    */
    __I  uint32_t PRNG_KEY6;

    /**
     * PRNG_KEY7
     * ===================================================================================================
     * Offset: 0x2C  PRNG Generated Key7
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYx      |Store PRNG Generated Key (Read Only)
     * |        |          |The bits store the key that is generated by PRNG.
    */
    __I  uint32_t PRNG_KEY7;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[8];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * AES_FDBCK0
     * ===================================================================================================
     * Offset: 0x50  AES Engine Output Feedback Data after Cryptographic Operation
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |FDBCK     |AES Feedback Information
     * |        |          |The feedback value is 128 bits in size.
     * |        |          |The AES engine uses the data from AES_FEEEDBACK as the data inputted to AES_IV for the next block in DMA cascade mode.
     * |        |          |The AES engine outputs feedback information for IV in the next block's operation.
     * |        |          |Software can use this feedback information to implement more than four DMA channels.
     * |        |          |Software can store that feedback value temporarily.
     * |        |          |After switching back, fill the stored feedback value to this register in the same channel operation, and then continue the operation with the original setting.
    */
    __I  uint32_t AES_FDBCK0;

    /**
     * AES_FDBCK1
     * ===================================================================================================
     * Offset: 0x54  AES Engine Output Feedback Data after Cryptographic Operation
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |FDBCK     |AES Feedback Information
     * |        |          |The feedback value is 128 bits in size.
     * |        |          |The AES engine uses the data from AES_FEEEDBACK as the data inputted to AES_IV for the next block in DMA cascade mode.
     * |        |          |The AES engine outputs feedback information for IV in the next block's operation.
     * |        |          |Software can use this feedback information to implement more than four DMA channels.
     * |        |          |Software can store that feedback value temporarily.
     * |        |          |After switching back, fill the stored feedback value to this register in the same channel operation, and then continue the operation with the original setting.
    */
    __I  uint32_t AES_FDBCK1;

    /**
     * AES_FDBCK2
     * ===================================================================================================
     * Offset: 0x58  AES Engine Output Feedback Data after Cryptographic Operation
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |FDBCK     |AES Feedback Information
     * |        |          |The feedback value is 128 bits in size.
     * |        |          |The AES engine uses the data from AES_FEEEDBACK as the data inputted to AES_IV for the next block in DMA cascade mode.
     * |        |          |The AES engine outputs feedback information for IV in the next block's operation.
     * |        |          |Software can use this feedback information to implement more than four DMA channels.
     * |        |          |Software can store that feedback value temporarily.
     * |        |          |After switching back, fill the stored feedback value to this register in the same channel operation, and then continue the operation with the original setting.
    */
    __I  uint32_t AES_FDBCK2;

    /**
     * AES_FDBCK3
     * ===================================================================================================
     * Offset: 0x5C  AES Engine Output Feedback Data after Cryptographic Operation
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |FDBCK     |AES Feedback Information
     * |        |          |The feedback value is 128 bits in size.
     * |        |          |The AES engine uses the data from AES_FEEEDBACK as the data inputted to AES_IV for the next block in DMA cascade mode.
     * |        |          |The AES engine outputs feedback information for IV in the next block's operation.
     * |        |          |Software can use this feedback information to implement more than four DMA channels.
     * |        |          |Software can store that feedback value temporarily.
     * |        |          |After switching back, fill the stored feedback value to this register in the same channel operation, and then continue the operation with the original setting.
    */
    __I  uint32_t AES_FDBCK3;

    /**
     * TDES_FDBCKH
     * ===================================================================================================
     * Offset: 0x60  TDES/DES Engine Output Feedback High Word Data after Cryptographic Operation
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |FDBCK     |TDES/DES Feedback
     * |        |          |The feedback value is 64 bits in size.
     * |        |          |The TDES/DES engine uses the data from CRPT_TDES_FEEEDBACK as the data inputted to CRPT_TDES_IV for the next block in DMA cascade mode.
     * |        |          |The feedback register is for CBC, CFB, and OFB mode.
     * |        |          |TDES/DES engine outputs feedback information for IV in the next block's operation.
     * |        |          |Software can use this feedback information to implement more than four DMA channels.
     * |        |          |Software can store that feedback value temporarily.
     * |        |          |After switching back, fill the stored feedback value to this register in the same channel operation.
     * |        |          |Then can continue the operation with the original setting.
    */
    __I  uint32_t TDES_FDBCKH;

    /**
     * TDES_FDBCKL
     * ===================================================================================================
     * Offset: 0x64  TDES/DES Engine Output Feedback Low Word Data after Cryptographic Operation
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |FDBCK     |TDES/DES Feedback
     * |        |          |The feedback value is 64 bits in size.
     * |        |          |The TDES/DES engine uses the data from CRPT_TDES_FEEEDBACK as the data inputted to CRPT_TDES_IV for the next block in DMA cascade mode.
     * |        |          |The feedback register is for CBC, CFB, and OFB mode.
     * |        |          |TDES/DES engine outputs feedback information for IV in the next block's operation.
     * |        |          |Software can use this feedback information to implement more than four DMA channels.
     * |        |          |Software can store that feedback value temporarily.
     * |        |          |After switching back, fill the stored feedback value to this register in the same channel operation.
     * |        |          |Then can continue the operation with the original setting.
    */
    __I  uint32_t TDES_FDBCKL;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[38];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * AES_CTL
     * ===================================================================================================
     * Offset: 0x100  AES Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |START     |AES Engine Start
     * |        |          |0 = No effect.
     * |        |          |1 = Start AES engine. BUSY flag will be set.
     * |        |          |Note: This bit is always 0 when it's read back.
     * |[1]     |STOP      |AES Engine Stop
     * |        |          |0 = No effect.
     * |        |          |1 = Stop AES engine.
     * |        |          |Note: This bit is always 0 when it's read back.
     * |[2:3]   |KEYSZ     |AES Key Size
     * |        |          |This bit defines three different key size for AES operation.
     * |        |          |2'b00 = 128 bits key.
     * |        |          |2'b01 = 192 bits key.
     * |        |          |2'b10 = 256 bits key.
     * |        |          |2'b11 = Reserved.
     * |        |          |If the AES accelerator is operating and the corresponding flag BUSY is 1, updating this register has no effect.
     * |[5]     |DMALAST   |AES Last Block
     * |        |          |In DMA mode, this bit must be set as beginning the last DMA cascade round.
     * |        |          |In Non-DMA mode, this bit must be set when feeding in the last block of data in ECB, CBC, CTR, OFB, and CFB mode, and feeding in the (last-1) block of data at CBC-CS1, CBC-CS2, and CBC-CS3 mode.
     * |        |          |This bit is always 0 when it's read back. Must be written again once START is triggered.
     * |[6]     |DMACSCAD  |AES Engine DMA With Cascade Mode
     * |        |          |0 = DMA cascade function Disabled.
     * |        |          |1 = In DMA cascade mode, software can update DMA source address register, destination address register, and byte count register during a cascade operation, without finishing the accelerator operation.
     * |[7]     |DMAEN     |AES Engine DMA Enable Control
     * |        |          |0 = AES DMA engine Disabled.
     * |        |          |The AES engine operates in Non-DMA mode, and gets data from the port CRPT_AES_DATIN.
     * |        |          |1 = AES DMA engine Enabled.
     * |        |          |The AES engine operates in DMA mode, and data movement from/to the engine is done by DMA logic.
     * |[8:15]  |OPMODE    |AES Engine Operation Modes
     * |        |          |0x00 = ECB (Electronic Codebook Mode)
     * |        |          |0x01 = CBC (Cipher Block Chaining Mode).
     * |        |          |0x02 = CFB (Cipher Feedback Mode).
     * |        |          |0x03 = OFB (Output Feedback Mode).
     * |        |          |0x04 = CTR (Counter Mode).
     * |        |          |0x10 = CBC-CS1 (CBC Ciphertext-Stealing 1 Mode).
     * |        |          |0x11 = CBC-CS2 (CBC Ciphertext-Stealing 2 Mode).
     * |        |          |0x12 = CBC-CS3 (CBC Ciphertext-Stealing 3 Mode).
     * |[16]    |ENCRPT    |AES Encryption/Decryption
     * |        |          |0 = AES engine executes decryption operation.
     * |        |          |1 = AES engine executes encryption operation.
     * |[22]    |OUTSWAP   |AES Engine Output Data Swap
     * |        |          |0 = Keep the original order.
     * |        |          |1 = The order that CPU outputs data from the accelerator will be changed from {byte3, byte2, byte1, byte0} to {byte0, byte1, byte2, byte3}.
     * |[23]    |INSWAP    |AES Engine Input Data Swap
     * |        |          |0 = Keep the original order.
     * |        |          |1 = The order that CPU feeds data to the accelerator will be changed from {byte3, byte2, byte1, byte0} to {byte0, byte1, byte2, byte3}.
     * |[24:25] |CHANNEL   |AES Engine Working Channel
     * |        |          |00 = Current control register setting is for channel 0.
     * |        |          |01 = Current control register setting is for channel 1.
     * |        |          |10 = Current control register setting is for channel 2.
     * |        |          |11 = Current control register setting is for channel 3.
     * |[26:30] |KEYUNPRT  |Unprotect Key
     * |        |          |Writing 0 to CRPT_AES_CTL [31] and "10110" to CRPT_AES_CTL [30:26] is to unprotect the AES key.
     * |        |          |The KEYUNPRT can be read and written.
     * |        |          |When it is written as the AES engine is operating, BUSY flag is 1, there would be no effect on KEYUNPRT.
     * |[31]    |KEYPRT    |Protect Key
     * |        |          |Read as a flag to reflect KEYPRT.
     * |        |          |0 = No effect.
     * |        |          |1 = Protect the content of the AES key from reading.
     * |        |          |The return value for reading CRPT_AESn_KEYx is not the content of the registers CRPT_AESn_KEYx.
     * |        |          |Once it is set, it can be cleared by asserting KEYUNPRT.
     * |        |          |And the key content would be cleared as well.
    */
    __IO uint32_t AES_CTL;

    /**
     * AES_STS
     * ===================================================================================================
     * Offset: 0x104  AES Engine Flag
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BUSY      |AES Engine Busy
     * |        |          |0 = The AES engine is idle or finished.
     * |        |          |1 = The AES engine is under processing.
     * |[8]     |INBUFEMPTY|AES Input Buffer Empty
     * |        |          |0 = There are some data in input buffer waiting for the AES engine to process.
     * |        |          |1 = AES input buffer is empty.
     * |        |          |Software needs to feed data to the AES engine.
     * |        |          |Otherwise, the AES engine will be pending to wait for input data.
     * |[9]     |INBUFFULL |AES Input Buffer Full Flag
     * |        |          |0 = AES input buffer is not full. Software can feed the data into the AES engine.
     * |        |          |1 = AES input buffer is full.
     * |        |          |Software cannot feed data to the AES engine.
     * |        |          |Otherwise, the flag INBUFERR will be set to 1.
     * |[10]    |INBUFERR  |AES Input Buffer Error Flag
     * |        |          |0 = No error.
     * |        |          |1 = Error happens during feeding data to the AES engine.
     * |[12]    |CNTERR    |AES_CNT Setting Error
     * |        |          |0 = No error in AES_CNT setting.
     * |        |          |1 = AES_CNT is not a multiply of 16 in ECB, CBC, CFB, OFB, and CTR mode.
     * |[16]    |OUTBUFEMPTY|AES Out Buffer Empty
     * |        |          |0 = AES output buffer is not empty. There are some valid data kept in output buffer.
     * |        |          |1 = AES output buffer is empty.
     * |        |          |Software cannot get data from AES_DATA_OUT.
     * |        |          |Otherwise, the flag OUTBUFERR will be set to 1 since the output buffer is empty.
     * |[17]    |OUTBUFFULL|AES Out Buffer Full Flag
     * |        |          |0 = AES output buffer is not full.
     * |        |          |1 = AES output buffer is full, and software needs to get data from AES_DATA_OUT.
     * |        |          |Otherwise, the AES engine will be pending since the output buffer is full.
     * |[18]    |OUTBUFERR |AES Out Buffer Error Flag
     * |        |          |0 = No error.
     * |        |          |1 = Error happens during getting the result from AES engine.
     * |[20]    |BUSERR    |AES DMA Access Bus Error Flag
     * |        |          |0 = No error.
     * |        |          |1 = Bus error will stop DMA operation and AES engine.
    */
    __I  uint32_t AES_STS;

    /**
     * AES_DATIN
     * ===================================================================================================
     * Offset: 0x108  AES Engine Data Input Port Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DATIN     |AES Engine Input Port
     * |        |          |CPU feeds data to AES engine through this port by checking CRPT_AES_STS. Feed data as INBUFFULL is 0.
    */
    __IO uint32_t AES_DATIN;

    /**
     * AES_DATOUT
     * ===================================================================================================
     * Offset: 0x10C  AES Engine Data Output Port Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DATOUT    |AES Engine Output Port
     * |        |          |CPU gets results from the AES engine through this port by checking CRPT_AES_STS.
     * |        |          |Get data as OUTBUFEMPTY is 0.
    */
    __I  uint32_t AES_DATOUT;

    /**
     * AES0_KEY0
     * ===================================================================================================
     * Offset: 0x110  AES Key Word 0 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES0_KEY0;

    /**
     * AES0_KEY1
     * ===================================================================================================
     * Offset: 0x114  AES Key Word 1 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES0_KEY1;

    /**
     * AES0_KEY2
     * ===================================================================================================
     * Offset: 0x118  AES Key Word 2 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES0_KEY2;

    /**
     * AES0_KEY3
     * ===================================================================================================
     * Offset: 0x11C  AES Key Word 3 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES0_KEY3;

    /**
     * AES0_KEY4
     * ===================================================================================================
     * Offset: 0x120  AES Key Word 4 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES0_KEY4;

    /**
     * AES0_KEY5
     * ===================================================================================================
     * Offset: 0x124  AES Key Word 5 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES0_KEY5;

    /**
     * AES0_KEY6
     * ===================================================================================================
     * Offset: 0x128  AES Key Word 6 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES0_KEY6;

    /**
     * AES0_KEY7
     * ===================================================================================================
     * Offset: 0x12C  AES Key Word 7 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES0_KEY7;

    /**
     * AES0_IV0
     * ===================================================================================================
     * Offset: 0x130  AES Initial Vector Word 0 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES0_IV0;

    /**
     * AES0_IV1
     * ===================================================================================================
     * Offset: 0x134  AES Initial Vector Word 1 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES0_IV1;

    /**
     * AES0_IV2
     * ===================================================================================================
     * Offset: 0x138  AES Initial Vector Word 2 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES0_IV2;

    /**
     * AES0_IV3
     * ===================================================================================================
     * Offset: 0x13C  AES Initial Vector Word 3 Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES0_IV3;

    /**
     * AES0_SADDR
     * ===================================================================================================
     * Offset: 0x140  AES DMA Source Address Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |AES DMA Source Address
     * |        |          |The AES accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The AES_SADR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the AES accelerator can read the plain text from system memory and do AES operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of AES_SADR are ignored.
     * |        |          |AES_SADR can be read and written.
     * |        |          |Writing to AES_SADR while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_SADR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next AES operation.
     * |        |          |In DMA mode, software can update the next AES_SADR before triggering START.
     * |        |          |The value of AES_SADR and AES_DADR can be the same.
    */
    __IO uint32_t AES0_SADDR;

    /**
     * AES0_DADDR
     * ===================================================================================================
     * Offset: 0x144  AES DMA Destination Address Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DADDR     |AES DMA Destination Address
     * |        |          |The AES accelerator supports DMA function to transfer the cipher text between system memory and embedded FIFO.
     * |        |          |The AES_DADR keeps the destination address of the data buffer where the engine output's text will be stored.
     * |        |          |Based on the destination address, the AES accelerator can write the cipher text back to system memory after the AES operation is finished.
     * |        |          |The start of destination address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of AES_DADR are ignored.
     * |        |          |AES_DADR can be read and written.
     * |        |          |Writing to AES_DADR while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_DADR will be updated later on.
     * |        |          |Consequently, software can prepare the destination address for the next AES operation.
     * |        |          |In DMA mode, software can update the next AES_DADR before triggering START.
     * |        |          |The value of AES_SADR and AES_DADR can be the same.
    */
    __IO uint32_t AES0_DADDR;

    /**
     * AES0_CNT
     * ===================================================================================================
     * Offset: 0x148  AES Byte Count Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CNT       |AES Byte Count
     * |        |          |The AES_CNT keeps the byte count of source text that is for the AES engine operating in DMA mode.
     * |        |          |The AES_CNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |AES_CNT can be read and written.
     * |        |          |Writing to AES_CNT while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next AES operation.
     * |        |          |According to CBC-CS1, CBC-CS2, and CBC-CS3 standard, the count of operation data must be at least one block.
     * |        |          |Operations that are less than one block will output unexpected result.
     * |        |          |In Non-DMA ECB, CBC, CFB, OFB, and CTR mode, AES_CNT must be set as byte count for the last block of data before feeding in the last block of data.
     * |        |          |In Non-DMA CBC-CS1, CBC-CS2, and CBC-CS3 mode, AES_CNT must be set as byte count for the last two blocks of data before feeding in the last two blocks of data.
    */
    __IO uint32_t AES0_CNT;

    /**
     * AES1_KEY0
     * ===================================================================================================
     * Offset: 0x14C  AES Key Word 0 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES1_KEY0;

    /**
     * AES1_KEY1
     * ===================================================================================================
     * Offset: 0x150  AES Key Word 1 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES1_KEY1;

    /**
     * AES1_KEY2
     * ===================================================================================================
     * Offset: 0x154  AES Key Word 2 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES1_KEY2;

    /**
     * AES1_KEY3
     * ===================================================================================================
     * Offset: 0x158  AES Key Word 3 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES1_KEY3;

    /**
     * AES1_KEY4
     * ===================================================================================================
     * Offset: 0x15C  AES Key Word 4 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES1_KEY4;

    /**
     * AES1_KEY5
     * ===================================================================================================
     * Offset: 0x160  AES Key Word 5 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES1_KEY5;

    /**
     * AES1_KEY6
     * ===================================================================================================
     * Offset: 0x164  AES Key Word 6 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES1_KEY6;

    /**
     * AES1_KEY7
     * ===================================================================================================
     * Offset: 0x168  AES Key Word 7 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES1_KEY7;

    /**
     * AES1_IV0
     * ===================================================================================================
     * Offset: 0x16C  AES Initial Vector Word 0 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES1_IV0;

    /**
     * AES1_IV1
     * ===================================================================================================
     * Offset: 0x170  AES Initial Vector Word 1 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES1_IV1;

    /**
     * AES1_IV2
     * ===================================================================================================
     * Offset: 0x174  AES Initial Vector Word 2 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES1_IV2;

    /**
     * AES1_IV3
     * ===================================================================================================
     * Offset: 0x178  AES Initial Vector Word 3 Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES1_IV3;

    /**
     * AES1_SADDR
     * ===================================================================================================
     * Offset: 0x17C  AES DMA Source Address Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |AES DMA Source Address
     * |        |          |The AES accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The AES_SADR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the AES accelerator can read the plain text from system memory and do AES operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of AES_SADR are ignored.
     * |        |          |AES_SADR can be read and written.
     * |        |          |Writing to AES_SADR while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_SADR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next AES operation.
     * |        |          |In DMA mode, software can update the next AES_SADR before triggering START.
     * |        |          |The value of AES_SADR and AES_DADR can be the same.
    */
    __IO uint32_t AES1_SADDR;

    /**
     * AES1_DADDR
     * ===================================================================================================
     * Offset: 0x180  AES DMA Destination Address Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DADDR     |AES DMA Destination Address
     * |        |          |The AES accelerator supports DMA function to transfer the cipher text between system memory and embedded FIFO.
     * |        |          |The AES_DADR keeps the destination address of the data buffer where the engine output's text will be stored.
     * |        |          |Based on the destination address, the AES accelerator can write the cipher text back to system memory after the AES operation is finished.
     * |        |          |The start of destination address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of AES_DADR are ignored.
     * |        |          |AES_DADR can be read and written.
     * |        |          |Writing to AES_DADR while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_DADR will be updated later on.
     * |        |          |Consequently, software can prepare the destination address for the next AES operation.
     * |        |          |In DMA mode, software can update the next AES_DADR before triggering START.
     * |        |          |The value of AES_SADR and AES_DADR can be the same.
    */
    __IO uint32_t AES1_DADDR;

    /**
     * AES1_CNT
     * ===================================================================================================
     * Offset: 0x184  AES Byte Count Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CNT       |AES Byte Count
     * |        |          |The AES_CNT keeps the byte count of source text that is for the AES engine operating in DMA mode.
     * |        |          |The AES_CNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |AES_CNT can be read and written.
     * |        |          |Writing to AES_CNT while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next AES operation.
     * |        |          |According to CBC-CS1, CBC-CS2, and CBC-CS3 standard, the count of operation data must be at least one block.
     * |        |          |Operations that are less than one block will output unexpected result.
     * |        |          |In Non-DMA ECB, CBC, CFB, OFB, and CTR mode, AES_CNT must be set as byte count for the last block of data before feeding in the last block of data.
     * |        |          |In Non-DMA CBC-CS1, CBC-CS2, and CBC-CS3 mode, AES_CNT must be set as byte count for the last two blocks of data before feeding in the last two blocks of data.
    */
    __IO uint32_t AES1_CNT;

    /**
     * AES2_KEY0
     * ===================================================================================================
     * Offset: 0x188  AES Key Word 0 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES2_KEY0;

    /**
     * AES2_KEY1
     * ===================================================================================================
     * Offset: 0x18C  AES Key Word 1 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES2_KEY1;

    /**
     * AES2_KEY2
     * ===================================================================================================
     * Offset: 0x190  AES Key Word 2 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES2_KEY2;

    /**
     * AES2_KEY3
     * ===================================================================================================
     * Offset: 0x194  AES Key Word 3 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES2_KEY3;

    /**
     * AES2_KEY4
     * ===================================================================================================
     * Offset: 0x198  AES Key Word 4 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES2_KEY4;

    /**
     * AES2_KEY5
     * ===================================================================================================
     * Offset: 0x19C  AES Key Word 5 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES2_KEY5;

    /**
     * AES2_KEY6
     * ===================================================================================================
     * Offset: 0x1A0  AES Key Word 6 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES2_KEY6;

    /**
     * AES2_KEY7
     * ===================================================================================================
     * Offset: 0x1A4  AES Key Word 7 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES2_KEY7;

    /**
     * AES2_IV0
     * ===================================================================================================
     * Offset: 0x1A8  AES Initial Vector Word 0 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES2_IV0;

    /**
     * AES2_IV1
     * ===================================================================================================
     * Offset: 0x1AC  AES Initial Vector Word 1 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES2_IV1;

    /**
     * AES2_IV2
     * ===================================================================================================
     * Offset: 0x1B0  AES Initial Vector Word 2 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES2_IV2;

    /**
     * AES2_IV3
     * ===================================================================================================
     * Offset: 0x1B4  AES Initial Vector Word 3 Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES2_IV3;

    /**
     * AES2_SADDR
     * ===================================================================================================
     * Offset: 0x1B8  AES DMA Source Address Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |AES DMA Source Address
     * |        |          |The AES accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The AES_SADR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the AES accelerator can read the plain text from system memory and do AES operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of AES_SADR are ignored.
     * |        |          |AES_SADR can be read and written.
     * |        |          |Writing to AES_SADR while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_SADR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next AES operation.
     * |        |          |In DMA mode, software can update the next AES_SADR before triggering START.
     * |        |          |The value of AES_SADR and AES_DADR can be the same.
    */
    __IO uint32_t AES2_SADDR;

    /**
     * AES2_DADDR
     * ===================================================================================================
     * Offset: 0x1BC  AES DMA Destination Address Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DADDR     |AES DMA Destination Address
     * |        |          |The AES accelerator supports DMA function to transfer the cipher text between system memory and embedded FIFO.
     * |        |          |The AES_DADR keeps the destination address of the data buffer where the engine output's text will be stored.
     * |        |          |Based on the destination address, the AES accelerator can write the cipher text back to system memory after the AES operation is finished.
     * |        |          |The start of destination address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of AES_DADR are ignored.
     * |        |          |AES_DADR can be read and written.
     * |        |          |Writing to AES_DADR while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_DADR will be updated later on.
     * |        |          |Consequently, software can prepare the destination address for the next AES operation.
     * |        |          |In DMA mode, software can update the next AES_DADR before triggering START.
     * |        |          |The value of AES_SADR and AES_DADR can be the same.
    */
    __IO uint32_t AES2_DADDR;

    /**
     * AES2_CNT
     * ===================================================================================================
     * Offset: 0x1C0  AES Byte Count Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CNT       |AES Byte Count
     * |        |          |The AES_CNT keeps the byte count of source text that is for the AES engine operating in DMA mode.
     * |        |          |The AES_CNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |AES_CNT can be read and written.
     * |        |          |Writing to AES_CNT while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next AES operation.
     * |        |          |According to CBC-CS1, CBC-CS2, and CBC-CS3 standard, the count of operation data must be at least one block.
     * |        |          |Operations that are less than one block will output unexpected result.
     * |        |          |In Non-DMA ECB, CBC, CFB, OFB, and CTR mode, AES_CNT must be set as byte count for the last block of data before feeding in the last block of data.
     * |        |          |In Non-DMA CBC-CS1, CBC-CS2, and CBC-CS3 mode, AES_CNT must be set as byte count for the last two blocks of data before feeding in the last two blocks of data.
    */
    __IO uint32_t AES2_CNT;

    /**
     * AES3_KEY0
     * ===================================================================================================
     * Offset: 0x1C4  AES Key Word 0 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES3_KEY0;

    /**
     * AES3_KEY1
     * ===================================================================================================
     * Offset: 0x1C8  AES Key Word 1 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES3_KEY1;

    /**
     * AES3_KEY2
     * ===================================================================================================
     * Offset: 0x1CC  AES Key Word 2 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES3_KEY2;

    /**
     * AES3_KEY3
     * ===================================================================================================
     * Offset: 0x1D0  AES Key Word 3 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES3_KEY3;

    /**
     * AES3_KEY4
     * ===================================================================================================
     * Offset: 0x1D4  AES Key Word 4 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES3_KEY4;

    /**
     * AES3_KEY5
     * ===================================================================================================
     * Offset: 0x1D8  AES Key Word 5 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES3_KEY5;

    /**
     * AES3_KEY6
     * ===================================================================================================
     * Offset: 0x1DC  AES Key Word 6 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES3_KEY6;

    /**
     * AES3_KEY7
     * ===================================================================================================
     * Offset: 0x1E0  AES Key Word 7 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |AES Key X
     * |        |          |The KEY keeps the security key for AES operation.
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..7.
     * |        |          |The security key for AES accelerator can be 128, 192, or 256 bits and four, six, or eight 32-bit registers are to store each security key.
     * |        |          |{AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 128-bit security key for AES operation.
     * |        |          |{AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 192-bit security key for AES operation.
     * |        |          |{AES_KEY7, AES_KEY6, AES_KEY5, AES_KEY4, AES_KEY3, AES_KEY2, AES_KEY1, AES_KEY0} stores the 256-bit security key for AES operation.
    */
    __IO uint32_t AES3_KEY7;

    /**
     * AES3_IV0
     * ===================================================================================================
     * Offset: 0x1E4  AES Initial Vector Word 0 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES3_IV0;

    /**
     * AES3_IV1
     * ===================================================================================================
     * Offset: 0x1E8  AES Initial Vector Word 1 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES3_IV1;

    /**
     * AES3_IV2
     * ===================================================================================================
     * Offset: 0x1EC  AES Initial Vector Word 2 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES3_IV2;

    /**
     * AES3_IV3
     * ===================================================================================================
     * Offset: 0x1F0  AES Initial Vector Word 3 Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IV        |AES Initial Vector Word X
     * |        |          |n = 0, 1..3.
     * |        |          |x = 0, 1..3.
     * |        |          |Four initial vectors (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) are for AES operating in CBC, CFB, and OFB mode.
     * |        |          |Four registers (AES_IV0, AES_IV1, AES_IV2, and AES_IV3) act as Nonce counter when the AES engine is operating in CTR mode.
    */
    __IO uint32_t AES3_IV3;

    /**
     * AES3_SADDR
     * ===================================================================================================
     * Offset: 0x1F4  AES DMA Source Address Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |AES DMA Source Address
     * |        |          |The AES accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The AES_SADR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the AES accelerator can read the plain text from system memory and do AES operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of AES_SADR are ignored.
     * |        |          |AES_SADR can be read and written.
     * |        |          |Writing to AES_SADR while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_SADR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next AES operation.
     * |        |          |In DMA mode, software can update the next AES_SADR before triggering START.
     * |        |          |The value of AES_SADR and AES_DADR can be the same.
    */
    __IO uint32_t AES3_SADDR;

    /**
     * AES3_DADDR
     * ===================================================================================================
     * Offset: 0x1F8  AES DMA Destination Address Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DADDR     |AES DMA Destination Address
     * |        |          |The AES accelerator supports DMA function to transfer the cipher text between system memory and embedded FIFO.
     * |        |          |The AES_DADR keeps the destination address of the data buffer where the engine output's text will be stored.
     * |        |          |Based on the destination address, the AES accelerator can write the cipher text back to system memory after the AES operation is finished.
     * |        |          |The start of destination address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of AES_DADR are ignored.
     * |        |          |AES_DADR can be read and written.
     * |        |          |Writing to AES_DADR while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_DADR will be updated later on.
     * |        |          |Consequently, software can prepare the destination address for the next AES operation.
     * |        |          |In DMA mode, software can update the next AES_DADR before triggering START.
     * |        |          |The value of AES_SADR and AES_DADR can be the same.
    */
    __IO uint32_t AES3_DADDR;

    /**
     * AES3_CNT
     * ===================================================================================================
     * Offset: 0x1FC  AES Byte Count Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CNT       |AES Byte Count
     * |        |          |The AES_CNT keeps the byte count of source text that is for the AES engine operating in DMA mode.
     * |        |          |The AES_CNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |AES_CNT can be read and written.
     * |        |          |Writing to AES_CNT while the AES accelerator is operating doesn't affect the current AES operation.
     * |        |          |But the value of AES_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next AES operation.
     * |        |          |According to CBC-CS1, CBC-CS2, and CBC-CS3 standard, the count of operation data must be at least one block.
     * |        |          |Operations that are less than one block will output unexpected result.
     * |        |          |In Non-DMA ECB, CBC, CFB, OFB, and CTR mode, AES_CNT must be set as byte count for the last block of data before feeding in the last block of data.
     * |        |          |In Non-DMA CBC-CS1, CBC-CS2, and CBC-CS3 mode, AES_CNT must be set as byte count for the last two blocks of data before feeding in the last two blocks of data.
    */
    __IO uint32_t AES3_CNT;

    /**
     * TDES_CTL
     * ===================================================================================================
     * Offset: 0x200  TDES/DES Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |START     |TDES/DES Engine Start
     * |        |          |0 = No effect.
     * |        |          |1 = Start TDES/DES engine. The flag BUSY would be set.
     * |        |          |Note: The bit is always 0 when it's read back.
     * |[1]     |STOP      |TDES/DES Engine Stop
     * |        |          |0 = No effect.
     * |        |          |1 = Stop TDES/DES engine.
     * |        |          |Note: The bit is always 0 when it's read back.
     * |[2]     |TMODE     |TDES/DES Engine Operating Mode
     * |        |          |0 = Set DES mode for TDES/DES engine.
     * |        |          |1 = Set Triple DES mode for TDES/DES engine.
     * |[3]     |3KEYS     |TDES/DES Key Number
     * |        |          |0 = Select KEY1 and KEY2 in TDES/DES engine.
     * |        |          |1 = Triple keys in TDES/DES engine Enabled.
     * |[5]     |DMALAST   |TDES/DES Engine Start For The Last Block
     * |        |          |In DMA mode, this bit must be set as beginning the last DMA cascade round.
     * |        |          |In Non-DMA mode, this bit must be set as feeding in last block of data.
     * |[6]     |DMACSCAD  |TDES/DES Engine DMA With Cascade Mode
     * |        |          |0 = DMA cascade function Disabled.
     * |        |          |1 = In DMA Cascade mode, software can update DMA source address register, destination address register, and byte count register during a cascade operation, without finishing the accelerator operation.
     * |[7]     |DMAEN     |TDES/DES Engine DMA Enable Control
     * |        |          |0 = TDES_DMA engine Disabled.
     * |        |          |TDES engine operates in Non-DMA mode, and get data from the port CRPT_TDES_DATIN.
     * |        |          |1 = TDES_DMA engine Enabled.
     * |        |          |TDES engine operates in DMA mode, and data movement from/to the engine is done by DMA logic.
     * |[8:10]  |OPMODE    |TDES/DES Engine Operation Mode
     * |        |          |0x00 = ECB (Electronic Codebook Mode).
     * |        |          |0x01 = CBC (Cipher Block Chaining Mode).
     * |        |          |0x02 = CFB (Cipher Feedback Mode).
     * |        |          |0x03 = OFB (Output Feedback Mode).
     * |        |          |0x04 = CTR (Counter Mode).
     * |        |          |Others = CTR (Counter Mode).
     * |[16]    |ENCRPT    |TDES/DES Encryption/Decryption
     * |        |          |0 = TDES engine executes decryption operation.
     * |        |          |1 = TDES engine executes encryption operation.
     * |[21]    |BLKSWAP   |TDES/DES Engine Block Double Word Endian Swap
     * |        |          |0 = Keep the original order, e.g. {WORD_H, WORD_L}.
     * |        |          |1 = When this bit is set to 1, the TDES engine would exchange high and low word in the sequence {WORD_L, WORD_H}.
     * |[22]    |OUTSWAP   |TDES/DES Engine Output Data Swap
     * |        |          |0 = Keep the original order.
     * |        |          |1 = The order that CPU outputs data from the accelerator will be changed from {byte3, byte2, byte1, byte0} to {byte0, byte1, byte2, byte3}.
     * |[23]    |INSWAP    |TDES/DES Engine Input Data Swap
     * |        |          |0 = Keep the original order.
     * |        |          |1 = The order that CPU feeds data to the accelerator will be changed from {byte3, byte2, byte1, byte0} to {byte0, byte1, byte2, byte3}.
     * |[24:25] |CHANNEL   |TDES/DES Engine Working Channel
     * |        |          |00 = Current control register setting is for channel 0.
     * |        |          |01 = Current control register setting is for channel 1.
     * |        |          |10 = Current control register setting is for channel 2.
     * |        |          |11 = Current control register setting is for channel 3.
     * |[26:30] |KEYUNPRT  |Unprotected Key
     * |        |          |Writing 0 to CRPT_TDES_CTL [31] and "10110" to CRPT_TDES_CTL [30:26] is to unprotect TDES key.
     * |        |          |The KEYUNPRT can be read and written.
     * |        |          |When it is written as the TDES engine is operating, BUSY flag is 1, there would be no effect on KEYUNPRT.
     * |[31]    |KEYPRT    |Protect Key
     * |        |          |Read as a flag to reflect KEYPRT.
     * |        |          |0 = No effect.
     * |        |          |1 = This bit is to protect the content of TDES key from reading.
     * |        |          |The return value for reading CRPT_ TDESn_KEYxH/L is not the content in the registers CRPT_ TDESn_KEYxH/L.
     * |        |          |Once it is set, it can be cleared by asserting KEYUNPRT.
     * |        |          |The key content would be cleared as well.
    */
    __IO uint32_t TDES_CTL;

    /**
     * TDES_STS
     * ===================================================================================================
     * Offset: 0x204  TDES/DES Engine Flag
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BUSY      |TDES/DES Engine Busy
     * |        |          |0 = TDES/DES engine is idle or finished.
     * |        |          |1 = TDES/DES engine is under processing.
     * |[8]     |INBUFEMPTY|TDES/DES In Buffer Empty
     * |        |          |0 = There are some data in input buffer waiting for the TDES/DES engine to process.
     * |        |          |1 = TDES/DES input buffer is empty.
     * |        |          |Software needs to feed data to the TDES/DES engine.
     * |        |          |Otherwise, the TDES/DES engine will be pending to wait for input data.
     * |[9]     |INBUFFULL |TDES/DES In Buffer Full Flag
     * |        |          |0 = TDES/DES input buffer is not full. Software can feed the data into the TDES/DES engine.
     * |        |          |1 = TDES input buffer is full.
     * |        |          |Software cannot feed data to the TDES/DES engine.
     * |        |          |Otherwise, the flag INBUFERR will be set to 1.
     * |[10]    |INBUFERR  |TDES/DES In Buffer Error Flag
     * |        |          |0 = No error.
     * |        |          |1 = Error happens during feeding data to the TDES/DES engine.
     * |[16]    |OUTBUFEMPTY|TDES/DES Output Buffer Empty Flag
     * |        |          |0 = TDES/DES output buffer is not empty. There are some valid data kept in output buffer.
     * |        |          |1 = TDES/DES output buffer is empty, Software cannot get data from TDES_DATA_OUT.
     * |        |          |Otherwise the flag OUTBUFERR will be set to 1, since output buffer is empty.
     * |[17]    |OUTBUFFULL|TDES/DES Output Buffer Full Flag
     * |        |          |0 = TDES/DES output buffer is not full.
     * |        |          |1 = TDES/DES output buffer is full, and software needs to get data from TDES_DATA_OUT.
     * |        |          |Otherwise, the TDES/DES engine will be pending since output buffer is full.
     * |[18]    |OUTBUFERR |TDES/DES Out Buffer Error Flag
     * |        |          |0 = No error.
     * |        |          |1 = Error happens during getting test result from TDES/DES engine.
     * |[20]    |BUSERR    |TDES/DES DMA Access Bus Error Flag
     * |        |          |0 = No error.
     * |        |          |1 = Bus error will stop DMA operation and TDES/DES engine.
    */
    __I  uint32_t TDES_STS;

    /**
     * TDES0_KEY1H
     * ===================================================================================================
     * Offset: 0x208  TDES/DES Key 1 High Word Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES0_KEY1H;

    /**
     * TDES0_KEY1L
     * ===================================================================================================
     * Offset: 0x20C  TDES/DES Key 1 Low Word Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES0_KEY1L;

    /**
     * TDES0_KEY2H
     * ===================================================================================================
     * Offset: 0x210  TDES Key 2 High Word Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES0_KEY2H;

    /**
     * TDES0_KEY2L
     * ===================================================================================================
     * Offset: 0x214  TDES Key 2 Low Word Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES0_KEY2L;

    /**
     * TDES0_KEY3H
     * ===================================================================================================
     * Offset: 0x218  TDES Key 3 High Word Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES0_KEY3H;

    /**
     * TDES0_KEY3L
     * ===================================================================================================
     * Offset: 0x21C  TDES Key 3 Low Word Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES0_KEY3L;

    /**
     * TDES0_IVH
     * ===================================================================================================
     * Offset: 0x220  TDES/DES Initial Vector High Word Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IVH_IVL   |TDES/DES Initial Vector High/Low Word
     * |        |          |Initial vector (IV) is for TDES/DES engine in CBC, CFB, and OFB mode.
     * |        |          |IV is Nonce counter for TDES/DES engine in CTR mode.
    */
    __IO uint32_t TDES0_IVH;

    /**
     * TDES0_IVL
     * ===================================================================================================
     * Offset: 0x224  TDES/DES Initial Vector Low Word Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IVH_IVL   |TDES/DES Initial Vector High/Low Word
     * |        |          |Initial vector (IV) is for TDES/DES engine in CBC, CFB, and OFB mode.
     * |        |          |IV is Nonce counter for TDES/DES engine in CTR mode.
    */
    __IO uint32_t TDES0_IVL;

    /**
     * TDES0_SADDR
     * ===================================================================================================
     * Offset: 0x228  TDES/DES DMA Source Address Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |TDES/DES DMA Source Address
     * |        |          |The TDES/DES accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The TDES_SADR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the TDES/DES accelerator can read the plain text from system memory and do TDES/DES operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of TDES_SADR are ignored.
     * |        |          |TDES_SADR can be read and written.
     * |        |          |Writing to TDES_SADR while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_SADR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next TDES/DES operation.
     * |        |          |In DMA mode, software can update the next TDES_SADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t TDES0_SADDR;

    /**
     * TDES0_DADDR
     * ===================================================================================================
     * Offset: 0x22C  TDES/DES DMA Destination Address Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DADDR     |TDES/DES DMA Destination Address
     * |        |          |The TDES/DES accelerator supports DMA function to transfer the cipher text between system memory and embedded FIFO.
     * |        |          |The TDES_DADR keeps the destination address of the data buffer where the engine output's text will be stored.
     * |        |          |Based on the destination address, the TDES/DES accelerator can write the cipher text back to system memory after the TDES/DES operation is finished.
     * |        |          |The start of destination address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of TDES_DADR are ignored.
     * |        |          |TDES_DADR can be read and written.
     * |        |          |Writing to TDES_DADR while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_DADR will be updated later on.
     * |        |          |Consequently, software can prepare the destination address for the next TDES/DES operation.
     * |        |          |In DMA mode, software can update the next TDES_DADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t TDES0_DADDR;

    /**
     * TDES0_CNT
     * ===================================================================================================
     * Offset: 0x230  TDES/DES Byte Count Register for Channel 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CNT       |TDES/DES Byte Count
     * |        |          |The TDES_CNT keeps the byte count of source text that is for the TDES/DES engine operating in DMA mode.
     * |        |          |The TDES_CNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |TDES_CNT can be read and written.
     * |        |          |Writing to TDES_CNT while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next TDES /DES operation.
     * |        |          |In Non-DMA ECB, CBC, CFB, OFB, and CTR mode, TDES_CNT must be set as byte count for the last block of data before feeding in the last block of data.
    */
    __IO uint32_t TDES0_CNT;

    /**
     * TDES_DATIN
     * ===================================================================================================
     * Offset: 0x234  TDES/DES Engine Input data Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DATIN     |TDES/DES Engine Input Port
     * |        |          |CPU feeds data to TDES/DES engine through this port by checking CRPT_TDES_STS.
     * |        |          |Feed data as INBUFFULL is 0.
    */
    __IO uint32_t TDES_DATIN;

    /**
     * TDES_DATOUT
     * ===================================================================================================
     * Offset: 0x238  TDES/DES Engine Output data Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DATOUT    |TDES/DES Engine Output Port
     * |        |          |CPU gets result from the TDES/DES engine through this port by checking CRPT_TDES_STS.
     * |        |          |Get data as OUTBUFEMPTY is 0.
    */
    __I  uint32_t TDES_DATOUT;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TDES1_KEY1H
     * ===================================================================================================
     * Offset: 0x248  TDES/DES Key 1 High Word Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES1_KEY1H;

    /**
     * TDES1_KEY1L
     * ===================================================================================================
     * Offset: 0x24C  TDES/DES Key 1 Low Word Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES1_KEY1L;

    /**
     * TDES1_KEY2H
     * ===================================================================================================
     * Offset: 0x250  TDES Key 2 High Word Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES1_KEY2H;

    /**
     * TDES1_KEY2L
     * ===================================================================================================
     * Offset: 0x254  TDES Key 2 Low Word Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES1_KEY2L;

    /**
     * TDES1_KEY3H
     * ===================================================================================================
     * Offset: 0x258  TDES Key 3 High Word Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES1_KEY3H;

    /**
     * TDES1_KEY3L
     * ===================================================================================================
     * Offset: 0x25C  TDES Key 3 Low Word Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES1_KEY3L;

    /**
     * TDES1_IVH
     * ===================================================================================================
     * Offset: 0x260  TDES/DES Initial Vector High Word Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IVH_IVL   |TDES/DES Initial Vector High/Low Word
     * |        |          |Initial vector (IV) is for TDES/DES engine in CBC, CFB, and OFB mode.
     * |        |          |IV is Nonce counter for TDES/DES engine in CTR mode.
    */
    __IO uint32_t TDES1_IVH;

    /**
     * TDES1_IVL
     * ===================================================================================================
     * Offset: 0x264  TDES/DES Initial Vector Low Word Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IVH_IVL   |TDES/DES Initial Vector High/Low Word
     * |        |          |Initial vector (IV) is for TDES/DES engine in CBC, CFB, and OFB mode.
     * |        |          |IV is Nonce counter for TDES/DES engine in CTR mode.
    */
    __IO uint32_t TDES1_IVL;

    /**
     * TDES1_SADDR
     * ===================================================================================================
     * Offset: 0x268  TDES/DES DMA Source Address Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |TDES/DES DMA Source Address
     * |        |          |The TDES/DES accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The TDES_SADR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the TDES/DES accelerator can read the plain text from system memory and do TDES/DES operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of TDES_SADR are ignored.
     * |        |          |TDES_SADR can be read and written.
     * |        |          |Writing to TDES_SADR while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_SADR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next TDES/DES operation.
     * |        |          |In DMA mode, software can update the next TDES_SADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t TDES1_SADDR;

    /**
     * TDES1_DADDR
     * ===================================================================================================
     * Offset: 0x26C  TDES/DES DMA Destination Address Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DADDR     |TDES/DES DMA Destination Address
     * |        |          |The TDES/DES accelerator supports DMA function to transfer the cipher text between system memory and embedded FIFO.
     * |        |          |The TDES_DADR keeps the destination address of the data buffer where the engine output's text will be stored.
     * |        |          |Based on the destination address, the TDES/DES accelerator can write the cipher text back to system memory after the TDES/DES operation is finished.
     * |        |          |The start of destination address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of TDES_DADR are ignored.
     * |        |          |TDES_DADR can be read and written.
     * |        |          |Writing to TDES_DADR while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_DADR will be updated later on.
     * |        |          |Consequently, software can prepare the destination address for the next TDES/DES operation.
     * |        |          |In DMA mode, software can update the next TDES_DADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t TDES1_DADDR;

    /**
     * TDES1_CNT
     * ===================================================================================================
     * Offset: 0x270  TDES/DES Byte Count Register for Channel 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CNT       |TDES/DES Byte Count
     * |        |          |The TDES_CNT keeps the byte count of source text that is for the TDES/DES engine operating in DMA mode.
     * |        |          |The TDES_CNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |TDES_CNT can be read and written.
     * |        |          |Writing to TDES_CNT while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next TDES /DES operation.
     * |        |          |In Non-DMA ECB, CBC, CFB, OFB, and CTR mode, TDES_CNT must be set as byte count for the last block of data before feeding in the last block of data.
    */
    __IO uint32_t TDES1_CNT;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE3[5];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TDES2_KEY1H
     * ===================================================================================================
     * Offset: 0x288  TDES/DES Key 1 High Word Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES2_KEY1H;

    /**
     * TDES2_KEY1L
     * ===================================================================================================
     * Offset: 0x28C  TDES/DES Key 1 Low Word Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES2_KEY1L;

    /**
     * TDES2_KEY2H
     * ===================================================================================================
     * Offset: 0x290  TDES Key 2 High Word Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES2_KEY2H;

    /**
     * TDES2_KEY2L
     * ===================================================================================================
     * Offset: 0x294  TDES Key 2 Low Word Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES2_KEY2L;

    /**
     * TDES2_KEY3H
     * ===================================================================================================
     * Offset: 0x298  TDES Key 3 High Word Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES2_KEY3H;

    /**
     * TDES2_KEY3L
     * ===================================================================================================
     * Offset: 0x29C  TDES Key 3 Low Word Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES2_KEY3L;

    /**
     * TDES2_IVH
     * ===================================================================================================
     * Offset: 0x2A0  TDES/DES Initial Vector High Word Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IVH_IVL   |TDES/DES Initial Vector High/Low Word
     * |        |          |Initial vector (IV) is for TDES/DES engine in CBC, CFB, and OFB mode.
     * |        |          |IV is Nonce counter for TDES/DES engine in CTR mode.
    */
    __IO uint32_t TDES2_IVH;

    /**
     * TDES2_IVL
     * ===================================================================================================
     * Offset: 0x2A4  TDES/DES Initial Vector Low Word Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IVH_IVL   |TDES/DES Initial Vector High/Low Word
     * |        |          |Initial vector (IV) is for TDES/DES engine in CBC, CFB, and OFB mode.
     * |        |          |IV is Nonce counter for TDES/DES engine in CTR mode.
    */
    __IO uint32_t TDES2_IVL;

    /**
     * TDES2_SADDR
     * ===================================================================================================
     * Offset: 0x2A8  TDES/DES DMA Source Address Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |TDES/DES DMA Source Address
     * |        |          |The TDES/DES accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The TDES_SADR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the TDES/DES accelerator can read the plain text from system memory and do TDES/DES operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of TDES_SADR are ignored.
     * |        |          |TDES_SADR can be read and written.
     * |        |          |Writing to TDES_SADR while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_SADR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next TDES/DES operation.
     * |        |          |In DMA mode, software can update the next TDES_SADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t TDES2_SADDR;

    /**
     * TDES2_DADDR
     * ===================================================================================================
     * Offset: 0x2AC  TDES/DES DMA Destination Address Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DADDR     |TDES/DES DMA Destination Address
     * |        |          |The TDES/DES accelerator supports DMA function to transfer the cipher text between system memory and embedded FIFO.
     * |        |          |The TDES_DADR keeps the destination address of the data buffer where the engine output's text will be stored.
     * |        |          |Based on the destination address, the TDES/DES accelerator can write the cipher text back to system memory after the TDES/DES operation is finished.
     * |        |          |The start of destination address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of TDES_DADR are ignored.
     * |        |          |TDES_DADR can be read and written.
     * |        |          |Writing to TDES_DADR while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_DADR will be updated later on.
     * |        |          |Consequently, software can prepare the destination address for the next TDES/DES operation.
     * |        |          |In DMA mode, software can update the next TDES_DADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t TDES2_DADDR;

    /**
     * TDES2_CNT
     * ===================================================================================================
     * Offset: 0x2B0  TDES/DES Byte Count Register for Channel 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CNT       |TDES/DES Byte Count
     * |        |          |The TDES_CNT keeps the byte count of source text that is for the TDES/DES engine operating in DMA mode.
     * |        |          |The TDES_CNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |TDES_CNT can be read and written.
     * |        |          |Writing to TDES_CNT while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next TDES /DES operation.
     * |        |          |In Non-DMA ECB, CBC, CFB, OFB, and CTR mode, TDES_CNT must be set as byte count for the last block of data before feeding in the last block of data.
    */
    __IO uint32_t TDES2_CNT;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE4[5];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TDES3_KEY1H
     * ===================================================================================================
     * Offset: 0x2C8  TDES/DES Key 1 High Word Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES3_KEY1H;

    /**
     * TDES3_KEY1L
     * ===================================================================================================
     * Offset: 0x2CC  TDES/DES Key 1 Low Word Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES3_KEY1L;

    /**
     * TDES3_KEY2H
     * ===================================================================================================
     * Offset: 0x2D0  TDES Key 2 High Word Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES3_KEY2H;

    /**
     * TDES3_KEY2L
     * ===================================================================================================
     * Offset: 0x2D4  TDES Key 2 Low Word Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES3_KEY2L;

    /**
     * TDES3_KEY3H
     * ===================================================================================================
     * Offset: 0x2D8  TDES Key 3 High Word Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES3_KEY3H;

    /**
     * TDES3_KEY3L
     * ===================================================================================================
     * Offset: 0x2DC  TDES Key 3 Low Word Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYH_KEYL |TDES/DES Key X High/Low Word
     * |        |          |The key registers for TDES/DES algorithm calculation
     * |        |          |The security key for the TDES/DES accelerator is 64 bits.
     * |        |          |Thus, it needs two 32-bit registers to store a security key.
     * |        |          |The register TDES_KEYxH is used to keep the bit [63:32] of security key for the TDES/DES operation, while the register TDES_KEYxL is used to keep the bit [31:0].
    */
    __IO uint32_t TDES3_KEY3L;

    /**
     * TDES3_IVH
     * ===================================================================================================
     * Offset: 0x2E0  TDES/DES Initial Vector High Word Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IVH_IVL   |TDES/DES Initial Vector High/Low Word
     * |        |          |Initial vector (IV) is for TDES/DES engine in CBC, CFB, and OFB mode.
     * |        |          |IV is Nonce counter for TDES/DES engine in CTR mode.
    */
    __IO uint32_t TDES3_IVH;

    /**
     * TDES3_IVL
     * ===================================================================================================
     * Offset: 0x2E4  TDES/DES Initial Vector Low Word Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |IVH_IVL   |TDES/DES Initial Vector High/Low Word
     * |        |          |Initial vector (IV) is for TDES/DES engine in CBC, CFB, and OFB mode.
     * |        |          |IV is Nonce counter for TDES/DES engine in CTR mode.
    */
    __IO uint32_t TDES3_IVL;

    /**
     * TDES3_SADDR
     * ===================================================================================================
     * Offset: 0x2E8  TDES/DES DMA Source Address Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |TDES/DES DMA Source Address
     * |        |          |The TDES/DES accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The TDES_SADR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the TDES/DES accelerator can read the plain text from system memory and do TDES/DES operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of TDES_SADR are ignored.
     * |        |          |TDES_SADR can be read and written.
     * |        |          |Writing to TDES_SADR while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_SADR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next TDES/DES operation.
     * |        |          |In DMA mode, software can update the next TDES_SADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t TDES3_SADDR;

    /**
     * TDES3_DADDR
     * ===================================================================================================
     * Offset: 0x2EC  TDES/DES DMA Destination Address Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DADDR     |TDES/DES DMA Destination Address
     * |        |          |The TDES/DES accelerator supports DMA function to transfer the cipher text between system memory and embedded FIFO.
     * |        |          |The TDES_DADR keeps the destination address of the data buffer where the engine output's text will be stored.
     * |        |          |Based on the destination address, the TDES/DES accelerator can write the cipher text back to system memory after the TDES/DES operation is finished.
     * |        |          |The start of destination address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of TDES_DADR are ignored.
     * |        |          |TDES_DADR can be read and written.
     * |        |          |Writing to TDES_DADR while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_DADR will be updated later on.
     * |        |          |Consequently, software can prepare the destination address for the next TDES/DES operation.
     * |        |          |In DMA mode, software can update the next TDES_DADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t TDES3_DADDR;

    /**
     * TDES3_CNT
     * ===================================================================================================
     * Offset: 0x2F0  TDES/DES Byte Count Register for Channel 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CNT       |TDES/DES Byte Count
     * |        |          |The TDES_CNT keeps the byte count of source text that is for the TDES/DES engine operating in DMA mode.
     * |        |          |The TDES_CNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |TDES_CNT can be read and written.
     * |        |          |Writing to TDES_CNT while the TDES/DES accelerator is operating doesn't affect the current TDES/DES operation.
     * |        |          |But the value of TDES_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next TDES /DES operation.
     * |        |          |In Non-DMA ECB, CBC, CFB, OFB, and CTR mode, TDES_CNT must be set as byte count for the last block of data before feeding in the last block of data.
    */
    __IO uint32_t TDES3_CNT;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE5[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * SHA_CTL
     * ===================================================================================================
     * Offset: 0x300  SHA Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |START     |SHA Engine Start
     * |        |          |0 = No effect.
     * |        |          |1 = Start SHA engine. BUSY flag will be set.
     * |        |          |Note: This bit is always 0 when it's read back.
     * |[1]     |STOP      |SHA Engine Stop
     * |        |          |0 = No effect.
     * |        |          |1 = Stop SHA engine.
     * |        |          |Note: This bit is always 0 when it's read back.
     * |[5]     |DMALAST   |SHA Last Block
     * |        |          |In DMA mode, this bit must be set as beginning the last DMA cascade round.
     * |        |          |In Non-DMA mode, this bit must be set as feeding in last byte of data.
     * |[7]     |DMAEN     |SHA Engine DMA Enable Control
     * |        |          |0 = SHA_DMA engine Disabled.
     * |        |          |The SHA engine operates in Non-DMA mode, and gets data from the port CRPT_SHA_DATIN.
     * |        |          |1 = SHA_DMA engine Enabled.
     * |        |          |The SHA engine operates in DMA mode, and data movement from/to the engine is done by DMA logic.
     * |[8:10]  |OPMODE    |SHA Engine Operation Modes
     * |        |          |000 = SHA160.
     * |        |          |100 = SHA256.
     * |        |          |101 = SHA224.
     * |        |          |Note: These bits can be read and written, but writing to them wouldn't take effect as BUSY is 1.
     * |[22]    |OUTSWAP   |SHA Engine Output Data Swap
     * |        |          |0 = Keep the original order.
     * |        |          |1 = The order that CPU feeds data to the accelerator will be changed from {byte3, byte2, byte1, byte0} to {byte0, byte1, byte2, byte3}.
     * |[23]    |INSWAP    |SHA Engine Input Data Swap
     * |        |          |0 = Keep the original order.
     * |        |          |1 = The order that CPU feeds data to the accelerator will be changed from {byte3, byte2, byte1, byte0} to {byte0, byte1, byte2, byte3}.
    */
    __IO uint32_t SHA_CTL;

    /**
     * SHA_STS
     * ===================================================================================================
     * Offset: 0x304  SHA Status Flag
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BUSY      |SHA Engine Busy
     * |        |          |0 = SHA engine is idle or finished.
     * |        |          |1 = SHA engine is busy.
     * |[1]     |DMABUSY   |SHA Engine DMA Busy Flag
     * |        |          |0 = SHA DMA engine is idle or finished.
     * |        |          |1 = SHA DMA engine is busy.
     * |[8]     |DMAERR    |SHA Engine DMA Error Flag
     * |        |          |0 = Show the SHA engine access normal.
     * |        |          |1 = Show the SHA engine access error.
     * |[16]    |DATINREQ  |SHA Non-DMA Mode Data Input Request
     * |        |          |0 = No effect.
     * |        |          |1 = Request SHA Non-DMA mode data input.
    */
    __I  uint32_t SHA_STS;

    /**
     * SHA_DGST0
     * ===================================================================================================
     * Offset: 0x308  SHA Digest Message 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DGST      |SHA Digest Message Word
     * |        |          |For SHA-160, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST4.
     * |        |          |For SHA-224, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST6.
     * |        |          |For SHA-256, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST7.
    */
    __I  uint32_t SHA_DGST0;

    /**
     * SHA_DGST1
     * ===================================================================================================
     * Offset: 0x30C  SHA Digest Message 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DGST      |SHA Digest Message Word
     * |        |          |For SHA-160, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST4.
     * |        |          |For SHA-224, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST6.
     * |        |          |For SHA-256, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST7.
    */
    __I  uint32_t SHA_DGST1;

    /**
     * SHA_DGST2
     * ===================================================================================================
     * Offset: 0x310  SHA Digest Message 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DGST      |SHA Digest Message Word
     * |        |          |For SHA-160, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST4.
     * |        |          |For SHA-224, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST6.
     * |        |          |For SHA-256, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST7.
    */
    __I  uint32_t SHA_DGST2;

    /**
     * SHA_DGST3
     * ===================================================================================================
     * Offset: 0x314  SHA Digest Message 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DGST      |SHA Digest Message Word
     * |        |          |For SHA-160, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST4.
     * |        |          |For SHA-224, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST6.
     * |        |          |For SHA-256, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST7.
    */
    __I  uint32_t SHA_DGST3;

    /**
     * SHA_DGST4
     * ===================================================================================================
     * Offset: 0x318  SHA Digest Message 4
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DGST      |SHA Digest Message Word
     * |        |          |For SHA-160, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST4.
     * |        |          |For SHA-224, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST6.
     * |        |          |For SHA-256, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST7.
    */
    __I  uint32_t SHA_DGST4;

    /**
     * SHA_DGST5
     * ===================================================================================================
     * Offset: 0x31C  SHA Digest Message 5
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DGST      |SHA Digest Message Word
     * |        |          |For SHA-160, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST4.
     * |        |          |For SHA-224, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST6.
     * |        |          |For SHA-256, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST7.
    */
    __I  uint32_t SHA_DGST5;

    /**
     * SHA_DGST6
     * ===================================================================================================
     * Offset: 0x320  SHA Digest Message 6
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DGST      |SHA Digest Message Word
     * |        |          |For SHA-160, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST4.
     * |        |          |For SHA-224, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST6.
     * |        |          |For SHA-256, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST7.
    */
    __I  uint32_t SHA_DGST6;

    /**
     * SHA_DGST7
     * ===================================================================================================
     * Offset: 0x324  SHA Digest Message 7
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DGST      |SHA Digest Message Word
     * |        |          |For SHA-160, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST4.
     * |        |          |For SHA-224, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST6.
     * |        |          |For SHA-256, the digest is stored in CRPT_SHA_DGST0 ~ CRPT_SHA_DGST7.
    */
    __I  uint32_t SHA_DGST7;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE6[8];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * SHA_KEYCNT
     * ===================================================================================================
     * Offset: 0x348  SHA Key Byte Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEYCNT    |SHA Key Byte Count
     * |        |          |The CRPT_SHA_KEYCNT keeps the byte count of key that SHA engine operates.
     * |        |          |The register is 32-bit and the maximum byte count is 4G bytes.
     * |        |          |It can be read and written.
     * |        |          |Writing to the register CRPT_SHA_KEYCNT as the SHA accelerator operating doesn't affect the current SHA operation.
     * |        |          |But the value of SHA _KEY_CNT will be updated later on.
     * |        |          |Consequently, software can prepare the key count for the next SHA operation.
    */
    __IO uint32_t SHA_KEYCNT;

    /**
     * SHA_SADDR
     * ===================================================================================================
     * Offset: 0x34C  SHA DMA Source Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SADDR     |SHA DMA Source Address
     * |        |          |The SHA accelerator supports DMA function to transfer the plain text between system memory and embedded FIFO.
     * |        |          |The CRPT_SHA_SADDR keeps the source address of the data buffer where the source text is stored.
     * |        |          |Based on the source address, the SHA accelerator can read the plain text from system memory and do SHA operation.
     * |        |          |The start of source address should be located at word boundary.
     * |        |          |In other words, bit 1 and 0 of CRPT_SHA_SADDR are ignored.
     * |        |          |CRPT_SHA_SADDR can be read and written.
     * |        |          |Writing to CRPT_SHA_SADDR while the SHA accelerator is operating doesn't affect the current SHA operation.
     * |        |          |But the value of CRPT_SHA_SADDR will be updated later on.
     * |        |          |Consequently, software can prepare the DMA source address for the next SHA operation.
     * |        |          |In DMA mode, software can update the next TDES_SADR before triggering START.
     * |        |          |TDES_SADR and TDES_DADR can be the same in the value.
    */
    __IO uint32_t SHA_SADDR;

    /**
     * SHA_DMACNT
     * ===================================================================================================
     * Offset: 0x350  SHA Byte Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DMACNT    |SHA Operation Byte Count
     * |        |          |The CRPT_SHA_DMACNT keeps the byte count of source text that is for the SHA engine operating in DMA mode.
     * |        |          |The CRPT_SHA_DMACNT is 32-bit and the maximum of byte count is 4G bytes.
     * |        |          |CRPT_SHA_DMACNT can be read and written.
     * |        |          |Writing to CRPT_SHA_DMACNT while the SHA accelerator is operating doesn't affect the current SHA operation.
     * |        |          |But the value of CRPT_SHA_DMACNT will be updated later on.
     * |        |          |Consequently, software can prepare the byte count of data for the next SHA operation.
     * |        |          |In Non-DMA mode, CRPT_SHA_DMACNT must be set as the byte count of the last block before feeding in the last block of data.
    */
    __IO uint32_t SHA_DMACNT;

    /**
     * SHA_DATIN
     * ===================================================================================================
     * Offset: 0x354  SHA Engine Non-DMA Mode Data Input Port Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DATIN     |SHA Engine Input Port
     * |        |          |CPU feeds data to SHA engine through this port by checking CRPT_SHA_STS. Feed data as DATINREQ is 1.
    */
    __IO uint32_t SHA_DATIN;

} CRPT_T;

/**
    @addtogroup CRPT_CONST CRPT Bit Field Definition
    Constant Definitions for CRPT Controller
@{ */

#define CRPT_INTEN_AESIEN_Pos            (0)                                               /*!< CRPT_T::INTEN: AESIEN Position            */
#define CRPT_INTEN_AESIEN_Msk            (0x1ul << CRPT_INTEN_AESIEN_Pos)                  /*!< CRPT_T::INTEN: AESIEN Mask                */

#define CRPT_INTEN_AESERRIEN_Pos         (1)                                               /*!< CRPT_T::INTEN: AESERRIEN Position         */
#define CRPT_INTEN_AESERRIEN_Msk         (0x1ul << CRPT_INTEN_AESERRIEN_Pos)               /*!< CRPT_T::INTEN: AESERRIEN Mask             */

#define CRPT_INTEN_TDESIEN_Pos           (8)                                               /*!< CRPT_T::INTEN: TDESIEN Position           */
#define CRPT_INTEN_TDESIEN_Msk           (0x1ul << CRPT_INTEN_TDESIEN_Pos)                 /*!< CRPT_T::INTEN: TDESIEN Mask               */

#define CRPT_INTEN_TDESERRIEN_Pos        (9)                                               /*!< CRPT_T::INTEN: TDESERRIEN Position        */
#define CRPT_INTEN_TDESERRIEN_Msk        (0x1ul << CRPT_INTEN_TDESERRIEN_Pos)              /*!< CRPT_T::INTEN: TDESERRIEN Mask            */

#define CRPT_INTEN_PRNGIEN_Pos           (16)                                              /*!< CRPT_T::INTEN: PRNGIEN Position           */
#define CRPT_INTEN_PRNGIEN_Msk           (0x1ul << CRPT_INTEN_PRNGIEN_Pos)                 /*!< CRPT_T::INTEN: PRNGIEN Mask               */

#define CRPT_INTEN_SHAIEN_Pos            (24)                                              /*!< CRPT_T::INTEN: SHAIEN Position            */
#define CRPT_INTEN_SHAIEN_Msk            (0x1ul << CRPT_INTEN_SHAIEN_Pos)                  /*!< CRPT_T::INTEN: SHAIEN Mask                */

#define CRPT_INTEN_SHAERRIEN_Pos         (25)                                              /*!< CRPT_T::INTEN: SHAERRIEN Position         */
#define CRPT_INTEN_SHAERRIEN_Msk         (0x1ul << CRPT_INTEN_SHAERRIEN_Pos)               /*!< CRPT_T::INTEN: SHAERRIEN Mask             */

#define CRPT_INTSTS_AESIF_Pos            (0)                                               /*!< CRPT_T::INTSTS: AESIF Position            */
#define CRPT_INTSTS_AESIF_Msk            (0x1ul << CRPT_INTSTS_AESIF_Pos)                  /*!< CRPT_T::INTSTS: AESIF Mask                */

#define CRPT_INTSTS_AESERRIF_Pos         (1)                                               /*!< CRPT_T::INTSTS: AESERRIF Position         */
#define CRPT_INTSTS_AESERRIF_Msk         (0x1ul << CRPT_INTSTS_AESERRIF_Pos)               /*!< CRPT_T::INTSTS: AESERRIF Mask             */

#define CRPT_INTSTS_TDESIF_Pos           (8)                                               /*!< CRPT_T::INTSTS: TDESIF Position           */
#define CRPT_INTSTS_TDESIF_Msk           (0x1ul << CRPT_INTSTS_TDESIF_Pos)                 /*!< CRPT_T::INTSTS: TDESIF Mask               */

#define CRPT_INTSTS_TDESERRIF_Pos        (9)                                               /*!< CRPT_T::INTSTS: TDESERRIF Position        */
#define CRPT_INTSTS_TDESERRIF_Msk        (0x1ul << CRPT_INTSTS_TDESERRIF_Pos)              /*!< CRPT_T::INTSTS: TDESERRIF Mask            */

#define CRPT_INTSTS_PRNGIF_Pos           (16)                                              /*!< CRPT_T::INTSTS: PRNGIF Position           */
#define CRPT_INTSTS_PRNGIF_Msk           (0x1ul << CRPT_INTSTS_PRNGIF_Pos)                 /*!< CRPT_T::INTSTS: PRNGIF Mask               */

#define CRPT_INTSTS_SHAIF_Pos            (24)                                              /*!< CRPT_T::INTSTS: SHAIF Position            */
#define CRPT_INTSTS_SHAIF_Msk            (0x1ul << CRPT_INTSTS_SHAIF_Pos)                  /*!< CRPT_T::INTSTS: SHAIF Mask                */

#define CRPT_INTSTS_SHAERRIF_Pos         (25)                                              /*!< CRPT_T::INTSTS: SHAERRIF Position         */
#define CRPT_INTSTS_SHAERRIF_Msk         (0x1ul << CRPT_INTSTS_SHAERRIF_Pos)               /*!< CRPT_T::INTSTS: SHAERRIF Mask             */

#define CRPT_PRNG_CTL_START_Pos          (0)                                               /*!< CRPT_T::PRNG_CTL: START Position          */
#define CRPT_PRNG_CTL_START_Msk          (0x1ul << CRPT_PRNG_CTL_START_Pos)                /*!< CRPT_T::PRNG_CTL: START Mask              */

#define CRPT_PRNG_CTL_SEEDRLD_Pos        (1)                                               /*!< CRPT_T::PRNG_CTL: SEEDRLD Position        */
#define CRPT_PRNG_CTL_SEEDRLD_Msk        (0x1ul << CRPT_PRNG_CTL_SEEDRLD_Pos)              /*!< CRPT_T::PRNG_CTL: SEEDRLD Mask            */

#define CRPT_PRNG_CTL_KEYSZ_Pos          (2)                                               /*!< CRPT_T::PRNG_CTL: KEYSZ Position          */
#define CRPT_PRNG_CTL_KEYSZ_Msk          (0x3ul << CRPT_PRNG_CTL_KEYSZ_Pos)                /*!< CRPT_T::PRNG_CTL: KEYSZ Mask              */

#define CRPT_PRNG_CTL_BUSY_Pos           (8)                                               /*!< CRPT_T::PRNG_CTL: BUSY Position           */
#define CRPT_PRNG_CTL_BUSY_Msk           (0x1ul << CRPT_PRNG_CTL_BUSY_Pos)                 /*!< CRPT_T::PRNG_CTL: BUSY Mask               */

#define CRPT_PRNG_SEED_SEED_Pos          (0)                                               /*!< CRPT_T::PRNG_SEED: SEED Position          */
#define CRPT_PRNG_SEED_SEED_Msk          (0xfffffffful << CRPT_PRNG_SEED_SEED_Pos)         /*!< CRPT_T::PRNG_SEED: SEED Mask              */

#define CRPT_PRNG_KEY0_KEY_Pos           (0)                                               /*!< CRPT_T::PRNG_KEY0: KEY Position           */
#define CRPT_PRNG_KEY0_KEY_Msk           (0xfffffffful << CRPT_PRNG_KEY0_KEY_Pos)          /*!< CRPT_T::PRNG_KEY0: KEY Mask               */

#define CRPT_PRNG_KEY1_KEY_Pos           (0)                                               /*!< CRPT_T::PRNG_KEY1: KEY Position           */
#define CRPT_PRNG_KEY1_KEY_Msk           (0xfffffffful << CRPT_PRNG_KEY1_KEY_Pos)          /*!< CRPT_T::PRNG_KEY1: KEY Mask               */

#define CRPT_PRNG_KEY2_KEY_Pos           (0)                                               /*!< CRPT_T::PRNG_KEY2: KEY Position           */
#define CRPT_PRNG_KEY2_KEY_Msk           (0xfffffffful << CRPT_PRNG_KEY2_KEY_Pos)          /*!< CRPT_T::PRNG_KEY2: KEY Mask               */

#define CRPT_PRNG_KEY3_KEY_Pos           (0)                                               /*!< CRPT_T::PRNG_KEY3: KEY Position           */
#define CRPT_PRNG_KEY3_KEY_Msk           (0xfffffffful << CRPT_PRNG_KEY3_KEY_Pos)          /*!< CRPT_T::PRNG_KEY3: KEY Mask               */

#define CRPT_PRNG_KEY4_KEY_Pos           (0)                                               /*!< CRPT_T::PRNG_KEY4: KEY Position           */
#define CRPT_PRNG_KEY4_KEY_Msk           (0xfffffffful << CRPT_PRNG_KEY4_KEY_Pos)          /*!< CRPT_T::PRNG_KEY4: KEY Mask               */

#define CRPT_PRNG_KEY5_KEY_Pos           (0)                                               /*!< CRPT_T::PRNG_KEY5: KEY Position           */
#define CRPT_PRNG_KEY5_KEY_Msk           (0xfffffffful << CRPT_PRNG_KEY5_KEY_Pos)          /*!< CRPT_T::PRNG_KEY5: KEY Mask               */

#define CRPT_PRNG_KEY6_KEY_Pos           (0)                                               /*!< CRPT_T::PRNG_KEY6: KEY Position           */
#define CRPT_PRNG_KEY6_KEY_Msk           (0xfffffffful << CRPT_PRNG_KEY6_KEY_Pos)          /*!< CRPT_T::PRNG_KEY6: KEY Mask               */

#define CRPT_PRNG_KEY7_KEY_Pos           (0)                                               /*!< CRPT_T::PRNG_KEY7: KEY Position           */
#define CRPT_PRNG_KEY7_KEY_Msk           (0xfffffffful << CRPT_PRNG_KEY7_KEY_Pos)          /*!< CRPT_T::PRNG_KEY7: KEY Mask               */

#define CRPT_AES_FDBCK0_FDBCK_Pos        (0)                                               /*!< CRPT_T::AES_FDBCK0: FDBCK Position        */
#define CRPT_AES_FDBCK0_FDBCK_Msk        (0xfffffffful << CRPT_AES_FDBCK0_FDBCK_Pos)       /*!< CRPT_T::AES_FDBCK0: FDBCK Mask            */

#define CRPT_AES_FDBCK1_FDBCK_Pos        (0)                                               /*!< CRPT_T::AES_FDBCK1: FDBCK Position        */
#define CRPT_AES_FDBCK1_FDBCK_Msk        (0xfffffffful << CRPT_AES_FDBCK1_FDBCK_Pos)       /*!< CRPT_T::AES_FDBCK1: FDBCK Mask            */

#define CRPT_AES_FDBCK2_FDBCK_Pos        (0)                                               /*!< CRPT_T::AES_FDBCK2: FDBCK Position        */
#define CRPT_AES_FDBCK2_FDBCK_Msk        (0xfffffffful << CRPT_AES_FDBCK2_FDBCK_Pos)       /*!< CRPT_T::AES_FDBCK2: FDBCK Mask            */

#define CRPT_AES_FDBCK3_FDBCK_Pos        (0)                                               /*!< CRPT_T::AES_FDBCK3: FDBCK Position        */
#define CRPT_AES_FDBCK3_FDBCK_Msk        (0xfffffffful << CRPT_AES_FDBCK3_FDBCK_Pos)       /*!< CRPT_T::AES_FDBCK3: FDBCK Mask            */

#define CRPT_TDES_FDBCKH_FDBCK_Pos       (0)                                               /*!< CRPT_T::TDES_FDBCKH: FDBCK Position       */
#define CRPT_TDES_FDBCKH_FDBCK_Msk       (0xfffffffful << CRPT_TDES_FDBCKH_FDBCK_Pos)      /*!< CRPT_T::TDES_FDBCKH: FDBCK Mask           */

#define CRPT_TDES_FDBCKL_FDBCK_Pos       (0)                                               /*!< CRPT_T::TDES_FDBCKL: FDBCK Position       */
#define CRPT_TDES_FDBCKL_FDBCK_Msk       (0xfffffffful << CRPT_TDES_FDBCKL_FDBCK_Pos)      /*!< CRPT_T::TDES_FDBCKL: FDBCK Mask           */

#define CRPT_AES_CTL_START_Pos           (0)                                               /*!< CRPT_T::AES_CTL: START Position           */
#define CRPT_AES_CTL_START_Msk           (0x1ul << CRPT_AES_CTL_START_Pos)                 /*!< CRPT_T::AES_CTL: START Mask               */

#define CRPT_AES_CTL_STOP_Pos            (1)                                               /*!< CRPT_T::AES_CTL: STOP Position            */
#define CRPT_AES_CTL_STOP_Msk            (0x1ul << CRPT_AES_CTL_STOP_Pos)                  /*!< CRPT_T::AES_CTL: STOP Mask                */

#define CRPT_AES_CTL_KEYSZ_Pos           (2)                                               /*!< CRPT_T::AES_CTL: KEYSZ Position           */
#define CRPT_AES_CTL_KEYSZ_Msk           (0x3ul << CRPT_AES_CTL_KEYSZ_Pos)                 /*!< CRPT_T::AES_CTL: KEYSZ Mask               */

#define CRPT_AES_CTL_DMALAST_Pos         (5)                                               /*!< CRPT_T::AES_CTL: DMALAST Position         */
#define CRPT_AES_CTL_DMALAST_Msk         (0x1ul << CRPT_AES_CTL_DMALAST_Pos)               /*!< CRPT_T::AES_CTL: DMALAST Mask             */

#define CRPT_AES_CTL_DMACSCAD_Pos        (6)                                               /*!< CRPT_T::AES_CTL: DMACSCAD Position        */
#define CRPT_AES_CTL_DMACSCAD_Msk        (0x1ul << CRPT_AES_CTL_DMACSCAD_Pos)              /*!< CRPT_T::AES_CTL: DMACSCAD Mask            */

#define CRPT_AES_CTL_DMAEN_Pos           (7)                                               /*!< CRPT_T::AES_CTL: DMAEN Position           */
#define CRPT_AES_CTL_DMAEN_Msk           (0x1ul << CRPT_AES_CTL_DMAEN_Pos)                 /*!< CRPT_T::AES_CTL: DMAEN Mask               */

#define CRPT_AES_CTL_OPMODE_Pos          (8)                                               /*!< CRPT_T::AES_CTL: OPMODE Position          */
#define CRPT_AES_CTL_OPMODE_Msk          (0xfful << CRPT_AES_CTL_OPMODE_Pos)               /*!< CRPT_T::AES_CTL: OPMODE Mask              */

#define CRPT_AES_CTL_ENCRPT_Pos          (16)                                              /*!< CRPT_T::AES_CTL: ENCRPT Position          */
#define CRPT_AES_CTL_ENCRPT_Msk          (0x1ul << CRPT_AES_CTL_ENCRPT_Pos)                /*!< CRPT_T::AES_CTL: ENCRPT Mask              */

#define CRPT_AES_CTL_OUTSWAP_Pos         (22)                                              /*!< CRPT_T::AES_CTL: OUTSWAP Position         */
#define CRPT_AES_CTL_OUTSWAP_Msk         (0x1ul << CRPT_AES_CTL_OUTSWAP_Pos)               /*!< CRPT_T::AES_CTL: OUTSWAP Mask             */

#define CRPT_AES_CTL_INSWAP_Pos          (23)                                              /*!< CRPT_T::AES_CTL: INSWAP Position          */
#define CRPT_AES_CTL_INSWAP_Msk          (0x1ul << CRPT_AES_CTL_INSWAP_Pos)                /*!< CRPT_T::AES_CTL: INSWAP Mask              */

#define CRPT_AES_CTL_CHANNEL_Pos         (24)                                              /*!< CRPT_T::AES_CTL: CHANNEL Position         */
#define CRPT_AES_CTL_CHANNEL_Msk         (0x3ul << CRPT_AES_CTL_CHANNEL_Pos)               /*!< CRPT_T::AES_CTL: CHANNEL Mask             */

#define CRPT_AES_CTL_KEYUNPRT_Pos        (26)                                              /*!< CRPT_T::AES_CTL: KEYUNPRT Position        */
#define CRPT_AES_CTL_KEYUNPRT_Msk        (0x1ful << CRPT_AES_CTL_KEYUNPRT_Pos)             /*!< CRPT_T::AES_CTL: KEYUNPRT Mask            */

#define CRPT_AES_CTL_KEYPRT_Pos          (31)                                              /*!< CRPT_T::AES_CTL: KEYPRT Position          */
#define CRPT_AES_CTL_KEYPRT_Msk          (0x1ul << CRPT_AES_CTL_KEYPRT_Pos)                /*!< CRPT_T::AES_CTL: KEYPRT Mask              */

#define CRPT_AES_STS_BUSY_Pos            (0)                                               /*!< CRPT_T::AES_STS: BUSY Position            */
#define CRPT_AES_STS_BUSY_Msk            (0x1ul << CRPT_AES_STS_BUSY_Pos)                  /*!< CRPT_T::AES_STS: BUSY Mask                */

#define CRPT_AES_STS_INBUFEMPTY_Pos      (8)                                               /*!< CRPT_T::AES_STS: INBUFEMPTY Position      */
#define CRPT_AES_STS_INBUFEMPTY_Msk      (0x1ul << CRPT_AES_STS_INBUFEMPTY_Pos)            /*!< CRPT_T::AES_STS: INBUFEMPTY Mask          */

#define CRPT_AES_STS_INBUFFULL_Pos       (9)                                               /*!< CRPT_T::AES_STS: INBUFFULL Position       */
#define CRPT_AES_STS_INBUFFULL_Msk       (0x1ul << CRPT_AES_STS_INBUFFULL_Pos)             /*!< CRPT_T::AES_STS: INBUFFULL Mask           */

#define CRPT_AES_STS_INBUFERR_Pos        (10)                                              /*!< CRPT_T::AES_STS: INBUFERR Position        */
#define CRPT_AES_STS_INBUFERR_Msk        (0x1ul << CRPT_AES_STS_INBUFERR_Pos)              /*!< CRPT_T::AES_STS: INBUFERR Mask            */

#define CRPT_AES_STS_CNTERR_Pos          (12)                                              /*!< CRPT_T::AES_STS: CNTERR Position          */
#define CRPT_AES_STS_CNTERR_Msk          (0x1ul << CRPT_AES_STS_CNTERR_Pos)                /*!< CRPT_T::AES_STS: CNTERR Mask              */

#define CRPT_AES_STS_OUTBUFEMPTY_Pos     (16)                                              /*!< CRPT_T::AES_STS: OUTBUFEMPTY Position     */
#define CRPT_AES_STS_OUTBUFEMPTY_Msk     (0x1ul << CRPT_AES_STS_OUTBUFEMPTY_Pos)           /*!< CRPT_T::AES_STS: OUTBUFEMPTY Mask         */

#define CRPT_AES_STS_OUTBUFFULL_Pos      (17)                                              /*!< CRPT_T::AES_STS: OUTBUFFULL Position      */
#define CRPT_AES_STS_OUTBUFFULL_Msk      (0x1ul << CRPT_AES_STS_OUTBUFFULL_Pos)            /*!< CRPT_T::AES_STS: OUTBUFFULL Mask          */

#define CRPT_AES_STS_OUTBUFERR_Pos       (18)                                              /*!< CRPT_T::AES_STS: OUTBUFERR Position       */
#define CRPT_AES_STS_OUTBUFERR_Msk       (0x1ul << CRPT_AES_STS_OUTBUFERR_Pos)             /*!< CRPT_T::AES_STS: OUTBUFERR Mask           */

#define CRPT_AES_STS_BUSERR_Pos          (20)                                              /*!< CRPT_T::AES_STS: BUSERR Position          */
#define CRPT_AES_STS_BUSERR_Msk          (0x1ul << CRPT_AES_STS_BUSERR_Pos)                /*!< CRPT_T::AES_STS: BUSERR Mask              */

#define CRPT_AES_DATIN_DATIN_Pos         (0)                                               /*!< CRPT_T::AES_DATIN: DATIN Position         */
#define CRPT_AES_DATIN_DATIN_Msk         (0xfffffffful << CRPT_AES_DATIN_DATIN_Pos)        /*!< CRPT_T::AES_DATIN: DATIN Mask             */

#define CRPT_AES_DATOUT_DATOUT_Pos       (0)                                               /*!< CRPT_T::AES_DATOUT: DATOUT Position       */
#define CRPT_AES_DATOUT_DATOUT_Msk       (0xfffffffful << CRPT_AES_DATOUT_DATOUT_Pos)      /*!< CRPT_T::AES_DATOUT: DATOUT Mask           */

#define CRPT_AES0_KEY0_KEY_Pos           (0)                                               /*!< CRPT_T::AES0_KEY0: KEY Position           */
#define CRPT_AES0_KEY0_KEY_Msk           (0xfffffffful << CRPT_AES0_KEY0_KEY_Pos)          /*!< CRPT_T::AES0_KEY0: KEY Mask               */

#define CRPT_AES0_KEY1_KEY_Pos           (0)                                               /*!< CRPT_T::AES0_KEY1: KEY Position           */
#define CRPT_AES0_KEY1_KEY_Msk           (0xfffffffful << CRPT_AES0_KEY1_KEY_Pos)          /*!< CRPT_T::AES0_KEY1: KEY Mask               */

#define CRPT_AES0_KEY2_KEY_Pos           (0)                                               /*!< CRPT_T::AES0_KEY2: KEY Position           */
#define CRPT_AES0_KEY2_KEY_Msk           (0xfffffffful << CRPT_AES0_KEY2_KEY_Pos)          /*!< CRPT_T::AES0_KEY2: KEY Mask               */

#define CRPT_AES0_KEY3_KEY_Pos           (0)                                               /*!< CRPT_T::AES0_KEY3: KEY Position           */
#define CRPT_AES0_KEY3_KEY_Msk           (0xfffffffful << CRPT_AES0_KEY3_KEY_Pos)          /*!< CRPT_T::AES0_KEY3: KEY Mask               */

#define CRPT_AES0_KEY4_KEY_Pos           (0)                                               /*!< CRPT_T::AES0_KEY4: KEY Position           */
#define CRPT_AES0_KEY4_KEY_Msk           (0xfffffffful << CRPT_AES0_KEY4_KEY_Pos)          /*!< CRPT_T::AES0_KEY4: KEY Mask               */

#define CRPT_AES0_KEY5_KEY_Pos           (0)                                               /*!< CRPT_T::AES0_KEY5: KEY Position           */
#define CRPT_AES0_KEY5_KEY_Msk           (0xfffffffful << CRPT_AES0_KEY5_KEY_Pos)          /*!< CRPT_T::AES0_KEY5: KEY Mask               */

#define CRPT_AES0_KEY6_KEY_Pos           (0)                                               /*!< CRPT_T::AES0_KEY6: KEY Position           */
#define CRPT_AES0_KEY6_KEY_Msk           (0xfffffffful << CRPT_AES0_KEY6_KEY_Pos)          /*!< CRPT_T::AES0_KEY6: KEY Mask               */

#define CRPT_AES0_KEY7_KEY_Pos           (0)                                               /*!< CRPT_T::AES0_KEY7: KEY Position           */
#define CRPT_AES0_KEY7_KEY_Msk           (0xfffffffful << CRPT_AES0_KEY7_KEY_Pos)          /*!< CRPT_T::AES0_KEY7: KEY Mask               */

#define CRPT_AES0_IV0_IV_Pos             (0)                                               /*!< CRPT_T::AES0_IV0: IV Position             */
#define CRPT_AES0_IV0_IV_Msk             (0xfffffffful << CRPT_AES0_IV0_IV_Pos)            /*!< CRPT_T::AES0_IV0: IV Mask                 */

#define CRPT_AES0_IV1_IV_Pos             (0)                                               /*!< CRPT_T::AES0_IV1: IV Position             */
#define CRPT_AES0_IV1_IV_Msk             (0xfffffffful << CRPT_AES0_IV1_IV_Pos)            /*!< CRPT_T::AES0_IV1: IV Mask                 */

#define CRPT_AES0_IV2_IV_Pos             (0)                                               /*!< CRPT_T::AES0_IV2: IV Position             */
#define CRPT_AES0_IV2_IV_Msk             (0xfffffffful << CRPT_AES0_IV2_IV_Pos)            /*!< CRPT_T::AES0_IV2: IV Mask                 */

#define CRPT_AES0_IV3_IV_Pos             (0)                                               /*!< CRPT_T::AES0_IV3: IV Position             */
#define CRPT_AES0_IV3_IV_Msk             (0xfffffffful << CRPT_AES0_IV3_IV_Pos)            /*!< CRPT_T::AES0_IV3: IV Mask                 */

#define CRPT_AES0_SADDR_SADDR_Pos        (0)                                               /*!< CRPT_T::AES0_SADDR: SADDR Position        */
#define CRPT_AES0_SADDR_SADDR_Msk        (0xfffffffful << CRPT_AES0_SADDR_SADDR_Pos)       /*!< CRPT_T::AES0_SADDR: SADDR Mask            */

#define CRPT_AES0_DADDR_DADDR_Pos        (0)                                               /*!< CRPT_T::AES0_DADDR: DADDR Position        */
#define CRPT_AES0_DADDR_DADDR_Msk        (0xfffffffful << CRPT_AES0_DADDR_DADDR_Pos)       /*!< CRPT_T::AES0_DADDR: DADDR Mask            */

#define CRPT_AES0_CNT_CNT_Pos            (0)                                               /*!< CRPT_T::AES0_CNT: CNT Position            */
#define CRPT_AES0_CNT_CNT_Msk            (0xfffffffful << CRPT_AES0_CNT_CNT_Pos)           /*!< CRPT_T::AES0_CNT: CNT Mask                */

#define CRPT_AES1_KEY0_KEY_Pos           (0)                                               /*!< CRPT_T::AES1_KEY0: KEY Position           */
#define CRPT_AES1_KEY0_KEY_Msk           (0xfffffffful << CRPT_AES1_KEY0_KEY_Pos)          /*!< CRPT_T::AES1_KEY0: KEY Mask               */

#define CRPT_AES1_KEY1_KEY_Pos           (0)                                               /*!< CRPT_T::AES1_KEY1: KEY Position           */
#define CRPT_AES1_KEY1_KEY_Msk           (0xfffffffful << CRPT_AES1_KEY1_KEY_Pos)          /*!< CRPT_T::AES1_KEY1: KEY Mask               */

#define CRPT_AES1_KEY2_KEY_Pos           (0)                                               /*!< CRPT_T::AES1_KEY2: KEY Position           */
#define CRPT_AES1_KEY2_KEY_Msk           (0xfffffffful << CRPT_AES1_KEY2_KEY_Pos)          /*!< CRPT_T::AES1_KEY2: KEY Mask               */

#define CRPT_AES1_KEY3_KEY_Pos           (0)                                               /*!< CRPT_T::AES1_KEY3: KEY Position           */
#define CRPT_AES1_KEY3_KEY_Msk           (0xfffffffful << CRPT_AES1_KEY3_KEY_Pos)          /*!< CRPT_T::AES1_KEY3: KEY Mask               */

#define CRPT_AES1_KEY4_KEY_Pos           (0)                                               /*!< CRPT_T::AES1_KEY4: KEY Position           */
#define CRPT_AES1_KEY4_KEY_Msk           (0xfffffffful << CRPT_AES1_KEY4_KEY_Pos)          /*!< CRPT_T::AES1_KEY4: KEY Mask               */

#define CRPT_AES1_KEY5_KEY_Pos           (0)                                               /*!< CRPT_T::AES1_KEY5: KEY Position           */
#define CRPT_AES1_KEY5_KEY_Msk           (0xfffffffful << CRPT_AES1_KEY5_KEY_Pos)          /*!< CRPT_T::AES1_KEY5: KEY Mask               */

#define CRPT_AES1_KEY6_KEY_Pos           (0)                                               /*!< CRPT_T::AES1_KEY6: KEY Position           */
#define CRPT_AES1_KEY6_KEY_Msk           (0xfffffffful << CRPT_AES1_KEY6_KEY_Pos)          /*!< CRPT_T::AES1_KEY6: KEY Mask               */

#define CRPT_AES1_KEY7_KEY_Pos           (0)                                               /*!< CRPT_T::AES1_KEY7: KEY Position           */
#define CRPT_AES1_KEY7_KEY_Msk           (0xfffffffful << CRPT_AES1_KEY7_KEY_Pos)          /*!< CRPT_T::AES1_KEY7: KEY Mask               */

#define CRPT_AES1_IV0_IV_Pos             (0)                                               /*!< CRPT_T::AES1_IV0: IV Position             */
#define CRPT_AES1_IV0_IV_Msk             (0xfffffffful << CRPT_AES1_IV0_IV_Pos)            /*!< CRPT_T::AES1_IV0: IV Mask                 */

#define CRPT_AES1_IV1_IV_Pos             (0)                                               /*!< CRPT_T::AES1_IV1: IV Position             */
#define CRPT_AES1_IV1_IV_Msk             (0xfffffffful << CRPT_AES1_IV1_IV_Pos)            /*!< CRPT_T::AES1_IV1: IV Mask                 */

#define CRPT_AES1_IV2_IV_Pos             (0)                                               /*!< CRPT_T::AES1_IV2: IV Position             */
#define CRPT_AES1_IV2_IV_Msk             (0xfffffffful << CRPT_AES1_IV2_IV_Pos)            /*!< CRPT_T::AES1_IV2: IV Mask                 */

#define CRPT_AES1_IV3_IV_Pos             (0)                                               /*!< CRPT_T::AES1_IV3: IV Position             */
#define CRPT_AES1_IV3_IV_Msk             (0xfffffffful << CRPT_AES1_IV3_IV_Pos)            /*!< CRPT_T::AES1_IV3: IV Mask                 */

#define CRPT_AES1_SADDR_SADDR_Pos        (0)                                               /*!< CRPT_T::AES1_SADDR: SADDR Position        */
#define CRPT_AES1_SADDR_SADDR_Msk        (0xfffffffful << CRPT_AES1_SADDR_SADDR_Pos)       /*!< CRPT_T::AES1_SADDR: SADDR Mask            */

#define CRPT_AES1_DADDR_DADDR_Pos        (0)                                               /*!< CRPT_T::AES1_DADDR: DADDR Position        */
#define CRPT_AES1_DADDR_DADDR_Msk        (0xfffffffful << CRPT_AES1_DADDR_DADDR_Pos)       /*!< CRPT_T::AES1_DADDR: DADDR Mask            */

#define CRPT_AES1_CNT_CNT_Pos            (0)                                               /*!< CRPT_T::AES1_CNT: CNT Position            */
#define CRPT_AES1_CNT_CNT_Msk            (0xfffffffful << CRPT_AES1_CNT_CNT_Pos)           /*!< CRPT_T::AES1_CNT: CNT Mask                */

#define CRPT_AES2_KEY0_KEY_Pos           (0)                                               /*!< CRPT_T::AES2_KEY0: KEY Position           */
#define CRPT_AES2_KEY0_KEY_Msk           (0xfffffffful << CRPT_AES2_KEY0_KEY_Pos)          /*!< CRPT_T::AES2_KEY0: KEY Mask               */

#define CRPT_AES2_KEY1_KEY_Pos           (0)                                               /*!< CRPT_T::AES2_KEY1: KEY Position           */
#define CRPT_AES2_KEY1_KEY_Msk           (0xfffffffful << CRPT_AES2_KEY1_KEY_Pos)          /*!< CRPT_T::AES2_KEY1: KEY Mask               */

#define CRPT_AES2_KEY2_KEY_Pos           (0)                                               /*!< CRPT_T::AES2_KEY2: KEY Position           */
#define CRPT_AES2_KEY2_KEY_Msk           (0xfffffffful << CRPT_AES2_KEY2_KEY_Pos)          /*!< CRPT_T::AES2_KEY2: KEY Mask               */

#define CRPT_AES2_KEY3_KEY_Pos           (0)                                               /*!< CRPT_T::AES2_KEY3: KEY Position           */
#define CRPT_AES2_KEY3_KEY_Msk           (0xfffffffful << CRPT_AES2_KEY3_KEY_Pos)          /*!< CRPT_T::AES2_KEY3: KEY Mask               */

#define CRPT_AES2_KEY4_KEY_Pos           (0)                                               /*!< CRPT_T::AES2_KEY4: KEY Position           */
#define CRPT_AES2_KEY4_KEY_Msk           (0xfffffffful << CRPT_AES2_KEY4_KEY_Pos)          /*!< CRPT_T::AES2_KEY4: KEY Mask               */

#define CRPT_AES2_KEY5_KEY_Pos           (0)                                               /*!< CRPT_T::AES2_KEY5: KEY Position           */
#define CRPT_AES2_KEY5_KEY_Msk           (0xfffffffful << CRPT_AES2_KEY5_KEY_Pos)          /*!< CRPT_T::AES2_KEY5: KEY Mask               */

#define CRPT_AES2_KEY6_KEY_Pos           (0)                                               /*!< CRPT_T::AES2_KEY6: KEY Position           */
#define CRPT_AES2_KEY6_KEY_Msk           (0xfffffffful << CRPT_AES2_KEY6_KEY_Pos)          /*!< CRPT_T::AES2_KEY6: KEY Mask               */

#define CRPT_AES2_KEY7_KEY_Pos           (0)                                               /*!< CRPT_T::AES2_KEY7: KEY Position           */
#define CRPT_AES2_KEY7_KEY_Msk           (0xfffffffful << CRPT_AES2_KEY7_KEY_Pos)          /*!< CRPT_T::AES2_KEY7: KEY Mask               */

#define CRPT_AES2_IV0_IV_Pos             (0)                                               /*!< CRPT_T::AES2_IV0: IV Position             */
#define CRPT_AES2_IV0_IV_Msk             (0xfffffffful << CRPT_AES2_IV0_IV_Pos)            /*!< CRPT_T::AES2_IV0: IV Mask                 */

#define CRPT_AES2_IV1_IV_Pos             (0)                                               /*!< CRPT_T::AES2_IV1: IV Position             */
#define CRPT_AES2_IV1_IV_Msk             (0xfffffffful << CRPT_AES2_IV1_IV_Pos)            /*!< CRPT_T::AES2_IV1: IV Mask                 */

#define CRPT_AES2_IV2_IV_Pos             (0)                                               /*!< CRPT_T::AES2_IV2: IV Position             */
#define CRPT_AES2_IV2_IV_Msk             (0xfffffffful << CRPT_AES2_IV2_IV_Pos)            /*!< CRPT_T::AES2_IV2: IV Mask                 */

#define CRPT_AES2_IV3_IV_Pos             (0)                                               /*!< CRPT_T::AES2_IV3: IV Position             */
#define CRPT_AES2_IV3_IV_Msk             (0xfffffffful << CRPT_AES2_IV3_IV_Pos)            /*!< CRPT_T::AES2_IV3: IV Mask                 */

#define CRPT_AES2_SADDR_SADDR_Pos        (0)                                               /*!< CRPT_T::AES2_SADDR: SADDR Position        */
#define CRPT_AES2_SADDR_SADDR_Msk        (0xfffffffful << CRPT_AES2_SADDR_SADDR_Pos)       /*!< CRPT_T::AES2_SADDR: SADDR Mask            */

#define CRPT_AES2_DADDR_DADDR_Pos        (0)                                               /*!< CRPT_T::AES2_DADDR: DADDR Position        */
#define CRPT_AES2_DADDR_DADDR_Msk        (0xfffffffful << CRPT_AES2_DADDR_DADDR_Pos)       /*!< CRPT_T::AES2_DADDR: DADDR Mask            */

#define CRPT_AES2_CNT_CNT_Pos            (0)                                               /*!< CRPT_T::AES2_CNT: CNT Position            */
#define CRPT_AES2_CNT_CNT_Msk            (0xfffffffful << CRPT_AES2_CNT_CNT_Pos)           /*!< CRPT_T::AES2_CNT: CNT Mask                */

#define CRPT_AES3_KEY0_KEY_Pos           (0)                                               /*!< CRPT_T::AES3_KEY0: KEY Position           */
#define CRPT_AES3_KEY0_KEY_Msk           (0xfffffffful << CRPT_AES3_KEY0_KEY_Pos)          /*!< CRPT_T::AES3_KEY0: KEY Mask               */

#define CRPT_AES3_KEY1_KEY_Pos           (0)                                               /*!< CRPT_T::AES3_KEY1: KEY Position           */
#define CRPT_AES3_KEY1_KEY_Msk           (0xfffffffful << CRPT_AES3_KEY1_KEY_Pos)          /*!< CRPT_T::AES3_KEY1: KEY Mask               */

#define CRPT_AES3_KEY2_KEY_Pos           (0)                                               /*!< CRPT_T::AES3_KEY2: KEY Position           */
#define CRPT_AES3_KEY2_KEY_Msk           (0xfffffffful << CRPT_AES3_KEY2_KEY_Pos)          /*!< CRPT_T::AES3_KEY2: KEY Mask               */

#define CRPT_AES3_KEY3_KEY_Pos           (0)                                               /*!< CRPT_T::AES3_KEY3: KEY Position           */
#define CRPT_AES3_KEY3_KEY_Msk           (0xfffffffful << CRPT_AES3_KEY3_KEY_Pos)          /*!< CRPT_T::AES3_KEY3: KEY Mask               */

#define CRPT_AES3_KEY4_KEY_Pos           (0)                                               /*!< CRPT_T::AES3_KEY4: KEY Position           */
#define CRPT_AES3_KEY4_KEY_Msk           (0xfffffffful << CRPT_AES3_KEY4_KEY_Pos)          /*!< CRPT_T::AES3_KEY4: KEY Mask               */

#define CRPT_AES3_KEY5_KEY_Pos           (0)                                               /*!< CRPT_T::AES3_KEY5: KEY Position           */
#define CRPT_AES3_KEY5_KEY_Msk           (0xfffffffful << CRPT_AES3_KEY5_KEY_Pos)          /*!< CRPT_T::AES3_KEY5: KEY Mask               */

#define CRPT_AES3_KEY6_KEY_Pos           (0)                                               /*!< CRPT_T::AES3_KEY6: KEY Position           */
#define CRPT_AES3_KEY6_KEY_Msk           (0xfffffffful << CRPT_AES3_KEY6_KEY_Pos)          /*!< CRPT_T::AES3_KEY6: KEY Mask               */

#define CRPT_AES3_KEY7_KEY_Pos           (0)                                               /*!< CRPT_T::AES3_KEY7: KEY Position           */
#define CRPT_AES3_KEY7_KEY_Msk           (0xfffffffful << CRPT_AES3_KEY7_KEY_Pos)          /*!< CRPT_T::AES3_KEY7: KEY Mask               */

#define CRPT_AES3_IV0_IV_Pos             (0)                                               /*!< CRPT_T::AES3_IV0: IV Position             */
#define CRPT_AES3_IV0_IV_Msk             (0xfffffffful << CRPT_AES3_IV0_IV_Pos)            /*!< CRPT_T::AES3_IV0: IV Mask                 */

#define CRPT_AES3_IV1_IV_Pos             (0)                                               /*!< CRPT_T::AES3_IV1: IV Position             */
#define CRPT_AES3_IV1_IV_Msk             (0xfffffffful << CRPT_AES3_IV1_IV_Pos)            /*!< CRPT_T::AES3_IV1: IV Mask                 */

#define CRPT_AES3_IV2_IV_Pos             (0)                                               /*!< CRPT_T::AES3_IV2: IV Position             */
#define CRPT_AES3_IV2_IV_Msk             (0xfffffffful << CRPT_AES3_IV2_IV_Pos)            /*!< CRPT_T::AES3_IV2: IV Mask                 */

#define CRPT_AES3_IV3_IV_Pos             (0)                                               /*!< CRPT_T::AES3_IV3: IV Position             */
#define CRPT_AES3_IV3_IV_Msk             (0xfffffffful << CRPT_AES3_IV3_IV_Pos)            /*!< CRPT_T::AES3_IV3: IV Mask                 */

#define CRPT_AES3_SADDR_SADDR_Pos        (0)                                               /*!< CRPT_T::AES3_SADDR: SADDR Position        */
#define CRPT_AES3_SADDR_SADDR_Msk        (0xfffffffful << CRPT_AES3_SADDR_SADDR_Pos)       /*!< CRPT_T::AES3_SADDR: SADDR Mask            */

#define CRPT_AES3_DADDR_DADDR_Pos        (0)                                               /*!< CRPT_T::AES3_DADDR: DADDR Position        */
#define CRPT_AES3_DADDR_DADDR_Msk        (0xfffffffful << CRPT_AES3_DADDR_DADDR_Pos)       /*!< CRPT_T::AES3_DADDR: DADDR Mask            */

#define CRPT_AES3_CNT_CNT_Pos            (0)                                               /*!< CRPT_T::AES3_CNT: CNT Position            */
#define CRPT_AES3_CNT_CNT_Msk            (0xfffffffful << CRPT_AES3_CNT_CNT_Pos)           /*!< CRPT_T::AES3_CNT: CNT Mask                */

#define CRPT_TDES_CTL_START_Pos          (0)                                               /*!< CRPT_T::TDES_CTL: START Position          */
#define CRPT_TDES_CTL_START_Msk          (0x1ul << CRPT_TDES_CTL_START_Pos)                /*!< CRPT_T::TDES_CTL: START Mask              */

#define CRPT_TDES_CTL_STOP_Pos           (1)                                               /*!< CRPT_T::TDES_CTL: STOP Position           */
#define CRPT_TDES_CTL_STOP_Msk           (0x1ul << CRPT_TDES_CTL_STOP_Pos)                 /*!< CRPT_T::TDES_CTL: STOP Mask               */

#define CRPT_TDES_CTL_TMODE_Pos          (2)                                               /*!< CRPT_T::TDES_CTL: TMODE Position          */
#define CRPT_TDES_CTL_TMODE_Msk          (0x1ul << CRPT_TDES_CTL_TMODE_Pos)                /*!< CRPT_T::TDES_CTL: TMODE Mask              */

#define CRPT_TDES_CTL_3KEYS_Pos          (3)                                               /*!< CRPT_T::TDES_CTL: 3KEYS Position          */
#define CRPT_TDES_CTL_3KEYS_Msk          (0x1ul << CRPT_TDES_CTL_3KEYS_Pos)                /*!< CRPT_T::TDES_CTL: 3KEYS Mask              */

#define CRPT_TDES_CTL_DMALAST_Pos        (5)                                               /*!< CRPT_T::TDES_CTL: DMALAST Position        */
#define CRPT_TDES_CTL_DMALAST_Msk        (0x1ul << CRPT_TDES_CTL_DMALAST_Pos)              /*!< CRPT_T::TDES_CTL: DMALAST Mask            */

#define CRPT_TDES_CTL_DMACSCAD_Pos       (6)                                               /*!< CRPT_T::TDES_CTL: DMACSCAD Position       */
#define CRPT_TDES_CTL_DMACSCAD_Msk       (0x1ul << CRPT_TDES_CTL_DMACSCAD_Pos)             /*!< CRPT_T::TDES_CTL: DMACSCAD Mask           */

#define CRPT_TDES_CTL_DMAEN_Pos          (7)                                               /*!< CRPT_T::TDES_CTL: DMAEN Position          */
#define CRPT_TDES_CTL_DMAEN_Msk          (0x1ul << CRPT_TDES_CTL_DMAEN_Pos)                /*!< CRPT_T::TDES_CTL: DMAEN Mask              */

#define CRPT_TDES_CTL_OPMODE_Pos         (8)                                               /*!< CRPT_T::TDES_CTL: OPMODE Position         */
#define CRPT_TDES_CTL_OPMODE_Msk         (0x7ul << CRPT_TDES_CTL_OPMODE_Pos)               /*!< CRPT_T::TDES_CTL: OPMODE Mask             */

#define CRPT_TDES_CTL_ENCRPT_Pos         (16)                                              /*!< CRPT_T::TDES_CTL: ENCRPT Position         */
#define CRPT_TDES_CTL_ENCRPT_Msk         (0x1ul << CRPT_TDES_CTL_ENCRPT_Pos)               /*!< CRPT_T::TDES_CTL: ENCRPT Mask             */

#define CRPT_TDES_CTL_BLKSWAP_Pos        (21)                                              /*!< CRPT_T::TDES_CTL: BLKSWAP Position        */
#define CRPT_TDES_CTL_BLKSWAP_Msk        (0x1ul << CRPT_TDES_CTL_BLKSWAP_Pos)              /*!< CRPT_T::TDES_CTL: BLKSWAP Mask            */

#define CRPT_TDES_CTL_OUTSWAP_Pos        (22)                                              /*!< CRPT_T::TDES_CTL: OUTSWAP Position        */
#define CRPT_TDES_CTL_OUTSWAP_Msk        (0x1ul << CRPT_TDES_CTL_OUTSWAP_Pos)              /*!< CRPT_T::TDES_CTL: OUTSWAP Mask            */

#define CRPT_TDES_CTL_INSWAP_Pos         (23)                                              /*!< CRPT_T::TDES_CTL: INSWAP Position         */
#define CRPT_TDES_CTL_INSWAP_Msk         (0x1ul << CRPT_TDES_CTL_INSWAP_Pos)               /*!< CRPT_T::TDES_CTL: INSWAP Mask             */

#define CRPT_TDES_CTL_CHANNEL_Pos        (24)                                              /*!< CRPT_T::TDES_CTL: CHANNEL Position        */
#define CRPT_TDES_CTL_CHANNEL_Msk        (0x3ul << CRPT_TDES_CTL_CHANNEL_Pos)              /*!< CRPT_T::TDES_CTL: CHANNEL Mask            */

#define CRPT_TDES_CTL_KEYUNPRT_Pos       (26)                                              /*!< CRPT_T::TDES_CTL: KEYUNPRT Position       */
#define CRPT_TDES_CTL_KEYUNPRT_Msk       (0x1ful << CRPT_TDES_CTL_KEYUNPRT_Pos)            /*!< CRPT_T::TDES_CTL: KEYUNPRT Mask           */

#define CRPT_TDES_CTL_KEYPRT_Pos         (31)                                              /*!< CRPT_T::TDES_CTL: KEYPRT Position         */
#define CRPT_TDES_CTL_KEYPRT_Msk         (0x1ul << CRPT_TDES_CTL_KEYPRT_Pos)               /*!< CRPT_T::TDES_CTL: KEYPRT Mask             */

#define CRPT_TDES_STS_BUSY_Pos           (0)                                               /*!< CRPT_T::TDES_STS: BUSY Position           */
#define CRPT_TDES_STS_BUSY_Msk           (0x1ul << CRPT_TDES_STS_BUSY_Pos)                 /*!< CRPT_T::TDES_STS: BUSY Mask               */

#define CRPT_TDES_STS_INBUFEMPTY_Pos     (8)                                               /*!< CRPT_T::TDES_STS: INBUFEMPTY Position     */
#define CRPT_TDES_STS_INBUFEMPTY_Msk     (0x1ul << CRPT_TDES_STS_INBUFEMPTY_Pos)           /*!< CRPT_T::TDES_STS: INBUFEMPTY Mask         */

#define CRPT_TDES_STS_INBUFFULL_Pos      (9)                                               /*!< CRPT_T::TDES_STS: INBUFFULL Position      */
#define CRPT_TDES_STS_INBUFFULL_Msk      (0x1ul << CRPT_TDES_STS_INBUFFULL_Pos)            /*!< CRPT_T::TDES_STS: INBUFFULL Mask          */

#define CRPT_TDES_STS_INBUFERR_Pos       (10)                                              /*!< CRPT_T::TDES_STS: INBUFERR Position       */
#define CRPT_TDES_STS_INBUFERR_Msk       (0x1ul << CRPT_TDES_STS_INBUFERR_Pos)             /*!< CRPT_T::TDES_STS: INBUFERR Mask           */

#define CRPT_TDES_STS_OUTBUFEMPTY_Pos    (16)                                              /*!< CRPT_T::TDES_STS: OUTBUFEMPTY Position    */
#define CRPT_TDES_STS_OUTBUFEMPTY_Msk    (0x1ul << CRPT_TDES_STS_OUTBUFEMPTY_Pos)          /*!< CRPT_T::TDES_STS: OUTBUFEMPTY Mask        */

#define CRPT_TDES_STS_OUTBUFFULL_Pos     (17)                                              /*!< CRPT_T::TDES_STS: OUTBUFFULL Position     */
#define CRPT_TDES_STS_OUTBUFFULL_Msk     (0x1ul << CRPT_TDES_STS_OUTBUFFULL_Pos)           /*!< CRPT_T::TDES_STS: OUTBUFFULL Mask         */

#define CRPT_TDES_STS_OUTBUFERR_Pos      (18)                                              /*!< CRPT_T::TDES_STS: OUTBUFERR Position      */
#define CRPT_TDES_STS_OUTBUFERR_Msk      (0x1ul << CRPT_TDES_STS_OUTBUFERR_Pos)            /*!< CRPT_T::TDES_STS: OUTBUFERR Mask          */

#define CRPT_TDES_STS_BUSERR_Pos         (20)                                              /*!< CRPT_T::TDES_STS: BUSERR Position         */
#define CRPT_TDES_STS_BUSERR_Msk         (0x1ul << CRPT_TDES_STS_BUSERR_Pos)               /*!< CRPT_T::TDES_STS: BUSERR Mask             */

#define CRPT_TDES0_KEY1H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES0_KEY1H: KEY Position         */
#define CRPT_TDES0_KEY1H_KEY_Msk         (0xfffffffful << CRPT_TDES0_KEY1H_KEY_Pos)        /*!< CRPT_T::TDES0_KEY1H: KEY Mask             */

#define CRPT_TDES0_KEY1L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES0_KEY1L: KEY Position         */
#define CRPT_TDES0_KEY1L_KEY_Msk         (0xfffffffful << CRPT_TDES0_KEY1L_KEY_Pos)        /*!< CRPT_T::TDES0_KEY1L: KEY Mask             */

#define CRPT_TDES0_KEY2H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES0_KEY2H: KEY Position         */
#define CRPT_TDES0_KEY2H_KEY_Msk         (0xfffffffful << CRPT_TDES0_KEY2H_KEY_Pos)        /*!< CRPT_T::TDES0_KEY2H: KEY Mask             */

#define CRPT_TDES0_KEY2L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES0_KEY2L: KEY Position         */
#define CRPT_TDES0_KEY2L_KEY_Msk         (0xfffffffful << CRPT_TDES0_KEY2L_KEY_Pos)        /*!< CRPT_T::TDES0_KEY2L: KEY Mask             */

#define CRPT_TDES0_KEY3H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES0_KEY3H: KEY Position         */
#define CRPT_TDES0_KEY3H_KEY_Msk         (0xfffffffful << CRPT_TDES0_KEY3H_KEY_Pos)        /*!< CRPT_T::TDES0_KEY3H: KEY Mask             */

#define CRPT_TDES0_KEY3L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES0_KEY3L: KEY Position         */
#define CRPT_TDES0_KEY3L_KEY_Msk         (0xfffffffful << CRPT_TDES0_KEY3L_KEY_Pos)        /*!< CRPT_T::TDES0_KEY3L: KEY Mask             */

#define CRPT_TDES0_IVH_IV_Pos            (0)                                               /*!< CRPT_T::TDES0_IVH: IV Position            */
#define CRPT_TDES0_IVH_IV_Msk            (0xfffffffful << CRPT_TDES0_IVH_IV_Pos)           /*!< CRPT_T::TDES0_IVH: IV Mask                */

#define CRPT_TDES0_IVL_IV_Pos            (0)                                               /*!< CRPT_T::TDES0_IVL: IV Position            */
#define CRPT_TDES0_IVL_IV_Msk            (0xfffffffful << CRPT_TDES0_IVL_IV_Pos)           /*!< CRPT_T::TDES0_IVL: IV Mask                */

#define CRPT_TDES0_SADDR_SADDR_Pos       (0)                                               /*!< CRPT_T::TDES0_SADDR: SADDR Position       */
#define CRPT_TDES0_SADDR_SADDR_Msk       (0xfffffffful << CRPT_TDES0_SADDR_SADDR_Pos)      /*!< CRPT_T::TDES0_SADDR: SADDR Mask           */

#define CRPT_TDES0_DADDR_DADDR_Pos       (0)                                               /*!< CRPT_T::TDES0_DADDR: DADDR Position       */
#define CRPT_TDES0_DADDR_DADDR_Msk       (0xfffffffful << CRPT_TDES0_DADDR_DADDR_Pos)      /*!< CRPT_T::TDES0_DADDR: DADDR Mask           */

#define CRPT_TDES0_CNT_CNT_Pos           (0)                                               /*!< CRPT_T::TDES0_CNT: CNT Position           */
#define CRPT_TDES0_CNT_CNT_Msk           (0xfffffffful << CRPT_TDES0_CNT_CNT_Pos)          /*!< CRPT_T::TDES0_CNT: CNT Mask               */

#define CRPT_TDES_DATIN_DATIN_Pos        (0)                                               /*!< CRPT_T::TDES_DATIN: DATIN Position        */
#define CRPT_TDES_DATIN_DATIN_Msk        (0xfffffffful << CRPT_TDES_DATIN_DATIN_Pos)       /*!< CRPT_T::TDES_DATIN: DATIN Mask            */

#define CRPT_TDES_DATOUT_DATOUT_Pos      (0)                                               /*!< CRPT_T::TDES_DATOUT: DATOUT Position      */
#define CRPT_TDES_DATOUT_DATOUT_Msk      (0xfffffffful << CRPT_TDES_DATOUT_DATOUT_Pos)     /*!< CRPT_T::TDES_DATOUT: DATOUT Mask          */

#define CRPT_TDES1_KEY1H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES1_KEY1H: KEY Position         */
#define CRPT_TDES1_KEY1H_KEY_Msk         (0xfffffffful << CRPT_TDES1_KEY1H_KEY_Pos)        /*!< CRPT_T::TDES1_KEY1H: KEY Mask             */

#define CRPT_TDES1_KEY1L_KEYL_Pos        (0)                                               /*!< CRPT_T::TDES1_KEY1L: KEY Position         */
#define CRPT_TDES1_KEY1L_KEY_Msk         (0xfffffffful << CRPT_TDES1_KEY1L_KEY_Pos)        /*!< CRPT_T::TDES1_KEY1L: KEY Mask             */

#define CRPT_TDES1_KEY2H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES1_KEY2H: KEY Position         */
#define CRPT_TDES1_KEY2H_KEY_Msk         (0xfffffffful << CRPT_TDES1_KEY2H_KEY_Pos)        /*!< CRPT_T::TDES1_KEY2H: KEY Mask             */

#define CRPT_TDES1_KEY2L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES1_KEY2L: KEY Position         */
#define CRPT_TDES1_KEY2L_KEY_Msk         (0xfffffffful << CRPT_TDES1_KEY2L_KEY_Pos)        /*!< CRPT_T::TDES1_KEY2L: KEY Mask             */

#define CRPT_TDES1_KEY3H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES1_KEY3H: KEY Position         */
#define CRPT_TDES1_KEY3H_KEY_Msk         (0xfffffffful << CRPT_TDES1_KEY3H_KEY_Pos)        /*!< CRPT_T::TDES1_KEY3H: KEY Mask             */

#define CRPT_TDES1_KEY3L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES1_KEY3L: KEY Position         */
#define CRPT_TDES1_KEY3L_KEY_Msk         (0xfffffffful << CRPT_TDES1_KEY3L_KEY_Pos)        /*!< CRPT_T::TDES1_KEY3L: KEY Mask             */

#define CRPT_TDES1_IVH_IV_Pos            (0)                                               /*!< CRPT_T::TDES1_IVH: IV Position            */
#define CRPT_TDES1_IVH_IV_Msk            (0xfffffffful << CRPT_TDES1_IVH_IV_Pos)           /*!< CRPT_T::TDES1_IVH: IV Mask                */

#define CRPT_TDES1_IVL_IV_Pos            (0)                                               /*!< CRPT_T::TDES1_IVL: IV Position            */
#define CRPT_TDES1_IVL_IV_Msk            (0xfffffffful << CRPT_TDES1_IVL_IV_Pos)           /*!< CRPT_T::TDES1_IVL: IV Mask                */

#define CRPT_TDES1_SADDR_SADDR_Pos       (0)                                               /*!< CRPT_T::TDES1_SADDR: SADDR Position       */
#define CRPT_TDES1_SADDR_SADDR_Msk       (0xfffffffful << CRPT_TDES1_SADDR_SADDR_Pos)      /*!< CRPT_T::TDES1_SADDR: SADDR Mask           */

#define CRPT_TDES1_DADDR_DADDR_Pos       (0)                                               /*!< CRPT_T::TDES1_DADDR: DADDR Position       */
#define CRPT_TDES1_DADDR_DADDR_Msk       (0xfffffffful << CRPT_TDES1_DADDR_DADDR_Pos)      /*!< CRPT_T::TDES1_DADDR: DADDR Mask           */

#define CRPT_TDES1_CNT_CNT_Pos           (0)                                               /*!< CRPT_T::TDES1_CNT: CNT Position           */
#define CRPT_TDES1_CNT_CNT_Msk           (0xfffffffful << CRPT_TDES1_CNT_CNT_Pos)          /*!< CRPT_T::TDES1_CNT: CNT Mask               */

#define CRPT_TDES2_KEY1H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES2_KEY1H: KEY Position         */
#define CRPT_TDES2_KEY1H_KEY_Msk         (0xfffffffful << CRPT_TDES2_KEY1H_KEY_Pos)        /*!< CRPT_T::TDES2_KEY1H: KEY Mask             */

#define CRPT_TDES2_KEY1L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES2_KEY1L: KEY Position         */
#define CRPT_TDES2_KEY1L_KEY_Msk         (0xfffffffful << CRPT_TDES2_KEY1L_KEY_Pos)        /*!< CRPT_T::TDES2_KEY1L: KEY Mask             */

#define CRPT_TDES2_KEY2H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES2_KEY2H: KEY Position         */
#define CRPT_TDES2_KEY2H_KEY_Msk         (0xfffffffful << CRPT_TDES2_KEY2H_KEY_Pos)        /*!< CRPT_T::TDES2_KEY2H: KEY Mask             */

#define CRPT_TDES2_KEY2L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES2_KEY2L: KEY Position         */
#define CRPT_TDES2_KEY2L_KEY_Msk         (0xfffffffful << CRPT_TDES2_KEY2L_KEY_Pos)        /*!< CRPT_T::TDES2_KEY2L: KEY Mask             */

#define CRPT_TDES2_KEY3H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES2_KEY3H: KEY Position         */
#define CRPT_TDES2_KEY3H_KEY_Msk         (0xfffffffful << CRPT_TDES2_KEY3H_KEY_Pos)        /*!< CRPT_T::TDES2_KEY3H: KEY Mask             */

#define CRPT_TDES2_KEY3L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES2_KEY3L: KEY Position         */
#define CRPT_TDES2_KEY3L_KEY_Msk         (0xfffffffful << CRPT_TDES2_KEY3L_KEY_Pos)        /*!< CRPT_T::TDES2_KEY3L: KEY Mask             */

#define CRPT_TDES2_IVH_IV_Pos            (0)                                               /*!< CRPT_T::TDES2_IVH: IV Position            */
#define CRPT_TDES2_IVH_IV_Msk            (0xfffffffful << CRPT_TDES2_IVH_IV_Pos)           /*!< CRPT_T::TDES2_IVH: IV Mask                */

#define CRPT_TDES2_IVL_IV_Pos            (0)                                               /*!< CRPT_T::TDES2_IVL: IV Position            */
#define CRPT_TDES2_IVL_IV_Msk            (0xfffffffful << CRPT_TDES2_IVL_IV_Pos)           /*!< CRPT_T::TDES2_IVL: IV Mask                */

#define CRPT_TDES2_SADDR_SADDR_Pos       (0)                                               /*!< CRPT_T::TDES2_SADDR: SADDR Position       */
#define CRPT_TDES2_SADDR_SADDR_Msk       (0xfffffffful << CRPT_TDES2_SADDR_SADDR_Pos)      /*!< CRPT_T::TDES2_SADDR: SADDR Mask           */

#define CRPT_TDES2_DADDR_DADDR_Pos       (0)                                               /*!< CRPT_T::TDES2_DADDR: DADDR Position       */
#define CRPT_TDES2_DADDR_DADDR_Msk       (0xfffffffful << CRPT_TDES2_DADDR_DADDR_Pos)      /*!< CRPT_T::TDES2_DADDR: DADDR Mask           */

#define CRPT_TDES2_CNT_CNT_Pos           (0)                                               /*!< CRPT_T::TDES2_CNT: CNT Position           */
#define CRPT_TDES2_CNT_CNT_Msk           (0xfffffffful << CRPT_TDES2_CNT_CNT_Pos)          /*!< CRPT_T::TDES2_CNT: CNT Mask               */

#define CRPT_TDES3_KEY1H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES3_KEY1H: KEY Position         */
#define CRPT_TDES3_KEY1H_KEY_Msk         (0xfffffffful << CRPT_TDES3_KEY1H_KEY_Pos)        /*!< CRPT_T::TDES3_KEY1H: KEY Mask             */

#define CRPT_TDES3_KEY1L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES3_KEY1L: KEY Position         */
#define CRPT_TDES3_KEY1L_KEY_Msk         (0xfffffffful << CRPT_TDES3_KEY1L_KEY_Pos)        /*!< CRPT_T::TDES3_KEY1L: KEY Mask             */

#define CRPT_TDES3_KEY2H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES3_KEY2H: KEY Position         */
#define CRPT_TDES3_KEY2H_KEY_Msk         (0xfffffffful << CRPT_TDES3_KEY2H_KEY_Pos)        /*!< CRPT_T::TDES3_KEY2H: KEY Mask             */

#define CRPT_TDES3_KEY2L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES3_KEY2L: KEY Position         */
#define CRPT_TDES3_KEY2L_KEY_Msk         (0xfffffffful << CRPT_TDES3_KEY2L_KEY_Pos)        /*!< CRPT_T::TDES3_KEY2L: KEY Mask             */

#define CRPT_TDES3_KEY3H_KEY_Pos         (0)                                               /*!< CRPT_T::TDES3_KEY3H: KEY Position         */
#define CRPT_TDES3_KEY3H_KEY_Msk         (0xfffffffful << CRPT_TDES3_KEY3H_KEY_Pos)        /*!< CRPT_T::TDES3_KEY3H: KEY Mask             */

#define CRPT_TDES3_KEY3L_KEY_Pos         (0)                                               /*!< CRPT_T::TDES3_KEY3L: KEY Position         */
#define CRPT_TDES3_KEY3L_KEY_Msk         (0xfffffffful << CRPT_TDES3_KEY3L_KEY_Pos)        /*!< CRPT_T::TDES3_KEY3L: KEY Mask             */

#define CRPT_TDES3_IVH_IV_Pos            (0)                                               /*!< CRPT_T::TDES3_IVH: IV Position            */
#define CRPT_TDES3_IVH_IV_Msk            (0xfffffffful << CRPT_TDES3_IVH_IV_Pos)           /*!< CRPT_T::TDES3_IVH: IV Mask                */

#define CRPT_TDES3_IVL_IV_Pos            (0)                                               /*!< CRPT_T::TDES3_IVL: IV Position            */
#define CRPT_TDES3_IVL_IV_Msk            (0xfffffffful << CRPT_TDES3_IVL_IV_Pos)           /*!< CRPT_T::TDES3_IVL: IV Mask                */

#define CRPT_TDES3_SADDR_SADDR_Pos       (0)                                               /*!< CRPT_T::TDES3_SADDR: SADDR Position       */
#define CRPT_TDES3_SADDR_SADDR_Msk       (0xfffffffful << CRPT_TDES3_SADDR_SADDR_Pos)      /*!< CRPT_T::TDES3_SADDR: SADDR Mask           */

#define CRPT_TDES3_DADDR_DADDR_Pos       (0)                                               /*!< CRPT_T::TDES3_DADDR: DADDR Position       */
#define CRPT_TDES3_DADDR_DADDR_Msk       (0xfffffffful << CRPT_TDES3_DADDR_DADDR_Pos)      /*!< CRPT_T::TDES3_DADDR: DADDR Mask           */

#define CRPT_TDES3_CNT_CNT_Pos           (0)                                               /*!< CRPT_T::TDES3_CNT: CNT Position           */
#define CRPT_TDES3_CNT_CNT_Msk           (0xfffffffful << CRPT_TDES3_CNT_CNT_Pos)          /*!< CRPT_T::TDES3_CNT: CNT Mask               */

#define CRPT_SHA_CTL_START_Pos           (0)                                               /*!< CRPT_T::SHA_CTL: START Position           */
#define CRPT_SHA_CTL_START_Msk           (0x1ul << CRPT_SHA_CTL_START_Pos)                 /*!< CRPT_T::SHA_CTL: START Mask               */

#define CRPT_SHA_CTL_STOP_Pos            (1)                                               /*!< CRPT_T::SHA_CTL: STOP Position            */
#define CRPT_SHA_CTL_STOP_Msk            (0x1ul << CRPT_SHA_CTL_STOP_Pos)                  /*!< CRPT_T::SHA_CTL: STOP Mask                */

#define CRPT_SHA_CTL_DMALAST_Pos         (5)                                               /*!< CRPT_T::SHA_CTL: DMALAST Position         */
#define CRPT_SHA_CTL_DMALAST_Msk         (0x1ul << CRPT_SHA_CTL_DMALAST_Pos)               /*!< CRPT_T::SHA_CTL: DMALAST Mask             */

#define CRPT_SHA_CTL_DMAEN_Pos           (7)                                               /*!< CRPT_T::SHA_CTL: DMAEN Position           */
#define CRPT_SHA_CTL_DMAEN_Msk           (0x1ul << CRPT_SHA_CTL_DMAEN_Pos)                 /*!< CRPT_T::SHA_CTL: DMAEN Mask               */

#define CRPT_SHA_CTL_OPMODE_Pos          (8)                                               /*!< CRPT_T::SHA_CTL: OPMODE Position          */
#define CRPT_SHA_CTL_OPMODE_Msk          (0x7ul << CRPT_SHA_CTL_OPMODE_Pos)                /*!< CRPT_T::SHA_CTL: OPMODE Mask              */

#define CRPT_SHA_CTL_OUTSWAP_Pos         (22)                                              /*!< CRPT_T::SHA_CTL: OUTSWAP Position         */
#define CRPT_SHA_CTL_OUTSWAP_Msk         (0x1ul << CRPT_SHA_CTL_OUTSWAP_Pos)               /*!< CRPT_T::SHA_CTL: OUTSWAP Mask             */

#define CRPT_SHA_CTL_INSWAP_Pos          (23)                                              /*!< CRPT_T::SHA_CTL: INSWAP Position          */
#define CRPT_SHA_CTL_INSWAP_Msk          (0x1ul << CRPT_SHA_CTL_INSWAP_Pos)                /*!< CRPT_T::SHA_CTL: INSWAP Mask              */

#define CRPT_SHA_STS_BUSY_Pos            (0)                                               /*!< CRPT_T::SHA_STS: BUSY Position            */
#define CRPT_SHA_STS_BUSY_Msk            (0x1ul << CRPT_SHA_STS_BUSY_Pos)                  /*!< CRPT_T::SHA_STS: BUSY Mask                */

#define CRPT_SHA_STS_DMABUSY_Pos         (1)                                               /*!< CRPT_T::SHA_STS: DMABUSY Position         */
#define CRPT_SHA_STS_DMABUSY_Msk         (0x1ul << CRPT_SHA_STS_DMABUSY_Pos)               /*!< CRPT_T::SHA_STS: DMABUSY Mask             */

#define CRPT_SHA_STS_DMAERR_Pos          (8)                                               /*!< CRPT_T::SHA_STS: DMAERR Position          */
#define CRPT_SHA_STS_DMAERR_Msk          (0x1ul << CRPT_SHA_STS_DMAERR_Pos)                /*!< CRPT_T::SHA_STS: DMAERR Mask              */

#define CRPT_SHA_STS_DATINREQ_Pos        (16)                                              /*!< CRPT_T::SHA_STS: DATINREQ Position        */
#define CRPT_SHA_STS_DATINREQ_Msk        (0x1ul << CRPT_SHA_STS_DATINREQ_Pos)              /*!< CRPT_T::SHA_STS: DATINREQ Mask            */

#define CRPT_SHA_DGST0_DGST_Pos          (0)                                               /*!< CRPT_T::SHA_DGST0: DGST Position          */
#define CRPT_SHA_DGST0_DGST_Msk          (0xfffffffful << CRPT_SHA_DGST0_DGST_Pos)         /*!< CRPT_T::SHA_DGST0: DGST Mask              */

#define CRPT_SHA_DGST1_DGST_Pos          (0)                                               /*!< CRPT_T::SHA_DGST1: DGST Position          */
#define CRPT_SHA_DGST1_DGST_Msk          (0xfffffffful << CRPT_SHA_DGST1_DGST_Pos)         /*!< CRPT_T::SHA_DGST1: DGST Mask              */

#define CRPT_SHA_DGST2_DGST_Pos          (0)                                               /*!< CRPT_T::SHA_DGST2: DGST Position          */
#define CRPT_SHA_DGST2_DGST_Msk          (0xfffffffful << CRPT_SHA_DGST2_DGST_Pos)         /*!< CRPT_T::SHA_DGST2: DGST Mask              */

#define CRPT_SHA_DGST3_DGST_Pos          (0)                                               /*!< CRPT_T::SHA_DGST3: DGST Position          */
#define CRPT_SHA_DGST3_DGST_Msk          (0xfffffffful << CRPT_SHA_DGST3_DGST_Pos)         /*!< CRPT_T::SHA_DGST3: DGST Mask              */

#define CRPT_SHA_DGST4_DGST_Pos          (0)                                               /*!< CRPT_T::SHA_DGST4: DGST Position          */
#define CRPT_SHA_DGST4_DGST_Msk          (0xfffffffful << CRPT_SHA_DGST4_DGST_Pos)         /*!< CRPT_T::SHA_DGST4: DGST Mask              */

#define CRPT_SHA_DGST5_DGST_Pos          (0)                                               /*!< CRPT_T::SHA_DGST5: DGST Position          */
#define CRPT_SHA_DGST5_DGST_Msk          (0xfffffffful << CRPT_SHA_DGST5_DGST_Pos)         /*!< CRPT_T::SHA_DGST5: DGST Mask              */

#define CRPT_SHA_DGST6_DGST_Pos          (0)                                               /*!< CRPT_T::SHA_DGST6: DGST Position          */
#define CRPT_SHA_DGST6_DGST_Msk          (0xfffffffful << CRPT_SHA_DGST6_DGST_Pos)         /*!< CRPT_T::SHA_DGST6: DGST Mask              */

#define CRPT_SHA_DGST7_DGST_Pos          (0)                                               /*!< CRPT_T::SHA_DGST7: DGST Position          */
#define CRPT_SHA_DGST7_DGST_Msk          (0xfffffffful << CRPT_SHA_DGST7_DGST_Pos)         /*!< CRPT_T::SHA_DGST7: DGST Mask              */

#define CRPT_SHA_KEYCNT_KEYCNT_Pos       (0)                                               /*!< CRPT_T::SHA_KEYCNT: KEYCNT Position       */
#define CRPT_SHA_KEYCNT_KEYCNT_Msk       (0xfffffffful << CRPT_SHA_KEYCNT_KEYCNT_Pos)      /*!< CRPT_T::SHA_KEYCNT: KEYCNT Mask           */

#define CRPT_SHA_SADDR_SADDR_Pos         (0)                                               /*!< CRPT_T::SHA_SADDR: SADDR Position         */
#define CRPT_SHA_SADDR_SADDR_Msk         (0xfffffffful << CRPT_SHA_SADDR_SADDR_Pos)        /*!< CRPT_T::SHA_SADDR: SADDR Mask             */

#define CRPT_SHA_DMACNT_DMACNT_Pos       (0)                                               /*!< CRPT_T::SHA_DMACNT: DMACNT Position       */
#define CRPT_SHA_DMACNT_DMACNT_Msk       (0xfffffffful << CRPT_SHA_DMACNT_DMACNT_Pos)      /*!< CRPT_T::SHA_DMACNT: DMACNT Mask           */

#define CRPT_SHA_DATIN_DATIN_Pos         (0)                                               /*!< CRPT_T::SHA_DATIN: DATIN Position         */
#define CRPT_SHA_DATIN_DATIN_Msk         (0xfffffffful << CRPT_SHA_DATIN_DATIN_Pos)        /*!< CRPT_T::SHA_DATIN: DATIN Mask             */

/**@}*/ /* CRPT_CONST */
/**@}*/ /* end of CRPT register group */


/*---------------------- Enhanced Analog to Digital Converter -------------------------*/
/**
    @addtogroup EADC Enhanced Analog to Digital Converter(EADC)
    Memory Mapped Structure for EADC Controller
@{ */

typedef struct {


    /**
     * AD0DAT0
     * ===================================================================================================
     * Offset: 0x00  A/D Data Register 0 for SAMPLE00
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DAT0;

    /**
     * AD0DAT1
     * ===================================================================================================
     * Offset: 0x04  A/D Data Register 1 for SAMPLE01
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DAT1;

    /**
     * AD0DAT2
     * ===================================================================================================
     * Offset: 0x08  A/D Data Register 2 for SAMPLE02
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DAT2;

    /**
     * AD0DAT3
     * ===================================================================================================
     * Offset: 0x0C  A/D Data Register 3 for SAMPLE03
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DAT3;

    /**
     * AD0DAT4
     * ===================================================================================================
     * Offset: 0x10  A/D Data Register 4 for SAMPLE04
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DAT4;

    /**
     * AD0DAT5
     * ===================================================================================================
     * Offset: 0x14  A/D Data Register 5 for SAMPLE05
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DAT5;

    /**
     * AD0DAT6
     * ===================================================================================================
     * Offset: 0x18  A/D Data Register 6 for SAMPLE06
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DAT6;

    /**
     * AD0DAT7
     * ===================================================================================================
     * Offset: 0x1C  A/D Data Register 7 for SAMPLE07
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DAT7;

    /**
     * AD1DAT0
     * ===================================================================================================
     * Offset: 0x20  A/D Data Register 8 for SAMPLE10
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DAT0;

    /**
     * AD1DAT1
     * ===================================================================================================
     * Offset: 0x24  A/D Data Register 9 for SAMPLE11
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DAT1;

    /**
     * AD1DAT2
     * ===================================================================================================
     * Offset: 0x28  A/D Data Register 10 for SAMPLE12
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DAT2;

    /**
     * AD1DAT3
     * ===================================================================================================
     * Offset: 0x2C  A/D Data Register 11 for SAMPLE13
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DAT3;

    /**
     * AD1DAT4
     * ===================================================================================================
     * Offset: 0x30  A/D Data Register 12 for SAMPLE14
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DAT4;

    /**
     * AD1DAT5
     * ===================================================================================================
     * Offset: 0x34  A/D Data Register 13 for SAMPLE15
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DAT5;

    /**
     * AD1DAT6
     * ===================================================================================================
     * Offset: 0x38  A/D Data Register 14 for SAMPLE16
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DAT6;

    /**
     * AD1DAT7
     * ===================================================================================================
     * Offset: 0x3C  A/D Data Register 15 for SAMPLE17
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |OV        |Overrun Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is recent conversion result.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is overwrite.
     * |        |          |If converted data in RESULT (EADC_ADnDATx[11:0]) has not been read before new conversion result is loaded to this register, OV (EADC_ADnDATx[16]) is set to 1.
     * |        |          |It is cleared by hardware after EADC_ADnDATx register is read.
     * |[17]    |VALID     |Valid Flag
     * |        |          |0 = Data in RESULT (EADC_ADnDATx[11:0]) is not valid.
     * |        |          |1 = Data in RESULT (EADC_ADnDATx[11:0]) is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DAT7;

    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x40  A/D Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ADCEN     |A/D Converter Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |        |          |Before starting A/D conversion function, this bit should be set to 1.
     * |        |          |Clear it to 0 to disable A/D converter analog circuit power consumption.
     * |[1]     |ADCRST    |ADC0, ADC1 A/D Converter Control Circuits Reset
     * |        |          |0 = No effect.
     * |        |          |1 = Cause ADC control circuits reset to initial state, but not change the ADC registers value.
     * |        |          |The ADCRST (EADC_CTL [1]) bit remains 1 during ADC reset, when ADC reset end, the ADCRST (EADC_CTL [1]) bit is automatically cleared to 0.
     * |[2]     |ADCIEN0   |Specific SAMPLE A/D ADINT0 Interrupt Enable Control
     * |        |          |0 = Specific SAMPLE A/D ADINT0 interrupt function Disabled.
     * |        |          |1 = Specific SAMPLE A/D ADINT0 interrupt function Enabled.
     * |        |          |The A/D converter generates a conversion end ADIF0 (EADC_STATUS1 [0]) flag upon the end of specific SAMPLE A/D conversion.
     * |        |          |If ADCIEN0 (EADC_CTL [2]) bit is set then conversion end interrupt request ADINT0 is generated.
     * |[3]     |ADCIEN1   |Specific SAMPLE A/D ADINT1 Interrupt Enable Control
     * |        |          |0 = Specific SAMPLE A/D ADINT1 interrupt function Disabled.
     * |        |          |1 = Specific SAMPLE A/D ADINT1 interrupt function Enabled.
     * |        |          |The A/D converter generates a conversion end ADIF0 (EADC_STATUS1 [1]) flag upon the end of specific SAMPLE A/D conversion.
     * |        |          |If ADCIEN1 EADC_CTL [3]) bit is set then conversion end interrupt request ADINT1 is generated.
     * |[4]     |ADCIEN2   |Specific SAMPLE A/D ADINT2 Interrupt Enable Control
     * |        |          |0 = Specific SAMPLE A/D ADINT2 interrupt function Disabled.
     * |        |          |1 = Specific SAMPLE A/D ADINT2 interrupt function Enabled.
     * |        |          |The A/D converter generates a conversion end ADIF2 (EADC_STATUS1 [2]) flag upon the end of specific SAMPLE A/D conversion.
     * |        |          |If ADCIEN2 (EADC_CTL [4]) bit is set then conversion end interrupt request ADINT2 is generated.
     * |[5]     |ADCIEN3   |Specific SAMPLE A/D ADINT3 Interrupt Enable Control
     * |        |          |0 = Specific SAMPLE A/D ADINT3 interrupt function Disabled.
     * |        |          |1 = Specific SAMPLE A/D ADINT3 interrupt function Enabled.
     * |        |          |The A/D converter generates a conversion end ADIF3 (EADC_STATUS1 [3]) flag upon the end of specific SAMPLE A/D conversion.
     * |        |          |If ADCIEN3 (EADC_CTL [5]) bit is set then conversion end interrupt request ADINT3 is generated.
    */
    __IO uint32_t CTL;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * SWTRG
     * ===================================================================================================
     * Offset: 0x48  A/D SAMPLE Software Start Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |SWTRG7_0  |A/D SAMPLE07~SAMPLE00 Software Force To Start ADC Conversion
     * |        |          |0 = No effect.
     * |        |          |1 = Start an ADC conversion when the priority is given to SAMPLE0x.
     * |        |          |Note: x = 0~7.
     * |[8:15]  |SWTRG15_8 |A/D SAMPLE17~SAMPLE10 Software Force To Start ADC Conversion
     * |        |          |0 = No effect.
     * |        |          |1 = Start an ADC conversion when the priority is given to SAMPLE1x.
     * |        |          |Note: x = 0~7.
    */
    __O  uint32_t SWTRG;

    /**
     * PENDSTS
     * ===================================================================================================
     * Offset: 0x4C  A/D Start of Conversion Pending Flag Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |STPF7_0   |A/D SAMPLE07~SAMPLE00 Start Of Conversion Pending Flag
     * |        |          |0 = There is no pending conversion for SAMPLE0x.
     * |        |          |1 = SAMPLE0x ADC start of conversion is pending.
     * |        |          |Note: This bit remains 1 during pending state, when the respective ADC conversion is started, the STPF bit is automatically cleared to 0.
     * |        |          |Note: x = 0~7.
     * |[8:15]  |STPF15_8  |A/D SAMPLE17~SAMPLE10 Start Of Conversion Pending Flag
     * |        |          |0 = There is no pending conversion for SAMPLE1x.
     * |        |          |1 = SAMPLE1x ADC start of conversion is pending.
     * |        |          |Note: This bit remains 1 during pending state, when the respective ADC conversion is started, the STPF bit is automatically cleared to 0.
     * |        |          |Note: x = 0~7.
    */
    __I  uint32_t PENDSTS;

    /**
     * ADIFOV
     * ===================================================================================================
     * Offset: 0x50  A/D ADINT3~0 Interrupt Flag Overrun Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ADFOV0    |A/D ADINT0 Interrupt Flag Overrun
     * |        |          |0 = ADINT0 interrupt flag is not overwritten to 1.
     * |        |          |1 = ADINT0 interrupt flag is overwritten to 1.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |[1]     |ADFOV1    |A/D ADINT1 Interrupt Flag Overrun
     * |        |          |0 = ADINT1 interrupt flag is not overwritten to 1.
     * |        |          |1 = ADINT1 interrupt flag is overwritten to 1.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |[2]     |ADFOV2    |A/D ADINT2 Interrupt Flag Overrun
     * |        |          |0 = ADINT2 interrupt flag is not overwritten to 1.
     * |        |          |1 = ADINT2 interrupt flag is overwritten to 1.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |[3]     |ADFOV3    |A/D ADINT3 Interrupt Flag Overrun
     * |        |          |0 = ADINT3 interrupt flag is not overwritten to 1.
     * |        |          |1 = ADINT3 interrupt flag is overwritten to 1.
     * |        |          |Note: This bit is cleared by writing 1 to it.
    */
    __IO uint32_t ADIFOV;

    /**
     * OVSTS
     * ===================================================================================================
     * Offset: 0x54  A/D SAMPLE Start of Conversion Overrun Flag Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |SPOVF7_0  |A/D SAMPLE07~SAMPLE00 Start Of Conversion Overrun Flag
     * |        |          |0 = No SAMPLE0x event overrun.
     * |        |          |1 = Indicates a new SAMPLE0x event is generated while an old one event is pending.
     * |        |          |If there is a new trigger event comes when the SAMPLE is pending for the last trigger event, the overrun is happened and the SPOVF bit will be set as 1.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |        |          |Note: x = 0~7.
     * |[8:15]  |SPOVF15_8 |A/D SAMPLE17~SAMPLE10 Start Of Conversion Overrun Flag
     * |        |          |0 = No SAMPLE1x event overrun.
     * |        |          |1 = Indicates a new SAMPLE1x event is generated while an old one event is pending.
     * |        |          |If there is a new trigger event comes when the SAMPLE is pending for the last trigger event, the overrun is happened and the SPOVF bit will be set as 1.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |        |          |Note: x = 0~7.
    */
    __IO uint32_t OVSTS;

    /**
     * AD0SPCTL0
     * ===================================================================================================
     * Offset: 0x58  A/D SAMPLE00 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:7]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |0000 = Disable hardware trigger.
     * |        |          |0001 = External pin (STADC) trigger.
     * |        |          |0010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |0011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |0100 = Timer0 overflow pulse trigger.
     * |        |          |0101 = Timer1 overflow pulse trigger.
     * |        |          |0110 = Timer2 overflow pulse trigger.
     * |        |          |0111 = Timer3 overflow pulse trigger.
     * |        |          |1000 = EPWM0_CH0 trigger.
     * |        |          |1001 = EPWM0_CH2 trigger.
     * |        |          |1010 = EPWM0_CH4 trigger.
     * |        |          |1011 = EPWM1_CH0 trigger.
     * |        |          |1100 = EPWM1_CH2 trigger.
     * |        |          |1101 = EPWM1_CH4 trigger.
     * |        |          |1110 = PWM0_CH0 trigger.
     * |        |          |1111 = PWM0_CH1 trigger.
     * |[8:15]  |TRGDLYCNT |A/D SAMPLE Start Of Conversion Trigger Delay Time
     * |        |          |Trigger delay time = (TRGDLYCNT + 4) x Trigger delay clock period.
     * |[16:17] |TRGDLYDIV |A/D SAMPLE Start Of Conversion Trigger Delay Clock Divider Selection
     * |        |          |Trigger delay clock frequency:
     * |        |          |00 = ADC_CLK/1.
     * |        |          |01 = ADC_CLK/2.
     * |        |          |10 = ADC_CLK/4.
     * |        |          |11 = ADC_CLK/16.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD0SPCTL0;

    /**
     * AD0SPCTL1
     * ===================================================================================================
     * Offset: 0x5C  A/D SAMPLE01 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:7]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |0000 = Disable hardware trigger.
     * |        |          |0001 = External pin (STADC) trigger.
     * |        |          |0010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |0011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |0100 = Timer0 overflow pulse trigger.
     * |        |          |0101 = Timer1 overflow pulse trigger.
     * |        |          |0110 = Timer2 overflow pulse trigger.
     * |        |          |0111 = Timer3 overflow pulse trigger.
     * |        |          |1000 = EPWM0_CH0 trigger.
     * |        |          |1001 = EPWM0_CH2 trigger.
     * |        |          |1010 = EPWM0_CH4 trigger.
     * |        |          |1011 = EPWM1_CH0 trigger.
     * |        |          |1100 = EPWM1_CH2 trigger.
     * |        |          |1101 = EPWM1_CH4 trigger.
     * |        |          |1110 = PWM0_CH0 trigger.
     * |        |          |1111 = PWM0_CH1 trigger.
     * |[8:15]  |TRGDLYCNT |A/D SAMPLE Start Of Conversion Trigger Delay Time
     * |        |          |Trigger delay time = (TRGDLYCNT + 4) x Trigger delay clock period.
     * |[16:17] |TRGDLYDIV |A/D SAMPLE Start Of Conversion Trigger Delay Clock Divider Selection
     * |        |          |Trigger delay clock frequency:
     * |        |          |00 = ADC_CLK/1.
     * |        |          |01 = ADC_CLK/2.
     * |        |          |10 = ADC_CLK/4.
     * |        |          |11 = ADC_CLK/16.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD0SPCTL1;

    /**
     * AD0SPCTL2
     * ===================================================================================================
     * Offset: 0x60  A/D SAMPLE02 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:7]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |0000 = Disable hardware trigger.
     * |        |          |0001 = External pin (STADC) trigger.
     * |        |          |0010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |0011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |0100 = Timer0 overflow pulse trigger.
     * |        |          |0101 = Timer1 overflow pulse trigger.
     * |        |          |0110 = Timer2 overflow pulse trigger.
     * |        |          |0111 = Timer3 overflow pulse trigger.
     * |        |          |1000 = EPWM0_CH0 trigger.
     * |        |          |1001 = EPWM0_CH2 trigger.
     * |        |          |1010 = EPWM0_CH4 trigger.
     * |        |          |1011 = EPWM1_CH0 trigger.
     * |        |          |1100 = EPWM1_CH2 trigger.
     * |        |          |1101 = EPWM1_CH4 trigger.
     * |        |          |1110 = PWM0_CH0 trigger.
     * |        |          |1111 = PWM0_CH1 trigger.
     * |[8:15]  |TRGDLYCNT |A/D SAMPLE Start Of Conversion Trigger Delay Time
     * |        |          |Trigger delay time = (TRGDLYCNT + 4) x Trigger delay clock period.
     * |[16:17] |TRGDLYDIV |A/D SAMPLE Start Of Conversion Trigger Delay Clock Divider Selection
     * |        |          |Trigger delay clock frequency:
     * |        |          |00 = ADC_CLK/1.
     * |        |          |01 = ADC_CLK/2.
     * |        |          |10 = ADC_CLK/4.
     * |        |          |11 = ADC_CLK/16.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD0SPCTL2;

    /**
     * AD0SPCTL3
     * ===================================================================================================
     * Offset: 0x64  A/D SAMPLE03 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:7]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |0000 = Disable hardware trigger.
     * |        |          |0001 = External pin (STADC) trigger.
     * |        |          |0010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |0011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |0100 = Timer0 overflow pulse trigger.
     * |        |          |0101 = Timer1 overflow pulse trigger.
     * |        |          |0110 = Timer2 overflow pulse trigger.
     * |        |          |0111 = Timer3 overflow pulse trigger.
     * |        |          |1000 = EPWM0_CH0 trigger.
     * |        |          |1001 = EPWM0_CH2 trigger.
     * |        |          |1010 = EPWM0_CH4 trigger.
     * |        |          |1011 = EPWM1_CH0 trigger.
     * |        |          |1100 = EPWM1_CH2 trigger.
     * |        |          |1101 = EPWM1_CH4 trigger.
     * |        |          |1110 = PWM0_CH0 trigger.
     * |        |          |1111 = PWM0_CH1 trigger.
     * |[8:15]  |TRGDLYCNT |A/D SAMPLE Start Of Conversion Trigger Delay Time
     * |        |          |Trigger delay time = (TRGDLYCNT + 4) x Trigger delay clock period.
     * |[16:17] |TRGDLYDIV |A/D SAMPLE Start Of Conversion Trigger Delay Clock Divider Selection
     * |        |          |Trigger delay clock frequency:
     * |        |          |00 = ADC_CLK/1.
     * |        |          |01 = ADC_CLK/2.
     * |        |          |10 = ADC_CLK/4.
     * |        |          |11 = ADC_CLK/16.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD0SPCTL3;

    /**
     * AD0SPCTL4
     * ===================================================================================================
     * Offset: 0x68  A/D SAMPLE04 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:6]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |000 = Disable hardware trigger.
     * |        |          |001 = External pin (STADC) trigger.
     * |        |          |010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |100 = Timer0 overflow pulse trigger.
     * |        |          |101 = Timer1 overflow pulse trigger.
     * |        |          |110 = Timer2 overflow pulse trigger.
     * |        |          |111 = Timer3 overflow pulse trigger.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD0SPCTL4;

    /**
     * AD0SPCTL5
     * ===================================================================================================
     * Offset: 0x6C  A/D SAMPLE05 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:6]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |000 = Disable hardware trigger.
     * |        |          |001 = External pin (STADC) trigger.
     * |        |          |010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |100 = Timer0 overflow pulse trigger.
     * |        |          |101 = Timer1 overflow pulse trigger.
     * |        |          |110 = Timer2 overflow pulse trigger.
     * |        |          |111 = Timer3 overflow pulse trigger.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD0SPCTL5;

    /**
     * AD0SPCTL6
     * ===================================================================================================
     * Offset: 0x70  A/D SAMPLE06 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:6]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |000 = Disable hardware trigger.
     * |        |          |001 = External pin (STADC) trigger.
     * |        |          |010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |100 = Timer0 overflow pulse trigger.
     * |        |          |101 = Timer1 overflow pulse trigger.
     * |        |          |110 = Timer2 overflow pulse trigger.
     * |        |          |111 = Timer3 overflow pulse trigger.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD0SPCTL6;

    /**
     * AD0SPCTL7
     * ===================================================================================================
     * Offset: 0x74  A/D SAMPLE07 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:6]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |000 = Disable hardware trigger.
     * |        |          |001 = External pin (STADC) trigger.
     * |        |          |010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |100 = Timer0 overflow pulse trigger.
     * |        |          |101 = Timer1 overflow pulse trigger.
     * |        |          |110 = Timer2 overflow pulse trigger.
     * |        |          |111 = Timer3 overflow pulse trigger.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD0SPCTL7;

    /**
     * AD1SPCTL0
     * ===================================================================================================
     * Offset: 0x78  A/D SAMPLE10 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:7]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |0000 = Disable hardware trigger.
     * |        |          |0001 = External pin (STADC) trigger.
     * |        |          |0010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |0011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |0100 = Timer0 overflow pulse trigger.
     * |        |          |0101 = Timer1 overflow pulse trigger.
     * |        |          |0110 = Timer2 overflow pulse trigger.
     * |        |          |0111 = Timer3 overflow pulse trigger.
     * |        |          |1000 = EPWM0_CH0 trigger.
     * |        |          |1001 = EPWM0_CH2 trigger.
     * |        |          |1010 = EPWM0_CH4 trigger.
     * |        |          |1011 = EPWM1_CH0 trigger.
     * |        |          |1100 = EPWM1_CH2 trigger.
     * |        |          |1101 = EPWM1_CH4 trigger.
     * |        |          |1110 = PWM0_CH0 trigger.
     * |        |          |1111 = PWM0_CH1 trigger.
     * |[8:15]  |TRGDLYCNT |A/D SAMPLE Start Of Conversion Trigger Delay Time
     * |        |          |Trigger delay time = (TRGDLYCNT + 4) x Trigger delay clock period.
     * |[16:17] |TRGDLYDIV |A/D SAMPLE Start Of Conversion Trigger Delay Clock Divider Selection
     * |        |          |Trigger delay clock frequency:
     * |        |          |00 = ADC_CLK/1.
     * |        |          |01 = ADC_CLK/2.
     * |        |          |10 = ADC_CLK/4.
     * |        |          |11 = ADC_CLK/16.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD1SPCTL0;

    /**
     * AD1SPCTL1
     * ===================================================================================================
     * Offset: 0x7C  A/D SAMPLE11 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:7]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |0000 = Disable hardware trigger.
     * |        |          |0001 = External pin (STADC) trigger.
     * |        |          |0010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |0011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |0100 = Timer0 overflow pulse trigger.
     * |        |          |0101 = Timer1 overflow pulse trigger.
     * |        |          |0110 = Timer2 overflow pulse trigger.
     * |        |          |0111 = Timer3 overflow pulse trigger.
     * |        |          |1000 = EPWM0_CH0 trigger.
     * |        |          |1001 = EPWM0_CH2 trigger.
     * |        |          |1010 = EPWM0_CH4 trigger.
     * |        |          |1011 = EPWM1_CH0 trigger.
     * |        |          |1100 = EPWM1_CH2 trigger.
     * |        |          |1101 = EPWM1_CH4 trigger.
     * |        |          |1110 = PWM0_CH0 trigger.
     * |        |          |1111 = PWM0_CH1 trigger.
     * |[8:15]  |TRGDLYCNT |A/D SAMPLE Start Of Conversion Trigger Delay Time
     * |        |          |Trigger delay time = (TRGDLYCNT + 4) x Trigger delay clock period.
     * |[16:17] |TRGDLYDIV |A/D SAMPLE Start Of Conversion Trigger Delay Clock Divider Selection
     * |        |          |Trigger delay clock frequency:
     * |        |          |00 = ADC_CLK/1.
     * |        |          |01 = ADC_CLK/2.
     * |        |          |10 = ADC_CLK/4.
     * |        |          |11 = ADC_CLK/16.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD1SPCTL1;

    /**
     * AD1SPCTL2
     * ===================================================================================================
     * Offset: 0x80  A/D SAMPLE12 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:7]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |0000 = Disable hardware trigger.
     * |        |          |0001 = External pin (STADC) trigger.
     * |        |          |0010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |0011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |0100 = Timer0 overflow pulse trigger.
     * |        |          |0101 = Timer1 overflow pulse trigger.
     * |        |          |0110 = Timer2 overflow pulse trigger.
     * |        |          |0111 = Timer3 overflow pulse trigger.
     * |        |          |1000 = EPWM0_CH0 trigger.
     * |        |          |1001 = EPWM0_CH2 trigger.
     * |        |          |1010 = EPWM0_CH4 trigger.
     * |        |          |1011 = EPWM1_CH0 trigger.
     * |        |          |1100 = EPWM1_CH2 trigger.
     * |        |          |1101 = EPWM1_CH4 trigger.
     * |        |          |1110 = PWM0_CH0 trigger.
     * |        |          |1111 = PWM0_CH1 trigger.
     * |[8:15]  |TRGDLYCNT |A/D SAMPLE Start Of Conversion Trigger Delay Time
     * |        |          |Trigger delay time = (TRGDLYCNT + 4) x Trigger delay clock period.
     * |[16:17] |TRGDLYDIV |A/D SAMPLE Start Of Conversion Trigger Delay Clock Divider Selection
     * |        |          |Trigger delay clock frequency:
     * |        |          |00 = ADC_CLK/1.
     * |        |          |01 = ADC_CLK/2.
     * |        |          |10 = ADC_CLK/4.
     * |        |          |11 = ADC_CLK/16.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD1SPCTL2;

    /**
     * AD1SPCTL3
     * ===================================================================================================
     * Offset: 0x84  A/D SAMPLE13 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:7]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |0000 = Disable hardware trigger.
     * |        |          |0001 = External pin (STADC) trigger.
     * |        |          |0010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |0011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |0100 = Timer0 overflow pulse trigger.
     * |        |          |0101 = Timer1 overflow pulse trigger.
     * |        |          |0110 = Timer2 overflow pulse trigger.
     * |        |          |0111 = Timer3 overflow pulse trigger.
     * |        |          |1000 = EPWM0_CH0 trigger.
     * |        |          |1001 = EPWM0_CH2 trigger.
     * |        |          |1010 = EPWM0_CH4 trigger.
     * |        |          |1011 = EPWM1_CH0 trigger.
     * |        |          |1100 = EPWM1_CH2 trigger.
     * |        |          |1101 = EPWM1_CH4 trigger.
     * |        |          |1110 = PWM0_CH0 trigger.
     * |        |          |1111 = PWM0_CH1 trigger.
     * |[8:15]  |TRGDLYCNT |A/D SAMPLE Start Of Conversion Trigger Delay Time
     * |        |          |Trigger delay time = (TRGDLYCNT + 4) x Trigger delay clock period.
     * |[16:17] |TRGDLYDIV |A/D SAMPLE Start Of Conversion Trigger Delay Clock Divider Selection
     * |        |          |Trigger delay clock frequency:
     * |        |          |00 = ADC_CLK/1.
     * |        |          |01 = ADC_CLK/2.
     * |        |          |10 = ADC_CLK/4.
     * |        |          |11 = ADC_CLK/16.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD1SPCTL3;

    /**
     * AD1SPCTL4
     * ===================================================================================================
     * Offset: 0x88  A/D SAMPLE14 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:6]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |000 = Disable hardware trigger.
     * |        |          |001 = External pin (STADC) trigger.
     * |        |          |010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |100 = Timer0 overflow pulse trigger.
     * |        |          |101 = Timer1 overflow pulse trigger.
     * |        |          |110 = Timer2 overflow pulse trigger.
     * |        |          |111 = Timer3 overflow pulse trigger.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD1SPCTL4;

    /**
     * AD1SPCTL5
     * ===================================================================================================
     * Offset: 0x8C  A/D SAMPLE15 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:6]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |000 = Disable hardware trigger.
     * |        |          |001 = External pin (STADC) trigger.
     * |        |          |010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |100 = Timer0 overflow pulse trigger.
     * |        |          |101 = Timer1 overflow pulse trigger.
     * |        |          |110 = Timer2 overflow pulse trigger.
     * |        |          |111 = Timer3 overflow pulse trigger.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD1SPCTL5;

    /**
     * AD1SPCTL6
     * ===================================================================================================
     * Offset: 0x90  A/D SAMPLE16 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:6]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |000 = Disable hardware trigger.
     * |        |          |001 = External pin (STADC) trigger.
     * |        |          |010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |100 = Timer0 overflow pulse trigger.
     * |        |          |101 = Timer1 overflow pulse trigger.
     * |        |          |110 = Timer2 overflow pulse trigger.
     * |        |          |111 = Timer3 overflow pulse trigger.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD1SPCTL6;

    /**
     * AD1SPCTL7
     * ===================================================================================================
     * Offset: 0x94  A/D SAMPLE17 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |CHSEL     |A/D SAMPLE0,1 Channel Selection
     * |        |          |0000 = ADCn_CH0.
     * |        |          |0001 = ADCn_CH1.
     * |        |          |0010 = ADCn_CH2.
     * |        |          |0011 = ADCn_CH3.
     * |        |          |0100 = ADCn_CH4.
     * |        |          |0101 = ADCn_CH5.
     * |        |          |0110 = ADCn_CH6.
     * |        |          |0111 = ADCn_CH7.
     * |        |          |For SAMPLE0
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OP0.
     * |        |          |For SAMPLE1
     * |        |          |1000= OP1.
     * |[4:6]   |TRGSEL    |A/D SAMPLE Start Of Conversion Trigger Source Selection
     * |        |          |000 = Disable hardware trigger.
     * |        |          |001 = External pin (STADC) trigger.
     * |        |          |010 = ADC ADINT0 interrupt EOC pulse trigger.
     * |        |          |011 = ADC ADINT1 interrupt EOC pulse trigger.
     * |        |          |100 = Timer0 overflow pulse trigger.
     * |        |          |101 = Timer1 overflow pulse trigger.
     * |        |          |110 = Timer2 overflow pulse trigger.
     * |        |          |111 = Timer3 overflow pulse trigger.
     * |[20]    |EXTREN    |A/D External Pin Rising Edge Trigger Enable Control
     * |        |          |0 = A/D external pin rising edge trigger Disabled.
     * |        |          |1 = A/D external pin rising edge trigger Enabled.
     * |[21]    |EXTFEN    |A/D External Pin Falling Edge Trigger Enable Control
     * |        |          |0 = A/D external pin falling edge trigger Disabled.
     * |        |          |1 = A/D external pin falling edge trigger Enabled.
    */
    __IO uint32_t AD1SPCTL7;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * SIMUSEL
     * ===================================================================================================
     * Offset: 0xA4  A/D SAMPLE Simultaneous Sampling Mode Select Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SIMUSEL0  |A/D SAMPLE00, SAMPLE10 Simultaneous Sampling Mode Selection
     * |        |          |0 = SAMPLE00, SAMPLE10 are in single sampling mode, both SAMPLE00 and SAMPLE10's 3 bits of CHSEL define the ADC channels to be converted.
     * |        |          |1 = SAMPLE00, SAMPLE10 are in simultaneous sampling mode, Only SAMPLE00 can trigger the both ADC conversions of SAMPLE00 and SAMPLE10, SAMPLE10 trigger select TRGSEL is ignored.
     * |        |          |If SAMPLE00's CHSEL = 1, and SAMPLE10's CHSEL = 3, the pair of channels are ADC0_CH1, ADC1_CH3, they will do the ADC conversion at the same time to reach the simulataneous sampling goal.
     * |[1]     |SIMUSEL1  |A/D SAMPLE01, SAMPLE11 Simultaneous Sampling Mode Selection
     * |        |          |0 = SAMPLE01, SAMPLE11 are in single sampling mode, both SAMPLE01 and SAMPLE11's 3 bits of CHSEL define the ADC channels to be converted.
     * |        |          |1 = SAMPLE01, SAMPLE11 are in simultaneous sampling mode, Only SAMPLE01 can trigger the both ADC conversions of SAMPLE01 and SAMPLE11, SAMPLE11 trigger select TRGSEL is ignored.
     * |        |          |If SAMPLE01's CHSEL = 1, and SAMPLE11's CHSEL = 3, the pair of channels are ADC0_CH1, ADC1_CH3, they will do the ADC conversion at the same time to reach the simulataneous sampling goal.
     * |[2]     |SIMUSEL2  |A/D SAMPLE02, SAMPLE12 Simultaneous Sampling Mode Selection
     * |        |          |0 = SAMPLE02, SAMPLE12 are in single sampling mode, both SAMPLE02 and SAMPLE12's 3 bits of CHSEL define the ADC channels to be converted.
     * |        |          |1 = SAMPLE02, SAMPLE12 are in simultaneous sampling mode, Only SAMPLE02 can trigger the both ADC conversions of SAMPLE02 and SAMPLE12, SAMPLE12 trigger select TRGSEL is ignored.
     * |        |          |If SAMPLE02's CHSEL = 1, and SAMPLE12's CHSEL = 3, the pair of channels are ADC0_CH1, ADC1_CH3, they will do the ADC conversion at the same time to reach the simulataneous sampling goal.
     * |[3]     |SIMUSEL3  |A/D SAMPLE03, SAMPLE13 Simultaneous Sampling Mode Selection
     * |        |          |0 = SAMPLE03, SAMPLE13 are in single sampling mode, both SAMPLE03 and SAMPLE13's 3 bits of CHSEL define the ADC channels to be converted.
     * |        |          |1 = SAMPLE03, SAMPLE13 are in simultaneous sampling mode, Only SAMPLE03 can trigger the both ADC conversions of SAMPLE03 and SAMPLE13, SAMPLE13 trigger select TRGSEL is ignored.
     * |        |          |If SAMPLE03's CHSEL = 1, and SAMPLE13's CHSEL = 3, the pair of channels are ADC0_CH1, ADC1_CH3, they will do the ADC conversion at the same time to reach the simulataneous sampling goal.
     * |[4]     |SIMUSEL4  |A/D SAMPLE04, SAMPLE14 Simultaneous Sampling Mode Selection
     * |        |          |0 = SAMPLE04, SAMPLE14 are in single sampling mode, both SAMPLE04 and SAMPLE14's 3 bits of CHSEL define the ADC channels to be converted.
     * |        |          |1 = SAMPLE04, SAMPLE14 are in simultaneous sampling mode, Only SAMPLE04 can trigger the both ADC conversions of SAMPLE04 and SAMPLE14, SAMPLE14 trigger select TRGSEL is ignored.
     * |        |          |If SAMPLE04's CHSEL = 1, and SAMPLE14's CHSEL = 3, the pair of channels are ADC0_CH1, ADC1_CH3, they will do the ADC conversion at the same time to reach the simulataneous sampling goal.
     * |[5]     |SIMUSEL5  |A/D SAMPLE05, SAMPLE15 Simultaneous Sampling Mode Selection
     * |        |          |0 = SAMPLE05, SAMPLE15 are in single sampling mode, both SAMPLE05 and SAMPLE15's 3 bits of CHSEL define the ADC channels to be converted.
     * |        |          |1 = SAMPLE05, SAMPLE15 are in simultaneous sampling mode, Only SAMPLE05 can trigger the both ADC conversions of SAMPLE05 and SAMPLE15, SAMPLE15 trigger select TRGSEL is ignored.
     * |        |          |if SAMPLE05's CHSEL = 1, and SAMPLE15's CHSEL = 3, the pair of channels are ADC0_CH1, ADC1_CH3, they will do the ADC conversion at the same time to reach the simulataneous sampling goal.
     * |[6]     |SIMUSEL6  |A/D SAMPLE06, SAMPLE16 Simultaneous Sampling Mode Selection
     * |        |          |0 = SAMPLE06, SAMPLE16 are in single sampling mode, both SAMPLE06 and SAMPLE16's 3 bits of CHSEL define the ADC channels to be converted.
     * |        |          |1 = SAMPLE06, SAMPLE16 are in simultaneous sampling mode, Only SAMPLE06 can trigger the both ADC conversions of SAMPLE06 and SAMPLE16, SAMPLE16 trigger select TRGSEL is ignored.
     * |        |          |If SAMPLE06's CHSEL = 1, and SAMPLE16's CHSEL = 3, the pair of channels are ADC0_CH1, ADC1_CH3, they will do the ADC conversion at the same time to reach the simulataneous sampling goal.
     * |[7]     |SIMUSEL7  |A/D SAMPLE07, SAMPLE17 Simultaneous Sampling Mode Selection
     * |        |          |0 = SAMPLE07, SAMPLE17 are in single sampling mode, both SAMPLE07 and SAMPLE17's 3 bits of CHSEL define the ADC channels to be converted.
     * |        |          |1 = SAMPLE07, SAMPLE17 are in simultaneous sampling mode, Only SAMPLE07 can trigger the both ADC conversions of SAMPLE07 and SAMPLE17, SAMPLE17 trigger select TRGSEL is ignored.
     * |        |          |If SAMPLE07's CHSEL = 1, SAMPLE17's CHSEL = 3, the pair of channels are ADC0_CH1, ADC1_CH3, they will do the ADC conversion at the same time to reach the simulataneous sampling goal.
    */
    __IO uint32_t SIMUSEL;

    /**
     * CMP0/1
     * ===================================================================================================
     * Offset: 0xA8  A/D Result Compare Register 0
     * Offset: 0xAC  A/D Result Compare Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ADCMPEN   |A/D Result Compare Enable Control
     * |        |          |0 = Compare Disabled.
     * |        |          |1 = Compare Enabled.
     * |        |          |Set this bit to 1 to enable compare CMPDAT (EADC_CMPx[27:16]) with specified SAMPLE conversion result when converted data is loaded into ADDR register.
     * |[1]     |ADCMPIE   |A/D Result Compare Interrupt Enable Control
     * |        |          |0 = Compare function interrupt Disabled.
     * |        |          |1 = Compare function interrupt Enabled.
     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPx[2]) and CMPMCNT (EADC_CMPx[11:8]), ADCMPF (EADC_STATUS1 [7:6]) bit will be asserted, in the meanwhile, if ADCMPIE (EADC_CMPx[1]) is set to 1, a compare interrupt request is generated.
     * |[2]     |CMPCOND   |Compare Condition
     * |        |          |0= Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPDAT (EADC_CMPx[27:16]), the internal match counter will increase one.
     * |        |          |1= Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPDAT (EADC_CMPx[27:16]), the internal match counter will increase one.
     * |        |          |Note: When the internal counter reaches the value to CMPMCNT (EADC_CMPx[11:8]) + 1, the CMPF bit will be set.
     * |[3:5]   |CMPSPL    |Compare SAMPLE Selection
     * |        |          |000 = SAMPLE00 conversion result EADC_AD0DAT0 is selected to be compared.
     * |        |          |001 = SAMPLE01 conversion result EADC_AD0DAT1 is selected to be compared.
     * |        |          |010 = SAMPLE02 conversion result EADC_AD0DAT2 is selected to be compared.
     * |        |          |011 = SAMPLE03 conversion result EADC_AD0DAT3 is selected to be compared.
     * |        |          |100 = SAMPLE10 conversion result EADC_AD1DAT0 is selected to be compared.
     * |        |          |101 = SAMPLE11 conversion result EADC_AD1DAT1 is selected to be compared.
     * |        |          |110 = SAMPLE12 conversion result EADC_AD1DAT2 is selected to be compared.
     * |        |          |111 = SAMPLE13 conversion result EADC_AD1DAT3 is selected to be compared.
     * |[8:11]  |CMPMCNT   |Compare Match Count
     * |        |          |When the specified A/D SAMPLE analog conversion result matches the compare condition defined by CMPCOND (EADC_CMPx[2]), the internal match counter will increase 1.
     * |        |          |When the internal counter reaches the value to CMPMCNT (EADC_CMPx[11:8] + 1, the ADCMPF (EADC_STATUS1 [7:6]) bit will be set.
     * |[16:27] |CMPDAT    |Compared Data
     * |        |          |The 12 bits data is used to compare with conversion result of specified SAMPLE.
     * |        |          |Software can use it to monitor the external analog input pin voltage transition without imposing a load on software.
    */
    __IO uint32_t CMP[2];

    /**
     * STATUS0
     * ===================================================================================================
     * Offset: 0xB0  A/D Status Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |VALID7_0  |ADDR07~ ADDR00 Data Valid Flag (Read Only)
     * |        |          |It is a mirror of VALID bit in SAMPLE0 A/D result data register EADC_AD0DAT0x.
     * |        |          |Note: x = 0~7.
     * |[8:15]  |VALID15_8 |ADDR17~ ADDR10 Data Valid Flag (Read Only)
     * |        |          |It is a mirror of VALID bit in SAMPLE1 A/D result data register EADC_AD0DAT1x.
     * |        |          |Note: x = 0~7.
     * |[16:23] |OV7_0     |ADDR07~ ADDR00 Overrun Flag (Read Only)
     * |        |          |It is a mirror to OV bit in SAMPLE0 A/D result data register EADC_AD0DAT0x.
     * |        |          |Note: x = 0~7.
     * |[24:31] |OV15_8    |ADDR17~ADDR10 Overrun Flag (Read Only)
     * |        |          |It is a mirror to OV bit in SAMPLE1 A/D result data register EADC_AD0DAT1x.
     * |        |          |Note: x = 0~7.
    */
    __I  uint32_t STATUS0;

    /**
     * STATUS1
     * ===================================================================================================
     * Offset: 0xB4  A/D Status Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ADIF0     |A/D ADINT0 Interrupt Flag
     * |        |          |0 = No ADINT0 interrupt pulse received.
     * |        |          |1 = ADINT0 interrupt pulse has been received.
     * |        |          |Note1: This bit is cleared by writing 1 to it.
     * |        |          |Note2:This bit indicates whether an A/D conversion of specific SAMPLE has been completed
     * |[1]     |ADIF1     |A/D ADINT1 Interrupt Flag
     * |        |          |0 = No ADINT1 interrupt pulse received.
     * |        |          |1 = ADINT1 interrupt pulse has been received.
     * |        |          |Note1: This bit is cleared by writing 1 to it.
     * |        |          |Note2:This bit indicates whether an A/D conversion of specific SAMPLE has been completed
     * |[2]     |ADIF2     |A/D ADINT2 Interrupt Flag
     * |        |          |0 = no ADINT2 interrupt pulse received.
     * |        |          |1 = ADINT2 interrupt pulse has been received.
     * |        |          |Note1: This bit is cleared by writing 1 to it.
     * |        |          |Note2:This bit indicates whether an A/D conversion of specific SAMPLE has been completed
     * |[3]     |ADIF3     |A/D ADINT3 Interrupt Flag
     * |        |          |0 = No ADINT3 interrupt pulse received.
     * |        |          |1 = ADINT3 interrupt pulse has been received.
     * |        |          |Note1: This bit is cleared by writing 1 to it.
     * |        |          |Note2:This bit indicates whether an A/D conversion of specific SAMPLE has been completed
     * |[4]     |ADCMPO0   |ADC Compare 0 Output Status
     * |        |          |The 12 bits compare0 data CMPDAT EADC_CMP0 [27:16]) is used to compare with conversion result of specified SAMPLE.
     * |        |          |Software can use it to monitor the external analog input pin voltage status.
     * |        |          |0 = Conversion result in ADDR less than CMPDAT (EADC_CMP0 [27:16]) setting.
     * |        |          |1 = Conversion result in ADDR great than or equal CMPDAT (EADC_CMP0 [27:16]) setting.
     * |[5]     |ADCMPO1   |ADC Compare 1 Output Status
     * |        |          |The 12 bits compare1 data CMPDAT (EADC_CMP1 [27:16]) is used to compare with conversion result of specified SAMPLE.
     * |        |          |Software can use it to monitor the external analog input pin voltage status.
     * |        |          |0 = Conversion result in ADDR less than CMPDAT EADC_CMP1 [27:16]) setting.
     * |        |          |1 = Conversion result in ADDR great than or equal CMPDAT (EADC_CMP1 [27:16]) setting.
     * |[6]     |ADCMPF0   |ADC Compare 0 Flag
     * |        |          |When the specific SAMPLE A/D conversion result meets setting condition in EADC_CMP0 then this bit is set to 1.
     * |        |          |0 = Conversion result in ADDR does not meet EADC_CMP0 setting.
     * |        |          |1 = Conversion result in ADDR meets EADC_CMP0 setting.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |[7]     |ADCMPF1   |ADC Compare 1 Flag
     * |        |          |When the specific SAMPLE A/D conversion result meets setting condition in EADC_CMP1 then this bit is set to 1.
     * |        |          |0 = Conversion result in ADDR does not meet EADC_CMP1 setting.
     * |        |          |1 = Conversion result in ADDR meets EADC_CMP1 setting.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |[8]     |BUSY0     |Busy/Idle (Read Only)
     * |        |          |0 = A/D converter 0 (ADC0) is in idle state.
     * |        |          |1 = A/D converter 0 (ADC0) is doing conversion.
     * |[12:15] |CHANNEL0  |Current Conversion Channel (Read Only)
     * |        |          |This filed reflects ADC0 current conversion channel when BUSY0 (EADC_STATUS1 [8]) = 1.
     * |        |          |When BUSY0 (EADC_STATUS1 [8]) = 0, it shows the last converted channel.
     * |        |          |0000 = ADC0_CH0.
     * |        |          |0001 = ADC0_CH1.
     * |        |          |0010 = ADC0_CH2.
     * |        |          |0011 = ADC0_CH3.
     * |        |          |0100 = ADC0_CH4.
     * |        |          |0100 = ADC0_CH5.
     * |        |          |0110 = ADC0_CH6.
     * |        |          |0111 = ADC0_CH7.
     * |        |          |1000 = VBG.
     * |        |          |1001 = VTEMP.
     * |        |          |1010 = AVSS.
     * |        |          |1011 = OPA0_O.
     * |        |          |Other = reserved.
     * |[16]    |BUSY1     |Busy/Idle
     * |        |          |0 = A/D converter 1 (ADC1) is in idle state.
     * |        |          |1 = A/D converter 1 (ADC1) is doing conversion.
     * |[20:23] |CHANNEL1  |Current Conversion Channel (Read Only)
     * |        |          |This filed reflects ADC1 current conversion channel when BUSY1 (EADC_STATUS1 [16]) = 1.
     * |        |          |When BUSY1 (EADC_STATUS1 [16]) = 0, it shows the last converted channel.
     * |        |          |0000 = ADC1_CH0.
     * |        |          |0001 = ADC1_CH1.
     * |        |          |0010 = ADC1_CH2.
     * |        |          |0011 = ADC1_CH3.
     * |        |          |0100 = ADC1_CH4.
     * |        |          |0101 = ADC1_CH5.
     * |        |          |0110 = ADC1_CH6.
     * |        |          |0111 = ADC1_CH7.
     * |        |          |1000 = OPA1_O.
     * |        |          |Other = reversed.
     * |[24]    |ADOVIF    |All A/D Interrupt Flag Overrun Bits Check
     * |        |          |0 = None of ADINT interrupt flag ADFOVx (ADIFOVR [15:0]) is overwritten to 1.
     * |        |          |1 = Any one of ADINT interrupt flag ADFOVx (ADIFOVR [15:0]) is overwritten to 1.
     * |        |          |Note: This bit will keep 1 when any ADFOVx (ADIFOVR [15:0]) Flag is equal to 1.
     * |[25]    |STOVF     |For All A/D SAMPLE Start Of Conversion Overrun Flags Check
     * |        |          |0 = None of SAMPLE event overrun flag SPOVFx (ADSPOVFR [15:0]) is set to 1.
     * |        |          |1 = Any one of SAMPLE event overrun flag SPOVFx (ADSPOVFR [15:0]) is set to 1.
     * |        |          |Note: This bit will keep 1 when any SPOVFx (ADSPOVFR [15:0]) Flag is equal to 1.
     * |[26]    |AVALID    |For All SAMPLE A/D Result Data Register ADDR Data Valid Flag Check
     * |        |          |0 = None of SAMPLE data register valid flag VALIDx (EADC_ADnDATx[17]) is set to 1.
     * |        |          |1 = Any one of SAMPLE data register valid flag VALIDx (EADC_ADnDATx[17]) is set to 1.
     * |        |          |Note: This bit will keep 1 when any VALIDx (EADC_ADnDATx[17]) Flag is equal to 1.
     * |[27]    |AOV       |For All SAMPLE A/D Result Data Register Overrun Flags Check
     * |        |          |0 = None of SAMPLE data register overrun flag OVx (EADC_ADnDATx[16]) is set to 1.
     * |        |          |1 = Any one of SAMPLE data register overrun flag OVx (EADC_ADnDATx[16]) is set to 1.
     * |        |          |Note: This bit will keep 1 when any OVx (EADC_ADnDATx[16]) Flag is equal to 1.
    */
    __IO uint32_t STATUS1;

    /**
     * EXTSMPT
     * ===================================================================================================
     * Offset: 0xB8  A/D Timing Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |EXTSMPT0  |ADC0 Extend Sampling Time
     * |        |          |When A/D converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend A/D sampling time after trigger source is coming to get enough sampling time.
     * |        |          |The range of start delay time is from 0~255 ADC clock.
     * |[16:23] |EXTSMPT1  |ADC1 Extend Sampling Time
     * |        |          |When A/D converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend A/D sampling time after trigger source is coming to get enough sampling time.
     * |        |          |The range of start delay time is from 0~255 ADC clock.
    */
    __IO uint32_t EXTSMPT;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[17];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * AD0DDAT0
     * ===================================================================================================
     * Offset: 0x100  A/D double Data Register 0 for SAMPLE00
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |VALID     |Valid Flag
     * |        |          |0 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is not valid.
     * |        |          |1 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DDAT0;

    /**
     * AD0DDAT1
     * ===================================================================================================
     * Offset: 0x104  A/D double Data Register 1 for SAMPLE01
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |VALID     |Valid Flag
     * |        |          |0 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is not valid.
     * |        |          |1 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DDAT1;

    /**
     * AD0DDAT2
     * ===================================================================================================
     * Offset: 0x108  A/D double Data Register 2 for SAMPLE02
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |VALID     |Valid Flag
     * |        |          |0 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is not valid.
     * |        |          |1 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DDAT2;

    /**
     * AD0DDAT3
     * ===================================================================================================
     * Offset: 0x10C  A/D double Data Register 3 for SAMPLE03
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |VALID     |Valid Flag
     * |        |          |0 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is not valid.
     * |        |          |1 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD0DDAT3;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE3[4];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * AD1DDAT0
     * ===================================================================================================
     * Offset: 0x120  A/D double Data Register 0 for SAMPLE10
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |VALID     |Valid Flag
     * |        |          |0 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is not valid.
     * |        |          |1 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DDAT0;

    /**
     * AD1DDAT1
     * ===================================================================================================
     * Offset: 0x124  A/D double Data Register 1 for SAMPLE11
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |VALID     |Valid Flag
     * |        |          |0 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is not valid.
     * |        |          |1 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DDAT1;

    /**
     * AD1DDAT2
     * ===================================================================================================
     * Offset: 0x128  A/D double Data Register 2 for SAMPLE12
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |VALID     |Valid Flag
     * |        |          |0 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is not valid.
     * |        |          |1 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DDAT2;

    /**
     * AD1DDAT3
     * ===================================================================================================
     * Offset: 0x12C  A/D double Data Register 3 for SAMPLE13
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |RESULT    |A/D Conversion Result
     * |        |          |This field contains 12 bits conversion result.
     * |[16]    |VALID     |Valid Flag
     * |        |          |0 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is not valid.
     * |        |          |1 = Double buffer data in RESULT (EADC_ADnDATx[11:0]) bits is valid.
     * |        |          |This bit is set to 1 when corresponding SAMPLE channel analog input conversion is completed and cleared by hardware after EADC_ADnDATx register is read.
    */
    __I  uint32_t AD1DDAT3;

    /**
     * DBMEN
     * ===================================================================================================
     * Offset: 0x130  A/D Double Buffer Mode select
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |AD0DBM0   |Double Buffer Mode For SAMPLE00
     * |        |          |0 = SAMPLE00 has one sample result register. (default).
     * |        |          |1 =SAMPLE00 has two sample result registers.
     * |[1]     |AD0DBM1   |Double Buffer Mode For SAMPLE01
     * |        |          |0 = SAMPLE01 has one sample result register. (default).
     * |        |          |1 = SAMPLE01 has two sample result registers.
     * |[2]     |AD0DBM2   |Double Buffer Mode For SAMPLE02
     * |        |          |0 = SAMPLE02 has one sample result register. (default).
     * |        |          |1 =SAMPLE02 has two sample result registers.
     * |[3]     |AD0DBM3   |Double Buffer Mode For SAMPLE03
     * |        |          |0 = SAMPLE03 has one sample result register. (default).
     * |        |          |1 =SAMPLE03 has two sample result registers.
     * |[8]     |AD1DBM0   |Double Buffer Mode For SAMPLE10
     * |        |          |0 = SAMPLE10 has one sample result register. (default)
     * |        |          |1 =SAMPLE10 has two sample result registers.
     * |[9]     |AD1DBM1   |Double Buffer Mode For SAMPLE11
     * |        |          |0 = SAMPLE11 has one sample result register. (default).
     * |        |          |1 =SAMPLE11 has two sample result registers.
     * |[10]    |AD1DBM2   |Double Buffer Mode For SAMPLE12
     * |        |          |0 = SAMPLE12 has one sample result register. (default).
     * |        |          |1 =SAMPLE12 has two sample result registers.
     * |[11]    |AD1DBM3   |Double Buffer Mode For SAMPLE13
     * |        |          |0 = SAMPLE13 has one sample result register. (default)
     * |        |          |1 =SAMPLE13 has two sample result registers.
    */
    __IO uint32_t DBMEN;

    /**
     * INTSRC0
     * ===================================================================================================
     * Offset: 0x134  A/D Interrupt 0 Source Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |AD0SPIE0  |SAMPLE00 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE00 interrupt mask Disabled.
     * |        |          |1 = SAMPLE00 interrupt mask Enabled.
     * |[1]     |AD0SPIE1  |SAMPLE01 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE01 interrupt mask Disabled.
     * |        |          |1 = SAMPLE01 interrupt mask Enabled.
     * |[2]     |AD0SPIE2  |SAMPLE02 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE02 interrupt mask Disabled.
     * |        |          |1 = SAMPLE02 interrupt mask Enabled.
     * |[3]     |AD0SPIE3  |SAMPLE03 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE03 interrupt mask Disabled.
     * |        |          |1 = SAMPLE03 interrupt mask Enabled.
     * |[4]     |AD0SPIE4  |SAMPLE04 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE04 interrupt mask Disabled.
     * |        |          |1 = SAMPLE04 interrupt mask Enabled.
     * |[5]     |AD0SPIE5  |SAMPLE05 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE05 interrupt mask Disabled.
     * |        |          |1 = SAMPLE05 interrupt mask Enabled.
     * |[6]     |AD0SPIE6  |SAMPLE06 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE06 interrupt mask Disabled.
     * |        |          |1 = SAMPLE06 interrupt mask Enabled.
     * |[7]     |AD0SPIE7  |SAMPLE07 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE07 interrupt mask Disabled.
     * |        |          |1 = SAMPLE07 interrupt mask Enabled.
     * |[8]     |AD1SPIE0  |SAMPLE10 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE10 interrupt mask Disabled.
     * |        |          |1 = SAMPLE10 interrupt mask Enabled.
     * |[9]     |AD1SPIE1  |SAMPLE11 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE11 interrupt mask Disabled.
     * |        |          |1 = SAMPLE11 interrupt mask Enabled.
     * |[10]    |AD1SPIE2  |SAMPLE12 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE12 interrupt mask Disabled.
     * |        |          |1 = SAMPLE12 interrupt mask Enabled.
     * |[11]    |AD1SPIE3  |SAMPLE13 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE13 interrupt mask Disabled.
     * |        |          |1 = SAMPLE13 interrupt mask Enabled.
     * |[12]    |AD1SPIE4  |SAMPLE14 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE14 interrupt mask Disabled.
     * |        |          |1 = SAMPLE14 interrupt mask Enabled.
     * |[13]    |AD1SPIE5  |SAMPLE15 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE15 interrupt mask Disabled.
     * |        |          |1 = SAMPLE15 interrupt mask Enabled.
     * |[14]    |AD1SPIE6  |SAMPLE16 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE16 interrupt mask Disabled.
     * |        |          |1 = SAMPLE16 interrupt mask Enabled.
     * |[15]    |AD1SPIE7  |SAMPLE17 Interrupt Mask Enable Control
     * |        |          |0 = SAMPLE17 interrupt mask Disabled.
     * |        |          |1 = SAMPLE17 interrupt mask Enabled.
    */
    __IO uint32_t INTSRC[4];

    /**
     * AD0TRGEN0
     * ===================================================================================================
     * Offset: 0x144  A/D trigger condition for SAMPLE00
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPWM00REN |EPWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |EPWM00FEN |EPWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |EPWM00PEN |EPWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |EPWM00CEN |EPWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |EPWM02REN |EPWM0_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |EPWM02FEN |EPWM0_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |EPWM02PEN |EPWM0_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[7]     |EPWM02CEN |EPWM0_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |EPWM04REN |EPWM0_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[9]     |EPWM04FEN |EPWM0_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[10]    |EPWM04PEN |EPWM0_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[11]    |EPWM04CEN |EPWM0_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[12]    |EPWM10REN |EPWM1_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |EPWM10FEN |EPWM1_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |EPWM10PEN |EPWM1_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[15]    |EPWM10CEN |EPWM1_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[16]    |EPWM12REN |EPWM1_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[17]    |EPWM120FEN|EPWM1_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[18]    |EPWM12PEN |EPWM1_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[19]    |EPWM12CEN |EPWM1_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[20]    |EPWM14REN |EPWM1_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[21]    |EPWM14FEN |EPWM1_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[22]    |EPWM14PEN |EPWM1_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[23]    |EPWM14CEN |EPWM1_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[24]    |PWM00REN  |PWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[25]    |PWM00FEN  |PWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[26]    |PWM00PEN  |PWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[27]    |PWM00CEN  |PWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[28]    |PWM01REN  |PWM0_CH1 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[29]    |PWM01FEN  |PWM0_CH1 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |PWM01PEN  |PWM0_CH1 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[31]    |PWM01CEN  |PWM0_CH1 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
    */
    __IO uint32_t AD0TRGEN0;

    /**
     * AD0TRGEN1
     * ===================================================================================================
     * Offset: 0x148  A/D trigger condition for SAMPLE01
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPWM00REN |EPWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |EPWM00FEN |EPWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |EPWM00PEN |EPWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |EPWM00CEN |EPWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |EPWM02REN |EPWM0_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |EPWM02FEN |EPWM0_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |EPWM02PEN |EPWM0_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[7]     |EPWM02CEN |EPWM0_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |EPWM04REN |EPWM0_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[9]     |EPWM04FEN |EPWM0_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[10]    |EPWM04PEN |EPWM0_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[11]    |EPWM04CEN |EPWM0_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[12]    |EPWM10REN |EPWM1_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |EPWM10FEN |EPWM1_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |EPWM10PEN |EPWM1_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[15]    |EPWM10CEN |EPWM1_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[16]    |EPWM12REN |EPWM1_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[17]    |EPWM120FEN|EPWM1_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[18]    |EPWM12PEN |EPWM1_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[19]    |EPWM12CEN |EPWM1_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[20]    |EPWM14REN |EPWM1_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[21]    |EPWM14FEN |EPWM1_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[22]    |EPWM14PEN |EPWM1_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[23]    |EPWM14CEN |EPWM1_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[24]    |PWM00REN  |PWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[25]    |PWM00FEN  |PWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[26]    |PWM00PEN  |PWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[27]    |PWM00CEN  |PWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[28]    |PWM01REN  |PWM0_CH1 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[29]    |PWM01FEN  |PWM0_CH1 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |PWM01PEN  |PWM0_CH1 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[31]    |PWM01CEN  |PWM0_CH1 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
    */
    __IO uint32_t AD0TRGEN1;

    /**
     * AD0TRGEN2
     * ===================================================================================================
     * Offset: 0x14C  A/D trigger condition for SAMPLE02
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPWM00REN |EPWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |EPWM00FEN |EPWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |EPWM00PEN |EPWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |EPWM00CEN |EPWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |EPWM02REN |EPWM0_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |EPWM02FEN |EPWM0_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |EPWM02PEN |EPWM0_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[7]     |EPWM02CEN |EPWM0_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |EPWM04REN |EPWM0_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[9]     |EPWM04FEN |EPWM0_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[10]    |EPWM04PEN |EPWM0_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[11]    |EPWM04CEN |EPWM0_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[12]    |EPWM10REN |EPWM1_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |EPWM10FEN |EPWM1_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |EPWM10PEN |EPWM1_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[15]    |EPWM10CEN |EPWM1_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[16]    |EPWM12REN |EPWM1_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[17]    |EPWM120FEN|EPWM1_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[18]    |EPWM12PEN |EPWM1_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[19]    |EPWM12CEN |EPWM1_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[20]    |EPWM14REN |EPWM1_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[21]    |EPWM14FEN |EPWM1_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[22]    |EPWM14PEN |EPWM1_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[23]    |EPWM14CEN |EPWM1_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[24]    |PWM00REN  |PWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[25]    |PWM00FEN  |PWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[26]    |PWM00PEN  |PWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[27]    |PWM00CEN  |PWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[28]    |PWM01REN  |PWM0_CH1 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[29]    |PWM01FEN  |PWM0_CH1 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |PWM01PEN  |PWM0_CH1 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[31]    |PWM01CEN  |PWM0_CH1 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
    */
    __IO uint32_t AD0TRGEN2;

    /**
     * AD0TRGEN3
     * ===================================================================================================
     * Offset: 0x150  A/D trigger condition for SAMPLE03
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPWM00REN |EPWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |EPWM00FEN |EPWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |EPWM00PEN |EPWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |EPWM00CEN |EPWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |EPWM02REN |EPWM0_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |EPWM02FEN |EPWM0_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |EPWM02PEN |EPWM0_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[7]     |EPWM02CEN |EPWM0_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |EPWM04REN |EPWM0_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[9]     |EPWM04FEN |EPWM0_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[10]    |EPWM04PEN |EPWM0_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[11]    |EPWM04CEN |EPWM0_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[12]    |EPWM10REN |EPWM1_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |EPWM10FEN |EPWM1_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |EPWM10PEN |EPWM1_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[15]    |EPWM10CEN |EPWM1_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[16]    |EPWM12REN |EPWM1_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[17]    |EPWM120FEN|EPWM1_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[18]    |EPWM12PEN |EPWM1_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[19]    |EPWM12CEN |EPWM1_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[20]    |EPWM14REN |EPWM1_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[21]    |EPWM14FEN |EPWM1_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[22]    |EPWM14PEN |EPWM1_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[23]    |EPWM14CEN |EPWM1_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[24]    |PWM00REN  |PWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[25]    |PWM00FEN  |PWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[26]    |PWM00PEN  |PWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[27]    |PWM00CEN  |PWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[28]    |PWM01REN  |PWM0_CH1 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[29]    |PWM01FEN  |PWM0_CH1 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |PWM01PEN  |PWM0_CH1 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[31]    |PWM01CEN  |PWM0_CH1 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
    */
    __IO uint32_t AD0TRGEN3;

    /**
     * AD1TRGEN0
     * ===================================================================================================
     * Offset: 0x154  A/D trigger condition for SAMPLE10
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPWM00REN |EPWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |EPWM00FEN |EPWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |EPWM00PEN |EPWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |EPWM00CEN |EPWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |EPWM02REN |EPWM0_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |EPWM02FEN |EPWM0_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |EPWM02PEN |EPWM0_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[7]     |EPWM02CEN |EPWM0_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |EPWM04REN |EPWM0_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[9]     |EPWM04FEN |EPWM0_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[10]    |EPWM04PEN |EPWM0_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[11]    |EPWM04CEN |EPWM0_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[12]    |EPWM10REN |EPWM1_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |EPWM10FEN |EPWM1_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |EPWM10PEN |EPWM1_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[15]    |EPWM10CEN |EPWM1_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[16]    |EPWM12REN |EPWM1_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[17]    |EPWM120FEN|EPWM1_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[18]    |EPWM12PEN |EPWM1_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[19]    |EPWM12CEN |EPWM1_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[20]    |EPWM14REN |EPWM1_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[21]    |EPWM14FEN |EPWM1_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[22]    |EPWM14PEN |EPWM1_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[23]    |EPWM14CEN |EPWM1_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[24]    |PWM00REN  |PWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[25]    |PWM00FEN  |PWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[26]    |PWM00PEN  |PWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[27]    |PWM00CEN  |PWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[28]    |PWM01REN  |PWM0_CH1 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[29]    |PWM01FEN  |PWM0_CH1 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |PWM01PEN  |PWM0_CH1 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[31]    |PWM01CEN  |PWM0_CH1 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
    */
    __IO uint32_t AD1TRGEN0;

    /**
     * AD1TRGEN1
     * ===================================================================================================
     * Offset: 0x158  A/D trigger condition for SAMPLE11
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPWM00REN |EPWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |EPWM00FEN |EPWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |EPWM00PEN |EPWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |EPWM00CEN |EPWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |EPWM02REN |EPWM0_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |EPWM02FEN |EPWM0_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |EPWM02PEN |EPWM0_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[7]     |EPWM02CEN |EPWM0_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |EPWM04REN |EPWM0_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[9]     |EPWM04FEN |EPWM0_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[10]    |EPWM04PEN |EPWM0_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[11]    |EPWM04CEN |EPWM0_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[12]    |EPWM10REN |EPWM1_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |EPWM10FEN |EPWM1_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |EPWM10PEN |EPWM1_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[15]    |EPWM10CEN |EPWM1_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[16]    |EPWM12REN |EPWM1_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[17]    |EPWM120FEN|EPWM1_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[18]    |EPWM12PEN |EPWM1_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[19]    |EPWM12CEN |EPWM1_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[20]    |EPWM14REN |EPWM1_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[21]    |EPWM14FEN |EPWM1_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[22]    |EPWM14PEN |EPWM1_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[23]    |EPWM14CEN |EPWM1_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[24]    |PWM00REN  |PWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[25]    |PWM00FEN  |PWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[26]    |PWM00PEN  |PWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[27]    |PWM00CEN  |PWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[28]    |PWM01REN  |PWM0_CH1 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[29]    |PWM01FEN  |PWM0_CH1 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |PWM01PEN  |PWM0_CH1 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[31]    |PWM01CEN  |PWM0_CH1 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
    */
    __IO uint32_t AD1TRGEN1;

    /**
     * AD1TRGEN2
     * ===================================================================================================
     * Offset: 0x15C  A/D trigger condition for SAMPLE12
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPWM00REN |EPWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |EPWM00FEN |EPWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |EPWM00PEN |EPWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |EPWM00CEN |EPWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |EPWM02REN |EPWM0_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |EPWM02FEN |EPWM0_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |EPWM02PEN |EPWM0_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[7]     |EPWM02CEN |EPWM0_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |EPWM04REN |EPWM0_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[9]     |EPWM04FEN |EPWM0_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[10]    |EPWM04PEN |EPWM0_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[11]    |EPWM04CEN |EPWM0_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[12]    |EPWM10REN |EPWM1_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |EPWM10FEN |EPWM1_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |EPWM10PEN |EPWM1_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[15]    |EPWM10CEN |EPWM1_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[16]    |EPWM12REN |EPWM1_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[17]    |EPWM120FEN|EPWM1_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[18]    |EPWM12PEN |EPWM1_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[19]    |EPWM12CEN |EPWM1_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[20]    |EPWM14REN |EPWM1_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[21]    |EPWM14FEN |EPWM1_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[22]    |EPWM14PEN |EPWM1_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[23]    |EPWM14CEN |EPWM1_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[24]    |PWM00REN  |PWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[25]    |PWM00FEN  |PWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[26]    |PWM00PEN  |PWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[27]    |PWM00CEN  |PWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[28]    |PWM01REN  |PWM0_CH1 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[29]    |PWM01FEN  |PWM0_CH1 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |PWM01PEN  |PWM0_CH1 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[31]    |PWM01CEN  |PWM0_CH1 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
    */
    __IO uint32_t AD1TRGEN2;

    /**
     * AD1TRGEN3
     * ===================================================================================================
     * Offset: 0x160  A/D trigger condition for SAMPLE13
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPWM00REN |EPWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |EPWM00FEN |EPWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |EPWM00PEN |EPWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |EPWM00CEN |EPWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |EPWM02REN |EPWM0_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |EPWM02FEN |EPWM0_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |EPWM02PEN |EPWM0_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[7]     |EPWM02CEN |EPWM0_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |EPWM04REN |EPWM0_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[9]     |EPWM04FEN |EPWM0_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[10]    |EPWM04PEN |EPWM0_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[11]    |EPWM04CEN |EPWM0_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[12]    |EPWM10REN |EPWM1_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |EPWM10FEN |EPWM1_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |EPWM10PEN |EPWM1_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[15]    |EPWM10CEN |EPWM1_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[16]    |EPWM12REN |EPWM1_CH2 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[17]    |EPWM120FEN|EPWM1_CH2 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[18]    |EPWM12PEN |EPWM1_CH2 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[19]    |EPWM12CEN |EPWM1_CH2 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[20]    |EPWM14REN |EPWM1_CH4 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[21]    |EPWM14FEN |EPWM1_CH4 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[22]    |EPWM14PEN |EPWM1_CH4 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[23]    |EPWM14CEN |EPWM1_CH4 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[24]    |PWM00REN  |PWM0_CH0 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[25]    |PWM00FEN  |PWM0_CH0 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[26]    |PWM00PEN  |PWM0_CH0 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[27]    |PWM00CEN  |PWM0_CH0 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[28]    |PWM01REN  |PWM0_CH1 Rising Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[29]    |PWM01FEN  |PWM0_CH1 Falling Edge Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |PWM01PEN  |PWM0_CH1 Period Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[31]    |PWM01CEN  |PWM0_CH1 Center Trigger Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
    */
    __IO uint32_t AD1TRGEN3;

} EADC_T;

/**
    @addtogroup EADC_CONST EADC Bit Field Definition
    Constant Definitions for EADC Controller
@{ */

#define EADC_AD0DAT0_RESULT_Pos          (0)                                               /*!< EADC_T::AD0DAT0: RESULT Position          */
#define EADC_AD0DAT0_RESULT_Msk          (0xffful << EADC_AD0DAT0_RESULT_Pos)              /*!< EADC_T::AD0DAT0: RESULT Mask              */

#define EADC_AD0DAT0_OV_Pos              (16)                                              /*!< EADC_T::AD0DAT0: OV Position              */
#define EADC_AD0DAT0_OV_Msk              (0x1ul << EADC_AD0DAT0_OV_Pos)                    /*!< EADC_T::AD0DAT0: OV Mask                  */

#define EADC_AD0DAT0_VALID_Pos           (17)                                              /*!< EADC_T::AD0DAT0: VALID Position           */
#define EADC_AD0DAT0_VALID_Msk           (0x1ul << EADC_AD0DAT0_VALID_Pos)                 /*!< EADC_T::AD0DAT0: VALID Mask               */

#define EADC_AD0DAT1_RESULT_Pos          (0)                                               /*!< EADC_T::AD0DAT1: RESULT Position          */
#define EADC_AD0DAT1_RESULT_Msk          (0xffful << EADC_AD0DAT1_RESULT_Pos)              /*!< EADC_T::AD0DAT1: RESULT Mask              */

#define EADC_AD0DAT1_OV_Pos              (16)                                              /*!< EADC_T::AD0DAT1: OV Position              */
#define EADC_AD0DAT1_OV_Msk              (0x1ul << EADC_AD0DAT1_OV_Pos)                    /*!< EADC_T::AD0DAT1: OV Mask                  */

#define EADC_AD0DAT1_VALID_Pos           (17)                                              /*!< EADC_T::AD0DAT1: VALID Position           */
#define EADC_AD0DAT1_VALID_Msk           (0x1ul << EADC_AD0DAT1_VALID_Pos)                 /*!< EADC_T::AD0DAT1: VALID Mask               */

#define EADC_AD0DAT2_RESULT_Pos          (0)                                               /*!< EADC_T::AD0DAT2: RESULT Position          */
#define EADC_AD0DAT2_RESULT_Msk          (0xffful << EADC_AD0DAT2_RESULT_Pos)              /*!< EADC_T::AD0DAT2: RESULT Mask              */

#define EADC_AD0DAT2_OV_Pos              (16)                                              /*!< EADC_T::AD0DAT2: OV Position              */
#define EADC_AD0DAT2_OV_Msk              (0x1ul << EADC_AD0DAT2_OV_Pos)                    /*!< EADC_T::AD0DAT2: OV Mask                  */

#define EADC_AD0DAT2_VALID_Pos           (17)                                              /*!< EADC_T::AD0DAT2: VALID Position           */
#define EADC_AD0DAT2_VALID_Msk           (0x1ul << EADC_AD0DAT2_VALID_Pos)                 /*!< EADC_T::AD0DAT2: VALID Mask               */

#define EADC_AD0DAT3_RESULT_Pos          (0)                                               /*!< EADC_T::AD0DAT3: RESULT Position          */
#define EADC_AD0DAT3_RESULT_Msk          (0xffful << EADC_AD0DAT3_RESULT_Pos)              /*!< EADC_T::AD0DAT3: RESULT Mask              */

#define EADC_AD0DAT3_OV_Pos              (16)                                              /*!< EADC_T::AD0DAT3: OV Position              */
#define EADC_AD0DAT3_OV_Msk              (0x1ul << EADC_AD0DAT3_OV_Pos)                    /*!< EADC_T::AD0DAT3: OV Mask                  */

#define EADC_AD0DAT3_VALID_Pos           (17)                                              /*!< EADC_T::AD0DAT3: VALID Position           */
#define EADC_AD0DAT3_VALID_Msk           (0x1ul << EADC_AD0DAT3_VALID_Pos)                 /*!< EADC_T::AD0DAT3: VALID Mask               */

#define EADC_AD0DAT4_RESULT_Pos          (0)                                               /*!< EADC_T::AD0DAT4: RESULT Position          */
#define EADC_AD0DAT4_RESULT_Msk          (0xffful << EADC_AD0DAT4_RESULT_Pos)              /*!< EADC_T::AD0DAT4: RESULT Mask              */

#define EADC_AD0DAT4_OV_Pos              (16)                                              /*!< EADC_T::AD0DAT4: OV Position              */
#define EADC_AD0DAT4_OV_Msk              (0x1ul << EADC_AD0DAT4_OV_Pos)                    /*!< EADC_T::AD0DAT4: OV Mask                  */

#define EADC_AD0DAT4_VALID_Pos           (17)                                              /*!< EADC_T::AD0DAT4: VALID Position           */
#define EADC_AD0DAT4_VALID_Msk           (0x1ul << EADC_AD0DAT4_VALID_Pos)                 /*!< EADC_T::AD0DAT4: VALID Mask               */

#define EADC_AD0DAT5_RESULT_Pos          (0)                                               /*!< EADC_T::AD0DAT5: RESULT Position          */
#define EADC_AD0DAT5_RESULT_Msk          (0xffful << EADC_AD0DAT5_RESULT_Pos)              /*!< EADC_T::AD0DAT5: RESULT Mask              */

#define EADC_AD0DAT5_OV_Pos              (16)                                              /*!< EADC_T::AD0DAT5: OV Position              */
#define EADC_AD0DAT5_OV_Msk              (0x1ul << EADC_AD0DAT5_OV_Pos)                    /*!< EADC_T::AD0DAT5: OV Mask                  */

#define EADC_AD0DAT5_VALID_Pos           (17)                                              /*!< EADC_T::AD0DAT5: VALID Position           */
#define EADC_AD0DAT5_VALID_Msk           (0x1ul << EADC_AD0DAT5_VALID_Pos)                 /*!< EADC_T::AD0DAT5: VALID Mask               */

#define EADC_AD0DAT6_RESULT_Pos          (0)                                               /*!< EADC_T::AD0DAT6: RESULT Position          */
#define EADC_AD0DAT6_RESULT_Msk          (0xffful << EADC_AD0DAT6_RESULT_Pos)              /*!< EADC_T::AD0DAT6: RESULT Mask              */

#define EADC_AD0DAT6_OV_Pos              (16)                                              /*!< EADC_T::AD0DAT6: OV Position              */
#define EADC_AD0DAT6_OV_Msk              (0x1ul << EADC_AD0DAT6_OV_Pos)                    /*!< EADC_T::AD0DAT6: OV Mask                  */

#define EADC_AD0DAT6_VALID_Pos           (17)                                              /*!< EADC_T::AD0DAT6: VALID Position           */
#define EADC_AD0DAT6_VALID_Msk           (0x1ul << EADC_AD0DAT6_VALID_Pos)                 /*!< EADC_T::AD0DAT6: VALID Mask               */

#define EADC_AD0DAT7_RESULT_Pos          (0)                                               /*!< EADC_T::AD0DAT7: RESULT Position          */
#define EADC_AD0DAT7_RESULT_Msk          (0xffful << EADC_AD0DAT7_RESULT_Pos)              /*!< EADC_T::AD0DAT7: RESULT Mask              */

#define EADC_AD0DAT7_OV_Pos              (16)                                              /*!< EADC_T::AD0DAT7: OV Position              */
#define EADC_AD0DAT7_OV_Msk              (0x1ul << EADC_AD0DAT7_OV_Pos)                    /*!< EADC_T::AD0DAT7: OV Mask                  */

#define EADC_AD0DAT7_VALID_Pos           (17)                                              /*!< EADC_T::AD0DAT7: VALID Position           */
#define EADC_AD0DAT7_VALID_Msk           (0x1ul << EADC_AD0DAT7_VALID_Pos)                 /*!< EADC_T::AD0DAT7: VALID Mask               */

#define EADC_AD1DAT0_RESULT_Pos          (0)                                               /*!< EADC_T::AD1DAT0: RESULT Position          */
#define EADC_AD1DAT0_RESULT_Msk          (0xffful << EADC_AD1DAT0_RESULT_Pos)              /*!< EADC_T::AD1DAT0: RESULT Mask              */

#define EADC_AD1DAT0_OV_Pos              (16)                                              /*!< EADC_T::AD1DAT0: OV Position              */
#define EADC_AD1DAT0_OV_Msk              (0x1ul << EADC_AD1DAT0_OV_Pos)                    /*!< EADC_T::AD1DAT0: OV Mask                  */

#define EADC_AD1DAT0_VALID_Pos           (17)                                              /*!< EADC_T::AD1DAT0: VALID Position           */
#define EADC_AD1DAT0_VALID_Msk           (0x1ul << EADC_AD1DAT0_VALID_Pos)                 /*!< EADC_T::AD1DAT0: VALID Mask               */

#define EADC_AD1DAT1_RESULT_Pos          (0)                                               /*!< EADC_T::AD1DAT1: RESULT Position          */
#define EADC_AD1DAT1_RESULT_Msk          (0xffful << EADC_AD1DAT1_RESULT_Pos)              /*!< EADC_T::AD1DAT1: RESULT Mask              */

#define EADC_AD1DAT1_OV_Pos              (16)                                              /*!< EADC_T::AD1DAT1: OV Position              */
#define EADC_AD1DAT1_OV_Msk              (0x1ul << EADC_AD1DAT1_OV_Pos)                    /*!< EADC_T::AD1DAT1: OV Mask                  */

#define EADC_AD1DAT1_VALID_Pos           (17)                                              /*!< EADC_T::AD1DAT1: VALID Position           */
#define EADC_AD1DAT1_VALID_Msk           (0x1ul << EADC_AD1DAT1_VALID_Pos)                 /*!< EADC_T::AD1DAT1: VALID Mask               */

#define EADC_AD1DAT2_RESULT_Pos          (0)                                               /*!< EADC_T::AD1DAT2: RESULT Position          */
#define EADC_AD1DAT2_RESULT_Msk          (0xffful << EADC_AD1DAT2_RESULT_Pos)              /*!< EADC_T::AD1DAT2: RESULT Mask              */

#define EADC_AD1DAT2_OV_Pos              (16)                                              /*!< EADC_T::AD1DAT2: OV Position              */
#define EADC_AD1DAT2_OV_Msk              (0x1ul << EADC_AD1DAT2_OV_Pos)                    /*!< EADC_T::AD1DAT2: OV Mask                  */

#define EADC_AD1DAT2_VALID_Pos           (17)                                              /*!< EADC_T::AD1DAT2: VALID Position           */
#define EADC_AD1DAT2_VALID_Msk           (0x1ul << EADC_AD1DAT2_VALID_Pos)                 /*!< EADC_T::AD1DAT2: VALID Mask               */

#define EADC_AD1DAT3_RESULT_Pos          (0)                                               /*!< EADC_T::AD1DAT3: RESULT Position          */
#define EADC_AD1DAT3_RESULT_Msk          (0xffful << EADC_AD1DAT3_RESULT_Pos)              /*!< EADC_T::AD1DAT3: RESULT Mask              */

#define EADC_AD1DAT3_OV_Pos              (16)                                              /*!< EADC_T::AD1DAT3: OV Position              */
#define EADC_AD1DAT3_OV_Msk              (0x1ul << EADC_AD1DAT3_OV_Pos)                    /*!< EADC_T::AD1DAT3: OV Mask                  */

#define EADC_AD1DAT3_VALID_Pos           (17)                                              /*!< EADC_T::AD1DAT3: VALID Position           */
#define EADC_AD1DAT3_VALID_Msk           (0x1ul << EADC_AD1DAT3_VALID_Pos)                 /*!< EADC_T::AD1DAT3: VALID Mask               */

#define EADC_AD1DAT4_RESULT_Pos          (0)                                               /*!< EADC_T::AD1DAT4: RESULT Position          */
#define EADC_AD1DAT4_RESULT_Msk          (0xffful << EADC_AD1DAT4_RESULT_Pos)              /*!< EADC_T::AD1DAT4: RESULT Mask              */

#define EADC_AD1DAT4_OV_Pos              (16)                                              /*!< EADC_T::AD1DAT4: OV Position              */
#define EADC_AD1DAT4_OV_Msk              (0x1ul << EADC_AD1DAT4_OV_Pos)                    /*!< EADC_T::AD1DAT4: OV Mask                  */

#define EADC_AD1DAT4_VALID_Pos           (17)                                              /*!< EADC_T::AD1DAT4: VALID Position           */
#define EADC_AD1DAT4_VALID_Msk           (0x1ul << EADC_AD1DAT4_VALID_Pos)                 /*!< EADC_T::AD1DAT4: VALID Mask               */

#define EADC_AD1DAT5_RESULT_Pos          (0)                                               /*!< EADC_T::AD1DAT5: RESULT Position          */
#define EADC_AD1DAT5_RESULT_Msk          (0xffful << EADC_AD1DAT5_RESULT_Pos)              /*!< EADC_T::AD1DAT5: RESULT Mask              */

#define EADC_AD1DAT5_OV_Pos              (16)                                              /*!< EADC_T::AD1DAT5: OV Position              */
#define EADC_AD1DAT5_OV_Msk              (0x1ul << EADC_AD1DAT5_OV_Pos)                    /*!< EADC_T::AD1DAT5: OV Mask                  */

#define EADC_AD1DAT5_VALID_Pos           (17)                                              /*!< EADC_T::AD1DAT5: VALID Position           */
#define EADC_AD1DAT5_VALID_Msk           (0x1ul << EADC_AD1DAT5_VALID_Pos)                 /*!< EADC_T::AD1DAT5: VALID Mask               */

#define EADC_AD1DAT6_RESULT_Pos          (0)                                               /*!< EADC_T::AD1DAT6: RESULT Position          */
#define EADC_AD1DAT6_RESULT_Msk          (0xffful << EADC_AD1DAT6_RESULT_Pos)              /*!< EADC_T::AD1DAT6: RESULT Mask              */

#define EADC_AD1DAT6_OV_Pos              (16)                                              /*!< EADC_T::AD1DAT6: OV Position              */
#define EADC_AD1DAT6_OV_Msk              (0x1ul << EADC_AD1DAT6_OV_Pos)                    /*!< EADC_T::AD1DAT6: OV Mask                  */

#define EADC_AD1DAT6_VALID_Pos           (17)                                              /*!< EADC_T::AD1DAT6: VALID Position           */
#define EADC_AD1DAT6_VALID_Msk           (0x1ul << EADC_AD1DAT6_VALID_Pos)                 /*!< EADC_T::AD1DAT6: VALID Mask               */

#define EADC_AD1DAT7_RESULT_Pos          (0)                                               /*!< EADC_T::AD1DAT7: RESULT Position          */
#define EADC_AD1DAT7_RESULT_Msk          (0xffful << EADC_AD1DAT7_RESULT_Pos)              /*!< EADC_T::AD1DAT7: RESULT Mask              */

#define EADC_AD1DAT7_OV_Pos              (16)                                              /*!< EADC_T::AD1DAT7: OV Position              */
#define EADC_AD1DAT7_OV_Msk              (0x1ul << EADC_AD1DAT7_OV_Pos)                    /*!< EADC_T::AD1DAT7: OV Mask                  */

#define EADC_AD1DAT7_VALID_Pos           (17)                                              /*!< EADC_T::AD1DAT7: VALID Position           */
#define EADC_AD1DAT7_VALID_Msk           (0x1ul << EADC_AD1DAT7_VALID_Pos)                 /*!< EADC_T::AD1DAT7: VALID Mask               */

#define EADC_CTL_ADCEN_Pos               (0)                                               /*!< EADC_T::CTL: ADCEN Position               */
#define EADC_CTL_ADCEN_Msk               (0x1ul << EADC_CTL_ADCEN_Pos)                     /*!< EADC_T::CTL: ADCEN Mask                   */

#define EADC_CTL_ADCRST_Pos              (1)                                               /*!< EADC_T::CTL: ADCRST Position              */
#define EADC_CTL_ADCRST_Msk              (0x1ul << EADC_CTL_ADCRST_Pos)                    /*!< EADC_T::CTL: ADCRST Mask                  */

#define EADC_CTL_ADCIEN0_Pos             (2)                                               /*!< EADC_T::CTL: ADCIEN0 Position             */
#define EADC_CTL_ADCIEN0_Msk             (0x1ul << EADC_CTL_ADCIEN0_Pos)                   /*!< EADC_T::CTL: ADCIEN0 Mask                 */

#define EADC_CTL_ADCIEN1_Pos             (3)                                               /*!< EADC_T::CTL: ADCIEN1 Position             */
#define EADC_CTL_ADCIEN1_Msk             (0x1ul << EADC_CTL_ADCIEN1_Pos)                   /*!< EADC_T::CTL: ADCIEN1 Mask                 */

#define EADC_CTL_ADCIEN2_Pos             (4)                                               /*!< EADC_T::CTL: ADCIEN2 Position             */
#define EADC_CTL_ADCIEN2_Msk             (0x1ul << EADC_CTL_ADCIEN2_Pos)                   /*!< EADC_T::CTL: ADCIEN2 Mask                 */

#define EADC_CTL_ADCIEN3_Pos             (5)                                               /*!< EADC_T::CTL: ADCIEN3 Position             */
#define EADC_CTL_ADCIEN3_Msk             (0x1ul << EADC_CTL_ADCIEN3_Pos)                   /*!< EADC_T::CTL: ADCIEN3 Mask                 */

#define EADC_SWTRG_SWTRG7_0_Pos          (0)                                               /*!< EADC_T::SWTRG: SWTRG7_0 Position          */
#define EADC_SWTRG_SWTRG7_0_Msk          (0xfful << EADC_SWTRG_SWTRG7_0_Pos)               /*!< EADC_T::SWTRG: SWTRG7_0 Mask              */

#define EADC_SWTRG_SWTRG15_8_Pos         (8)                                               /*!< EADC_T::SWTRG: SWTRG15_8 Position         */
#define EADC_SWTRG_SWTRG15_8_Msk         (0xfful << EADC_SWTRG_SWTRG15_8_Pos)              /*!< EADC_T::SWTRG: SWTRG15_8 Mask             */

#define EADC_PENDSTS_STPF7_0_Pos         (0)                                               /*!< EADC_T::PENDSTS: STPF7_0 Position         */
#define EADC_PENDSTS_STPF7_0_Msk         (0xfful << EADC_PENDSTS_STPF7_0_Pos)              /*!< EADC_T::PENDSTS: STPF7_0 Mask             */

#define EADC_PENDSTS_STPF15_8_Pos        (8)                                               /*!< EADC_T::PENDSTS: STPF15_8 Position        */
#define EADC_PENDSTS_STPF15_8_Msk        (0xfful << EADC_PENDSTS_STPF15_8_Pos)             /*!< EADC_T::PENDSTS: STPF15_8 Mask            */

#define EADC_ADIFOV_ADFOV0_Pos           (0)                                               /*!< EADC_T::ADIFOV: ADFOV0 Position           */
#define EADC_ADIFOV_ADFOV0_Msk           (0x1ul << EADC_ADIFOV_ADFOV0_Pos)                 /*!< EADC_T::ADIFOV: ADFOV0 Mask               */

#define EADC_ADIFOV_ADFOV1_Pos           (1)                                               /*!< EADC_T::ADIFOV: ADFOV1 Position           */
#define EADC_ADIFOV_ADFOV1_Msk           (0x1ul << EADC_ADIFOV_ADFOV1_Pos)                 /*!< EADC_T::ADIFOV: ADFOV1 Mask               */

#define EADC_ADIFOV_ADFOV2_Pos           (2)                                               /*!< EADC_T::ADIFOV: ADFOV2 Position           */
#define EADC_ADIFOV_ADFOV2_Msk           (0x1ul << EADC_ADIFOV_ADFOV2_Pos)                 /*!< EADC_T::ADIFOV: ADFOV2 Mask               */

#define EADC_ADIFOV_ADFOV3_Pos           (3)                                               /*!< EADC_T::ADIFOV: ADFOV3 Position           */
#define EADC_ADIFOV_ADFOV3_Msk           (0x1ul << EADC_ADIFOV_ADFOV3_Pos)                 /*!< EADC_T::ADIFOV: ADFOV3 Mask               */

#define EADC_OVSTS_SPOVF7_0_Pos          (0)                                               /*!< EADC_T::OVSTS: SPOVF7_0 Position          */
#define EADC_OVSTS_SPOVF7_0_Msk          (0xfful << EADC_OVSTS_SPOVF7_0_Pos)               /*!< EADC_T::OVSTS: SPOVF7_0 Mask              */

#define EADC_OVSTS_SPOVF15_8_Pos         (8)                                               /*!< EADC_T::OVSTS: SPOVF15_8 Position         */
#define EADC_OVSTS_SPOVF15_8_Msk         (0xfful << EADC_OVSTS_SPOVF15_8_Pos)              /*!< EADC_T::OVSTS: SPOVF15_8 Mask             */

#define EADC_AD0SPCTL0_CHSEL_Pos         (0)                                               /*!< EADC_T::AD0SPCTL0: CHSEL Position         */
#define EADC_AD0SPCTL0_CHSEL_Msk         (0xful << EADC_AD0SPCTL0_CHSEL_Pos)               /*!< EADC_T::AD0SPCTL0: CHSEL Mask             */

#define EADC_AD0SPCTL0_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD0SPCTL0: TRGSEL Position        */
#define EADC_AD0SPCTL0_TRGSEL_Msk        (0xful << EADC_AD0SPCTL0_TRGSEL_Pos)              /*!< EADC_T::AD0SPCTL0: TRGSEL Mask            */

#define EADC_AD0SPCTL0_TRGDLYCNT_Pos     (8)                                               /*!< EADC_T::AD0SPCTL0: TRGDLYCNT Position     */
#define EADC_AD0SPCTL0_TRGDLYCNT_Msk     (0xfful << EADC_AD0SPCTL0_TRGDLYCNT_Pos)          /*!< EADC_T::AD0SPCTL0: TRGDLYCNT Mask         */

#define EADC_AD0SPCTL0_TRGDLYDIV_Pos     (16)                                              /*!< EADC_T::AD0SPCTL0: TRGDLYDIV Position     */
#define EADC_AD0SPCTL0_TRGDLYDIV_Msk     (0x3ul << EADC_AD0SPCTL0_TRGDLYDIV_Pos)           /*!< EADC_T::AD0SPCTL0: TRGDLYDIV Mask         */

#define EADC_AD0SPCTL0_EXTREN_Pos        (20)                                              /*!< EADC_T::AD0SPCTL0: EXTREN Position        */
#define EADC_AD0SPCTL0_EXTREN_Msk        (0x1ul << EADC_AD0SPCTL0_EXTREN_Pos)              /*!< EADC_T::AD0SPCTL0: EXTREN Mask            */

#define EADC_AD0SPCTL0_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD0SPCTL0: EXTFEN Position        */
#define EADC_AD0SPCTL0_EXTFEN_Msk        (0x1ul << EADC_AD0SPCTL0_EXTFEN_Pos)              /*!< EADC_T::AD0SPCTL0: EXTFEN Mask            */

#define EADC_AD0SPCTL1_CHSEL_Pos         (0)                                               /*!< EADC_T::AD0SPCTL1: CHSEL Position         */
#define EADC_AD0SPCTL1_CHSEL_Msk         (0xful << EADC_AD0SPCTL1_CHSEL_Pos)               /*!< EADC_T::AD0SPCTL1: CHSEL Mask             */

#define EADC_AD0SPCTL1_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD0SPCTL1: TRGSEL Position        */
#define EADC_AD0SPCTL1_TRGSEL_Msk        (0xful << EADC_AD0SPCTL1_TRGSEL_Pos)              /*!< EADC_T::AD0SPCTL1: TRGSEL Mask            */

#define EADC_AD0SPCTL1_TRGDLYCNT_Pos     (8)                                               /*!< EADC_T::AD0SPCTL1: TRGDLYCNT Position     */
#define EADC_AD0SPCTL1_TRGDLYCNT_Msk     (0xfful << EADC_AD0SPCTL1_TRGDLYCNT_Pos)          /*!< EADC_T::AD0SPCTL1: TRGDLYCNT Mask         */

#define EADC_AD0SPCTL1_TRGDLYDIV_Pos     (16)                                              /*!< EADC_T::AD0SPCTL1: TRGDLYDIV Position     */
#define EADC_AD0SPCTL1_TRGDLYDIV_Msk     (0x3ul << EADC_AD0SPCTL1_TRGDLYDIV_Pos)           /*!< EADC_T::AD0SPCTL1: TRGDLYDIV Mask         */

#define EADC_AD0SPCTL1_EXTREN_Pos        (20)                                              /*!< EADC_T::AD0SPCTL1: EXTREN Position        */
#define EADC_AD0SPCTL1_EXTREN_Msk        (0x1ul << EADC_AD0SPCTL1_EXTREN_Pos)              /*!< EADC_T::AD0SPCTL1: EXTREN Mask            */

#define EADC_AD0SPCTL1_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD0SPCTL1: EXTFEN Position        */
#define EADC_AD0SPCTL1_EXTFEN_Msk        (0x1ul << EADC_AD0SPCTL1_EXTFEN_Pos)              /*!< EADC_T::AD0SPCTL1: EXTFEN Mask            */

#define EADC_AD0SPCTL2_CHSEL_Pos         (0)                                               /*!< EADC_T::AD0SPCTL2: CHSEL Position         */
#define EADC_AD0SPCTL2_CHSEL_Msk         (0xful << EADC_AD0SPCTL2_CHSEL_Pos)               /*!< EADC_T::AD0SPCTL2: CHSEL Mask             */

#define EADC_AD0SPCTL2_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD0SPCTL2: TRGSEL Position        */
#define EADC_AD0SPCTL2_TRGSEL_Msk        (0xful << EADC_AD0SPCTL2_TRGSEL_Pos)              /*!< EADC_T::AD0SPCTL2: TRGSEL Mask            */

#define EADC_AD0SPCTL2_TRGDLYCNT_Pos     (8)                                               /*!< EADC_T::AD0SPCTL2: TRGDLYCNT Position     */
#define EADC_AD0SPCTL2_TRGDLYCNT_Msk     (0xfful << EADC_AD0SPCTL2_TRGDLYCNT_Pos)          /*!< EADC_T::AD0SPCTL2: TRGDLYCNT Mask         */

#define EADC_AD0SPCTL2_TRGDLYDIV_Pos     (16)                                              /*!< EADC_T::AD0SPCTL2: TRGDLYDIV Position     */
#define EADC_AD0SPCTL2_TRGDLYDIV_Msk     (0x3ul << EADC_AD0SPCTL2_TRGDLYDIV_Pos)           /*!< EADC_T::AD0SPCTL2: TRGDLYDIV Mask         */

#define EADC_AD0SPCTL2_EXTREN_Pos        (20)                                              /*!< EADC_T::AD0SPCTL2: EXTREN Position        */
#define EADC_AD0SPCTL2_EXTREN_Msk        (0x1ul << EADC_AD0SPCTL2_EXTREN_Pos)              /*!< EADC_T::AD0SPCTL2: EXTREN Mask            */

#define EADC_AD0SPCTL2_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD0SPCTL2: EXTFEN Position        */
#define EADC_AD0SPCTL2_EXTFEN_Msk        (0x1ul << EADC_AD0SPCTL2_EXTFEN_Pos)              /*!< EADC_T::AD0SPCTL2: EXTFEN Mask            */

#define EADC_AD0SPCTL3_CHSEL_Pos         (0)                                               /*!< EADC_T::AD0SPCTL3: CHSEL Position         */
#define EADC_AD0SPCTL3_CHSEL_Msk         (0xful << EADC_AD0SPCTL3_CHSEL_Pos)               /*!< EADC_T::AD0SPCTL3: CHSEL Mask             */

#define EADC_AD0SPCTL3_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD0SPCTL3: TRGSEL Position        */
#define EADC_AD0SPCTL3_TRGSEL_Msk        (0xful << EADC_AD0SPCTL3_TRGSEL_Pos)              /*!< EADC_T::AD0SPCTL3: TRGSEL Mask            */

#define EADC_AD0SPCTL3_TRGDLYCNT_Pos     (8)                                               /*!< EADC_T::AD0SPCTL3: TRGDLYCNT Position     */
#define EADC_AD0SPCTL3_TRGDLYCNT_Msk     (0xfful << EADC_AD0SPCTL3_TRGDLYCNT_Pos)          /*!< EADC_T::AD0SPCTL3: TRGDLYCNT Mask         */

#define EADC_AD0SPCTL3_TRGDLYDIV_Pos     (16)                                              /*!< EADC_T::AD0SPCTL3: TRGDLYDIV Position     */
#define EADC_AD0SPCTL3_TRGDLYDIV_Msk     (0x3ul << EADC_AD0SPCTL3_TRGDLYDIV_Pos)           /*!< EADC_T::AD0SPCTL3: TRGDLYDIV Mask         */

#define EADC_AD0SPCTL3_EXTREN_Pos        (20)                                              /*!< EADC_T::AD0SPCTL3: EXTREN Position        */
#define EADC_AD0SPCTL3_EXTREN_Msk        (0x1ul << EADC_AD0SPCTL3_EXTREN_Pos)              /*!< EADC_T::AD0SPCTL3: EXTREN Mask            */

#define EADC_AD0SPCTL3_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD0SPCTL3: EXTFEN Position        */
#define EADC_AD0SPCTL3_EXTFEN_Msk        (0x1ul << EADC_AD0SPCTL3_EXTFEN_Pos)              /*!< EADC_T::AD0SPCTL3: EXTFEN Mask            */

#define EADC_AD0SPCTL4_CHSEL_Pos         (0)                                               /*!< EADC_T::AD0SPCTL4: CHSEL Position         */
#define EADC_AD0SPCTL4_CHSEL_Msk         (0xful << EADC_AD0SPCTL4_CHSEL_Pos)               /*!< EADC_T::AD0SPCTL4: CHSEL Mask             */

#define EADC_AD0SPCTL4_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD0SPCTL4: TRGSEL Position        */
#define EADC_AD0SPCTL4_TRGSEL_Msk        (0x7ul << EADC_AD0SPCTL4_TRGSEL_Pos)              /*!< EADC_T::AD0SPCTL4: TRGSEL Mask            */

#define EADC_AD0SPCTL4_EXTREN_Pos        (20)                                              /*!< EADC_T::AD0SPCTL4: EXTREN Position        */
#define EADC_AD0SPCTL4_EXTREN_Msk        (0x1ul << EADC_AD0SPCTL4_EXTREN_Pos)              /*!< EADC_T::AD0SPCTL4: EXTREN Mask            */

#define EADC_AD0SPCTL4_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD0SPCTL4: EXTFEN Position        */
#define EADC_AD0SPCTL4_EXTFEN_Msk        (0x1ul << EADC_AD0SPCTL4_EXTFEN_Pos)              /*!< EADC_T::AD0SPCTL4: EXTFEN Mask            */

#define EADC_AD0SPCTL5_CHSEL_Pos         (0)                                               /*!< EADC_T::AD0SPCTL5: CHSEL Position         */
#define EADC_AD0SPCTL5_CHSEL_Msk         (0xful << EADC_AD0SPCTL5_CHSEL_Pos)               /*!< EADC_T::AD0SPCTL5: CHSEL Mask             */

#define EADC_AD0SPCTL5_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD0SPCTL5: TRGSEL Position        */
#define EADC_AD0SPCTL5_TRGSEL_Msk        (0x7ul << EADC_AD0SPCTL5_TRGSEL_Pos)              /*!< EADC_T::AD0SPCTL5: TRGSEL Mask            */

#define EADC_AD0SPCTL5_EXTREN_Pos        (20)                                              /*!< EADC_T::AD0SPCTL5: EXTREN Position        */
#define EADC_AD0SPCTL5_EXTREN_Msk        (0x1ul << EADC_AD0SPCTL5_EXTREN_Pos)              /*!< EADC_T::AD0SPCTL5: EXTREN Mask            */

#define EADC_AD0SPCTL5_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD0SPCTL5: EXTFEN Position        */
#define EADC_AD0SPCTL5_EXTFEN_Msk        (0x1ul << EADC_AD0SPCTL5_EXTFEN_Pos)              /*!< EADC_T::AD0SPCTL5: EXTFEN Mask            */

#define EADC_AD0SPCTL6_CHSEL_Pos         (0)                                               /*!< EADC_T::AD0SPCTL6: CHSEL Position         */
#define EADC_AD0SPCTL6_CHSEL_Msk         (0xful << EADC_AD0SPCTL6_CHSEL_Pos)               /*!< EADC_T::AD0SPCTL6: CHSEL Mask             */

#define EADC_AD0SPCTL6_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD0SPCTL6: TRGSEL Position        */
#define EADC_AD0SPCTL6_TRGSEL_Msk        (0x7ul << EADC_AD0SPCTL6_TRGSEL_Pos)              /*!< EADC_T::AD0SPCTL6: TRGSEL Mask            */

#define EADC_AD0SPCTL6_EXTREN_Pos        (20)                                              /*!< EADC_T::AD0SPCTL6: EXTREN Position        */
#define EADC_AD0SPCTL6_EXTREN_Msk        (0x1ul << EADC_AD0SPCTL6_EXTREN_Pos)              /*!< EADC_T::AD0SPCTL6: EXTREN Mask            */

#define EADC_AD0SPCTL6_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD0SPCTL6: EXTFEN Position        */
#define EADC_AD0SPCTL6_EXTFEN_Msk        (0x1ul << EADC_AD0SPCTL6_EXTFEN_Pos)              /*!< EADC_T::AD0SPCTL6: EXTFEN Mask            */

#define EADC_AD0SPCTL7_CHSEL_Pos         (0)                                               /*!< EADC_T::AD0SPCTL7: CHSEL Position         */
#define EADC_AD0SPCTL7_CHSEL_Msk         (0xful << EADC_AD0SPCTL7_CHSEL_Pos)               /*!< EADC_T::AD0SPCTL7: CHSEL Mask             */

#define EADC_AD0SPCTL7_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD0SPCTL7: TRGSEL Position        */
#define EADC_AD0SPCTL7_TRGSEL_Msk        (0x7ul << EADC_AD0SPCTL7_TRGSEL_Pos)              /*!< EADC_T::AD0SPCTL7: TRGSEL Mask            */

#define EADC_AD0SPCTL7_EXTREN_Pos        (20)                                              /*!< EADC_T::AD0SPCTL7: EXTREN Position        */
#define EADC_AD0SPCTL7_EXTREN_Msk        (0x1ul << EADC_AD0SPCTL7_EXTREN_Pos)              /*!< EADC_T::AD0SPCTL7: EXTREN Mask            */

#define EADC_AD0SPCTL7_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD0SPCTL7: EXTFEN Position        */
#define EADC_AD0SPCTL7_EXTFEN_Msk        (0x1ul << EADC_AD0SPCTL7_EXTFEN_Pos)              /*!< EADC_T::AD0SPCTL7: EXTFEN Mask            */

#define EADC_AD1SPCTL0_CHSEL_Pos         (0)                                               /*!< EADC_T::AD1SPCTL0: CHSEL Position         */
#define EADC_AD1SPCTL0_CHSEL_Msk         (0xful << EADC_AD1SPCTL0_CHSEL_Pos)               /*!< EADC_T::AD1SPCTL0: CHSEL Mask             */

#define EADC_AD1SPCTL0_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD1SPCTL0: TRGSEL Position        */
#define EADC_AD1SPCTL0_TRGSEL_Msk        (0xful << EADC_AD1SPCTL0_TRGSEL_Pos)              /*!< EADC_T::AD1SPCTL0: TRGSEL Mask            */

#define EADC_AD1SPCTL0_TRGDLYCNT_Pos     (8)                                               /*!< EADC_T::AD1SPCTL0: TRGDLYCNT Position     */
#define EADC_AD1SPCTL0_TRGDLYCNT_Msk     (0xfful << EADC_AD1SPCTL0_TRGDLYCNT_Pos)          /*!< EADC_T::AD1SPCTL0: TRGDLYCNT Mask         */

#define EADC_AD1SPCTL0_TRGDLYDIV_Pos     (16)                                              /*!< EADC_T::AD1SPCTL0: TRGDLYDIV Position     */
#define EADC_AD1SPCTL0_TRGDLYDIV_Msk     (0x3ul << EADC_AD1SPCTL0_TRGDLYDIV_Pos)           /*!< EADC_T::AD1SPCTL0: TRGDLYDIV Mask         */

#define EADC_AD1SPCTL0_EXTREN_Pos        (20)                                              /*!< EADC_T::AD1SPCTL0: EXTREN Position        */
#define EADC_AD1SPCTL0_EXTREN_Msk        (0x1ul << EADC_AD1SPCTL0_EXTREN_Pos)              /*!< EADC_T::AD1SPCTL0: EXTREN Mask            */

#define EADC_AD1SPCTL0_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD1SPCTL0: EXTFEN Position        */
#define EADC_AD1SPCTL0_EXTFEN_Msk        (0x1ul << EADC_AD1SPCTL0_EXTFEN_Pos)              /*!< EADC_T::AD1SPCTL0: EXTFEN Mask            */

#define EADC_AD1SPCTL1_CHSEL_Pos         (0)                                               /*!< EADC_T::AD1SPCTL1: CHSEL Position         */
#define EADC_AD1SPCTL1_CHSEL_Msk         (0xful << EADC_AD1SPCTL1_CHSEL_Pos)               /*!< EADC_T::AD1SPCTL1: CHSEL Mask             */

#define EADC_AD1SPCTL1_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD1SPCTL1: TRGSEL Position        */
#define EADC_AD1SPCTL1_TRGSEL_Msk        (0xful << EADC_AD1SPCTL1_TRGSEL_Pos)              /*!< EADC_T::AD1SPCTL1: TRGSEL Mask            */

#define EADC_AD1SPCTL1_TRGDLYCNT_Pos     (8)                                               /*!< EADC_T::AD1SPCTL1: TRGDLYCNT Position     */
#define EADC_AD1SPCTL1_TRGDLYCNT_Msk     (0xfful << EADC_AD1SPCTL1_TRGDLYCNT_Pos)          /*!< EADC_T::AD1SPCTL1: TRGDLYCNT Mask         */

#define EADC_AD1SPCTL1_TRGDLYDIV_Pos     (16)                                              /*!< EADC_T::AD1SPCTL1: TRGDLYDIV Position     */
#define EADC_AD1SPCTL1_TRGDLYDIV_Msk     (0x3ul << EADC_AD1SPCTL1_TRGDLYDIV_Pos)           /*!< EADC_T::AD1SPCTL1: TRGDLYDIV Mask         */

#define EADC_AD1SPCTL1_EXTREN_Pos        (20)                                              /*!< EADC_T::AD1SPCTL1: EXTREN Position        */
#define EADC_AD1SPCTL1_EXTREN_Msk        (0x1ul << EADC_AD1SPCTL1_EXTREN_Pos)              /*!< EADC_T::AD1SPCTL1: EXTREN Mask            */

#define EADC_AD1SPCTL1_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD1SPCTL1: EXTFEN Position        */
#define EADC_AD1SPCTL1_EXTFEN_Msk        (0x1ul << EADC_AD1SPCTL1_EXTFEN_Pos)              /*!< EADC_T::AD1SPCTL1: EXTFEN Mask            */

#define EADC_AD1SPCTL2_CHSEL_Pos         (0)                                               /*!< EADC_T::AD1SPCTL2: CHSEL Position         */
#define EADC_AD1SPCTL2_CHSEL_Msk         (0xful << EADC_AD1SPCTL2_CHSEL_Pos)               /*!< EADC_T::AD1SPCTL2: CHSEL Mask             */

#define EADC_AD1SPCTL2_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD1SPCTL2: TRGSEL Position        */
#define EADC_AD1SPCTL2_TRGSEL_Msk        (0xful << EADC_AD1SPCTL2_TRGSEL_Pos)              /*!< EADC_T::AD1SPCTL2: TRGSEL Mask            */

#define EADC_AD1SPCTL2_TRGDLYCNT_Pos     (8)                                               /*!< EADC_T::AD1SPCTL2: TRGDLYCNT Position     */
#define EADC_AD1SPCTL2_TRGDLYCNT_Msk     (0xfful << EADC_AD1SPCTL2_TRGDLYCNT_Pos)          /*!< EADC_T::AD1SPCTL2: TRGDLYCNT Mask         */

#define EADC_AD1SPCTL2_TRGDLYDIV_Pos     (16)                                              /*!< EADC_T::AD1SPCTL2: TRGDLYDIV Position     */
#define EADC_AD1SPCTL2_TRGDLYDIV_Msk     (0x3ul << EADC_AD1SPCTL2_TRGDLYDIV_Pos)           /*!< EADC_T::AD1SPCTL2: TRGDLYDIV Mask         */

#define EADC_AD1SPCTL2_EXTREN_Pos        (20)                                              /*!< EADC_T::AD1SPCTL2: EXTREN Position        */
#define EADC_AD1SPCTL2_EXTREN_Msk        (0x1ul << EADC_AD1SPCTL2_EXTREN_Pos)              /*!< EADC_T::AD1SPCTL2: EXTREN Mask            */

#define EADC_AD1SPCTL2_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD1SPCTL2: EXTFEN Position        */
#define EADC_AD1SPCTL2_EXTFEN_Msk        (0x1ul << EADC_AD1SPCTL2_EXTFEN_Pos)              /*!< EADC_T::AD1SPCTL2: EXTFEN Mask            */

#define EADC_AD1SPCTL3_CHSEL_Pos         (0)                                               /*!< EADC_T::AD1SPCTL3: CHSEL Position         */
#define EADC_AD1SPCTL3_CHSEL_Msk         (0xful << EADC_AD1SPCTL3_CHSEL_Pos)               /*!< EADC_T::AD1SPCTL3: CHSEL Mask             */

#define EADC_AD1SPCTL3_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD1SPCTL3: TRGSEL Position        */
#define EADC_AD1SPCTL3_TRGSEL_Msk        (0xful << EADC_AD1SPCTL3_TRGSEL_Pos)              /*!< EADC_T::AD1SPCTL3: TRGSEL Mask            */

#define EADC_AD1SPCTL3_TRGDLYCNT_Pos     (8)                                               /*!< EADC_T::AD1SPCTL3: TRGDLYCNT Position     */
#define EADC_AD1SPCTL3_TRGDLYCNT_Msk     (0xfful << EADC_AD1SPCTL3_TRGDLYCNT_Pos)          /*!< EADC_T::AD1SPCTL3: TRGDLYCNT Mask         */

#define EADC_AD1SPCTL3_TRGDLYDIV_Pos     (16)                                              /*!< EADC_T::AD1SPCTL3: TRGDLYDIV Position     */
#define EADC_AD1SPCTL3_TRGDLYDIV_Msk     (0x3ul << EADC_AD1SPCTL3_TRGDLYDIV_Pos)           /*!< EADC_T::AD1SPCTL3: TRGDLYDIV Mask         */

#define EADC_AD1SPCTL3_EXTREN_Pos        (20)                                              /*!< EADC_T::AD1SPCTL3: EXTREN Position        */
#define EADC_AD1SPCTL3_EXTREN_Msk        (0x1ul << EADC_AD1SPCTL3_EXTREN_Pos)              /*!< EADC_T::AD1SPCTL3: EXTREN Mask            */

#define EADC_AD1SPCTL3_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD1SPCTL3: EXTFEN Position        */
#define EADC_AD1SPCTL3_EXTFEN_Msk        (0x1ul << EADC_AD1SPCTL3_EXTFEN_Pos)              /*!< EADC_T::AD1SPCTL3: EXTFEN Mask            */

#define EADC_AD1SPCTL4_CHSEL_Pos         (0)                                               /*!< EADC_T::AD1SPCTL4: CHSEL Position         */
#define EADC_AD1SPCTL4_CHSEL_Msk         (0xful << EADC_AD1SPCTL4_CHSEL_Pos)               /*!< EADC_T::AD1SPCTL4: CHSEL Mask             */

#define EADC_AD1SPCTL4_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD1SPCTL4: TRGSEL Position        */
#define EADC_AD1SPCTL4_TRGSEL_Msk        (0x7ul << EADC_AD1SPCTL4_TRGSEL_Pos)              /*!< EADC_T::AD1SPCTL4: TRGSEL Mask            */

#define EADC_AD1SPCTL4_EXTREN_Pos        (20)                                              /*!< EADC_T::AD1SPCTL4: EXTREN Position        */
#define EADC_AD1SPCTL4_EXTREN_Msk        (0x1ul << EADC_AD1SPCTL4_EXTREN_Pos)              /*!< EADC_T::AD1SPCTL4: EXTREN Mask            */

#define EADC_AD1SPCTL4_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD1SPCTL4: EXTFEN Position        */
#define EADC_AD1SPCTL4_EXTFEN_Msk        (0x1ul << EADC_AD1SPCTL4_EXTFEN_Pos)              /*!< EADC_T::AD1SPCTL4: EXTFEN Mask            */

#define EADC_AD1SPCTL5_CHSEL_Pos         (0)                                               /*!< EADC_T::AD1SPCTL5: CHSEL Position         */
#define EADC_AD1SPCTL5_CHSEL_Msk         (0xful << EADC_AD1SPCTL5_CHSEL_Pos)               /*!< EADC_T::AD1SPCTL5: CHSEL Mask             */

#define EADC_AD1SPCTL5_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD1SPCTL5: TRGSEL Position        */
#define EADC_AD1SPCTL5_TRGSEL_Msk        (0x7ul << EADC_AD1SPCTL5_TRGSEL_Pos)              /*!< EADC_T::AD1SPCTL5: TRGSEL Mask            */

#define EADC_AD1SPCTL5_EXTREN_Pos        (20)                                              /*!< EADC_T::AD1SPCTL5: EXTREN Position        */
#define EADC_AD1SPCTL5_EXTREN_Msk        (0x1ul << EADC_AD1SPCTL5_EXTREN_Pos)              /*!< EADC_T::AD1SPCTL5: EXTREN Mask            */

#define EADC_AD1SPCTL5_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD1SPCTL5: EXTFEN Position        */
#define EADC_AD1SPCTL5_EXTFEN_Msk        (0x1ul << EADC_AD1SPCTL5_EXTFEN_Pos)              /*!< EADC_T::AD1SPCTL5: EXTFEN Mask            */

#define EADC_AD1SPCTL6_CHSEL_Pos         (0)                                               /*!< EADC_T::AD1SPCTL6: CHSEL Position         */
#define EADC_AD1SPCTL6_CHSEL_Msk         (0xful << EADC_AD1SPCTL6_CHSEL_Pos)               /*!< EADC_T::AD1SPCTL6: CHSEL Mask             */

#define EADC_AD1SPCTL6_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD1SPCTL6: TRGSEL Position        */
#define EADC_AD1SPCTL6_TRGSEL_Msk        (0x7ul << EADC_AD1SPCTL6_TRGSEL_Pos)              /*!< EADC_T::AD1SPCTL6: TRGSEL Mask            */

#define EADC_AD1SPCTL6_EXTREN_Pos        (20)                                              /*!< EADC_T::AD1SPCTL6: EXTREN Position        */
#define EADC_AD1SPCTL6_EXTREN_Msk        (0x1ul << EADC_AD1SPCTL6_EXTREN_Pos)              /*!< EADC_T::AD1SPCTL6: EXTREN Mask            */

#define EADC_AD1SPCTL6_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD1SPCTL6: EXTFEN Position        */
#define EADC_AD1SPCTL6_EXTFEN_Msk        (0x1ul << EADC_AD1SPCTL6_EXTFEN_Pos)              /*!< EADC_T::AD1SPCTL6: EXTFEN Mask            */

#define EADC_AD1SPCTL7_CHSEL_Pos         (0)                                               /*!< EADC_T::AD1SPCTL7: CHSEL Position         */
#define EADC_AD1SPCTL7_CHSEL_Msk         (0xful << EADC_AD1SPCTL7_CHSEL_Pos)               /*!< EADC_T::AD1SPCTL7: CHSEL Mask             */

#define EADC_AD1SPCTL7_TRGSEL_Pos        (4)                                               /*!< EADC_T::AD1SPCTL7: TRGSEL Position        */
#define EADC_AD1SPCTL7_TRGSEL_Msk        (0x7ul << EADC_AD1SPCTL7_TRGSEL_Pos)              /*!< EADC_T::AD1SPCTL7: TRGSEL Mask            */

#define EADC_AD1SPCTL7_EXTREN_Pos        (20)                                              /*!< EADC_T::AD1SPCTL7: EXTREN Position        */
#define EADC_AD1SPCTL7_EXTREN_Msk        (0x1ul << EADC_AD1SPCTL7_EXTREN_Pos)              /*!< EADC_T::AD1SPCTL7: EXTREN Mask            */

#define EADC_AD1SPCTL7_EXTFEN_Pos        (21)                                              /*!< EADC_T::AD1SPCTL7: EXTFEN Position        */
#define EADC_AD1SPCTL7_EXTFEN_Msk        (0x1ul << EADC_AD1SPCTL7_EXTFEN_Pos)              /*!< EADC_T::AD1SPCTL7: EXTFEN Mask            */

#define EADC_SIMUSEL_SIMUSEL0_Pos        (0)                                               /*!< EADC_T::SIMUSEL: SIMUSEL0 Position        */
#define EADC_SIMUSEL_SIMUSEL0_Msk        (0x1ul << EADC_SIMUSEL_SIMUSEL0_Pos)              /*!< EADC_T::SIMUSEL: SIMUSEL0 Mask            */

#define EADC_SIMUSEL_SIMUSEL1_Pos        (1)                                               /*!< EADC_T::SIMUSEL: SIMUSEL1 Position        */
#define EADC_SIMUSEL_SIMUSEL1_Msk        (0x1ul << EADC_SIMUSEL_SIMUSEL1_Pos)              /*!< EADC_T::SIMUSEL: SIMUSEL1 Mask            */

#define EADC_SIMUSEL_SIMUSEL2_Pos        (2)                                               /*!< EADC_T::SIMUSEL: SIMUSEL2 Position        */
#define EADC_SIMUSEL_SIMUSEL2_Msk        (0x1ul << EADC_SIMUSEL_SIMUSEL2_Pos)              /*!< EADC_T::SIMUSEL: SIMUSEL2 Mask            */

#define EADC_SIMUSEL_SIMUSEL3_Pos        (3)                                               /*!< EADC_T::SIMUSEL: SIMUSEL3 Position        */
#define EADC_SIMUSEL_SIMUSEL3_Msk        (0x1ul << EADC_SIMUSEL_SIMUSEL3_Pos)              /*!< EADC_T::SIMUSEL: SIMUSEL3 Mask            */

#define EADC_SIMUSEL_SIMUSEL4_Pos        (4)                                               /*!< EADC_T::SIMUSEL: SIMUSEL4 Position        */
#define EADC_SIMUSEL_SIMUSEL4_Msk        (0x1ul << EADC_SIMUSEL_SIMUSEL4_Pos)              /*!< EADC_T::SIMUSEL: SIMUSEL4 Mask            */

#define EADC_SIMUSEL_SIMUSEL5_Pos        (5)                                               /*!< EADC_T::SIMUSEL: SIMUSEL5 Position        */
#define EADC_SIMUSEL_SIMUSEL5_Msk        (0x1ul << EADC_SIMUSEL_SIMUSEL5_Pos)              /*!< EADC_T::SIMUSEL: SIMUSEL5 Mask            */

#define EADC_SIMUSEL_SIMUSEL6_Pos        (6)                                               /*!< EADC_T::SIMUSEL: SIMUSEL6 Position        */
#define EADC_SIMUSEL_SIMUSEL6_Msk        (0x1ul << EADC_SIMUSEL_SIMUSEL6_Pos)              /*!< EADC_T::SIMUSEL: SIMUSEL6 Mask            */

#define EADC_SIMUSEL_SIMUSEL7_Pos        (7)                                               /*!< EADC_T::SIMUSEL: SIMUSEL7 Position        */
#define EADC_SIMUSEL_SIMUSEL7_Msk        (0x1ul << EADC_SIMUSEL_SIMUSEL7_Pos)              /*!< EADC_T::SIMUSEL: SIMUSEL7 Mask            */

#define EADC_CMP0_ADCMPEN_Pos            (0)                                               /*!< EADC_T::CMP: ADCMPEN Position            */
#define EADC_CMP0_ADCMPEN_Msk            (0x1ul << EADC_CMP0_ADCMPEN_Pos)                  /*!< EADC_T::CMP: ADCMPEN Mask                */

#define EADC_CMP0_ADCMPIE_Pos            (1)                                               /*!< EADC_T::CMP: ADCMPIE Position            */
#define EADC_CMP0_ADCMPIE_Msk            (0x1ul << EADC_CMP0_ADCMPIE_Pos)                  /*!< EADC_T::CMP: ADCMPIE Mask                */

#define EADC_CMP0_CMPCOND_Pos            (2)                                               /*!< EADC_T::CMP: CMPCOND Position            */
#define EADC_CMP0_CMPCOND_Msk            (0x1ul << EADC_CMP0_CMPCOND_Pos)                  /*!< EADC_T::CMP: CMPCOND Mask                */

#define EADC_CMP0_CMPSPL_Pos             (3)                                               /*!< EADC_T::CMP: CMPSPL Position             */
#define EADC_CMP0_CMPSPL_Msk             (0x7ul << EADC_CMP0_CMPSPL_Pos)                   /*!< EADC_T::CMP: CMPSPL Mask                 */

#define EADC_CMP0_CMPMCNT_Pos            (8)                                               /*!< EADC_T::CMP: CMPMCNT Position            */
#define EADC_CMP0_CMPMCNT_Msk            (0xful << EADC_CMP0_CMPMCNT_Pos)                  /*!< EADC_T::CMP: CMPMCNT Mask                */

#define EADC_CMP0_CMPDAT_Pos             (16)                                              /*!< EADC_T::CMP: CMPDAT Position             */
#define EADC_CMP0_CMPDAT_Msk             (0xffful << EADC_CMP0_CMPDAT_Pos)                 /*!< EADC_T::CMP: CMPDAT Mask                 */

#define EADC_CMP1_ADCMPEN_Pos            (0)                                               /*!< EADC_T::CMP: ADCMPEN Position            */
#define EADC_CMP1_ADCMPEN_Msk            (0x1ul << EADC_CMP1_ADCMPEN_Pos)                  /*!< EADC_T::CMP: ADCMPEN Mask                */

#define EADC_CMP1_ADCMPIE_Pos            (1)                                               /*!< EADC_T::CMP: ADCMPIE Position            */
#define EADC_CMP1_ADCMPIE_Msk            (0x1ul << EADC_CMP1_ADCMPIE_Pos)                  /*!< EADC_T::CMP: ADCMPIE Mask                */

#define EADC_CMP1_CMPCOND_Pos            (2)                                               /*!< EADC_T::CMP: CMPCOND Position            */
#define EADC_CMP1_CMPCOND_Msk            (0x1ul << EADC_CMP1_CMPCOND_Pos)                  /*!< EADC_T::CMP: CMPCOND Mask                */

#define EADC_CMP1_CMPSPL_Pos             (3)                                               /*!< EADC_T::CMP: CMPSPL Position             */
#define EADC_CMP1_CMPSPL_Msk             (0x7ul << EADC_CMP1_CMPSPL_Pos)                   /*!< EADC_T::CMP: CMPSPL Mask                 */

#define EADC_CMP1_CMPMCNT_Pos            (8)                                               /*!< EADC_T::CMP: CMPMCNT Position            */
#define EADC_CMP1_CMPMCNT_Msk            (0xful << EADC_CMP1_CMPMCNT_Pos)                  /*!< EADC_T::CMP: CMPMCNT Mask                */

#define EADC_CMP1_CMPDAT_Pos             (16)                                              /*!< EADC_T::CMP: CMPDAT Position             */
#define EADC_CMP1_CMPDAT_Msk             (0xffful << EADC_CMP1_CMPDAT_Pos)                 /*!< EADC_T::CMP: CMPDAT Mask                 */

#define EADC_STATUS0_VALID_Pos           (0)                                               /*!< EADC_T::STATUS0: VALID Position           */
#define EADC_STATUS0_VALID_Msk           (0xfffful << EADC_STATUS0_VALID_Pos)              /*!< EADC_T::STATUS0: VALID Mask               */

#define EADC_STATUS0_OV_Pos              (16)                                              /*!< EADC_T::STATUS0: OV Position              */
#define EADC_STATUS0_OV_Msk              (0xfffful << EADC_STATUS0_OV_Pos)                 /*!< EADC_T::STATUS0: OV Mask                  */

#define EADC_STATUS1_ADIF0_Pos           (0)                                               /*!< EADC_T::STATUS1: ADIF0 Position           */
#define EADC_STATUS1_ADIF0_Msk           (0x1ul << EADC_STATUS1_ADIF0_Pos)                 /*!< EADC_T::STATUS1: ADIF0 Mask               */

#define EADC_STATUS1_ADIF1_Pos           (1)                                               /*!< EADC_T::STATUS1: ADIF1 Position           */
#define EADC_STATUS1_ADIF1_Msk           (0x1ul << EADC_STATUS1_ADIF1_Pos)                 /*!< EADC_T::STATUS1: ADIF1 Mask               */

#define EADC_STATUS1_ADIF2_Pos           (2)                                               /*!< EADC_T::STATUS1: ADIF2 Position           */
#define EADC_STATUS1_ADIF2_Msk           (0x1ul << EADC_STATUS1_ADIF2_Pos)                 /*!< EADC_T::STATUS1: ADIF2 Mask               */

#define EADC_STATUS1_ADIF3_Pos           (3)                                               /*!< EADC_T::STATUS1: ADIF3 Position           */
#define EADC_STATUS1_ADIF3_Msk           (0x1ul << EADC_STATUS1_ADIF3_Pos)                 /*!< EADC_T::STATUS1: ADIF3 Mask               */

#define EADC_STATUS1_ADCMPO0_Pos         (4)                                               /*!< EADC_T::STATUS1: ADCMPO0 Position         */
#define EADC_STATUS1_ADCMPO0_Msk         (0x1ul << EADC_STATUS1_ADCMPO0_Pos)               /*!< EADC_T::STATUS1: ADCMPO0 Mask             */

#define EADC_STATUS1_ADCMPO1_Pos         (5)                                               /*!< EADC_T::STATUS1: ADCMPO1 Position         */
#define EADC_STATUS1_ADCMPO1_Msk         (0x1ul << EADC_STATUS1_ADCMPO1_Pos)               /*!< EADC_T::STATUS1: ADCMPO1 Mask             */

#define EADC_STATUS1_ADCMPF0_Pos         (6)                                               /*!< EADC_T::STATUS1: ADCMPF0 Position         */
#define EADC_STATUS1_ADCMPF0_Msk         (0x1ul << EADC_STATUS1_ADCMPF0_Pos)               /*!< EADC_T::STATUS1: ADCMPF0 Mask             */

#define EADC_STATUS1_ADCMPF1_Pos         (7)                                               /*!< EADC_T::STATUS1: ADCMPF1 Position         */
#define EADC_STATUS1_ADCMPF1_Msk         (0x1ul << EADC_STATUS1_ADCMPF1_Pos)               /*!< EADC_T::STATUS1: ADCMPF1 Mask             */

#define EADC_STATUS1_BUSY0_Pos           (8)                                               /*!< EADC_T::STATUS1: BUSY0 Position           */
#define EADC_STATUS1_BUSY0_Msk           (0x1ul << EADC_STATUS1_BUSY0_Pos)                 /*!< EADC_T::STATUS1: BUSY0 Mask               */

#define EADC_STATUS1_CHANNEL0_Pos        (12)                                              /*!< EADC_T::STATUS1: CHANNEL0 Position        */
#define EADC_STATUS1_CHANNEL0_Msk        (0xful << EADC_STATUS1_CHANNEL0_Pos)              /*!< EADC_T::STATUS1: CHANNEL0 Mask            */

#define EADC_STATUS1_BUSY1_Pos           (16)                                              /*!< EADC_T::STATUS1: BUSY1 Position           */
#define EADC_STATUS1_BUSY1_Msk           (0x1ul << EADC_STATUS1_BUSY1_Pos)                 /*!< EADC_T::STATUS1: BUSY1 Mask               */

#define EADC_STATUS1_CHANNEL1_Pos        (20)                                              /*!< EADC_T::STATUS1: CHANNEL1 Position        */
#define EADC_STATUS1_CHANNEL1_Msk        (0xful << EADC_STATUS1_CHANNEL1_Pos)              /*!< EADC_T::STATUS1: CHANNEL1 Mask            */

#define EADC_STATUS1_ADOVIF_Pos          (24)                                              /*!< EADC_T::STATUS1: ADOVIF Position          */
#define EADC_STATUS1_ADOVIF_Msk          (0x1ul << EADC_STATUS1_ADOVIF_Pos)                /*!< EADC_T::STATUS1: ADOVIF Mask              */

#define EADC_STATUS1_STOVF_Pos           (25)                                              /*!< EADC_T::STATUS1: STOVF Position           */
#define EADC_STATUS1_STOVF_Msk           (0x1ul << EADC_STATUS1_STOVF_Pos)                 /*!< EADC_T::STATUS1: STOVF Mask               */

#define EADC_STATUS1_AVALID_Pos          (26)                                              /*!< EADC_T::STATUS1: AVALID Position          */
#define EADC_STATUS1_AVALID_Msk          (0x1ul << EADC_STATUS1_AVALID_Pos)                /*!< EADC_T::STATUS1: AVALID Mask              */

#define EADC_STATUS1_AOV_Pos             (27)                                              /*!< EADC_T::STATUS1: AOV Position             */
#define EADC_STATUS1_AOV_Msk             (0x1ul << EADC_STATUS1_AOV_Pos)                   /*!< EADC_T::STATUS1: AOV Mask                 */

#define EADC_EXTSMPT_EXTSMPT0_Pos        (0)                                               /*!< EADC_T::EXTSMPT: EXTSMPT0 Position        */
#define EADC_EXTSMPT_EXTSMPT0_Msk        (0xfful << EADC_EXTSMPT_EXTSMPT0_Pos)             /*!< EADC_T::EXTSMPT: EXTSMPT0 Mask            */

#define EADC_EXTSMPT_EXTSMPT1_Pos        (16)                                              /*!< EADC_T::EXTSMPT: EXTSMPT1 Position        */
#define EADC_EXTSMPT_EXTSMPT1_Msk        (0xfful << EADC_EXTSMPT_EXTSMPT1_Pos)             /*!< EADC_T::EXTSMPT: EXTSMPT1 Mask            */

#define EADC_AD0DDAT0_RESULT_Pos         (0)                                               /*!< EADC_T::AD0DDAT0: RESULT Position         */
#define EADC_AD0DDAT0_RESULT_Msk         (0xffful << EADC_AD0DDAT0_RESULT_Pos)             /*!< EADC_T::AD0DDAT0: RESULT Mask             */

#define EADC_AD0DDAT0_VALID_Pos          (16)                                              /*!< EADC_T::AD0DDAT0: VALID Position          */
#define EADC_AD0DDAT0_VALID_Msk          (0x1ul << EADC_AD0DDAT0_VALID_Pos)                /*!< EADC_T::AD0DDAT0: VALID Mask              */

#define EADC_AD0DDAT1_RESULT_Pos         (0)                                               /*!< EADC_T::AD0DDAT1: RESULT Position         */
#define EADC_AD0DDAT1_RESULT_Msk         (0xffful << EADC_AD0DDAT1_RESULT_Pos)             /*!< EADC_T::AD0DDAT1: RESULT Mask             */

#define EADC_AD0DDAT1_VALID_Pos          (16)                                              /*!< EADC_T::AD0DDAT1: VALID Position          */
#define EADC_AD0DDAT1_VALID_Msk          (0x1ul << EADC_AD0DDAT1_VALID_Pos)                /*!< EADC_T::AD0DDAT1: VALID Mask              */

#define EADC_AD0DDAT2_RESULT_Pos         (0)                                               /*!< EADC_T::AD0DDAT2: RESULT Position         */
#define EADC_AD0DDAT2_RESULT_Msk         (0xffful << EADC_AD0DDAT2_RESULT_Pos)             /*!< EADC_T::AD0DDAT2: RESULT Mask             */

#define EADC_AD0DDAT2_VALID_Pos          (16)                                              /*!< EADC_T::AD0DDAT2: VALID Position          */
#define EADC_AD0DDAT2_VALID_Msk          (0x1ul << EADC_AD0DDAT2_VALID_Pos)                /*!< EADC_T::AD0DDAT2: VALID Mask              */

#define EADC_AD0DDAT3_RESULT_Pos         (0)                                               /*!< EADC_T::AD0DDAT3: RESULT Position         */
#define EADC_AD0DDAT3_RESULT_Msk         (0xffful << EADC_AD0DDAT3_RESULT_Pos)             /*!< EADC_T::AD0DDAT3: RESULT Mask             */

#define EADC_AD0DDAT3_VALID_Pos          (16)                                              /*!< EADC_T::AD0DDAT3: VALID Position          */
#define EADC_AD0DDAT3_VALID_Msk          (0x1ul << EADC_AD0DDAT3_VALID_Pos)                /*!< EADC_T::AD0DDAT3: VALID Mask              */

#define EADC_AD1DDAT0_RESULT_Pos         (0)                                               /*!< EADC_T::AD1DDAT0: RESULT Position         */
#define EADC_AD1DDAT0_RESULT_Msk         (0xffful << EADC_AD1DDAT0_RESULT_Pos)             /*!< EADC_T::AD1DDAT0: RESULT Mask             */

#define EADC_AD1DDAT0_VALID_Pos          (16)                                              /*!< EADC_T::AD1DDAT0: VALID Position          */
#define EADC_AD1DDAT0_VALID_Msk          (0x1ul << EADC_AD1DDAT0_VALID_Pos)                /*!< EADC_T::AD1DDAT0: VALID Mask              */

#define EADC_AD1DDAT1_RESULT_Pos         (0)                                               /*!< EADC_T::AD1DDAT1: RESULT Position         */
#define EADC_AD1DDAT1_RESULT_Msk         (0xffful << EADC_AD1DDAT1_RESULT_Pos)             /*!< EADC_T::AD1DDAT1: RESULT Mask             */

#define EADC_AD1DDAT1_VALID_Pos          (16)                                              /*!< EADC_T::AD1DDAT1: VALID Position          */
#define EADC_AD1DDAT1_VALID_Msk          (0x1ul << EADC_AD1DDAT1_VALID_Pos)                /*!< EADC_T::AD1DDAT1: VALID Mask              */

#define EADC_AD1DDAT2_RESULT_Pos         (0)                                               /*!< EADC_T::AD1DDAT2: RESULT Position         */
#define EADC_AD1DDAT2_RESULT_Msk         (0xffful << EADC_AD1DDAT2_RESULT_Pos)             /*!< EADC_T::AD1DDAT2: RESULT Mask             */

#define EADC_AD1DDAT2_VALID_Pos          (16)                                              /*!< EADC_T::AD1DDAT2: VALID Position          */
#define EADC_AD1DDAT2_VALID_Msk          (0x1ul << EADC_AD1DDAT2_VALID_Pos)                /*!< EADC_T::AD1DDAT2: VALID Mask              */

#define EADC_AD1DDAT3_RESULT_Pos         (0)                                               /*!< EADC_T::AD1DDAT3: RESULT Position         */
#define EADC_AD1DDAT3_RESULT_Msk         (0xffful << EADC_AD1DDAT3_RESULT_Pos)             /*!< EADC_T::AD1DDAT3: RESULT Mask             */

#define EADC_AD1DDAT3_VALID_Pos          (16)                                              /*!< EADC_T::AD1DDAT3: VALID Position          */
#define EADC_AD1DDAT3_VALID_Msk          (0x1ul << EADC_AD1DDAT3_VALID_Pos)                /*!< EADC_T::AD1DDAT3: VALID Mask              */

#define EADC_DBMEN_AD0DBM0_Pos           (0)                                               /*!< EADC_T::DBMEN: AD0DBM0 Position           */
#define EADC_DBMEN_AD0DBM0_Msk           (0x1ul << EADC_DBMEN_AD0DBM0_Pos)                 /*!< EADC_T::DBMEN: AD0DBM0 Mask               */

#define EADC_DBMEN_AD0DBM1_Pos           (1)                                               /*!< EADC_T::DBMEN: AD0DBM1 Position           */
#define EADC_DBMEN_AD0DBM1_Msk           (0x1ul << EADC_DBMEN_AD0DBM1_Pos)                 /*!< EADC_T::DBMEN: AD0DBM1 Mask               */

#define EADC_DBMEN_AD0DBM2_Pos           (2)                                               /*!< EADC_T::DBMEN: AD0DBM2 Position           */
#define EADC_DBMEN_AD0DBM2_Msk           (0x1ul << EADC_DBMEN_AD0DBM2_Pos)                 /*!< EADC_T::DBMEN: AD0DBM2 Mask               */

#define EADC_DBMEN_AD0DBM3_Pos           (3)                                               /*!< EADC_T::DBMEN: AD0DBM3 Position           */
#define EADC_DBMEN_AD0DBM3_Msk           (0x1ul << EADC_DBMEN_AD0DBM3_Pos)                 /*!< EADC_T::DBMEN: AD0DBM3 Mask               */

#define EADC_DBMEN_AD1DBM0_Pos           (8)                                               /*!< EADC_T::DBMEN: AD1DBM0 Position           */
#define EADC_DBMEN_AD1DBM0_Msk           (0x1ul << EADC_DBMEN_AD1DBM0_Pos)                 /*!< EADC_T::DBMEN: AD1DBM0 Mask               */

#define EADC_DBMEN_AD1DBM1_Pos           (9)                                               /*!< EADC_T::DBMEN: AD1DBM1 Position           */
#define EADC_DBMEN_AD1DBM1_Msk           (0x1ul << EADC_DBMEN_AD1DBM1_Pos)                 /*!< EADC_T::DBMEN: AD1DBM1 Mask               */

#define EADC_DBMEN_AD1DBM2_Pos           (10)                                              /*!< EADC_T::DBMEN: AD1DBM2 Position           */
#define EADC_DBMEN_AD1DBM2_Msk           (0x1ul << EADC_DBMEN_AD1DBM2_Pos)                 /*!< EADC_T::DBMEN: AD1DBM2 Mask               */

#define EADC_DBMEN_AD1DBM3_Pos           (11)                                              /*!< EADC_T::DBMEN: AD1DBM3 Position           */
#define EADC_DBMEN_AD1DBM3_Msk           (0x1ul << EADC_DBMEN_AD1DBM3_Pos)                 /*!< EADC_T::DBMEN: AD1DBM3 Mask               */

#define EADC_INTSRC0_AD0SPIE0_Pos        (0)                                               /*!< EADC_T::INTSRC: AD0SPIE0 Position        */
#define EADC_INTSRC0_AD0SPIE0_Msk        (0x1ul << EADC_INTSRC0_AD0SPIE0_Pos)              /*!< EADC_T::INTSRC: AD0SPIE0 Mask            */

#define EADC_INTSRC0_AD0SPIE1_Pos        (1)                                               /*!< EADC_T::INTSRC: AD0SPIE1 Position        */
#define EADC_INTSRC0_AD0SPIE1_Msk        (0x1ul << EADC_INTSRC0_AD0SPIE1_Pos)              /*!< EADC_T::INTSRC: AD0SPIE1 Mask            */

#define EADC_INTSRC0_AD0SPIE2_Pos        (2)                                               /*!< EADC_T::INTSRC: AD0SPIE2 Position        */
#define EADC_INTSRC0_AD0SPIE2_Msk        (0x1ul << EADC_INTSRC0_AD0SPIE2_Pos)              /*!< EADC_T::INTSRC: AD0SPIE2 Mask            */

#define EADC_INTSRC0_AD0SPIE3_Pos        (3)                                               /*!< EADC_T::INTSRC: AD0SPIE3 Position        */
#define EADC_INTSRC0_AD0SPIE3_Msk        (0x1ul << EADC_INTSRC0_AD0SPIE3_Pos)              /*!< EADC_T::INTSRC: AD0SPIE3 Mask            */

#define EADC_INTSRC0_AD0SPIE4_Pos        (4)                                               /*!< EADC_T::INTSRC: AD0SPIE4 Position        */
#define EADC_INTSRC0_AD0SPIE4_Msk        (0x1ul << EADC_INTSRC0_AD0SPIE4_Pos)              /*!< EADC_T::INTSRC: AD0SPIE4 Mask            */

#define EADC_INTSRC0_AD0SPIE5_Pos        (5)                                               /*!< EADC_T::INTSRC: AD0SPIE5 Position        */
#define EADC_INTSRC0_AD0SPIE5_Msk        (0x1ul << EADC_INTSRC0_AD0SPIE5_Pos)              /*!< EADC_T::INTSRC: AD0SPIE5 Mask            */

#define EADC_INTSRC0_AD0SPIE6_Pos        (6)                                               /*!< EADC_T::INTSRC: AD0SPIE6 Position        */
#define EADC_INTSRC0_AD0SPIE6_Msk        (0x1ul << EADC_INTSRC0_AD0SPIE6_Pos)              /*!< EADC_T::INTSRC: AD0SPIE6 Mask            */

#define EADC_INTSRC0_AD0SPIE7_Pos        (7)                                               /*!< EADC_T::INTSRC: AD0SPIE7 Position        */
#define EADC_INTSRC0_AD0SPIE7_Msk        (0x1ul << EADC_INTSRC0_AD0SPIE7_Pos)              /*!< EADC_T::INTSRC: AD0SPIE7 Mask            */

#define EADC_INTSRC0_AD1SPIE0_Pos        (8)                                               /*!< EADC_T::INTSRC: AD1SPIE0 Position        */
#define EADC_INTSRC0_AD1SPIE0_Msk        (0x1ul << EADC_INTSRC0_AD1SPIE0_Pos)              /*!< EADC_T::INTSRC: AD1SPIE0 Mask            */

#define EADC_INTSRC0_AD1SPIE1_Pos        (9)                                               /*!< EADC_T::INTSRC: AD1SPIE1 Position        */
#define EADC_INTSRC0_AD1SPIE1_Msk        (0x1ul << EADC_INTSRC0_AD1SPIE1_Pos)              /*!< EADC_T::INTSRC: AD1SPIE1 Mask            */

#define EADC_INTSRC0_AD1SPIE2_Pos        (10)                                              /*!< EADC_T::INTSRC: AD1SPIE2 Position        */
#define EADC_INTSRC0_AD1SPIE2_Msk        (0x1ul << EADC_INTSRC0_AD1SPIE2_Pos)              /*!< EADC_T::INTSRC: AD1SPIE2 Mask            */

#define EADC_INTSRC0_AD1SPIE3_Pos        (11)                                              /*!< EADC_T::INTSRC: AD1SPIE3 Position        */
#define EADC_INTSRC0_AD1SPIE3_Msk        (0x1ul << EADC_INTSRC0_AD1SPIE3_Pos)              /*!< EADC_T::INTSRC: AD1SPIE3 Mask            */

#define EADC_INTSRC0_AD1SPIE4_Pos        (12)                                              /*!< EADC_T::INTSRC: AD1SPIE4 Position        */
#define EADC_INTSRC0_AD1SPIE4_Msk        (0x1ul << EADC_INTSRC0_AD1SPIE4_Pos)              /*!< EADC_T::INTSRC: AD1SPIE4 Mask            */

#define EADC_INTSRC0_AD1SPIE5_Pos        (13)                                              /*!< EADC_T::INTSRC: AD1SPIE5 Position        */
#define EADC_INTSRC0_AD1SPIE5_Msk        (0x1ul << EADC_INTSRC0_AD1SPIE5_Pos)              /*!< EADC_T::INTSRC: AD1SPIE5 Mask            */

#define EADC_INTSRC0_AD1SPIE6_Pos        (14)                                              /*!< EADC_T::INTSRC: AD1SPIE6 Position        */
#define EADC_INTSRC0_AD1SPIE6_Msk        (0x1ul << EADC_INTSRC0_AD1SPIE6_Pos)              /*!< EADC_T::INTSRC: AD1SPIE6 Mask            */

#define EADC_INTSRC0_AD1SPIE7_Pos        (15)                                              /*!< EADC_T::INTSRC: AD1SPIE7 Position        */
#define EADC_INTSRC0_AD1SPIE7_Msk        (0x1ul << EADC_INTSRC0_AD1SPIE7_Pos)              /*!< EADC_T::INTSRC: AD1SPIE7 Mask            */

#define EADC_INTSRC1_AD0SPIE0_Pos        (0)                                               /*!< EADC_T::INTSRC: AD0SPIE0 Position        */
#define EADC_INTSRC1_AD0SPIE0_Msk        (0x1ul << EADC_INTSRC1_AD0SPIE0_Pos)              /*!< EADC_T::INTSRC: AD0SPIE0 Mask            */

#define EADC_INTSRC1_AD0SPIE1_Pos        (1)                                               /*!< EADC_T::INTSRC: AD0SPIE1 Position        */
#define EADC_INTSRC1_AD0SPIE1_Msk        (0x1ul << EADC_INTSRC1_AD0SPIE1_Pos)              /*!< EADC_T::INTSRC: AD0SPIE1 Mask            */

#define EADC_INTSRC1_AD0SPIE2_Pos        (2)                                               /*!< EADC_T::INTSRC: AD0SPIE2 Position        */
#define EADC_INTSRC1_AD0SPIE2_Msk        (0x1ul << EADC_INTSRC1_AD0SPIE2_Pos)              /*!< EADC_T::INTSRC: AD0SPIE2 Mask            */

#define EADC_INTSRC1_AD0SPIE3_Pos        (3)                                               /*!< EADC_T::INTSRC: AD0SPIE3 Position        */
#define EADC_INTSRC1_AD0SPIE3_Msk        (0x1ul << EADC_INTSRC1_AD0SPIE3_Pos)              /*!< EADC_T::INTSRC: AD0SPIE3 Mask            */

#define EADC_INTSRC1_AD0SPIE4_Pos        (4)                                               /*!< EADC_T::INTSRC: AD0SPIE4 Position        */
#define EADC_INTSRC1_AD0SPIE4_Msk        (0x1ul << EADC_INTSRC1_AD0SPIE4_Pos)              /*!< EADC_T::INTSRC: AD0SPIE4 Mask            */

#define EADC_INTSRC1_AD0SPIE5_Pos        (5)                                               /*!< EADC_T::INTSRC: AD0SPIE5 Position        */
#define EADC_INTSRC1_AD0SPIE5_Msk        (0x1ul << EADC_INTSRC1_AD0SPIE5_Pos)              /*!< EADC_T::INTSRC: AD0SPIE5 Mask            */

#define EADC_INTSRC1_AD0SPIE6_Pos        (6)                                               /*!< EADC_T::INTSRC: AD0SPIE6 Position        */
#define EADC_INTSRC1_AD0SPIE6_Msk        (0x1ul << EADC_INTSRC1_AD0SPIE6_Pos)              /*!< EADC_T::INTSRC: AD0SPIE6 Mask            */

#define EADC_INTSRC1_AD0SPIE7_Pos        (7)                                               /*!< EADC_T::INTSRC: AD0SPIE7 Position        */
#define EADC_INTSRC1_AD0SPIE7_Msk        (0x1ul << EADC_INTSRC1_AD0SPIE7_Pos)              /*!< EADC_T::INTSRC: AD0SPIE7 Mask            */

#define EADC_INTSRC1_AD1SPIE0_Pos        (8)                                               /*!< EADC_T::INTSRC: AD1SPIE0 Position        */
#define EADC_INTSRC1_AD1SPIE0_Msk        (0x1ul << EADC_INTSRC1_AD1SPIE0_Pos)              /*!< EADC_T::INTSRC: AD1SPIE0 Mask            */

#define EADC_INTSRC1_AD1SPIE1_Pos        (9)                                               /*!< EADC_T::INTSRC: AD1SPIE1 Position        */
#define EADC_INTSRC1_AD1SPIE1_Msk        (0x1ul << EADC_INTSRC1_AD1SPIE1_Pos)              /*!< EADC_T::INTSRC: AD1SPIE1 Mask            */

#define EADC_INTSRC1_AD1SPIE2_Pos        (10)                                              /*!< EADC_T::INTSRC: AD1SPIE2 Position        */
#define EADC_INTSRC1_AD1SPIE2_Msk        (0x1ul << EADC_INTSRC1_AD1SPIE2_Pos)              /*!< EADC_T::INTSRC: AD1SPIE2 Mask            */

#define EADC_INTSRC1_AD1SPIE3_Pos        (11)                                              /*!< EADC_T::INTSRC: AD1SPIE3 Position        */
#define EADC_INTSRC1_AD1SPIE3_Msk        (0x1ul << EADC_INTSRC1_AD1SPIE3_Pos)              /*!< EADC_T::INTSRC: AD1SPIE3 Mask            */

#define EADC_INTSRC1_AD1SPIE4_Pos        (12)                                              /*!< EADC_T::INTSRC: AD1SPIE4 Position        */
#define EADC_INTSRC1_AD1SPIE4_Msk        (0x1ul << EADC_INTSRC1_AD1SPIE4_Pos)              /*!< EADC_T::INTSRC: AD1SPIE4 Mask            */

#define EADC_INTSRC1_AD1SPIE5_Pos        (13)                                              /*!< EADC_T::INTSRC: AD1SPIE5 Position        */
#define EADC_INTSRC1_AD1SPIE5_Msk        (0x1ul << EADC_INTSRC1_AD1SPIE5_Pos)              /*!< EADC_T::INTSRC: AD1SPIE5 Mask            */

#define EADC_INTSRC1_AD1SPIE6_Pos        (14)                                              /*!< EADC_T::INTSRC: AD1SPIE6 Position        */
#define EADC_INTSRC1_AD1SPIE6_Msk        (0x1ul << EADC_INTSRC1_AD1SPIE6_Pos)              /*!< EADC_T::INTSRC: AD1SPIE6 Mask            */

#define EADC_INTSRC1_AD1SPIE7_Pos        (15)                                              /*!< EADC_T::INTSRC: AD1SPIE7 Position        */
#define EADC_INTSRC1_AD1SPIE7_Msk        (0x1ul << EADC_INTSRC1_AD1SPIE7_Pos)              /*!< EADC_T::INTSRC: AD1SPIE7 Mask            */

#define EADC_INTSRC2_AD0SPIE0_Pos        (0)                                               /*!< EADC_T::INTSRC: AD0SPIE0 Position        */
#define EADC_INTSRC2_AD0SPIE0_Msk        (0x1ul << EADC_INTSRC2_AD0SPIE0_Pos)              /*!< EADC_T::INTSRC: AD0SPIE0 Mask            */

#define EADC_INTSRC2_AD0SPIE1_Pos        (1)                                               /*!< EADC_T::INTSRC: AD0SPIE1 Position        */
#define EADC_INTSRC2_AD0SPIE1_Msk        (0x1ul << EADC_INTSRC2_AD0SPIE1_Pos)              /*!< EADC_T::INTSRC: AD0SPIE1 Mask            */

#define EADC_INTSRC2_AD0SPIE2_Pos        (2)                                               /*!< EADC_T::INTSRC: AD0SPIE2 Position        */
#define EADC_INTSRC2_AD0SPIE2_Msk        (0x1ul << EADC_INTSRC2_AD0SPIE2_Pos)              /*!< EADC_T::INTSRC: AD0SPIE2 Mask            */

#define EADC_INTSRC2_AD0SPIE3_Pos        (3)                                               /*!< EADC_T::INTSRC: AD0SPIE3 Position        */
#define EADC_INTSRC2_AD0SPIE3_Msk        (0x1ul << EADC_INTSRC2_AD0SPIE3_Pos)              /*!< EADC_T::INTSRC: AD0SPIE3 Mask            */

#define EADC_INTSRC2_AD0SPIE4_Pos        (4)                                               /*!< EADC_T::INTSRC: AD0SPIE4 Position        */
#define EADC_INTSRC2_AD0SPIE4_Msk        (0x1ul << EADC_INTSRC2_AD0SPIE4_Pos)              /*!< EADC_T::INTSRC: AD0SPIE4 Mask            */

#define EADC_INTSRC2_AD0SPIE5_Pos        (5)                                               /*!< EADC_T::INTSRC: AD0SPIE5 Position        */
#define EADC_INTSRC2_AD0SPIE5_Msk        (0x1ul << EADC_INTSRC2_AD0SPIE5_Pos)              /*!< EADC_T::INTSRC: AD0SPIE5 Mask            */

#define EADC_INTSRC2_AD0SPIE6_Pos        (6)                                               /*!< EADC_T::INTSRC: AD0SPIE6 Position        */
#define EADC_INTSRC2_AD0SPIE6_Msk        (0x1ul << EADC_INTSRC2_AD0SPIE6_Pos)              /*!< EADC_T::INTSRC: AD0SPIE6 Mask            */

#define EADC_INTSRC2_AD0SPIE7_Pos        (7)                                               /*!< EADC_T::INTSRC: AD0SPIE7 Position        */
#define EADC_INTSRC2_AD0SPIE7_Msk        (0x1ul << EADC_INTSRC2_AD0SPIE7_Pos)              /*!< EADC_T::INTSRC: AD0SPIE7 Mask            */

#define EADC_INTSRC2_AD1SPIE0_Pos        (8)                                               /*!< EADC_T::INTSRC: AD1SPIE0 Position        */
#define EADC_INTSRC2_AD1SPIE0_Msk        (0x1ul << EADC_INTSRC2_AD1SPIE0_Pos)              /*!< EADC_T::INTSRC: AD1SPIE0 Mask            */

#define EADC_INTSRC2_AD1SPIE1_Pos        (9)                                               /*!< EADC_T::INTSRC: AD1SPIE1 Position        */
#define EADC_INTSRC2_AD1SPIE1_Msk        (0x1ul << EADC_INTSRC2_AD1SPIE1_Pos)              /*!< EADC_T::INTSRC: AD1SPIE1 Mask            */

#define EADC_INTSRC2_AD1SPIE2_Pos        (10)                                              /*!< EADC_T::INTSRC: AD1SPIE2 Position        */
#define EADC_INTSRC2_AD1SPIE2_Msk        (0x1ul << EADC_INTSRC2_AD1SPIE2_Pos)              /*!< EADC_T::INTSRC: AD1SPIE2 Mask            */

#define EADC_INTSRC2_AD1SPIE3_Pos        (11)                                              /*!< EADC_T::INTSRC: AD1SPIE3 Position        */
#define EADC_INTSRC2_AD1SPIE3_Msk        (0x1ul << EADC_INTSRC2_AD1SPIE3_Pos)              /*!< EADC_T::INTSRC: AD1SPIE3 Mask            */

#define EADC_INTSRC2_AD1SPIE4_Pos        (12)                                              /*!< EADC_T::INTSRC: AD1SPIE4 Position        */
#define EADC_INTSRC2_AD1SPIE4_Msk        (0x1ul << EADC_INTSRC2_AD1SPIE4_Pos)              /*!< EADC_T::INTSRC: AD1SPIE4 Mask            */

#define EADC_INTSRC2_AD1SPIE5_Pos        (13)                                              /*!< EADC_T::INTSRC: AD1SPIE5 Position        */
#define EADC_INTSRC2_AD1SPIE5_Msk        (0x1ul << EADC_INTSRC2_AD1SPIE5_Pos)              /*!< EADC_T::INTSRC: AD1SPIE5 Mask            */

#define EADC_INTSRC2_AD1SPIE6_Pos        (14)                                              /*!< EADC_T::INTSRC: AD1SPIE6 Position        */
#define EADC_INTSRC2_AD1SPIE6_Msk        (0x1ul << EADC_INTSRC2_AD1SPIE6_Pos)              /*!< EADC_T::INTSRC: AD1SPIE6 Mask            */

#define EADC_INTSRC2_AD1SPIE7_Pos        (15)                                              /*!< EADC_T::INTSRC: AD1SPIE7 Position        */
#define EADC_INTSRC2_AD1SPIE7_Msk        (0x1ul << EADC_INTSRC2_AD1SPIE7_Pos)              /*!< EADC_T::INTSRC: AD1SPIE7 Mask            */

#define EADC_INTSRC3_AD0SPIE0_Pos        (0)                                               /*!< EADC_T::INTSRC: AD0SPIE0 Position        */
#define EADC_INTSRC3_AD0SPIE0_Msk        (0x1ul << EADC_INTSRC3_AD0SPIE0_Pos)              /*!< EADC_T::INTSRC: AD0SPIE0 Mask            */

#define EADC_INTSRC3_AD0SPIE1_Pos        (1)                                               /*!< EADC_T::INTSRC: AD0SPIE1 Position        */
#define EADC_INTSRC3_AD0SPIE1_Msk        (0x1ul << EADC_INTSRC3_AD0SPIE1_Pos)              /*!< EADC_T::INTSRC: AD0SPIE1 Mask            */

#define EADC_INTSRC3_AD0SPIE2_Pos        (2)                                               /*!< EADC_T::INTSRC: AD0SPIE2 Position        */
#define EADC_INTSRC3_AD0SPIE2_Msk        (0x1ul << EADC_INTSRC3_AD0SPIE2_Pos)              /*!< EADC_T::INTSRC: AD0SPIE2 Mask            */

#define EADC_INTSRC3_AD0SPIE3_Pos        (3)                                               /*!< EADC_T::INTSRC: AD0SPIE3 Position        */
#define EADC_INTSRC3_AD0SPIE3_Msk        (0x1ul << EADC_INTSRC3_AD0SPIE3_Pos)              /*!< EADC_T::INTSRC: AD0SPIE3 Mask            */

#define EADC_INTSRC3_AD0SPIE4_Pos        (4)                                               /*!< EADC_T::INTSRC: AD0SPIE4 Position        */
#define EADC_INTSRC3_AD0SPIE4_Msk        (0x1ul << EADC_INTSRC3_AD0SPIE4_Pos)              /*!< EADC_T::INTSRC: AD0SPIE4 Mask            */

#define EADC_INTSRC3_AD0SPIE5_Pos        (5)                                               /*!< EADC_T::INTSRC: AD0SPIE5 Position        */
#define EADC_INTSRC3_AD0SPIE5_Msk        (0x1ul << EADC_INTSRC3_AD0SPIE5_Pos)              /*!< EADC_T::INTSRC: AD0SPIE5 Mask            */

#define EADC_INTSRC3_AD0SPIE6_Pos        (6)                                               /*!< EADC_T::INTSRC: AD0SPIE6 Position        */
#define EADC_INTSRC3_AD0SPIE6_Msk        (0x1ul << EADC_INTSRC3_AD0SPIE6_Pos)              /*!< EADC_T::INTSRC: AD0SPIE6 Mask            */

#define EADC_INTSRC3_AD0SPIE7_Pos        (7)                                               /*!< EADC_T::INTSRC: AD0SPIE7 Position        */
#define EADC_INTSRC3_AD0SPIE7_Msk        (0x1ul << EADC_INTSRC3_AD0SPIE7_Pos)              /*!< EADC_T::INTSRC: AD0SPIE7 Mask            */

#define EADC_INTSRC3_AD1SPIE0_Pos        (8)                                               /*!< EADC_T::INTSRC: AD1SPIE0 Position        */
#define EADC_INTSRC3_AD1SPIE0_Msk        (0x1ul << EADC_INTSRC3_AD1SPIE0_Pos)              /*!< EADC_T::INTSRC: AD1SPIE0 Mask            */

#define EADC_INTSRC3_AD1SPIE1_Pos        (9)                                               /*!< EADC_T::INTSRC: AD1SPIE1 Position        */
#define EADC_INTSRC3_AD1SPIE1_Msk        (0x1ul << EADC_INTSRC3_AD1SPIE1_Pos)              /*!< EADC_T::INTSRC: AD1SPIE1 Mask            */

#define EADC_INTSRC3_AD1SPIE2_Pos        (10)                                              /*!< EADC_T::INTSRC: AD1SPIE2 Position        */
#define EADC_INTSRC3_AD1SPIE2_Msk        (0x1ul << EADC_INTSRC3_AD1SPIE2_Pos)              /*!< EADC_T::INTSRC: AD1SPIE2 Mask            */

#define EADC_INTSRC3_AD1SPIE3_Pos        (11)                                              /*!< EADC_T::INTSRC: AD1SPIE3 Position        */
#define EADC_INTSRC3_AD1SPIE3_Msk        (0x1ul << EADC_INTSRC3_AD1SPIE3_Pos)              /*!< EADC_T::INTSRC: AD1SPIE3 Mask            */

#define EADC_INTSRC3_AD1SPIE4_Pos        (12)                                              /*!< EADC_T::INTSRC: AD1SPIE4 Position        */
#define EADC_INTSRC3_AD1SPIE4_Msk        (0x1ul << EADC_INTSRC3_AD1SPIE4_Pos)              /*!< EADC_T::INTSRC: AD1SPIE4 Mask            */

#define EADC_INTSRC3_AD1SPIE5_Pos        (13)                                              /*!< EADC_T::INTSRC: AD1SPIE5 Position        */
#define EADC_INTSRC3_AD1SPIE5_Msk        (0x1ul << EADC_INTSRC3_AD1SPIE5_Pos)              /*!< EADC_T::INTSRC: AD1SPIE5 Mask            */

#define EADC_INTSRC3_AD1SPIE6_Pos        (14)                                              /*!< EADC_T::INTSRC: AD1SPIE6 Position        */
#define EADC_INTSRC3_AD1SPIE6_Msk        (0x1ul << EADC_INTSRC3_AD1SPIE6_Pos)              /*!< EADC_T::INTSRC: AD1SPIE6 Mask            */

#define EADC_INTSRC3_AD1SPIE7_Pos        (15)                                              /*!< EADC_T::INTSRC: AD1SPIE7 Position        */
#define EADC_INTSRC3_AD1SPIE7_Msk        (0x1ul << EADC_INTSRC3_AD1SPIE7_Pos)              /*!< EADC_T::INTSRC: AD1SPIE7 Mask            */

#define EADC_AD0TRGEN0_EPWM00REN_Pos     (0)                                               /*!< EADC_T::AD0TRGEN0: EPWM00REN Position     */
#define EADC_AD0TRGEN0_EPWM00REN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM00REN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM00REN Mask         */

#define EADC_AD0TRGEN0_EPWM00FEN_Pos     (1)                                               /*!< EADC_T::AD0TRGEN0: EPWM00FEN Position     */
#define EADC_AD0TRGEN0_EPWM00FEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM00FEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM00FEN Mask         */

#define EADC_AD0TRGEN0_EPWM00PEN_Pos     (2)                                               /*!< EADC_T::AD0TRGEN0: EPWM00PEN Position     */
#define EADC_AD0TRGEN0_EPWM00PEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM00PEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM00PEN Mask         */

#define EADC_AD0TRGEN0_EPWM00CEN_Pos     (3)                                               /*!< EADC_T::AD0TRGEN0: EPWM00CEN Position     */
#define EADC_AD0TRGEN0_EPWM00CEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM00CEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM00CEN Mask         */

#define EADC_AD0TRGEN0_EPWM02REN_Pos     (4)                                               /*!< EADC_T::AD0TRGEN0: EPWM02REN Position     */
#define EADC_AD0TRGEN0_EPWM02REN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM02REN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM02REN Mask         */

#define EADC_AD0TRGEN0_EPWM02FEN_Pos     (5)                                               /*!< EADC_T::AD0TRGEN0: EPWM02FEN Position     */
#define EADC_AD0TRGEN0_EPWM02FEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM02FEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM02FEN Mask         */

#define EADC_AD0TRGEN0_EPWM02PEN_Pos     (6)                                               /*!< EADC_T::AD0TRGEN0: EPWM02PEN Position     */
#define EADC_AD0TRGEN0_EPWM02PEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM02PEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM02PEN Mask         */

#define EADC_AD0TRGEN0_EPWM02CEN_Pos     (7)                                               /*!< EADC_T::AD0TRGEN0: EPWM02CEN Position     */
#define EADC_AD0TRGEN0_EPWM02CEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM02CEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM02CEN Mask         */

#define EADC_AD0TRGEN0_EPWM04REN_Pos     (8)                                               /*!< EADC_T::AD0TRGEN0: EPWM04REN Position     */
#define EADC_AD0TRGEN0_EPWM04REN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM04REN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM04REN Mask         */

#define EADC_AD0TRGEN0_EPWM04FEN_Pos     (9)                                               /*!< EADC_T::AD0TRGEN0: EPWM04FEN Position     */
#define EADC_AD0TRGEN0_EPWM04FEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM04FEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM04FEN Mask         */

#define EADC_AD0TRGEN0_EPWM04PEN_Pos     (10)                                              /*!< EADC_T::AD0TRGEN0: EPWM04PEN Position     */
#define EADC_AD0TRGEN0_EPWM04PEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM04PEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM04PEN Mask         */

#define EADC_AD0TRGEN0_EPWM04CEN_Pos     (11)                                              /*!< EADC_T::AD0TRGEN0: EPWM04CEN Position     */
#define EADC_AD0TRGEN0_EPWM04CEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM04CEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM04CEN Mask         */

#define EADC_AD0TRGEN0_EPWM10REN_Pos     (12)                                              /*!< EADC_T::AD0TRGEN0: EPWM10REN Position     */
#define EADC_AD0TRGEN0_EPWM10REN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM10REN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM10REN Mask         */

#define EADC_AD0TRGEN0_EPWM10FEN_Pos     (13)                                              /*!< EADC_T::AD0TRGEN0: EPWM10FEN Position     */
#define EADC_AD0TRGEN0_EPWM10FEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM10FEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM10FEN Mask         */

#define EADC_AD0TRGEN0_EPWM10PEN_Pos     (14)                                              /*!< EADC_T::AD0TRGEN0: EPWM10PEN Position     */
#define EADC_AD0TRGEN0_EPWM10PEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM10PEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM10PEN Mask         */

#define EADC_AD0TRGEN0_EPWM10CEN_Pos     (15)                                              /*!< EADC_T::AD0TRGEN0: EPWM10CEN Position     */
#define EADC_AD0TRGEN0_EPWM10CEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM10CEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM10CEN Mask         */

#define EADC_AD0TRGEN0_EPWM12REN_Pos     (16)                                              /*!< EADC_T::AD0TRGEN0: EPWM12REN Position     */
#define EADC_AD0TRGEN0_EPWM12REN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM12REN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM12REN Mask         */

#define EADC_AD0TRGEN0_EPWM120FEN_Pos    (17)                                              /*!< EADC_T::AD0TRGEN0: EPWM120FEN Position    */
#define EADC_AD0TRGEN0_EPWM120FEN_Msk    (0x1ul << EADC_AD0TRGEN0_EPWM120FEN_Pos)          /*!< EADC_T::AD0TRGEN0: EPWM120FEN Mask        */

#define EADC_AD0TRGEN0_EPWM12PEN_Pos     (18)                                              /*!< EADC_T::AD0TRGEN0: EPWM12PEN Position     */
#define EADC_AD0TRGEN0_EPWM12PEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM12PEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM12PEN Mask         */

#define EADC_AD0TRGEN0_EPWM12CEN_Pos     (19)                                              /*!< EADC_T::AD0TRGEN0: EPWM12CEN Position     */
#define EADC_AD0TRGEN0_EPWM12CEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM12CEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM12CEN Mask         */

#define EADC_AD0TRGEN0_EPWM14REN_Pos     (20)                                              /*!< EADC_T::AD0TRGEN0: EPWM14REN Position     */
#define EADC_AD0TRGEN0_EPWM14REN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM14REN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM14REN Mask         */

#define EADC_AD0TRGEN0_EPWM14FEN_Pos     (21)                                              /*!< EADC_T::AD0TRGEN0: EPWM14FEN Position     */
#define EADC_AD0TRGEN0_EPWM14FEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM14FEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM14FEN Mask         */

#define EADC_AD0TRGEN0_EPWM14PEN_Pos     (22)                                              /*!< EADC_T::AD0TRGEN0: EPWM14PEN Position     */
#define EADC_AD0TRGEN0_EPWM14PEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM14PEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM14PEN Mask         */

#define EADC_AD0TRGEN0_EPWM14CEN_Pos     (23)                                              /*!< EADC_T::AD0TRGEN0: EPWM14CEN Position     */
#define EADC_AD0TRGEN0_EPWM14CEN_Msk     (0x1ul << EADC_AD0TRGEN0_EPWM14CEN_Pos)           /*!< EADC_T::AD0TRGEN0: EPWM14CEN Mask         */

#define EADC_AD0TRGEN0_PWM00REN_Pos      (24)                                              /*!< EADC_T::AD0TRGEN0: PWM00REN Position      */
#define EADC_AD0TRGEN0_PWM00REN_Msk      (0x1ul << EADC_AD0TRGEN0_PWM00REN_Pos)            /*!< EADC_T::AD0TRGEN0: PWM00REN Mask          */

#define EADC_AD0TRGEN0_PWM00FEN_Pos      (25)                                              /*!< EADC_T::AD0TRGEN0: PWM00FEN Position      */
#define EADC_AD0TRGEN0_PWM00FEN_Msk      (0x1ul << EADC_AD0TRGEN0_PWM00FEN_Pos)            /*!< EADC_T::AD0TRGEN0: PWM00FEN Mask          */

#define EADC_AD0TRGEN0_PWM00PEN_Pos      (26)                                              /*!< EADC_T::AD0TRGEN0: PWM00PEN Position      */
#define EADC_AD0TRGEN0_PWM00PEN_Msk      (0x1ul << EADC_AD0TRGEN0_PWM00PEN_Pos)            /*!< EADC_T::AD0TRGEN0: PWM00PEN Mask          */

#define EADC_AD0TRGEN0_PWM00CEN_Pos      (27)                                              /*!< EADC_T::AD0TRGEN0: PWM00CEN Position      */
#define EADC_AD0TRGEN0_PWM00CEN_Msk      (0x1ul << EADC_AD0TRGEN0_PWM00CEN_Pos)            /*!< EADC_T::AD0TRGEN0: PWM00CEN Mask          */

#define EADC_AD0TRGEN0_PWM01REN_Pos      (28)                                              /*!< EADC_T::AD0TRGEN0: PWM01REN Position      */
#define EADC_AD0TRGEN0_PWM01REN_Msk      (0x1ul << EADC_AD0TRGEN0_PWM01REN_Pos)            /*!< EADC_T::AD0TRGEN0: PWM01REN Mask          */

#define EADC_AD0TRGEN0_PWM01FEN_Pos      (29)                                              /*!< EADC_T::AD0TRGEN0: PWM01FEN Position      */
#define EADC_AD0TRGEN0_PWM01FEN_Msk      (0x1ul << EADC_AD0TRGEN0_PWM01FEN_Pos)            /*!< EADC_T::AD0TRGEN0: PWM01FEN Mask          */

#define EADC_AD0TRGEN0_PWM01PEN_Pos      (30)                                              /*!< EADC_T::AD0TRGEN0: PWM01PEN Position      */
#define EADC_AD0TRGEN0_PWM01PEN_Msk      (0x1ul << EADC_AD0TRGEN0_PWM01PEN_Pos)            /*!< EADC_T::AD0TRGEN0: PWM01PEN Mask          */

#define EADC_AD0TRGEN0_PWM01CEN_Pos      (31)                                              /*!< EADC_T::AD0TRGEN0: PWM01CEN Position      */
#define EADC_AD0TRGEN0_PWM01CEN_Msk      (0x1ul << EADC_AD0TRGEN0_PWM01CEN_Pos)            /*!< EADC_T::AD0TRGEN0: PWM01CEN Mask          */

#define EADC_AD0TRGEN1_EPWM00REN_Pos     (0)                                               /*!< EADC_T::AD0TRGEN1: EPWM00REN Position     */
#define EADC_AD0TRGEN1_EPWM00REN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM00REN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM00REN Mask         */

#define EADC_AD0TRGEN1_EPWM00FEN_Pos     (1)                                               /*!< EADC_T::AD0TRGEN1: EPWM00FEN Position     */
#define EADC_AD0TRGEN1_EPWM00FEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM00FEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM00FEN Mask         */

#define EADC_AD0TRGEN1_EPWM00PEN_Pos     (2)                                               /*!< EADC_T::AD0TRGEN1: EPWM00PEN Position     */
#define EADC_AD0TRGEN1_EPWM00PEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM00PEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM00PEN Mask         */

#define EADC_AD0TRGEN1_EPWM00CEN_Pos     (3)                                               /*!< EADC_T::AD0TRGEN1: EPWM00CEN Position     */
#define EADC_AD0TRGEN1_EPWM00CEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM00CEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM00CEN Mask         */

#define EADC_AD0TRGEN1_EPWM02REN_Pos     (4)                                               /*!< EADC_T::AD0TRGEN1: EPWM02REN Position     */
#define EADC_AD0TRGEN1_EPWM02REN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM02REN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM02REN Mask         */

#define EADC_AD0TRGEN1_EPWM02FEN_Pos     (5)                                               /*!< EADC_T::AD0TRGEN1: EPWM02FEN Position     */
#define EADC_AD0TRGEN1_EPWM02FEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM02FEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM02FEN Mask         */

#define EADC_AD0TRGEN1_EPWM02PEN_Pos     (6)                                               /*!< EADC_T::AD0TRGEN1: EPWM02PEN Position     */
#define EADC_AD0TRGEN1_EPWM02PEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM02PEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM02PEN Mask         */

#define EADC_AD0TRGEN1_EPWM02CEN_Pos     (7)                                               /*!< EADC_T::AD0TRGEN1: EPWM02CEN Position     */
#define EADC_AD0TRGEN1_EPWM02CEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM02CEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM02CEN Mask         */

#define EADC_AD0TRGEN1_EPWM04REN_Pos     (8)                                               /*!< EADC_T::AD0TRGEN1: EPWM04REN Position     */
#define EADC_AD0TRGEN1_EPWM04REN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM04REN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM04REN Mask         */

#define EADC_AD0TRGEN1_EPWM04FEN_Pos     (9)                                               /*!< EADC_T::AD0TRGEN1: EPWM04FEN Position     */
#define EADC_AD0TRGEN1_EPWM04FEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM04FEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM04FEN Mask         */

#define EADC_AD0TRGEN1_EPWM04PEN_Pos     (10)                                              /*!< EADC_T::AD0TRGEN1: EPWM04PEN Position     */
#define EADC_AD0TRGEN1_EPWM04PEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM04PEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM04PEN Mask         */

#define EADC_AD0TRGEN1_EPWM04CEN_Pos     (11)                                              /*!< EADC_T::AD0TRGEN1: EPWM04CEN Position     */
#define EADC_AD0TRGEN1_EPWM04CEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM04CEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM04CEN Mask         */

#define EADC_AD0TRGEN1_EPWM10REN_Pos     (12)                                              /*!< EADC_T::AD0TRGEN1: EPWM10REN Position     */
#define EADC_AD0TRGEN1_EPWM10REN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM10REN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM10REN Mask         */

#define EADC_AD0TRGEN1_EPWM10FEN_Pos     (13)                                              /*!< EADC_T::AD0TRGEN1: EPWM10FEN Position     */
#define EADC_AD0TRGEN1_EPWM10FEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM10FEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM10FEN Mask         */

#define EADC_AD0TRGEN1_EPWM10PEN_Pos     (14)                                              /*!< EADC_T::AD0TRGEN1: EPWM10PEN Position     */
#define EADC_AD0TRGEN1_EPWM10PEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM10PEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM10PEN Mask         */

#define EADC_AD0TRGEN1_EPWM10CEN_Pos     (15)                                              /*!< EADC_T::AD0TRGEN1: EPWM10CEN Position     */
#define EADC_AD0TRGEN1_EPWM10CEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM10CEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM10CEN Mask         */

#define EADC_AD0TRGEN1_EPWM12REN_Pos     (16)                                              /*!< EADC_T::AD0TRGEN1: EPWM12REN Position     */
#define EADC_AD0TRGEN1_EPWM12REN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM12REN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM12REN Mask         */

#define EADC_AD0TRGEN1_EPWM120FEN_Pos    (17)                                              /*!< EADC_T::AD0TRGEN1: EPWM120FEN Position    */
#define EADC_AD0TRGEN1_EPWM120FEN_Msk    (0x1ul << EADC_AD0TRGEN1_EPWM120FEN_Pos)          /*!< EADC_T::AD0TRGEN1: EPWM120FEN Mask        */

#define EADC_AD0TRGEN1_EPWM12PEN_Pos     (18)                                              /*!< EADC_T::AD0TRGEN1: EPWM12PEN Position     */
#define EADC_AD0TRGEN1_EPWM12PEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM12PEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM12PEN Mask         */

#define EADC_AD0TRGEN1_EPWM12CEN_Pos     (19)                                              /*!< EADC_T::AD0TRGEN1: EPWM12CEN Position     */
#define EADC_AD0TRGEN1_EPWM12CEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM12CEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM12CEN Mask         */

#define EADC_AD0TRGEN1_EPWM14REN_Pos     (20)                                              /*!< EADC_T::AD0TRGEN1: EPWM14REN Position     */
#define EADC_AD0TRGEN1_EPWM14REN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM14REN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM14REN Mask         */

#define EADC_AD0TRGEN1_EPWM14FEN_Pos     (21)                                              /*!< EADC_T::AD0TRGEN1: EPWM14FEN Position     */
#define EADC_AD0TRGEN1_EPWM14FEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM14FEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM14FEN Mask         */

#define EADC_AD0TRGEN1_EPWM14PEN_Pos     (22)                                              /*!< EADC_T::AD0TRGEN1: EPWM14PEN Position     */
#define EADC_AD0TRGEN1_EPWM14PEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM14PEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM14PEN Mask         */

#define EADC_AD0TRGEN1_EPWM14CEN_Pos     (23)                                              /*!< EADC_T::AD0TRGEN1: EPWM14CEN Position     */
#define EADC_AD0TRGEN1_EPWM14CEN_Msk     (0x1ul << EADC_AD0TRGEN1_EPWM14CEN_Pos)           /*!< EADC_T::AD0TRGEN1: EPWM14CEN Mask         */

#define EADC_AD0TRGEN1_PWM00REN_Pos      (24)                                              /*!< EADC_T::AD0TRGEN1: PWM00REN Position      */
#define EADC_AD0TRGEN1_PWM00REN_Msk      (0x1ul << EADC_AD0TRGEN1_PWM00REN_Pos)            /*!< EADC_T::AD0TRGEN1: PWM00REN Mask          */

#define EADC_AD0TRGEN1_PWM00FEN_Pos      (25)                                              /*!< EADC_T::AD0TRGEN1: PWM00FEN Position      */
#define EADC_AD0TRGEN1_PWM00FEN_Msk      (0x1ul << EADC_AD0TRGEN1_PWM00FEN_Pos)            /*!< EADC_T::AD0TRGEN1: PWM00FEN Mask          */

#define EADC_AD0TRGEN1_PWM00PEN_Pos      (26)                                              /*!< EADC_T::AD0TRGEN1: PWM00PEN Position      */
#define EADC_AD0TRGEN1_PWM00PEN_Msk      (0x1ul << EADC_AD0TRGEN1_PWM00PEN_Pos)            /*!< EADC_T::AD0TRGEN1: PWM00PEN Mask          */

#define EADC_AD0TRGEN1_PWM00CEN_Pos      (27)                                              /*!< EADC_T::AD0TRGEN1: PWM00CEN Position      */
#define EADC_AD0TRGEN1_PWM00CEN_Msk      (0x1ul << EADC_AD0TRGEN1_PWM00CEN_Pos)            /*!< EADC_T::AD0TRGEN1: PWM00CEN Mask          */

#define EADC_AD0TRGEN1_PWM01REN_Pos      (28)                                              /*!< EADC_T::AD0TRGEN1: PWM01REN Position      */
#define EADC_AD0TRGEN1_PWM01REN_Msk      (0x1ul << EADC_AD0TRGEN1_PWM01REN_Pos)            /*!< EADC_T::AD0TRGEN1: PWM01REN Mask          */

#define EADC_AD0TRGEN1_PWM01FEN_Pos      (29)                                              /*!< EADC_T::AD0TRGEN1: PWM01FEN Position      */
#define EADC_AD0TRGEN1_PWM01FEN_Msk      (0x1ul << EADC_AD0TRGEN1_PWM01FEN_Pos)            /*!< EADC_T::AD0TRGEN1: PWM01FEN Mask          */

#define EADC_AD0TRGEN1_PWM01PEN_Pos      (30)                                              /*!< EADC_T::AD0TRGEN1: PWM01PEN Position      */
#define EADC_AD0TRGEN1_PWM01PEN_Msk      (0x1ul << EADC_AD0TRGEN1_PWM01PEN_Pos)            /*!< EADC_T::AD0TRGEN1: PWM01PEN Mask          */

#define EADC_AD0TRGEN1_PWM01CEN_Pos      (31)                                              /*!< EADC_T::AD0TRGEN1: PWM01CEN Position      */
#define EADC_AD0TRGEN1_PWM01CEN_Msk      (0x1ul << EADC_AD0TRGEN1_PWM01CEN_Pos)            /*!< EADC_T::AD0TRGEN1: PWM01CEN Mask          */

#define EADC_AD0TRGEN2_EPWM00REN_Pos     (0)                                               /*!< EADC_T::AD0TRGEN2: EPWM00REN Position     */
#define EADC_AD0TRGEN2_EPWM00REN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM00REN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM00REN Mask         */

#define EADC_AD0TRGEN2_EPWM00FEN_Pos     (1)                                               /*!< EADC_T::AD0TRGEN2: EPWM00FEN Position     */
#define EADC_AD0TRGEN2_EPWM00FEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM00FEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM00FEN Mask         */

#define EADC_AD0TRGEN2_EPWM00PEN_Pos     (2)                                               /*!< EADC_T::AD0TRGEN2: EPWM00PEN Position     */
#define EADC_AD0TRGEN2_EPWM00PEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM00PEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM00PEN Mask         */

#define EADC_AD0TRGEN2_EPWM00CEN_Pos     (3)                                               /*!< EADC_T::AD0TRGEN2: EPWM00CEN Position     */
#define EADC_AD0TRGEN2_EPWM00CEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM00CEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM00CEN Mask         */

#define EADC_AD0TRGEN2_EPWM02REN_Pos     (4)                                               /*!< EADC_T::AD0TRGEN2: EPWM02REN Position     */
#define EADC_AD0TRGEN2_EPWM02REN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM02REN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM02REN Mask         */

#define EADC_AD0TRGEN2_EPWM02FEN_Pos     (5)                                               /*!< EADC_T::AD0TRGEN2: EPWM02FEN Position     */
#define EADC_AD0TRGEN2_EPWM02FEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM02FEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM02FEN Mask         */

#define EADC_AD0TRGEN2_EPWM02PEN_Pos     (6)                                               /*!< EADC_T::AD0TRGEN2: EPWM02PEN Position     */
#define EADC_AD0TRGEN2_EPWM02PEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM02PEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM02PEN Mask         */

#define EADC_AD0TRGEN2_EPWM02CEN_Pos     (7)                                               /*!< EADC_T::AD0TRGEN2: EPWM02CEN Position     */
#define EADC_AD0TRGEN2_EPWM02CEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM02CEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM02CEN Mask         */

#define EADC_AD0TRGEN2_EPWM04REN_Pos     (8)                                               /*!< EADC_T::AD0TRGEN2: EPWM04REN Position     */
#define EADC_AD0TRGEN2_EPWM04REN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM04REN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM04REN Mask         */

#define EADC_AD0TRGEN2_EPWM04FEN_Pos     (9)                                               /*!< EADC_T::AD0TRGEN2: EPWM04FEN Position     */
#define EADC_AD0TRGEN2_EPWM04FEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM04FEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM04FEN Mask         */

#define EADC_AD0TRGEN2_EPWM04PEN_Pos     (10)                                              /*!< EADC_T::AD0TRGEN2: EPWM04PEN Position     */
#define EADC_AD0TRGEN2_EPWM04PEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM04PEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM04PEN Mask         */

#define EADC_AD0TRGEN2_EPWM04CEN_Pos     (11)                                              /*!< EADC_T::AD0TRGEN2: EPWM04CEN Position     */
#define EADC_AD0TRGEN2_EPWM04CEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM04CEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM04CEN Mask         */

#define EADC_AD0TRGEN2_EPWM10REN_Pos     (12)                                              /*!< EADC_T::AD0TRGEN2: EPWM10REN Position     */
#define EADC_AD0TRGEN2_EPWM10REN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM10REN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM10REN Mask         */

#define EADC_AD0TRGEN2_EPWM10FEN_Pos     (13)                                              /*!< EADC_T::AD0TRGEN2: EPWM10FEN Position     */
#define EADC_AD0TRGEN2_EPWM10FEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM10FEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM10FEN Mask         */

#define EADC_AD0TRGEN2_EPWM10PEN_Pos     (14)                                              /*!< EADC_T::AD0TRGEN2: EPWM10PEN Position     */
#define EADC_AD0TRGEN2_EPWM10PEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM10PEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM10PEN Mask         */

#define EADC_AD0TRGEN2_EPWM10CEN_Pos     (15)                                              /*!< EADC_T::AD0TRGEN2: EPWM10CEN Position     */
#define EADC_AD0TRGEN2_EPWM10CEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM10CEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM10CEN Mask         */

#define EADC_AD0TRGEN2_EPWM12REN_Pos     (16)                                              /*!< EADC_T::AD0TRGEN2: EPWM12REN Position     */
#define EADC_AD0TRGEN2_EPWM12REN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM12REN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM12REN Mask         */

#define EADC_AD0TRGEN2_EPWM120FEN_Pos    (17)                                              /*!< EADC_T::AD0TRGEN2: EPWM120FEN Position    */
#define EADC_AD0TRGEN2_EPWM120FEN_Msk    (0x1ul << EADC_AD0TRGEN2_EPWM120FEN_Pos)          /*!< EADC_T::AD0TRGEN2: EPWM120FEN Mask        */

#define EADC_AD0TRGEN2_EPWM12PEN_Pos     (18)                                              /*!< EADC_T::AD0TRGEN2: EPWM12PEN Position     */
#define EADC_AD0TRGEN2_EPWM12PEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM12PEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM12PEN Mask         */

#define EADC_AD0TRGEN2_EPWM12CEN_Pos     (19)                                              /*!< EADC_T::AD0TRGEN2: EPWM12CEN Position     */
#define EADC_AD0TRGEN2_EPWM12CEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM12CEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM12CEN Mask         */

#define EADC_AD0TRGEN2_EPWM14REN_Pos     (20)                                              /*!< EADC_T::AD0TRGEN2: EPWM14REN Position     */
#define EADC_AD0TRGEN2_EPWM14REN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM14REN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM14REN Mask         */

#define EADC_AD0TRGEN2_EPWM14FEN_Pos     (21)                                              /*!< EADC_T::AD0TRGEN2: EPWM14FEN Position     */
#define EADC_AD0TRGEN2_EPWM14FEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM14FEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM14FEN Mask         */

#define EADC_AD0TRGEN2_EPWM14PEN_Pos     (22)                                              /*!< EADC_T::AD0TRGEN2: EPWM14PEN Position     */
#define EADC_AD0TRGEN2_EPWM14PEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM14PEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM14PEN Mask         */

#define EADC_AD0TRGEN2_EPWM14CEN_Pos     (23)                                              /*!< EADC_T::AD0TRGEN2: EPWM14CEN Position     */
#define EADC_AD0TRGEN2_EPWM14CEN_Msk     (0x1ul << EADC_AD0TRGEN2_EPWM14CEN_Pos)           /*!< EADC_T::AD0TRGEN2: EPWM14CEN Mask         */

#define EADC_AD0TRGEN2_PWM00REN_Pos      (24)                                              /*!< EADC_T::AD0TRGEN2: PWM00REN Position      */
#define EADC_AD0TRGEN2_PWM00REN_Msk      (0x1ul << EADC_AD0TRGEN2_PWM00REN_Pos)            /*!< EADC_T::AD0TRGEN2: PWM00REN Mask          */

#define EADC_AD0TRGEN2_PWM00FEN_Pos      (25)                                              /*!< EADC_T::AD0TRGEN2: PWM00FEN Position      */
#define EADC_AD0TRGEN2_PWM00FEN_Msk      (0x1ul << EADC_AD0TRGEN2_PWM00FEN_Pos)            /*!< EADC_T::AD0TRGEN2: PWM00FEN Mask          */

#define EADC_AD0TRGEN2_PWM00PEN_Pos      (26)                                              /*!< EADC_T::AD0TRGEN2: PWM00PEN Position      */
#define EADC_AD0TRGEN2_PWM00PEN_Msk      (0x1ul << EADC_AD0TRGEN2_PWM00PEN_Pos)            /*!< EADC_T::AD0TRGEN2: PWM00PEN Mask          */

#define EADC_AD0TRGEN2_PWM00CEN_Pos      (27)                                              /*!< EADC_T::AD0TRGEN2: PWM00CEN Position      */
#define EADC_AD0TRGEN2_PWM00CEN_Msk      (0x1ul << EADC_AD0TRGEN2_PWM00CEN_Pos)            /*!< EADC_T::AD0TRGEN2: PWM00CEN Mask          */

#define EADC_AD0TRGEN2_PWM01REN_Pos      (28)                                              /*!< EADC_T::AD0TRGEN2: PWM01REN Position      */
#define EADC_AD0TRGEN2_PWM01REN_Msk      (0x1ul << EADC_AD0TRGEN2_PWM01REN_Pos)            /*!< EADC_T::AD0TRGEN2: PWM01REN Mask          */

#define EADC_AD0TRGEN2_PWM01FEN_Pos      (29)                                              /*!< EADC_T::AD0TRGEN2: PWM01FEN Position      */
#define EADC_AD0TRGEN2_PWM01FEN_Msk      (0x1ul << EADC_AD0TRGEN2_PWM01FEN_Pos)            /*!< EADC_T::AD0TRGEN2: PWM01FEN Mask          */

#define EADC_AD0TRGEN2_PWM01PEN_Pos      (30)                                              /*!< EADC_T::AD0TRGEN2: PWM01PEN Position      */
#define EADC_AD0TRGEN2_PWM01PEN_Msk      (0x1ul << EADC_AD0TRGEN2_PWM01PEN_Pos)            /*!< EADC_T::AD0TRGEN2: PWM01PEN Mask          */

#define EADC_AD0TRGEN2_PWM01CEN_Pos      (31)                                              /*!< EADC_T::AD0TRGEN2: PWM01CEN Position      */
#define EADC_AD0TRGEN2_PWM01CEN_Msk      (0x1ul << EADC_AD0TRGEN2_PWM01CEN_Pos)            /*!< EADC_T::AD0TRGEN2: PWM01CEN Mask          */

#define EADC_AD0TRGEN3_EPWM00REN_Pos     (0)                                               /*!< EADC_T::AD0TRGEN3: EPWM00REN Position     */
#define EADC_AD0TRGEN3_EPWM00REN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM00REN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM00REN Mask         */

#define EADC_AD0TRGEN3_EPWM00FEN_Pos     (1)                                               /*!< EADC_T::AD0TRGEN3: EPWM00FEN Position     */
#define EADC_AD0TRGEN3_EPWM00FEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM00FEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM00FEN Mask         */

#define EADC_AD0TRGEN3_EPWM00PEN_Pos     (2)                                               /*!< EADC_T::AD0TRGEN3: EPWM00PEN Position     */
#define EADC_AD0TRGEN3_EPWM00PEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM00PEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM00PEN Mask         */

#define EADC_AD0TRGEN3_EPWM00CEN_Pos     (3)                                               /*!< EADC_T::AD0TRGEN3: EPWM00CEN Position     */
#define EADC_AD0TRGEN3_EPWM00CEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM00CEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM00CEN Mask         */

#define EADC_AD0TRGEN3_EPWM02REN_Pos     (4)                                               /*!< EADC_T::AD0TRGEN3: EPWM02REN Position     */
#define EADC_AD0TRGEN3_EPWM02REN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM02REN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM02REN Mask         */

#define EADC_AD0TRGEN3_EPWM02FEN_Pos     (5)                                               /*!< EADC_T::AD0TRGEN3: EPWM02FEN Position     */
#define EADC_AD0TRGEN3_EPWM02FEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM02FEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM02FEN Mask         */

#define EADC_AD0TRGEN3_EPWM02PEN_Pos     (6)                                               /*!< EADC_T::AD0TRGEN3: EPWM02PEN Position     */
#define EADC_AD0TRGEN3_EPWM02PEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM02PEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM02PEN Mask         */

#define EADC_AD0TRGEN3_EPWM02CEN_Pos     (7)                                               /*!< EADC_T::AD0TRGEN3: EPWM02CEN Position     */
#define EADC_AD0TRGEN3_EPWM02CEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM02CEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM02CEN Mask         */

#define EADC_AD0TRGEN3_EPWM04REN_Pos     (8)                                               /*!< EADC_T::AD0TRGEN3: EPWM04REN Position     */
#define EADC_AD0TRGEN3_EPWM04REN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM04REN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM04REN Mask         */

#define EADC_AD0TRGEN3_EPWM04FEN_Pos     (9)                                               /*!< EADC_T::AD0TRGEN3: EPWM04FEN Position     */
#define EADC_AD0TRGEN3_EPWM04FEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM04FEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM04FEN Mask         */

#define EADC_AD0TRGEN3_EPWM04PEN_Pos     (10)                                              /*!< EADC_T::AD0TRGEN3: EPWM04PEN Position     */
#define EADC_AD0TRGEN3_EPWM04PEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM04PEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM04PEN Mask         */

#define EADC_AD0TRGEN3_EPWM04CEN_Pos     (11)                                              /*!< EADC_T::AD0TRGEN3: EPWM04CEN Position     */
#define EADC_AD0TRGEN3_EPWM04CEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM04CEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM04CEN Mask         */

#define EADC_AD0TRGEN3_EPWM10REN_Pos     (12)                                              /*!< EADC_T::AD0TRGEN3: EPWM10REN Position     */
#define EADC_AD0TRGEN3_EPWM10REN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM10REN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM10REN Mask         */

#define EADC_AD0TRGEN3_EPWM10FEN_Pos     (13)                                              /*!< EADC_T::AD0TRGEN3: EPWM10FEN Position     */
#define EADC_AD0TRGEN3_EPWM10FEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM10FEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM10FEN Mask         */

#define EADC_AD0TRGEN3_EPWM10PEN_Pos     (14)                                              /*!< EADC_T::AD0TRGEN3: EPWM10PEN Position     */
#define EADC_AD0TRGEN3_EPWM10PEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM10PEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM10PEN Mask         */

#define EADC_AD0TRGEN3_EPWM10CEN_Pos     (15)                                              /*!< EADC_T::AD0TRGEN3: EPWM10CEN Position     */
#define EADC_AD0TRGEN3_EPWM10CEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM10CEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM10CEN Mask         */

#define EADC_AD0TRGEN3_EPWM12REN_Pos     (16)                                              /*!< EADC_T::AD0TRGEN3: EPWM12REN Position     */
#define EADC_AD0TRGEN3_EPWM12REN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM12REN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM12REN Mask         */

#define EADC_AD0TRGEN3_EPWM120FEN_Pos    (17)                                              /*!< EADC_T::AD0TRGEN3: EPWM120FEN Position    */
#define EADC_AD0TRGEN3_EPWM120FEN_Msk    (0x1ul << EADC_AD0TRGEN3_EPWM120FEN_Pos)          /*!< EADC_T::AD0TRGEN3: EPWM120FEN Mask        */

#define EADC_AD0TRGEN3_EPWM12PEN_Pos     (18)                                              /*!< EADC_T::AD0TRGEN3: EPWM12PEN Position     */
#define EADC_AD0TRGEN3_EPWM12PEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM12PEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM12PEN Mask         */

#define EADC_AD0TRGEN3_EPWM12CEN_Pos     (19)                                              /*!< EADC_T::AD0TRGEN3: EPWM12CEN Position     */
#define EADC_AD0TRGEN3_EPWM12CEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM12CEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM12CEN Mask         */

#define EADC_AD0TRGEN3_EPWM14REN_Pos     (20)                                              /*!< EADC_T::AD0TRGEN3: EPWM14REN Position     */
#define EADC_AD0TRGEN3_EPWM14REN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM14REN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM14REN Mask         */

#define EADC_AD0TRGEN3_EPWM14FEN_Pos     (21)                                              /*!< EADC_T::AD0TRGEN3: EPWM14FEN Position     */
#define EADC_AD0TRGEN3_EPWM14FEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM14FEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM14FEN Mask         */

#define EADC_AD0TRGEN3_EPWM14PEN_Pos     (22)                                              /*!< EADC_T::AD0TRGEN3: EPWM14PEN Position     */
#define EADC_AD0TRGEN3_EPWM14PEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM14PEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM14PEN Mask         */

#define EADC_AD0TRGEN3_EPWM14CEN_Pos     (23)                                              /*!< EADC_T::AD0TRGEN3: EPWM14CEN Position     */
#define EADC_AD0TRGEN3_EPWM14CEN_Msk     (0x1ul << EADC_AD0TRGEN3_EPWM14CEN_Pos)           /*!< EADC_T::AD0TRGEN3: EPWM14CEN Mask         */

#define EADC_AD0TRGEN3_PWM00REN_Pos      (24)                                              /*!< EADC_T::AD0TRGEN3: PWM00REN Position      */
#define EADC_AD0TRGEN3_PWM00REN_Msk      (0x1ul << EADC_AD0TRGEN3_PWM00REN_Pos)            /*!< EADC_T::AD0TRGEN3: PWM00REN Mask          */

#define EADC_AD0TRGEN3_PWM00FEN_Pos      (25)                                              /*!< EADC_T::AD0TRGEN3: PWM00FEN Position      */
#define EADC_AD0TRGEN3_PWM00FEN_Msk      (0x1ul << EADC_AD0TRGEN3_PWM00FEN_Pos)            /*!< EADC_T::AD0TRGEN3: PWM00FEN Mask          */

#define EADC_AD0TRGEN3_PWM00PEN_Pos      (26)                                              /*!< EADC_T::AD0TRGEN3: PWM00PEN Position      */
#define EADC_AD0TRGEN3_PWM00PEN_Msk      (0x1ul << EADC_AD0TRGEN3_PWM00PEN_Pos)            /*!< EADC_T::AD0TRGEN3: PWM00PEN Mask          */

#define EADC_AD0TRGEN3_PWM00CEN_Pos      (27)                                              /*!< EADC_T::AD0TRGEN3: PWM00CEN Position      */
#define EADC_AD0TRGEN3_PWM00CEN_Msk      (0x1ul << EADC_AD0TRGEN3_PWM00CEN_Pos)            /*!< EADC_T::AD0TRGEN3: PWM00CEN Mask          */

#define EADC_AD0TRGEN3_PWM01REN_Pos      (28)                                              /*!< EADC_T::AD0TRGEN3: PWM01REN Position      */
#define EADC_AD0TRGEN3_PWM01REN_Msk      (0x1ul << EADC_AD0TRGEN3_PWM01REN_Pos)            /*!< EADC_T::AD0TRGEN3: PWM01REN Mask          */

#define EADC_AD0TRGEN3_PWM01FEN_Pos      (29)                                              /*!< EADC_T::AD0TRGEN3: PWM01FEN Position      */
#define EADC_AD0TRGEN3_PWM01FEN_Msk      (0x1ul << EADC_AD0TRGEN3_PWM01FEN_Pos)            /*!< EADC_T::AD0TRGEN3: PWM01FEN Mask          */

#define EADC_AD0TRGEN3_PWM01PEN_Pos      (30)                                              /*!< EADC_T::AD0TRGEN3: PWM01PEN Position      */
#define EADC_AD0TRGEN3_PWM01PEN_Msk      (0x1ul << EADC_AD0TRGEN3_PWM01PEN_Pos)            /*!< EADC_T::AD0TRGEN3: PWM01PEN Mask          */

#define EADC_AD0TRGEN3_PWM01CEN_Pos      (31)                                              /*!< EADC_T::AD0TRGEN3: PWM01CEN Position      */
#define EADC_AD0TRGEN3_PWM01CEN_Msk      (0x1ul << EADC_AD0TRGEN3_PWM01CEN_Pos)            /*!< EADC_T::AD0TRGEN3: PWM01CEN Mask          */

#define EADC_AD1TRGEN0_EPWM00REN_Pos     (0)                                               /*!< EADC_T::AD1TRGEN0: EPWM00REN Position     */
#define EADC_AD1TRGEN0_EPWM00REN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM00REN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM00REN Mask         */

#define EADC_AD1TRGEN0_EPWM00FEN_Pos     (1)                                               /*!< EADC_T::AD1TRGEN0: EPWM00FEN Position     */
#define EADC_AD1TRGEN0_EPWM00FEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM00FEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM00FEN Mask         */

#define EADC_AD1TRGEN0_EPWM00PEN_Pos     (2)                                               /*!< EADC_T::AD1TRGEN0: EPWM00PEN Position     */
#define EADC_AD1TRGEN0_EPWM00PEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM00PEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM00PEN Mask         */

#define EADC_AD1TRGEN0_EPWM00CEN_Pos     (3)                                               /*!< EADC_T::AD1TRGEN0: EPWM00CEN Position     */
#define EADC_AD1TRGEN0_EPWM00CEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM00CEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM00CEN Mask         */

#define EADC_AD1TRGEN0_EPWM02REN_Pos     (4)                                               /*!< EADC_T::AD1TRGEN0: EPWM02REN Position     */
#define EADC_AD1TRGEN0_EPWM02REN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM02REN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM02REN Mask         */

#define EADC_AD1TRGEN0_EPWM02FEN_Pos     (5)                                               /*!< EADC_T::AD1TRGEN0: EPWM02FEN Position     */
#define EADC_AD1TRGEN0_EPWM02FEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM02FEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM02FEN Mask         */

#define EADC_AD1TRGEN0_EPWM02PEN_Pos     (6)                                               /*!< EADC_T::AD1TRGEN0: EPWM02PEN Position     */
#define EADC_AD1TRGEN0_EPWM02PEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM02PEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM02PEN Mask         */

#define EADC_AD1TRGEN0_EPWM02CEN_Pos     (7)                                               /*!< EADC_T::AD1TRGEN0: EPWM02CEN Position     */
#define EADC_AD1TRGEN0_EPWM02CEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM02CEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM02CEN Mask         */

#define EADC_AD1TRGEN0_EPWM04REN_Pos     (8)                                               /*!< EADC_T::AD1TRGEN0: EPWM04REN Position     */
#define EADC_AD1TRGEN0_EPWM04REN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM04REN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM04REN Mask         */

#define EADC_AD1TRGEN0_EPWM04FEN_Pos     (9)                                               /*!< EADC_T::AD1TRGEN0: EPWM04FEN Position     */
#define EADC_AD1TRGEN0_EPWM04FEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM04FEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM04FEN Mask         */

#define EADC_AD1TRGEN0_EPWM04PEN_Pos     (10)                                              /*!< EADC_T::AD1TRGEN0: EPWM04PEN Position     */
#define EADC_AD1TRGEN0_EPWM04PEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM04PEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM04PEN Mask         */

#define EADC_AD1TRGEN0_EPWM04CEN_Pos     (11)                                              /*!< EADC_T::AD1TRGEN0: EPWM04CEN Position     */
#define EADC_AD1TRGEN0_EPWM04CEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM04CEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM04CEN Mask         */

#define EADC_AD1TRGEN0_EPWM10REN_Pos     (12)                                              /*!< EADC_T::AD1TRGEN0: EPWM10REN Position     */
#define EADC_AD1TRGEN0_EPWM10REN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM10REN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM10REN Mask         */

#define EADC_AD1TRGEN0_EPWM10FEN_Pos     (13)                                              /*!< EADC_T::AD1TRGEN0: EPWM10FEN Position     */
#define EADC_AD1TRGEN0_EPWM10FEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM10FEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM10FEN Mask         */

#define EADC_AD1TRGEN0_EPWM10PEN_Pos     (14)                                              /*!< EADC_T::AD1TRGEN0: EPWM10PEN Position     */
#define EADC_AD1TRGEN0_EPWM10PEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM10PEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM10PEN Mask         */

#define EADC_AD1TRGEN0_EPWM10CEN_Pos     (15)                                              /*!< EADC_T::AD1TRGEN0: EPWM10CEN Position     */
#define EADC_AD1TRGEN0_EPWM10CEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM10CEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM10CEN Mask         */

#define EADC_AD1TRGEN0_EPWM12REN_Pos     (16)                                              /*!< EADC_T::AD1TRGEN0: EPWM12REN Position     */
#define EADC_AD1TRGEN0_EPWM12REN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM12REN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM12REN Mask         */

#define EADC_AD1TRGEN0_EPWM120FEN_Pos    (17)                                              /*!< EADC_T::AD1TRGEN0: EPWM120FEN Position    */
#define EADC_AD1TRGEN0_EPWM120FEN_Msk    (0x1ul << EADC_AD1TRGEN0_EPWM120FEN_Pos)          /*!< EADC_T::AD1TRGEN0: EPWM120FEN Mask        */

#define EADC_AD1TRGEN0_EPWM12PEN_Pos     (18)                                              /*!< EADC_T::AD1TRGEN0: EPWM12PEN Position     */
#define EADC_AD1TRGEN0_EPWM12PEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM12PEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM12PEN Mask         */

#define EADC_AD1TRGEN0_EPWM12CEN_Pos     (19)                                              /*!< EADC_T::AD1TRGEN0: EPWM12CEN Position     */
#define EADC_AD1TRGEN0_EPWM12CEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM12CEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM12CEN Mask         */

#define EADC_AD1TRGEN0_EPWM14REN_Pos     (20)                                              /*!< EADC_T::AD1TRGEN0: EPWM14REN Position     */
#define EADC_AD1TRGEN0_EPWM14REN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM14REN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM14REN Mask         */

#define EADC_AD1TRGEN0_EPWM14FEN_Pos     (21)                                              /*!< EADC_T::AD1TRGEN0: EPWM14FEN Position     */
#define EADC_AD1TRGEN0_EPWM14FEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM14FEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM14FEN Mask         */

#define EADC_AD1TRGEN0_EPWM14PEN_Pos     (22)                                              /*!< EADC_T::AD1TRGEN0: EPWM14PEN Position     */
#define EADC_AD1TRGEN0_EPWM14PEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM14PEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM14PEN Mask         */

#define EADC_AD1TRGEN0_EPWM14CEN_Pos     (23)                                              /*!< EADC_T::AD1TRGEN0: EPWM14CEN Position     */
#define EADC_AD1TRGEN0_EPWM14CEN_Msk     (0x1ul << EADC_AD1TRGEN0_EPWM14CEN_Pos)           /*!< EADC_T::AD1TRGEN0: EPWM14CEN Mask         */

#define EADC_AD1TRGEN0_PWM00REN_Pos      (24)                                              /*!< EADC_T::AD1TRGEN0: PWM00REN Position      */
#define EADC_AD1TRGEN0_PWM00REN_Msk      (0x1ul << EADC_AD1TRGEN0_PWM00REN_Pos)            /*!< EADC_T::AD1TRGEN0: PWM00REN Mask          */

#define EADC_AD1TRGEN0_PWM00FEN_Pos      (25)                                              /*!< EADC_T::AD1TRGEN0: PWM00FEN Position      */
#define EADC_AD1TRGEN0_PWM00FEN_Msk      (0x1ul << EADC_AD1TRGEN0_PWM00FEN_Pos)            /*!< EADC_T::AD1TRGEN0: PWM00FEN Mask          */

#define EADC_AD1TRGEN0_PWM00PEN_Pos      (26)                                              /*!< EADC_T::AD1TRGEN0: PWM00PEN Position      */
#define EADC_AD1TRGEN0_PWM00PEN_Msk      (0x1ul << EADC_AD1TRGEN0_PWM00PEN_Pos)            /*!< EADC_T::AD1TRGEN0: PWM00PEN Mask          */

#define EADC_AD1TRGEN0_PWM00CEN_Pos      (27)                                              /*!< EADC_T::AD1TRGEN0: PWM00CEN Position      */
#define EADC_AD1TRGEN0_PWM00CEN_Msk      (0x1ul << EADC_AD1TRGEN0_PWM00CEN_Pos)            /*!< EADC_T::AD1TRGEN0: PWM00CEN Mask          */

#define EADC_AD1TRGEN0_PWM01REN_Pos      (28)                                              /*!< EADC_T::AD1TRGEN0: PWM01REN Position      */
#define EADC_AD1TRGEN0_PWM01REN_Msk      (0x1ul << EADC_AD1TRGEN0_PWM01REN_Pos)            /*!< EADC_T::AD1TRGEN0: PWM01REN Mask          */

#define EADC_AD1TRGEN0_PWM01FEN_Pos      (29)                                              /*!< EADC_T::AD1TRGEN0: PWM01FEN Position      */
#define EADC_AD1TRGEN0_PWM01FEN_Msk      (0x1ul << EADC_AD1TRGEN0_PWM01FEN_Pos)            /*!< EADC_T::AD1TRGEN0: PWM01FEN Mask          */

#define EADC_AD1TRGEN0_PWM01PEN_Pos      (30)                                              /*!< EADC_T::AD1TRGEN0: PWM01PEN Position      */
#define EADC_AD1TRGEN0_PWM01PEN_Msk      (0x1ul << EADC_AD1TRGEN0_PWM01PEN_Pos)            /*!< EADC_T::AD1TRGEN0: PWM01PEN Mask          */

#define EADC_AD1TRGEN0_PWM01CEN_Pos      (31)                                              /*!< EADC_T::AD1TRGEN0: PWM01CEN Position      */
#define EADC_AD1TRGEN0_PWM01CEN_Msk      (0x1ul << EADC_AD1TRGEN0_PWM01CEN_Pos)            /*!< EADC_T::AD1TRGEN0: PWM01CEN Mask          */

#define EADC_AD1TRGEN1_EPWM00REN_Pos     (0)                                               /*!< EADC_T::AD1TRGEN1: EPWM00REN Position     */
#define EADC_AD1TRGEN1_EPWM00REN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM00REN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM00REN Mask         */

#define EADC_AD1TRGEN1_EPWM00FEN_Pos     (1)                                               /*!< EADC_T::AD1TRGEN1: EPWM00FEN Position     */
#define EADC_AD1TRGEN1_EPWM00FEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM00FEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM00FEN Mask         */

#define EADC_AD1TRGEN1_EPWM00PEN_Pos     (2)                                               /*!< EADC_T::AD1TRGEN1: EPWM00PEN Position     */
#define EADC_AD1TRGEN1_EPWM00PEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM00PEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM00PEN Mask         */

#define EADC_AD1TRGEN1_EPWM00CEN_Pos     (3)                                               /*!< EADC_T::AD1TRGEN1: EPWM00CEN Position     */
#define EADC_AD1TRGEN1_EPWM00CEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM00CEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM00CEN Mask         */

#define EADC_AD1TRGEN1_EPWM02REN_Pos     (4)                                               /*!< EADC_T::AD1TRGEN1: EPWM02REN Position     */
#define EADC_AD1TRGEN1_EPWM02REN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM02REN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM02REN Mask         */

#define EADC_AD1TRGEN1_EPWM02FEN_Pos     (5)                                               /*!< EADC_T::AD1TRGEN1: EPWM02FEN Position     */
#define EADC_AD1TRGEN1_EPWM02FEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM02FEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM02FEN Mask         */

#define EADC_AD1TRGEN1_EPWM02PEN_Pos     (6)                                               /*!< EADC_T::AD1TRGEN1: EPWM02PEN Position     */
#define EADC_AD1TRGEN1_EPWM02PEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM02PEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM02PEN Mask         */

#define EADC_AD1TRGEN1_EPWM02CEN_Pos     (7)                                               /*!< EADC_T::AD1TRGEN1: EPWM02CEN Position     */
#define EADC_AD1TRGEN1_EPWM02CEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM02CEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM02CEN Mask         */

#define EADC_AD1TRGEN1_EPWM04REN_Pos     (8)                                               /*!< EADC_T::AD1TRGEN1: EPWM04REN Position     */
#define EADC_AD1TRGEN1_EPWM04REN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM04REN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM04REN Mask         */

#define EADC_AD1TRGEN1_EPWM04FEN_Pos     (9)                                               /*!< EADC_T::AD1TRGEN1: EPWM04FEN Position     */
#define EADC_AD1TRGEN1_EPWM04FEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM04FEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM04FEN Mask         */

#define EADC_AD1TRGEN1_EPWM04PEN_Pos     (10)                                              /*!< EADC_T::AD1TRGEN1: EPWM04PEN Position     */
#define EADC_AD1TRGEN1_EPWM04PEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM04PEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM04PEN Mask         */

#define EADC_AD1TRGEN1_EPWM04CEN_Pos     (11)                                              /*!< EADC_T::AD1TRGEN1: EPWM04CEN Position     */
#define EADC_AD1TRGEN1_EPWM04CEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM04CEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM04CEN Mask         */

#define EADC_AD1TRGEN1_EPWM10REN_Pos     (12)                                              /*!< EADC_T::AD1TRGEN1: EPWM10REN Position     */
#define EADC_AD1TRGEN1_EPWM10REN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM10REN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM10REN Mask         */

#define EADC_AD1TRGEN1_EPWM10FEN_Pos     (13)                                              /*!< EADC_T::AD1TRGEN1: EPWM10FEN Position     */
#define EADC_AD1TRGEN1_EPWM10FEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM10FEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM10FEN Mask         */

#define EADC_AD1TRGEN1_EPWM10PEN_Pos     (14)                                              /*!< EADC_T::AD1TRGEN1: EPWM10PEN Position     */
#define EADC_AD1TRGEN1_EPWM10PEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM10PEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM10PEN Mask         */

#define EADC_AD1TRGEN1_EPWM10CEN_Pos     (15)                                              /*!< EADC_T::AD1TRGEN1: EPWM10CEN Position     */
#define EADC_AD1TRGEN1_EPWM10CEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM10CEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM10CEN Mask         */

#define EADC_AD1TRGEN1_EPWM12REN_Pos     (16)                                              /*!< EADC_T::AD1TRGEN1: EPWM12REN Position     */
#define EADC_AD1TRGEN1_EPWM12REN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM12REN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM12REN Mask         */

#define EADC_AD1TRGEN1_EPWM120FEN_Pos    (17)                                              /*!< EADC_T::AD1TRGEN1: EPWM120FEN Position    */
#define EADC_AD1TRGEN1_EPWM120FEN_Msk    (0x1ul << EADC_AD1TRGEN1_EPWM120FEN_Pos)          /*!< EADC_T::AD1TRGEN1: EPWM120FEN Mask        */

#define EADC_AD1TRGEN1_EPWM12PEN_Pos     (18)                                              /*!< EADC_T::AD1TRGEN1: EPWM12PEN Position     */
#define EADC_AD1TRGEN1_EPWM12PEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM12PEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM12PEN Mask         */

#define EADC_AD1TRGEN1_EPWM12CEN_Pos     (19)                                              /*!< EADC_T::AD1TRGEN1: EPWM12CEN Position     */
#define EADC_AD1TRGEN1_EPWM12CEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM12CEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM12CEN Mask         */

#define EADC_AD1TRGEN1_EPWM14REN_Pos     (20)                                              /*!< EADC_T::AD1TRGEN1: EPWM14REN Position     */
#define EADC_AD1TRGEN1_EPWM14REN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM14REN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM14REN Mask         */

#define EADC_AD1TRGEN1_EPWM14FEN_Pos     (21)                                              /*!< EADC_T::AD1TRGEN1: EPWM14FEN Position     */
#define EADC_AD1TRGEN1_EPWM14FEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM14FEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM14FEN Mask         */

#define EADC_AD1TRGEN1_EPWM14PEN_Pos     (22)                                              /*!< EADC_T::AD1TRGEN1: EPWM14PEN Position     */
#define EADC_AD1TRGEN1_EPWM14PEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM14PEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM14PEN Mask         */

#define EADC_AD1TRGEN1_EPWM14CEN_Pos     (23)                                              /*!< EADC_T::AD1TRGEN1: EPWM14CEN Position     */
#define EADC_AD1TRGEN1_EPWM14CEN_Msk     (0x1ul << EADC_AD1TRGEN1_EPWM14CEN_Pos)           /*!< EADC_T::AD1TRGEN1: EPWM14CEN Mask         */

#define EADC_AD1TRGEN1_PWM00REN_Pos      (24)                                              /*!< EADC_T::AD1TRGEN1: PWM00REN Position      */
#define EADC_AD1TRGEN1_PWM00REN_Msk      (0x1ul << EADC_AD1TRGEN1_PWM00REN_Pos)            /*!< EADC_T::AD1TRGEN1: PWM00REN Mask          */

#define EADC_AD1TRGEN1_PWM00FEN_Pos      (25)                                              /*!< EADC_T::AD1TRGEN1: PWM00FEN Position      */
#define EADC_AD1TRGEN1_PWM00FEN_Msk      (0x1ul << EADC_AD1TRGEN1_PWM00FEN_Pos)            /*!< EADC_T::AD1TRGEN1: PWM00FEN Mask          */

#define EADC_AD1TRGEN1_PWM00PEN_Pos      (26)                                              /*!< EADC_T::AD1TRGEN1: PWM00PEN Position      */
#define EADC_AD1TRGEN1_PWM00PEN_Msk      (0x1ul << EADC_AD1TRGEN1_PWM00PEN_Pos)            /*!< EADC_T::AD1TRGEN1: PWM00PEN Mask          */

#define EADC_AD1TRGEN1_PWM00CEN_Pos      (27)                                              /*!< EADC_T::AD1TRGEN1: PWM00CEN Position      */
#define EADC_AD1TRGEN1_PWM00CEN_Msk      (0x1ul << EADC_AD1TRGEN1_PWM00CEN_Pos)            /*!< EADC_T::AD1TRGEN1: PWM00CEN Mask          */

#define EADC_AD1TRGEN1_PWM01REN_Pos      (28)                                              /*!< EADC_T::AD1TRGEN1: PWM01REN Position      */
#define EADC_AD1TRGEN1_PWM01REN_Msk      (0x1ul << EADC_AD1TRGEN1_PWM01REN_Pos)            /*!< EADC_T::AD1TRGEN1: PWM01REN Mask          */

#define EADC_AD1TRGEN1_PWM01FEN_Pos      (29)                                              /*!< EADC_T::AD1TRGEN1: PWM01FEN Position      */
#define EADC_AD1TRGEN1_PWM01FEN_Msk      (0x1ul << EADC_AD1TRGEN1_PWM01FEN_Pos)            /*!< EADC_T::AD1TRGEN1: PWM01FEN Mask          */

#define EADC_AD1TRGEN1_PWM01PEN_Pos      (30)                                              /*!< EADC_T::AD1TRGEN1: PWM01PEN Position      */
#define EADC_AD1TRGEN1_PWM01PEN_Msk      (0x1ul << EADC_AD1TRGEN1_PWM01PEN_Pos)            /*!< EADC_T::AD1TRGEN1: PWM01PEN Mask          */

#define EADC_AD1TRGEN1_PWM01CEN_Pos      (31)                                              /*!< EADC_T::AD1TRGEN1: PWM01CEN Position      */
#define EADC_AD1TRGEN1_PWM01CEN_Msk      (0x1ul << EADC_AD1TRGEN1_PWM01CEN_Pos)            /*!< EADC_T::AD1TRGEN1: PWM01CEN Mask          */

#define EADC_AD1TRGEN2_EPWM00REN_Pos     (0)                                               /*!< EADC_T::AD1TRGEN2: EPWM00REN Position     */
#define EADC_AD1TRGEN2_EPWM00REN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM00REN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM00REN Mask         */

#define EADC_AD1TRGEN2_EPWM00FEN_Pos     (1)                                               /*!< EADC_T::AD1TRGEN2: EPWM00FEN Position     */
#define EADC_AD1TRGEN2_EPWM00FEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM00FEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM00FEN Mask         */

#define EADC_AD1TRGEN2_EPWM00PEN_Pos     (2)                                               /*!< EADC_T::AD1TRGEN2: EPWM00PEN Position     */
#define EADC_AD1TRGEN2_EPWM00PEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM00PEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM00PEN Mask         */

#define EADC_AD1TRGEN2_EPWM00CEN_Pos     (3)                                               /*!< EADC_T::AD1TRGEN2: EPWM00CEN Position     */
#define EADC_AD1TRGEN2_EPWM00CEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM00CEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM00CEN Mask         */

#define EADC_AD1TRGEN2_EPWM02REN_Pos     (4)                                               /*!< EADC_T::AD1TRGEN2: EPWM02REN Position     */
#define EADC_AD1TRGEN2_EPWM02REN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM02REN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM02REN Mask         */

#define EADC_AD1TRGEN2_EPWM02FEN_Pos     (5)                                               /*!< EADC_T::AD1TRGEN2: EPWM02FEN Position     */
#define EADC_AD1TRGEN2_EPWM02FEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM02FEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM02FEN Mask         */

#define EADC_AD1TRGEN2_EPWM02PEN_Pos     (6)                                               /*!< EADC_T::AD1TRGEN2: EPWM02PEN Position     */
#define EADC_AD1TRGEN2_EPWM02PEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM02PEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM02PEN Mask         */

#define EADC_AD1TRGEN2_EPWM02CEN_Pos     (7)                                               /*!< EADC_T::AD1TRGEN2: EPWM02CEN Position     */
#define EADC_AD1TRGEN2_EPWM02CEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM02CEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM02CEN Mask         */

#define EADC_AD1TRGEN2_EPWM04REN_Pos     (8)                                               /*!< EADC_T::AD1TRGEN2: EPWM04REN Position     */
#define EADC_AD1TRGEN2_EPWM04REN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM04REN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM04REN Mask         */

#define EADC_AD1TRGEN2_EPWM04FEN_Pos     (9)                                               /*!< EADC_T::AD1TRGEN2: EPWM04FEN Position     */
#define EADC_AD1TRGEN2_EPWM04FEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM04FEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM04FEN Mask         */

#define EADC_AD1TRGEN2_EPWM04PEN_Pos     (10)                                              /*!< EADC_T::AD1TRGEN2: EPWM04PEN Position     */
#define EADC_AD1TRGEN2_EPWM04PEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM04PEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM04PEN Mask         */

#define EADC_AD1TRGEN2_EPWM04CEN_Pos     (11)                                              /*!< EADC_T::AD1TRGEN2: EPWM04CEN Position     */
#define EADC_AD1TRGEN2_EPWM04CEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM04CEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM04CEN Mask         */

#define EADC_AD1TRGEN2_EPWM10REN_Pos     (12)                                              /*!< EADC_T::AD1TRGEN2: EPWM10REN Position     */
#define EADC_AD1TRGEN2_EPWM10REN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM10REN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM10REN Mask         */

#define EADC_AD1TRGEN2_EPWM10FEN_Pos     (13)                                              /*!< EADC_T::AD1TRGEN2: EPWM10FEN Position     */
#define EADC_AD1TRGEN2_EPWM10FEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM10FEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM10FEN Mask         */

#define EADC_AD1TRGEN2_EPWM10PEN_Pos     (14)                                              /*!< EADC_T::AD1TRGEN2: EPWM10PEN Position     */
#define EADC_AD1TRGEN2_EPWM10PEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM10PEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM10PEN Mask         */

#define EADC_AD1TRGEN2_EPWM10CEN_Pos     (15)                                              /*!< EADC_T::AD1TRGEN2: EPWM10CEN Position     */
#define EADC_AD1TRGEN2_EPWM10CEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM10CEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM10CEN Mask         */

#define EADC_AD1TRGEN2_EPWM12REN_Pos     (16)                                              /*!< EADC_T::AD1TRGEN2: EPWM12REN Position     */
#define EADC_AD1TRGEN2_EPWM12REN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM12REN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM12REN Mask         */

#define EADC_AD1TRGEN2_EPWM120FEN_Pos    (17)                                              /*!< EADC_T::AD1TRGEN2: EPWM120FEN Position    */
#define EADC_AD1TRGEN2_EPWM120FEN_Msk    (0x1ul << EADC_AD1TRGEN2_EPWM120FEN_Pos)          /*!< EADC_T::AD1TRGEN2: EPWM120FEN Mask        */

#define EADC_AD1TRGEN2_EPWM12PEN_Pos     (18)                                              /*!< EADC_T::AD1TRGEN2: EPWM12PEN Position     */
#define EADC_AD1TRGEN2_EPWM12PEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM12PEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM12PEN Mask         */

#define EADC_AD1TRGEN2_EPWM12CEN_Pos     (19)                                              /*!< EADC_T::AD1TRGEN2: EPWM12CEN Position     */
#define EADC_AD1TRGEN2_EPWM12CEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM12CEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM12CEN Mask         */

#define EADC_AD1TRGEN2_EPWM14REN_Pos     (20)                                              /*!< EADC_T::AD1TRGEN2: EPWM14REN Position     */
#define EADC_AD1TRGEN2_EPWM14REN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM14REN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM14REN Mask         */

#define EADC_AD1TRGEN2_EPWM14FEN_Pos     (21)                                              /*!< EADC_T::AD1TRGEN2: EPWM14FEN Position     */
#define EADC_AD1TRGEN2_EPWM14FEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM14FEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM14FEN Mask         */

#define EADC_AD1TRGEN2_EPWM14PEN_Pos     (22)                                              /*!< EADC_T::AD1TRGEN2: EPWM14PEN Position     */
#define EADC_AD1TRGEN2_EPWM14PEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM14PEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM14PEN Mask         */

#define EADC_AD1TRGEN2_EPWM14CEN_Pos     (23)                                              /*!< EADC_T::AD1TRGEN2: EPWM14CEN Position     */
#define EADC_AD1TRGEN2_EPWM14CEN_Msk     (0x1ul << EADC_AD1TRGEN2_EPWM14CEN_Pos)           /*!< EADC_T::AD1TRGEN2: EPWM14CEN Mask         */

#define EADC_AD1TRGEN2_PWM00REN_Pos      (24)                                              /*!< EADC_T::AD1TRGEN2: PWM00REN Position      */
#define EADC_AD1TRGEN2_PWM00REN_Msk      (0x1ul << EADC_AD1TRGEN2_PWM00REN_Pos)            /*!< EADC_T::AD1TRGEN2: PWM00REN Mask          */

#define EADC_AD1TRGEN2_PWM00FEN_Pos      (25)                                              /*!< EADC_T::AD1TRGEN2: PWM00FEN Position      */
#define EADC_AD1TRGEN2_PWM00FEN_Msk      (0x1ul << EADC_AD1TRGEN2_PWM00FEN_Pos)            /*!< EADC_T::AD1TRGEN2: PWM00FEN Mask          */

#define EADC_AD1TRGEN2_PWM00PEN_Pos      (26)                                              /*!< EADC_T::AD1TRGEN2: PWM00PEN Position      */
#define EADC_AD1TRGEN2_PWM00PEN_Msk      (0x1ul << EADC_AD1TRGEN2_PWM00PEN_Pos)            /*!< EADC_T::AD1TRGEN2: PWM00PEN Mask          */

#define EADC_AD1TRGEN2_PWM00CEN_Pos      (27)                                              /*!< EADC_T::AD1TRGEN2: PWM00CEN Position      */
#define EADC_AD1TRGEN2_PWM00CEN_Msk      (0x1ul << EADC_AD1TRGEN2_PWM00CEN_Pos)            /*!< EADC_T::AD1TRGEN2: PWM00CEN Mask          */

#define EADC_AD1TRGEN2_PWM01REN_Pos      (28)                                              /*!< EADC_T::AD1TRGEN2: PWM01REN Position      */
#define EADC_AD1TRGEN2_PWM01REN_Msk      (0x1ul << EADC_AD1TRGEN2_PWM01REN_Pos)            /*!< EADC_T::AD1TRGEN2: PWM01REN Mask          */

#define EADC_AD1TRGEN2_PWM01FEN_Pos      (29)                                              /*!< EADC_T::AD1TRGEN2: PWM01FEN Position      */
#define EADC_AD1TRGEN2_PWM01FEN_Msk      (0x1ul << EADC_AD1TRGEN2_PWM01FEN_Pos)            /*!< EADC_T::AD1TRGEN2: PWM01FEN Mask          */

#define EADC_AD1TRGEN2_PWM01PEN_Pos      (30)                                              /*!< EADC_T::AD1TRGEN2: PWM01PEN Position      */
#define EADC_AD1TRGEN2_PWM01PEN_Msk      (0x1ul << EADC_AD1TRGEN2_PWM01PEN_Pos)            /*!< EADC_T::AD1TRGEN2: PWM01PEN Mask          */

#define EADC_AD1TRGEN2_PWM01CEN_Pos      (31)                                              /*!< EADC_T::AD1TRGEN2: PWM01CEN Position      */
#define EADC_AD1TRGEN2_PWM01CEN_Msk      (0x1ul << EADC_AD1TRGEN2_PWM01CEN_Pos)            /*!< EADC_T::AD1TRGEN2: PWM01CEN Mask          */

#define EADC_AD1TRGEN3_EPWM00REN_Pos     (0)                                               /*!< EADC_T::AD1TRGEN3: EPWM00REN Position     */
#define EADC_AD1TRGEN3_EPWM00REN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM00REN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM00REN Mask         */

#define EADC_AD1TRGEN3_EPWM00FEN_Pos     (1)                                               /*!< EADC_T::AD1TRGEN3: EPWM00FEN Position     */
#define EADC_AD1TRGEN3_EPWM00FEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM00FEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM00FEN Mask         */

#define EADC_AD1TRGEN3_EPWM00PEN_Pos     (2)                                               /*!< EADC_T::AD1TRGEN3: EPWM00PEN Position     */
#define EADC_AD1TRGEN3_EPWM00PEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM00PEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM00PEN Mask         */

#define EADC_AD1TRGEN3_EPWM00CEN_Pos     (3)                                               /*!< EADC_T::AD1TRGEN3: EPWM00CEN Position     */
#define EADC_AD1TRGEN3_EPWM00CEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM00CEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM00CEN Mask         */

#define EADC_AD1TRGEN3_EPWM02REN_Pos     (4)                                               /*!< EADC_T::AD1TRGEN3: EPWM02REN Position     */
#define EADC_AD1TRGEN3_EPWM02REN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM02REN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM02REN Mask         */

#define EADC_AD1TRGEN3_EPWM02FEN_Pos     (5)                                               /*!< EADC_T::AD1TRGEN3: EPWM02FEN Position     */
#define EADC_AD1TRGEN3_EPWM02FEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM02FEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM02FEN Mask         */

#define EADC_AD1TRGEN3_EPWM02PEN_Pos     (6)                                               /*!< EADC_T::AD1TRGEN3: EPWM02PEN Position     */
#define EADC_AD1TRGEN3_EPWM02PEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM02PEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM02PEN Mask         */

#define EADC_AD1TRGEN3_EPWM02CEN_Pos     (7)                                               /*!< EADC_T::AD1TRGEN3: EPWM02CEN Position     */
#define EADC_AD1TRGEN3_EPWM02CEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM02CEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM02CEN Mask         */

#define EADC_AD1TRGEN3_EPWM04REN_Pos     (8)                                               /*!< EADC_T::AD1TRGEN3: EPWM04REN Position     */
#define EADC_AD1TRGEN3_EPWM04REN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM04REN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM04REN Mask         */

#define EADC_AD1TRGEN3_EPWM04FEN_Pos     (9)                                               /*!< EADC_T::AD1TRGEN3: EPWM04FEN Position     */
#define EADC_AD1TRGEN3_EPWM04FEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM04FEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM04FEN Mask         */

#define EADC_AD1TRGEN3_EPWM04PEN_Pos     (10)                                              /*!< EADC_T::AD1TRGEN3: EPWM04PEN Position     */
#define EADC_AD1TRGEN3_EPWM04PEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM04PEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM04PEN Mask         */

#define EADC_AD1TRGEN3_EPWM04CEN_Pos     (11)                                              /*!< EADC_T::AD1TRGEN3: EPWM04CEN Position     */
#define EADC_AD1TRGEN3_EPWM04CEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM04CEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM04CEN Mask         */

#define EADC_AD1TRGEN3_EPWM10REN_Pos     (12)                                              /*!< EADC_T::AD1TRGEN3: EPWM10REN Position     */
#define EADC_AD1TRGEN3_EPWM10REN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM10REN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM10REN Mask         */

#define EADC_AD1TRGEN3_EPWM10FEN_Pos     (13)                                              /*!< EADC_T::AD1TRGEN3: EPWM10FEN Position     */
#define EADC_AD1TRGEN3_EPWM10FEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM10FEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM10FEN Mask         */

#define EADC_AD1TRGEN3_EPWM10PEN_Pos     (14)                                              /*!< EADC_T::AD1TRGEN3: EPWM10PEN Position     */
#define EADC_AD1TRGEN3_EPWM10PEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM10PEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM10PEN Mask         */

#define EADC_AD1TRGEN3_EPWM10CEN_Pos     (15)                                              /*!< EADC_T::AD1TRGEN3: EPWM10CEN Position     */
#define EADC_AD1TRGEN3_EPWM10CEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM10CEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM10CEN Mask         */

#define EADC_AD1TRGEN3_EPWM12REN_Pos     (16)                                              /*!< EADC_T::AD1TRGEN3: EPWM12REN Position     */
#define EADC_AD1TRGEN3_EPWM12REN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM12REN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM12REN Mask         */

#define EADC_AD1TRGEN3_EPWM120FEN_Pos    (17)                                              /*!< EADC_T::AD1TRGEN3: EPWM120FEN Position    */
#define EADC_AD1TRGEN3_EPWM120FEN_Msk    (0x1ul << EADC_AD1TRGEN3_EPWM120FEN_Pos)          /*!< EADC_T::AD1TRGEN3: EPWM120FEN Mask        */

#define EADC_AD1TRGEN3_EPWM12PEN_Pos     (18)                                              /*!< EADC_T::AD1TRGEN3: EPWM12PEN Position     */
#define EADC_AD1TRGEN3_EPWM12PEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM12PEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM12PEN Mask         */

#define EADC_AD1TRGEN3_EPWM12CEN_Pos     (19)                                              /*!< EADC_T::AD1TRGEN3: EPWM12CEN Position     */
#define EADC_AD1TRGEN3_EPWM12CEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM12CEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM12CEN Mask         */

#define EADC_AD1TRGEN3_EPWM14REN_Pos     (20)                                              /*!< EADC_T::AD1TRGEN3: EPWM14REN Position     */
#define EADC_AD1TRGEN3_EPWM14REN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM14REN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM14REN Mask         */

#define EADC_AD1TRGEN3_EPWM14FEN_Pos     (21)                                              /*!< EADC_T::AD1TRGEN3: EPWM14FEN Position     */
#define EADC_AD1TRGEN3_EPWM14FEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM14FEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM14FEN Mask         */

#define EADC_AD1TRGEN3_EPWM14PEN_Pos     (22)                                              /*!< EADC_T::AD1TRGEN3: EPWM14PEN Position     */
#define EADC_AD1TRGEN3_EPWM14PEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM14PEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM14PEN Mask         */

#define EADC_AD1TRGEN3_EPWM14CEN_Pos     (23)                                              /*!< EADC_T::AD1TRGEN3: EPWM14CEN Position     */
#define EADC_AD1TRGEN3_EPWM14CEN_Msk     (0x1ul << EADC_AD1TRGEN3_EPWM14CEN_Pos)           /*!< EADC_T::AD1TRGEN3: EPWM14CEN Mask         */

#define EADC_AD1TRGEN3_PWM00REN_Pos      (24)                                              /*!< EADC_T::AD1TRGEN3: PWM00REN Position      */
#define EADC_AD1TRGEN3_PWM00REN_Msk      (0x1ul << EADC_AD1TRGEN3_PWM00REN_Pos)            /*!< EADC_T::AD1TRGEN3: PWM00REN Mask          */

#define EADC_AD1TRGEN3_PWM00FEN_Pos      (25)                                              /*!< EADC_T::AD1TRGEN3: PWM00FEN Position      */
#define EADC_AD1TRGEN3_PWM00FEN_Msk      (0x1ul << EADC_AD1TRGEN3_PWM00FEN_Pos)            /*!< EADC_T::AD1TRGEN3: PWM00FEN Mask          */

#define EADC_AD1TRGEN3_PWM00PEN_Pos      (26)                                              /*!< EADC_T::AD1TRGEN3: PWM00PEN Position      */
#define EADC_AD1TRGEN3_PWM00PEN_Msk      (0x1ul << EADC_AD1TRGEN3_PWM00PEN_Pos)            /*!< EADC_T::AD1TRGEN3: PWM00PEN Mask          */

#define EADC_AD1TRGEN3_PWM00CEN_Pos      (27)                                              /*!< EADC_T::AD1TRGEN3: PWM00CEN Position      */
#define EADC_AD1TRGEN3_PWM00CEN_Msk      (0x1ul << EADC_AD1TRGEN3_PWM00CEN_Pos)            /*!< EADC_T::AD1TRGEN3: PWM00CEN Mask          */

#define EADC_AD1TRGEN3_PWM01REN_Pos      (28)                                              /*!< EADC_T::AD1TRGEN3: PWM01REN Position      */
#define EADC_AD1TRGEN3_PWM01REN_Msk      (0x1ul << EADC_AD1TRGEN3_PWM01REN_Pos)            /*!< EADC_T::AD1TRGEN3: PWM01REN Mask          */

#define EADC_AD1TRGEN3_PWM01FEN_Pos      (29)                                              /*!< EADC_T::AD1TRGEN3: PWM01FEN Position      */
#define EADC_AD1TRGEN3_PWM01FEN_Msk      (0x1ul << EADC_AD1TRGEN3_PWM01FEN_Pos)            /*!< EADC_T::AD1TRGEN3: PWM01FEN Mask          */

#define EADC_AD1TRGEN3_PWM01PEN_Pos      (30)                                              /*!< EADC_T::AD1TRGEN3: PWM01PEN Position      */
#define EADC_AD1TRGEN3_PWM01PEN_Msk      (0x1ul << EADC_AD1TRGEN3_PWM01PEN_Pos)            /*!< EADC_T::AD1TRGEN3: PWM01PEN Mask          */

#define EADC_AD1TRGEN3_PWM01CEN_Pos      (31)                                              /*!< EADC_T::AD1TRGEN3: PWM01CEN Position      */
#define EADC_AD1TRGEN3_PWM01CEN_Msk      (0x1ul << EADC_AD1TRGEN3_PWM01CEN_Pos)            /*!< EADC_T::AD1TRGEN3: PWM01CEN Mask          */

/**@}*/ /* EADC_CONST */
/**@}*/ /* end of EADC register group */


/*---------------------- External Bus Interface Controller -------------------------*/
/**
    @addtogroup EBI External Bus Interface Controller(EBI)
    Memory Mapped Structure for EBI Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  External Bus Interface General Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[8:10]  |MCLKDIV   |External Output Clock Divider
     * |        |          |The frequency of EBI output clock is controlled by MCLKDIV as below:
     * |        |          |000 = HCLK/1.
     * |        |          |001 = HCLK/2.
     * |        |          |010 = HCLK/4.
     * |        |          |011 = HCLK/8.
     * |        |          |100 = HCLK/16.
     * |        |          |101 = HCLK/32.
     * |        |          |11x = Default.
     * |        |          |Note: Default value of output clock is HCLK/1
     * |[24:27] |CRYPTOEN  |Encrypt/Decrypt Function Enable Control (For 4 Individual Chip Select)
     * |        |          |0 = Encrypt/Decrypt function Disabled.
     * |        |          |1 = Encrypt/Decrypt function Enabled.
     * |[28:31] |CSPOLINV  |Reverse Chip Select
     * |        |          |The original design Chip Select is active low nCS.
     * |        |          |"Chip Select Active High" can be specified by customers-Bit[28+n] is for nCS[n], where n=0~3.
     * |        |          |0 = nCS (chip select active low).
     * |        |          |1 = CS (chip select active high).
    */
    __IO uint32_t CTL;

    /**
     * TCTL
     * ===================================================================================================
     * Offset: 0x04 - 0x10  External Bus Interface Bank0~3 Timing Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |TALE      |Bank Expand Time Of ALE
     * |        |          |The ALE width (tALE) to latch the address can be controlled by TALE.
     * |        |          |tALE = (TALE+1)*MCLK.
     * |[3:7]   |TACC      |EBI Bank Data Access Time
     * |        |          |TACC define data access time (tACC).
     * |        |          |tACC = (TACC +1) * MCLK.
     * |[8:10]  |TAHD      |EBI Bank Data Access Hold Time
     * |        |          |TAHD define data access hold time (tAHD).
     * |        |          |tAHD = (TAHD +1) * MCLK.
     * |[12:15] |W2X       |Bank Idle State Cycle After Write
     * |        |          |When write action is finish, idle state is inserted and nCS[0] return to high if W2X is not zero.
     * |        |          |Idle state cycle = (W2X*MCLK).
     * |        |          |0 = reserved.
     * |[16:19] |R2W       |Bank Idle State Cycle Between Read-Write
     * |        |          |When read action is finish and next action is going to write, idle state is inserted and nCS[0] return to high if R2W is not zero.
     * |        |          |Idle state cycle = (R2W*MCLK).
     * |        |          |0 = reserved.
     * |[24:27] |R2R       |Bank Idle State Cycle Between Read-Read
     * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS[0] return to high if R2R is not zero.
     * |        |          |Idle state cycle = (R2R*MCLK).
     * |        |          |0 = reserved.
     * |[28]    |CSEN      |EBI Bank Enable Control
     * |        |          |This bit is the functional enable bit for EBI.
     * |        |          |0 = EBI function Disabled.
     * |        |          |1 = EBI function Enabled.
     * |[29]    |DW16      |EBI Bank Data Width 16-Bit
     * |        |          |This bit defines if the data bus is 8-bit or 16-bit.
     * |        |          |0 = EBI data width is 8-bit.
     * |        |          |1 = EBI data width is 16-bit.
     * |[30]    |SEPEN     |EBI Bank Address/Data Bus Separating Enable Control
     * |        |          |0 = Address/Data Bus Separating Disabled.
     * |        |          |1 = Address/Data Bus Separating Enabled.
    */
    __IO uint32_t TCTL[4];

    /**
     * KEY0
     * ===================================================================================================
     * Offset: 0x14  External Bus Interface Crypto Key Word 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY0      |Crypto Key Word 0 (key[31:0]).
    */
    __IO uint32_t KEY0;

    /**
     * KEY1
     * ===================================================================================================
     * Offset: 0x18  External Bus Interface Crypto Key Word 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |Crypto Key Word 1 (key[63:32]).
    */
    __IO uint32_t KEY1;

    /**
     * KEY2
     * ===================================================================================================
     * Offset: 0x1C  External Bus Interface Crypto Key Word 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |Crypto Key Word 2 (key[95:64]).
    */
    __IO uint32_t KEY2;

    /**
     * KEY3
     * ===================================================================================================
     * Offset: 0x20  External Bus Interface Crypto Key Word 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |KEY       |Crypto Key Word 3 (key[127:96]).
    */
    __IO uint32_t KEY3;

} EBI_T;

/**
    @addtogroup EBI_CONST EBI Bit Field Definition
    Constant Definitions for EBI Controller
@{ */

#define EBI_CTL_MCLKDIV_Pos              (8)                                               /*!< EBI_T::CTL: MCLKDIV Position              */
#define EBI_CTL_MCLKDIV_Msk              (0x7ul << EBI_CTL_MCLKDIV_Pos)                    /*!< EBI_T::CTL: MCLKDIV Mask                  */

#define EBI_CTL_CRYPTOEN_Pos             (24)                                              /*!< EBI_T::CTL: CRYPTOEN Position             */
#define EBI_CTL_CRYPTOEN_Msk             (0xful << EBI_CTL_CRYPTOEN_Pos)                   /*!< EBI_T::CTL: CRYPTOEN Mask                 */

#define EBI_CTL_CSPOLINV_Pos             (28)                                              /*!< EBI_T::CTL: CSPOLINV Position             */
#define EBI_CTL_CSPOLINV_Msk             (0xful << EBI_CTL_CSPOLINV_Pos)                   /*!< EBI_T::CTL: CSPOLINV Mask                 */

#define EBI_TCTL_TALE_Pos                (0)                                               /*!< EBI_T::TCTL: TALE Position                */
#define EBI_TCTL_TALE_Msk                (0x7ul << EBI_TCTL_TALE_Pos)                      /*!< EBI_T::TCTL: TALE Mask                    */

#define EBI_TCTL_TACC_Pos                (3)                                               /*!< EBI_T::TCTL: TACC Position                */
#define EBI_TCTL_TACC_Msk                (0x1ful << EBI_TCTL_TACC_Pos)                     /*!< EBI_T::TCTL: TACC Mask                    */

#define EBI_TCTL_TAHD_Pos                (8)                                               /*!< EBI_T::TCTL: TAHD Position                */
#define EBI_TCTL_TAHD_Msk                (0x7ul << EBI_TCTL_TAHD_Pos)                      /*!< EBI_T::TCTL: TAHD Mask                    */

#define EBI_TCTL_W2X_Pos                 (12)                                              /*!< EBI_T::TCTL: W2X Position                 */
#define EBI_TCTL_W2X_Msk                 (0xful << EBI_TCTL_W2X_Pos)                       /*!< EBI_T::TCTL: W2X Mask                     */

#define EBI_TCTL_R2W_Pos                 (16)                                              /*!< EBI_T::TCTL: R2W Position                 */
#define EBI_TCTL_R2W_Msk                 (0xful << EBI_TCTL_R2W_Pos)                       /*!< EBI_T::TCTL: R2W Mask                     */

#define EBI_TCTL_R2R_Pos                 (24)                                              /*!< EBI_T::TCTL: R2R Position                 */
#define EBI_TCTL_R2R_Msk                 (0xful << EBI_TCTL_R2R_Pos)                       /*!< EBI_T::TCTL: R2R Mask                     */

#define EBI_TCTL_CSEN_Pos                (28)                                              /*!< EBI_T::TCTL: CSEN Position                */
#define EBI_TCTL_CSEN_Msk                (0x1ul << EBI_TCTL_CSEN_Pos)                      /*!< EBI_T::TCTL: CSEN Mask                    */

#define EBI_TCTL_DW16_Pos                (29)                                              /*!< EBI_T::TCTL: DW16 Position                */
#define EBI_TCTL_DW16_Msk                (0x1ul << EBI_TCTL_DW16_Pos)                      /*!< EBI_T::TCTL: DW16 Mask                    */

#define EBI_TCTL_SEPEN_Pos               (30)                                              /*!< EBI_T::TCTL: SEPEN Position               */
#define EBI_TCTL_SEPEN_Msk               (0x1ul << EBI_TCTL_SEPEN_Pos)                     /*!< EBI_T::TCTL: SEPEN Mask                   */

#define EBI_KEY0_KEY_Pos                 (0)                                               /*!< EBI_T::KEY0: KEY Position                 */
#define EBI_KEY0_KEY_Msk                 (0xfffffffful << EBI_KEY0_KEY_Pos)                /*!< EBI_T::KEY0: KEY Mask                     */

#define EBI_KEY1_KEY_Pos                 (0)                                               /*!< EBI_T::KEY1: KEY Position                 */
#define EBI_KEY1_KEY_Msk                 (0xfffffffful << EBI_KEY1_KEY_Pos)                /*!< EBI_T::KEY1: KEY Mask                     */

#define EBI_KEY2_KEY_Pos                 (0)                                               /*!< EBI_T::KEY2: KEY Position                 */
#define EBI_KEY2_KEY_Msk                 (0xfffffffful << EBI_KEY2_KEY_Pos)                /*!< EBI_T::KEY2: KEY Mask                     */

#define EBI_KEY3_KEY_Pos                 (0)                                               /*!< EBI_T::KEY3: KEY Position                 */
#define EBI_KEY3_KEY_Msk                 (0xfffffffful << EBI_KEY3_KEY_Pos)                /*!< EBI_T::KEY3: KEY Mask                     */

/**@}*/ /* EBI_CONST */
/**@}*/ /* end of EBI register group */


/*---------------------- Ethernet MAC Controller -------------------------*/
/**
    @addtogroup EMAC Ethernet MAC Controller(EMAC)
    Memory Mapped Structure for EMAC Controller
@{ */

typedef struct {


    /**
     * CAMCTL
     * ===================================================================================================
     * Offset: 0x00  CAM Comparison Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |AUP       |Accept Unicast Packet
     * |        |          |The AUP controls the unicast packet reception.
     * |        |          |If AUP is enabled, EMAC receives all incoming packet its destination MAC address is a unicast address.
     * |        |          |0 = EMAC receives packet depends on the CAM comparison result.
     * |        |          |1 = EMAC receives all unicast packets.
     * |[1]     |AMP       |Accept Multicast Packet
     * |        |          |The AMP controls the multicast packet reception.
     * |        |          |If AMP is enabled, EMAC receives all incoming packet its destination MAC address is a multicast address.
     * |        |          |0 = EMAC receives packet depends on the CAM comparison result.
     * |        |          |1 = EMAC receives all multicast packets.
     * |[2]     |ABP       |Accept Broadcast Packet
     * |        |          |The ABP controls the broadcast packet reception.
     * |        |          |If ABP is enabled, EMAC receives all incoming packet its destination MAC address is a broadcast address.
     * |        |          |0 = EMAC receives packet depends on the CAM comparison result.
     * |        |          |1 = EMAC receives all broadcast packets.
     * |[3]     |COMPEN    |Complement CAM Comparison Enable
     * |        |          |The COMPEN controls the complement of the CAM comparison result.
     * |        |          |If the CMPEN and COMPEN are both enabled, the incoming packet with specific destination MAC address configured in CAM entry will be dropped.
     * |        |          |And the incoming packet with destination MAC address does not configured in any CAM entry will be received.
     * |        |          |0 = The CAM comparison result does not complement.
     * |        |          |1 = The CAM comparison result complemented.
     * |[4]     |CMPEN     |CAM Compare Enable
     * |        |          |The CMPEN controls the enable of CAM comparison function for destination MAC address recognition.
     * |        |          |If software wants to receive a packet with specific destination MAC address, configures the MAC address into CAM 12~0, then enables that CAM entry and set CMPEN to 1.
     * |        |          |0 = CAM comparison function for destination MAC address recognition disabled.
     * |        |          |1 = CAM comparison function for destination MAC address recognition enabled.
    */
    __IO uint32_t CAMCTL;

    /**
     * CAMEN
     * ===================================================================================================
     * Offset: 0x04  CAM Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CAMxEN    |CAM Entry X Enable Control
     * |        |          |The CAMxEN controls the validation of CAM entry x.
     * |        |          |The CAM entry 13, 14 and 15 are for PAUSE control frame transmission.
     * |        |          |If software wants to transmit a PAUSE control frame out to network, the enable bits of these three CAM entries all must be enabled first.
     * |        |          |0 = CAM entry x Disabled.
     * |        |          |1 = CAM entry x Enabled.
    */
    __IO uint32_t CAMEN;

    /**
     * CAM0M
     * ===================================================================================================
     * Offset: 0x08  CAM0 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM0M;

    /**
     * CAM0L
     * ===================================================================================================
     * Offset: 0x0C  CAM0 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM0L;

    /**
     * CAM1M
     * ===================================================================================================
     * Offset: 0x10  CAM1 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM1M;

    /**
     * CAM1L
     * ===================================================================================================
     * Offset: 0x14  CAM1 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM1L;

    /**
     * CAM2M
     * ===================================================================================================
     * Offset: 0x18  CAM2 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM2M;

    /**
     * CAM2L
     * ===================================================================================================
     * Offset: 0x1C  CAM2 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM2L;

    /**
     * CAM3M
     * ===================================================================================================
     * Offset: 0x20  CAM3 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM3M;

    /**
     * CAM3L
     * ===================================================================================================
     * Offset: 0x24  CAM3 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM3L;

    /**
     * CAM4M
     * ===================================================================================================
     * Offset: 0x28  CAM4 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM4M;

    /**
     * CAM4L
     * ===================================================================================================
     * Offset: 0x2C  CAM4 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM4L;

    /**
     * CAM5M
     * ===================================================================================================
     * Offset: 0x30  CAM5 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM5M;

    /**
     * CAM5L
     * ===================================================================================================
     * Offset: 0x34  CAM5 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM5L;

    /**
     * CAM6M
     * ===================================================================================================
     * Offset: 0x38  CAM6 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM6M;

    /**
     * CAM6L
     * ===================================================================================================
     * Offset: 0x3C  CAM6 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM6L;

    /**
     * CAM7M
     * ===================================================================================================
     * Offset: 0x40  CAM7 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM7M;

    /**
     * CAM7L
     * ===================================================================================================
     * Offset: 0x44  CAM7 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM7L;

    /**
     * CAM8M
     * ===================================================================================================
     * Offset: 0x48  CAM8 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM8M;

    /**
     * CAM8L
     * ===================================================================================================
     * Offset: 0x4C  CAM8 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM8L;

    /**
     * CAM9M
     * ===================================================================================================
     * Offset: 0x50  CAM9 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM9M;

    /**
     * CAM9L
     * ===================================================================================================
     * Offset: 0x54  CAM9 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM9L;

    /**
     * CAM10M
     * ===================================================================================================
     * Offset: 0x58  CAM10 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM10M;

    /**
     * CAM10L
     * ===================================================================================================
     * Offset: 0x5C  CAM10 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM10L;

    /**
     * CAM11M
     * ===================================================================================================
     * Offset: 0x60  CAM11 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM11M;

    /**
     * CAM11L
     * ===================================================================================================
     * Offset: 0x64  CAM11 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM11L;

    /**
     * CAM12M
     * ===================================================================================================
     * Offset: 0x68  CAM12 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM12M;

    /**
     * CAM12L
     * ===================================================================================================
     * Offset: 0x6C  CAM12 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM12L;

    /**
     * CAM13M
     * ===================================================================================================
     * Offset: 0x70  CAM13 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM13M;

    /**
     * CAM13L
     * ===================================================================================================
     * Offset: 0x74  CAM13 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM13L;

    /**
     * CAM14M
     * ===================================================================================================
     * Offset: 0x78  CAM14 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |MACADDR2  |MAC Address Byte 2
     * |[8:15]  |MACADDR3  |MAC Address Byte 3
     * |[16:23] |MACADDR4  |MAC Address Byte 4
     * |[24:31] |MACADDR5  |MAC Address Byte 5
     * |        |          |The CAMxM keeps the bit 47~16 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM14M;

    /**
     * CAM14L
     * ===================================================================================================
     * Offset: 0x7C  CAM14 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:23] |MACADDR0  |MAC Address Byte 0
     * |[24:31] |MACADDR1  |MAC Address Byte 1
     * |        |          |The CAMxL keeps the bit 15~0 of MAC address.
     * |        |          |The x can be the 0~14.
     * |        |          |The register pair {EMAC_CAMxMSB, EMAC_CAMxLSB} represents a CAM entry and keeps a MAC address.
     * |        |          |For example, if the MAC address 00-50-BA-33-BA-44 kept in CAM entry 1, the register EMAC_CAM1M is 0x0050_BA33 and EMAC_CAM1L is 0xBA44_0000.
    */
    __IO uint32_t CAM14L;

    /**
     * CAM15MSB
     * ===================================================================================================
     * Offset: 0x80  CAM15 Most Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |OPCODE    |OP Code Field of PAUSE Control Frame
     * |        |          |In the PAUSE control frame, an op code field defined and is 0x0001.
     * |[16:31] |LENGTH    |LENGTH Field of PAUSE Control Frame
     * |        |          |In the PAUSE control frame, a LENGTH field defined and is 0x8808.
    */
    __IO uint32_t CAM15MSB;

    /**
     * CAM15LSB
     * ===================================================================================================
     * Offset: 0x84  CAM15 Least Significant Word Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[24:31] |OPERAND   |Pause Parameter
     * |        |          |In the PAUSE control frame, an OPERAND field defined and controls how much time the destination Ethernet MAC Controller paused.
     * |        |          |The unit of the OPERAND is a slot time, the 512 bits time.
    */
    __IO uint32_t CAM15LSB;

    /**
     * TXDSA
     * ===================================================================================================
     * Offset: 0x88  Transmit Descriptor Link List Start Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |TXDSA     |Transmit Descriptor Link-List Start Address
     * |        |          |The TXDSA keeps the start address of transmit descriptor link-list.
     * |        |          |If the software enables the bit TXON (EMAC_CTL[8]), the content of TXDSA will be loaded into the current transmit descriptor start address register (EMAC_CTXDSA).
     * |        |          |The TXDSA does not be updated by EMAC.
     * |        |          |During the operation, EMAC will ignore the bits [1:0] of TXDSA.
     * |        |          |This means that each TX descriptor always must locate at word boundary memory address.
    */
    __IO uint32_t TXDSA;

    /**
     * RXDSA
     * ===================================================================================================
     * Offset: 0x8C  Receive Descriptor Link List Start Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |RXDSA     |Receive Descriptor Link-List Start Address
     * |        |          |The RXDSA keeps the start address of receive descriptor link-list.
     * |        |          |If the S/W enables the bit RXON (EMAC_CTL[0]), the content of RXDSA will be loaded into the current receive descriptor start address register (EMAC_CRXDSA).
     * |        |          |The RXDSA does not be updated by EMAC.
     * |        |          |During the operation, EMAC will ignore the bits [1:0] of RXDSA.
     * |        |          |This means that each RX descriptor always must locate at word boundary memory address.
    */
    __IO uint32_t RXDSA;

    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x90  MAC Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RXON      |Frame Reception ON
     * |        |          |The RXON controls the normal packet reception of EMAC.
     * |        |          |If the RXON is set to high, the EMAC starts the packet reception process, including the RX descriptor fetching, packet reception and RX descriptor modification.
     * |        |          |It is necessary to finish EMAC initial sequence before enable RXON.
     * |        |          |Otherwise, the EMAC operation is undefined.
     * |        |          |If the RXON is disabled during EMAC is receiving an incoming packet, the EMAC stops the packet reception process after the current packet reception finished.
     * |        |          |0 = Packet reception process stopped.
     * |        |          |1 = Packet reception process started.
     * |[1]     |ALP       |Accept Long Packet
     * |        |          |The ALP controls the long packet, which packet length is greater than 1518 bytes, reception.
     * |        |          |If the ALP is set to high, the EMAC will accept the long packet.
     * |        |          |Otherwise, the long packet will be dropped.
     * |        |          |0 = Ethernet MAC controller dropped the long packet.
     * |        |          |1 = Ethernet MAC controller received the long packet.
     * |[2]     |ARP       |Accept Runt Packet
     * |        |          |The ARP controls the runt packet, which length is less than 64 bytes, reception.
     * |        |          |If the ARP is set to high, the EMAC will accept the runt packet.
     * |        |          |Otherwise, the runt packet will be dropped.
     * |        |          |0 = Ethernet MAC controller dropped the runt packet.
     * |        |          |1 = Ethernet MAC controller received the runt packet.
     * |[3]     |ACP       |Accept Control Packet
     * |        |          |The ACP controls the control frame reception.
     * |        |          |If the ACP is set to high, the EMAC will accept the control frame.
     * |        |          |Otherwise, the control frame will be dropped.
     * |        |          |It is recommended that S/W only enable ACP while EMAC is operating on full duplex mode.
     * |        |          |0 = Ethernet MAC controller dropped the control frame.
     * |        |          |1 = Ethernet MAC controller received the control frame.
     * |[4]     |AEP       |Accept CRC Error Packet
     * |        |          |The AEP controls the EMAC accepts or drops the CRC error packet.
     * |        |          |If the AEP is set to high, the incoming packet with CRC error will be received by EMAC as a good packet.
     * |        |          |0 = Ethernet MAC controller dropped the CRC error packet.
     * |        |          |1 = Ethernet MAC controller received the CRC error packet.
     * |[5]     |STRIPCRC  |Strip CRC Checksum
     * |        |          |The STRIPCRC controls if the length of incoming packet is calculated with 4 bytes CRC checksum.
     * |        |          |If the STRIPCRC is set to high, 4 bytes CRC checksum is excluded from length calculation of incoming packet.
     * |        |          |0 = The 4 bytes CRC checksum is included in packet length calculation.
     * |        |          |1 = The 4 bytes CRC checksum is excluded in packet length calculation.
     * |[6]     |WOLEN     |Wake On LAN Enable
     * |        |          |The WOLEN high enables the functionality that Ethernet MAC controller checked if the incoming packet is Magic Packet and wakeup system from Power-down mode.
     * |        |          |If incoming packet was a Magic Packet and the system was in Power-down, the Ethernet MAC controller would generate a wakeup event to wake system up from Power-down mode.
     * |        |          |0 = Wake-up by Magic Packet function Disabled.
     * |        |          |1 = Wake-up by Magic Packet function Enabled.
     * |[8]     |TXON      |Frame Transmission ON
     * |        |          |The TXON controls the normal packet transmission of EMAC.
     * |        |          |If the TXON is set to high, the EMAC starts the packet transmission process, including the TX descriptor fetching, packet transmission and TX descriptor modification.
     * |        |          |It is must to finish EMAC initial sequence before enable TXON.
     * |        |          |Otherwise, the EMAC operation is undefined.
     * |        |          |If the TXON is disabled during EMAC is transmitting a packet out, the EMAC stops the packet transmission process after the current packet transmission finished.
     * |        |          |0 = Packet transmission process stopped.
     * |        |          |1 = Packet transmission process started.
     * |[9]     |NODEF     |No Deferral
     * |        |          |The NODEF controls the enable of deferral exceed counter.
     * |        |          |If NODEF is set to high, the deferral exceed counter is disabled.
     * |        |          |The NODEF is only useful while EMAC is operating on half duplex mode.
     * |        |          |0 = The deferral exceed counter Enabled.
     * |        |          |1 = The deferral exceed counter Disabled.
     * |[16]    |SDPZ      |Send PAUSE Frame
     * |        |          |The SDPZ controls the PAUSE control frame transmission.
     * |        |          |If S/W wants to send a PAUSE control frame out, the CAM entry 13, 14 and 15 must be configured first and the corresponding CAM enable bit of CAMEN register also must be set.
     * |        |          |Then, set SDPZ to 1 enables the PAUSE control frame transmission.
     * |        |          |The SDPZ is a self-clear bit.
     * |        |          |This means after the PAUSE control frame transmission has completed, the SDPZ will be cleared automatically.
     * |        |          |It is recommended that only enabling SNDPAUSE while EMAC is operating in Full Duplex mode.
     * |        |          |0 = PAUSE control frame transmission completed.
     * |        |          |1 = PAUSE control frame transmission Enabled.
     * |[17]    |SQECHKEN  |SQE Checking Enable
     * |        |          |The SQECHKEN controls the enable of SQE checking.
     * |        |          |The SQE checking is only available while EMAC is operating on 10M bps and half duplex mode.
     * |        |          |In other words, the SQECHKEN cannot affect EMAC operation, if the EMAC is operating on 100M bps or full duplex mode.
     * |        |          |0 = SQE checking Disabled while EMAC is operating in 10Mbps and Half Duplex mode.
     * |        |          |1 = SQE checking Enabled while EMAC is operating in 10Mbps and Half Duplex mode.
     * |[18]    |FUDUP     |Full Duplex Mode Selection
     * |        |          |The FUDUP controls that if EMAC is operating on full or half duplex mode.
     * |        |          |0 = EMAC operates in half duplex mode.
     * |        |          |1 = EMAC operates in full duplex mode.
     * |[19]    |RMIIRXCTL |RMII RX Control
     * |        |          |The RMIIRXCTL control the receive data sample in RMII mode.
     * |        |          |It's necessary to set this bit high when RMIIEN (EMAC_CTL[ [22]) is high.
     * |        |          |0 = RMII RX control disabled.
     * |        |          |1 = RMII RX control enabled.
     * |[20]    |OPMODE    |Operation Mode Selection
     * |        |          |The OPMODE defines that if the EMAC is operating on 10M or 100M bps mode.
     * |        |          |The RST (EMAC_CTL[24]) would not affect OPMODE value.
     * |        |          |0 = EMAC operates in 10Mbps mode.
     * |        |          |1 = EMAC operates in 100Mbps mode.
     * |[22]    |RMIIEN    |RMII Mode Enable
     * |        |          |This bit controls if Ethernet MAC controller connected with off-chip Ethernet PHY by MII interface or RMII interface.
     * |        |          |The RST (EMAC_CTL[24]) would not affect RMIIEN value.
     * |        |          |0 = Ethernet MAC controller MII mode Enabled.
     * |        |          |1 = Ethernet MAC controller RMII mode Enabled.
     * |[24]    |RST       |Software Reset
     * |        |          |The RST implements a reset function to make the EMAC return default state.
     * |        |          |The RST is a self-clear bit.
     * |        |          |This means after the software reset finished, the RST will be cleared automatically.
     * |        |          |Enable RST can also reset all control and status registers, exclusive of the control bits RMIIEN (EMAC_CTL[22]), LOOPBK (EMAC_CTL[21]) and OPMODE (EMAC_CTL[20]).
     * |        |          |The EMAC re-initial is necessary after the software reset completed.
     * |        |          |0 = Software reset completed.
     * |        |          |1 = Software reset Enabled.
    */
    __IO uint32_t CTL;

    /**
     * MIIMDAT
     * ===================================================================================================
     * Offset: 0x94  MII Management Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |DATA      |MII Management Data
     * |        |          |The DATA is the 16 bits data that will be written into the registers of external PHY for MII Management write command or the data from the registers of external PHY for MII Management read command.
    */
    __IO uint32_t MIIMDAT;

    /**
     * MIIMCTL
     * ===================================================================================================
     * Offset: 0x98  MII Management Control and Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:4]   |PHYREG    |PHY Register Address
     * |        |          |The PHYREG keeps the address to indicate which register of external PHY is the target of the MII management command.
     * |[8:12]  |PHYADDR   |PHY Address
     * |        |          |The PHYADDR keeps the address to differentiate which external PHY is the target of the MII management command.
     * |[16]    |WRITE     |Write Command
     * |        |          |The Write defines the MII management command is a read or write.
     * |        |          |0 = MII management command is a read command.
     * |        |          |1 = MII management command is a write command.
     * |[17]    |BUSY      |Busy Bit
     * |        |          |The BUSY controls the enable of the MII management frame generation.
     * |        |          |If S/W wants to access registers of external PHY, it set BUSY to high and EMAC generates the MII management frame to external PHY through MII Management I/F.
     * |        |          |The BUSY is a self-clear bit.
     * |        |          |This means the BUSY will be cleared automatically after the MII management command finished.
     * |        |          |0 = MII management command generation finished.
     * |        |          |1 = MII management command generation Enabled.
     * |[18]    |PREAMSP   |Preamble Suppress
     * |        |          |The PREAMSP controls the preamble field generation of MII management frame.
     * |        |          |If the PREAMSP is set to high, the preamble field generation of MII management frame is skipped.
     * |        |          |0 = Preamble field generation of MII management frame not skipped.
     * |        |          |1 = Preamble field generation of MII management frame skipped.
     * |[19]    |MDCON     |MDC Clock ON Always
     * |        |          |The MDC controls the MDC clock generation.
     * |        |          |If the MDCON is set to high, the MDC clock actives always.
     * |        |          |Otherwise, the MDC will only active while S/W issues a MII management command.
     * |        |          |0 = MDC clock only actives while S/W issues a MII management command.
     * |        |          |1 = MDC clock actives always.
    */
    __IO uint32_t MIIMCTL;

    /**
     * FIFOCTL
     * ===================================================================================================
     * Offset: 0x9C  FIFO Threshold Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |RXFIFOTH  |RXFIFO Low Threshold
     * |        |          |The RXFIFOTH controls when RXDMA requests internal arbiter for data transfer between RXFIFO and system memory.
     * |        |          |The RXFIFOTH defines not only the high threshold of RXFIFO, but also the low threshold.
     * |        |          |The low threshold is the half of high threshold always.
     * |        |          |During the packet reception, if the RXFIFO reaches the high threshold, the RXDMA starts to transfer frame data from RXFIFO to system memory.
     * |        |          |If the frame data in RXFIFO is less than low threshold, RXDMA stops to transfer the frame data to system memory.
     * |        |          |00 = Depend on the burst length setting.
     * |        |          |If the burst length is 8 words, high threshold is 8 words, too.
     * |        |          |01 = RXFIFO high threshold is 64B and low threshold is 32B.
     * |        |          |10 = RXFIFO high threshold is 128B and low threshold is 64B.
     * |        |          |11 = RXFIFO high threshold is 192B and low threshold is 96B.
     * |[8:9]   |TXFIFOTH  |TXFIFO Low Threshold
     * |        |          |The TXFIFOTH controls when TXDMA requests internal arbiter for data transfer between system memory and TXFIFO.
     * |        |          |The TXFIFOTH defines not only the low threshold of TXFIFO, but also the high threshold.
     * |        |          |The high threshold is the twice of low threshold always.During the packet transmission, if the TXFIFO reaches the high threshold, the TXDMA stops generate request to transfer frame data from system memory to TXFIFO.
     * |        |          |If the frame data in TXFIFO is less than low threshold, TXDMA starts to transfer frame data from system memory to TXFIFO.
     * |        |          |The TXFIFOTH also defines when the TXMAC starts to transmit frame out to network.
     * |        |          |The TXMAC starts to transmit the frame out while the TXFIFO first time reaches the high threshold during the transmission of the frame.
     * |        |          |If the frame data length is less than TXFIFO high threshold, the TXMAC starts to transmit the frame out after the frame data are all inside the TXFIFO.
     * |        |          |00 = Undefined.
     * |        |          |01 = TXFIFO low threshold is 64B and high threshold is 128B.
     * |        |          |10 = TXFIFO low threshold is 80B and high threshold is 160B.
     * |        |          |11 = TXFIFO low threshold is 96B and high threshold is 192B.
     * |[20:21] |BURSTLEN  |DMA Burst Length
     * |        |          |This defines the burst length of AHB bus cycle while EMAC accesses system memory.
     * |        |          |00 = 16 words.
     * |        |          |01 = 16 words.
     * |        |          |10 = 8 words.
     * |        |          |11 = 4 words.
    */
    __IO uint32_t FIFOCTL;

    /**
     * TXST
     * ===================================================================================================
     * Offset: 0xA0  Transmit Start Demand Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |TXST      |Transmit Start Demand
     * |        |          |If the TX descriptor is not available for use of TXDMA after the TXON (EMAC_CTL[8]) is enabled, the FSM (Finite State Machine) of TXDMA enters the Halt state and the frame transmission is halted.
     * |        |          |After the S/W has prepared the new TX descriptor for frame transmission, it must issue a write command to EMAC_TXST register to make TXDMA to leave Halt state and continue the frame transmission.
     * |        |          |The EMAC_TXST is a write only register and read from this register is undefined.
     * |        |          |The write to EMAC_TXST register takes effect only when TXDMA stayed at Halt state.
    */
    __O  uint32_t TXST;

    /**
     * RXST
     * ===================================================================================================
     * Offset: 0xA4  Receive Start Demand Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |RXST      |Receive Start Demand
     * |        |          |If the RX descriptor is not available for use of RXDMA after the RXON (EMAC_CTL[0]) is enabled, the FSM (Finite State Machine) of RXDMA enters the Halt state and the frame reception is halted.
     * |        |          |After the S/W has prepared the new RX descriptor for frame reception, it must issue a write command to EMAC_RXST register to make RXDMA to leave Halt state and continue the frame reception.
     * |        |          |The EMAC_RXST is a write only register and read from this register is undefined.
     * |        |          |The write to EMAC_RXST register take effect only when RXDMA stayed at Halt state.
    */
    __O  uint32_t RXST;

    /**
     * MRFL
     * ===================================================================================================
     * Offset: 0xA8  Maximum Receive Frame Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |MRFL      |Maximum Receive Frame Length
     * |        |          |The MRFL defines the maximum frame length for received frame.
     * |        |          |If the frame length of received frame is greater than MRFL, and bit MFLEIEN (EMAC_INTEN[8]) is also enabled, the bit MFLEIF (EMAC_INTSTS[8]) is set and the RX interrupt is triggered.
     * |        |          |It is recommended that only use MRFL to qualify the length of received frame while S/W wants to receive a frame which length is greater than 1518 bytes.
    */
    __IO uint32_t MRFL;

    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0xAC  MAC Interrupt Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RXIEN     |Receive Interrupt Enable Control
     * |        |          |The RXIEN controls the RX interrupt generation.
     * |        |          |If RXIEN is enabled and RXIF (EMAC_INTSTS[0]) is high, EMAC generates the RX interrupt to CPU.
     * |        |          |If RXIEN is disabled, no RX interrupt is generated to CPU even any status bit EMAC_INTSTS[15:1] is set and the corresponding bit of EMAC_INTEN is enabled.
     * |        |          |In other words, if S/W wants to receive RX interrupt from EMAC, this bit must be enabled.
     * |        |          |And, if S/W doesn't want to receive any RX interrupt from EMAC, disables this bit.
     * |        |          |0 = RXIF (EMAC_INTSTS[0]) is masked and RX interrupt generation Disabled.
     * |        |          |1 = RXIF (EMAC_INTSTS[0]) is not masked and RX interrupt generation Enabled.
     * |[1]     |CRCEIEN   |CRC Error Interrupt Enable Control
     * |        |          |The CRCEIEN controls the CRCEIF (EMAC_INTSTS[1]) interrupt generation.
     * |        |          |If CRCEIF (EMAC_INTSTS[1]) is set, and both CRCEIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If CRCEIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the CRCEIF (EMAC_INTSTS[1]) is set.
     * |        |          |0 = CRCEIF (EMAC_INTSTS[1]) trigger RX interrupt Disabled.
     * |        |          |1 = CRCEIF (EMAC_INTSTS[1]) trigger RX interrupt Enabled.
     * |[2]     |RXOVIEN   |Receive FIFO Overflow Interrupt Enable Control
     * |        |          |The RXOVIEN controls the RXOVIF (EMAC_INTSTS[2]) interrupt generation.
     * |        |          |If RXOVIF (EMAC_INTSTS[2]) is set, and both RXOVIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If RXOVIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the RXOVIF (EMAC_INTSTS[2]) is set.
     * |        |          |0 = RXOVIF (EMAC_INTSTS[2]) trigger RX interrupt Disabled.
     * |        |          |1 = RXOVIF (EMAC_INTSTS[2]) trigger RX interrupt Enabled.
     * |[3]     |LPIEN     |Long Packet Interrupt Enable
     * |        |          |The LPIEN controls the LPIF (EMAC_INTSTS[3]) interrupt generation.
     * |        |          |If LPIF (EMAC_INTSTS[3]) is set, and both LPIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If LPIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the LPIF (EMAC_INTSTS[3]) is set.
     * |        |          |0 = LPIF (EMAC_INTSTS[3]) trigger RX interrupt Disabled.
     * |        |          |1 = LPIF (EMAC_INTSTS[3]) trigger RX interrupt Enabled.
     * |[4]     |RXGDIEN   |Receive Good Interrupt Enable Control
     * |        |          |The RXGDIEN controls the RXGDIF (EMAC_INTSTS[4]) interrupt generation.
     * |        |          |If RXGDIF (EMAC_INTSTS[4]) is set, and both RXGDIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If RXGDIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the RXGDIF (EMAC_INTSTS[4]) is set.
     * |        |          |0 = RXGDIF (EMAC_INTSTS[4]) trigger RX interrupt Disabled.
     * |        |          |1 = RXGDIF (EMAC_INTSTS[4]) trigger RX interrupt Enabled.
     * |[5]     |ALIEIEN   |Alignment Error Interrupt Enable Control
     * |        |          |The ALIEIEN controls the ALIEIF (EMAC_INTSTS[5]) interrupt generation.
     * |        |          |If ALIEIF (EMAC_INTSTS[5]) is set, and both ALIEIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If ALIEIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the ALIEIF (EMAC_INTSTS[5]) is set.
     * |        |          |0 = ALIEIF (EMAC_INTSTS[5]) trigger RX interrupt Disabled.
     * |        |          |1 = ALIEIF (EMAC_INTSTS[5]) trigger RX interrupt Enabled.
     * |[6]     |RPIEN     |Runt Packet Interrupt Enable Control
     * |        |          |The RPIEN controls the RPIF (EMAC_INTSTS[6]) interrupt generation.
     * |        |          |If RPIF (EMAC_INTSTS[6]) is set, and both RPIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If RPIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the RPIF (EMAC_INTSTS[6]) is set.
     * |        |          |0 = RPIF (EMAC_INTSTS[6]) trigger RX interrupt Disabled.
     * |        |          |1 = RPIF (EMAC_INTSTS[6]) trigger RX interrupt Enabled.
     * |[7]     |MPCOVIEN  |Miss Packet Counter Overrun Interrupt Enable
     * |        |          |The MPCOVIEN controls the MPCOVIF (EMAC_INTSTS[7]) interrupt generation.
     * |        |          |If MPCOVIF (EMAC_INTSTS[7]) is set, and both MPCOVIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If MPCOVIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the MPCOVIF (EMAC_INTSTS[7]) is set.
     * |        |          |0 = MPCOVIF (EMAC_INTSTS[7]) trigger RX interrupt Disabled.
     * |        |          |1 = MPCOVIF (EMAC_INTSTS[7]) trigger RX interrupt Enabled.
     * |[8]     |MFLEIEN   |Maximum Frame Length Exceed Interrupt Enable
     * |        |          |The MFLEIEN controls the MFLEIF (EMAC_INTSTS[8]) interrupt generation.
     * |        |          |If MFLEIF (EMAC_INTSTS[8]) is set, and both MFLEIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If MFLEIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the MFLEIF (EMAC_INTSTS[8]) is set.
     * |        |          |0 = MFLEIF (EMAC_INTSTS[8]) trigger RX interrupt Disabled.
     * |        |          |1 = MFLEIF (EMAC_INTSTS[8]) trigger RX interrupt Enabled.
     * |[9]     |DENIEN    |DMA Early Notification Interrupt Enable Control
     * |        |          |The DENIEN controls the DENIF (EMAC_INTSTS[9]) interrupt generation.
     * |        |          |If DENIF (EMAC_INTSTS[9]) is set, and both DENIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If DENIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the DENIF (EMAC_INTSTS[9]) is set.
     * |        |          |0 = TDENIF (EMAC_INTSTS[9]) trigger RX interrupt Disabled.
     * |        |          |1 = TDENIF (EMAC_INTSTS[9]) trigger RX interrupt Enabled.
     * |[10]    |RDUIEN    |Receive Descriptor Unavailable Interrupt Enable Control
     * |        |          |The RDUIEN controls the RDUIF (EMAC_INTSTS[10]) interrupt generation.
     * |        |          |If RDUIF (EMAC_INTSTS[10]) is set, and both RDUIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If RDUIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the RDUIF (EMAC_MIOSTA[10]) register is set.
     * |        |          |0 = RDUIF (EMAC_INTSTS[10]) trigger RX interrupt Disabled.
     * |        |          |1 = RDUIF (EMAC_INTSTS[10]) trigger RX interrupt Enabled.
     * |[11]    |RXBEIEN   |Receive Bus Error Interrupt Enable Control
     * |        |          |The RXBEIEN controls the RXBEIF (EMAC_INTSTS[11]) interrupt generation.
     * |        |          |If RXBEIF (EMAC_INTSTS[11]) is set, and both RXBEIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If RXBEIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the RXBEIF (EMAC_INTSTS[11]) is set.
     * |        |          |0 = RXBEIF (EMAC_INTSTS[11]) trigger RX interrupt Disabled.
     * |        |          |1 = RXBEIF (EMAC_INTSTS[11]) trigger RX interrupt Enabled.
     * |[14]    |CFRIEN    |Control Frame Receive Interrupt Enable Control
     * |        |          |The CFRIEN controls the CFRIF (EMAC_INTSTS[14]) interrupt generation.
     * |        |          |If CFRIF (EMAC_INTSTS[14]) is set, and both CFRIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If CFRIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the CFRIF (EMAC_INTSTS[14]) register is set.
     * |        |          |0 = CFRIF (EMAC_INTSTS[14]) trigger RX interrupt Disabled.
     * |        |          |1 = CFRIF (EMAC_INTSTS[14]) trigger RX interrupt Enabled.
     * |[15]    |WOLIEN    |Wake On LAN Interrupt Enable
     * |        |          |The WOLIEN controls the WOLIF (EMAC_INTSTS[15]) interrupt generation.
     * |        |          |If WOLIF (EMAC_INTSTS[15]) is set, and both WOLIEN and RXIEN (EMAC_INTEN[0]) are enabled, the EMAC generates the RX interrupt to CPU.
     * |        |          |If WOLIEN or RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated to CPU even the WOLIF (EMAC_INTSTS[15]) is set.
     * |        |          |0 = WOLIF (EMAC_INTSTS[15]) trigger RX interrupt Disabled.
     * |        |          |1 = WOLIF (EMAC_INTSTS[15]) trigger RX interrupt Enabled.
     * |[16]    |TXIEN     |Transmit Interrupt Enable Control
     * |        |          |The TXIEN controls the TX interrupt generation.
     * |        |          |If TXIEN is enabled and TXIF (EMAC_INTSTS[16]) is high, EMAC generates the TX interrupt to CPU.
     * |        |          |If TXIEN is disabled, no TX interrupt is generated to CPU even any status bit of EMAC_INTSTS[24:17] set and the corresponding bit of EMAC_INTEN is enabled.
     * |        |          |In other words, if S/W wants to receive TX interrupt from EMAC, this bit must be enabled.
     * |        |          |And, if S/W doesn't want to receive any TX interrupt from EMAC, disables this bit.
     * |        |          |0 = TXIF (EMAC_INTSTS[16]) is masked and TX interrupt generation Disabled.
     * |        |          |1 = TXIF (EMAC_INTSTS[16]) is not masked and TX interrupt generation Enabled.
     * |[17]    |TXUDIEN   |Transmit FIFO Underflow Interrupt Enable Control
     * |        |          |The TXUDIEN controls the TXUDIF (EMAC_INTSTS[17]) interrupt generation.
     * |        |          |If TXUDIF (EMAC_INTSTS[17]) is set, and both TXUDIEN and TXIEN (EMAC_INTEN[16]) are enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If TXUDIEN or TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated to CPU even the TXUDIF (EMAC_INTSTS[17]) is set.
     * |        |          |0 = TXUDIF (EMAC_INTSTS[17]) TX interrupt Disabled.
     * |        |          |1 = TXUDIF (EMAC_INTSTS[17]) TX interrupt Enabled.
     * |[18]    |TXCPIEN   |Transmit Completion Interrupt Enable Control
     * |        |          |The TXCPIEN controls the TXCPIF (EMAC_INTSTS[18]) interrupt generation.
     * |        |          |If TXCPIF (EMAC_INTSTS[18]) is set, and both TXCPIEN and TXIEN (EMAC_INTEN[16]) are enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If TXCPIEN or TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated to CPU even the TXCPIF (EMAC_INTSTS[18]) is set.
     * |        |          |0 = TXCPIF (EMAC_INTSTS[18]) trigger TX interrupt Disabled.
     * |        |          |1 = TXCPIF (EMAC_INTSTS[18]) trigger TX interrupt Enabled.
     * |[19]    |EXDEFIEN  |Defer Exceed Interrupt Enable Control
     * |        |          |The EXDEFIEN controls the EXDEFIF (EMAC_INTSTS[19]) interrupt generation.
     * |        |          |If EXDEFIF (EMAC_INTSTS[19]) is set, and both EXDEFIEN and TXIEN (EMAC_INTEN[16]) are enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If EXDEFIEN or TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated to CPU even the EXDEFIF (EMAC_INTSTS[19]) is set.
     * |        |          |0 = EXDEFIF (EMAC_INTSTS[19]) trigger TX interrupt Disabled.
     * |        |          |1 = EXDEFIF (EMAC_INTSTS[19]) trigger TX interrupt Enabled.
     * |[20]    |NCSIEN    |No Carrier Sense Interrupt Enable Control
     * |        |          |The NCSIEN controls the NCSIF (EMAC_INTSTS[20]) interrupt generation.
     * |        |          |If NCSIF (EMAC_INTSTS[20]) is set, and both NCSIEN and TXIEN (EMAC_INTEN[16]) are enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If NCSIEN or TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated to CPU even the NCSIF (EMAC_INTSTS[20]) is set.
     * |        |          |0 = NCSIF (EMAC_INTSTS[20]) trigger TX interrupt Disabled.
     * |        |          |1 = NCSIF (EMAC_INTSTS[20]) trigger TX interrupt Enabled.
     * |[21]    |TXABTIEN  |Transmit Abort Interrupt Enable Control
     * |        |          |The TXABTIEN controls the TXABTIF (EMAC_INTSTS[21]) interrupt generation.
     * |        |          |If TXABTIF (EMAC_INTSTS[21]) is set, and both TXABTIEN and TXIEN (EMAC_INTEN[16]) are enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If TXABTIEN or TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated to CPU even the TXABTIF (EMAC_INTSTS[21]) is set.
     * |        |          |0 = TXABTIF (EMAC_INTSTS[21]) trigger TX interrupt Disabled.
     * |        |          |1 = TXABTIF (EMAC_INTSTS[21]) trigger TX interrupt Enabled.
     * |[22]    |LCIEN     |Late Collision Interrupt Enable Control
     * |        |          |The LCIEN controls the LCIF (EMAC_INTSTS[22]) interrupt generation.
     * |        |          |If LCIF (EMAC_INTSTS[22]) is set, and both LCIEN and TXIEN (EMAC_INTEN[16]) are enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If LCIEN or TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated to CPU even the LCIF (EMAC_INTSTS[22]) is set.
     * |        |          |0 = LCIF (EMAC_INTSTS[22]) trigger TX interrupt Disabled.
     * |        |          |1 = LCIF (EMAC_INTSTS[22]) trigger TX interrupt Enabled.
     * |[23]    |TDUIEN    |Transmit Descriptor Unavailable Interrupt Enable Control
     * |        |          |The TDUIEN controls the TDUIF (EMAC_INTSTS[23]) interrupt generation.
     * |        |          |If TDUIF (EMAC_INTSTS[23]) is set, and both TDUIEN and TXIEN (EMAC_INTEN[16]) are enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If TDUIEN or TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated to CPU even the TDUIF (EMAC_INTSTS[23]) is set.
     * |        |          |0 = TDUIF (EMAC_INTSTS[23]) trigger TX interrupt Disabled.
     * |        |          |1 = TDUIF (EMAC_INTSTS[23]) trigger TX interrupt Enabled.
     * |[24]    |TXBEIEN   |Transmit Bus Error Interrupt Enable Control
     * |        |          |The TXBEIEN controls the TXBEIF (EMAC_INTSTS[24]) interrupt generation.
     * |        |          |If TXBEIF (EMAC_INTSTS[24]) is set, and both TXBEIEN and TXIEN (EMAC_INTEN[16]) are enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If TXBEIEN or TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated to CPU even the TXBEIF (EMAC_INTSTS[24]) is set.
     * |        |          |0 = TXBEIF (EMAC_INTSTS[24]) trigger TX interrupt Disabled.
     * |        |          |1 = TXBEIF (EMAC_INTSTS[24]) trigger TX interrupt Enabled.
     * |[28]    |TSALMIEN  |Time Stamp Alarm Interrupt Enable Control
     * |        |          |The TSALMIEN controls the TSALMIF (EMAC_INTSTS[28]) interrupt generation.
     * |        |          |If TSALMIF (EMAC_INTSTS[28]) is set, and both TSALMIEN and TXIEN (EMAC_INTEN[16]) enabled, the EMAC generates the TX interrupt to CPU.
     * |        |          |If TSALMIEN or TXIEN (EMAC_INTEN[16]) disabled, no TX interrupt generated to CPU even the TXTSALMIF (EMAC_INTEN[28]) is set.
     * |        |          |0 = TXTSALMIF (EMAC_INTSTS[28]) trigger TX interrupt Disabled.
     * |        |          |1 = TXTSALMIF (EMAC_INTSTS[28]) trigger TX interrupt Enabled.
    */
    __IO uint32_t INTEN;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0xB0  MAC Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RXIF      |Receive Interrupt
     * |        |          |The RXIF indicates the RX interrupt status.
     * |        |          |If RXIF high and its corresponding enable bit, RXIEN (EMAC_INTEN[0]), is also high indicates the EMAC generates RX interrupt to CPU.
     * |        |          |If RXIF is high but RXIEN (EMAC_INTEN[0]) is disabled, no RX interrupt is generated.
     * |        |          |The RXIF is logic OR result of bit logic AND result of EMAC_INTSTS[15:1] and EMAC_INTEN[15:1].
     * |        |          |In other words, if any bit of EMAC_INTSTS[15:1] is high and its corresponding enable bit in EMAC_INTEN[15:1] is also enabled, the RXIF will be high.
     * |        |          |Because the RXIF is a logic OR result, clears EMAC_INTSTS[15:1] makes RXIF be cleared, too.
     * |        |          |0 = No status bit in EMAC_INTSTS[15:1] is set or no enable bit in EMAC_INTEN[15:1] is enabled.
     * |        |          |1 = At least one status in EMAC_INTSTS[15:1] is set and its corresponding enable bit in EMAC_INTEN[15:1] is enabled, too.
     * |[1]     |CRCEIF    |CRC Error Interrupt
     * |        |          |The CRCEIF high indicates the incoming packet incurred the CRC error and the packet is dropped.
     * |        |          |If the AEP (EMAC_CTL[4]) is set, the CRC error packet will be regarded as a good packet and CRCEIF will not be set.
     * |        |          |If the CRCEIF is high and CRCEIEN (EMAC_INTEN[1]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the CRCEIF status.
     * |        |          |0 = The frame does not incur CRC error.
     * |        |          |1 = The frame incurred CRC error.
     * |[2]     |RXOVIF    |Receive FIFO Overflow Interrupt
     * |        |          |The RXOVIF high indicates the RXFIFO overflow occurred during packet reception.
     * |        |          |While the RXFIFO overflow occurred, the EMAC drops the current receiving packer.
     * |        |          |If the RXFIFO overflow occurred often, it is recommended that modify RXFIFO threshold control, the RXFIFOTH of FFTCR register, to higher level.
     * |        |          |If the RXOVIF is high and RXOVIEN (EMAC_INTEN[2]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the RXOVIF status.
     * |        |          |0 = No RXFIFO overflow occurred during packet reception.
     * |        |          |1 = RXFIFO overflow occurred during packet reception.
     * |[3]     |LPIF      |Long Packet Interrupt Flag
     * |        |          |The LPIF high indicates the length of the incoming packet is greater than 1518 bytes and the incoming packet is dropped.
     * |        |          |If the ALP (EMAC_CTL[1]) is set, the long packet will be regarded as a good packet and LPIF will not be set.
     * |        |          |If the LPIF is high and LPIEN (EMAC_INTEN[3]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the LPIF status.
     * |        |          |0 = The incoming frame is not a long frame or S/W wants to receive a long frame.
     * |        |          |1 = The incoming frame is a long frame and dropped.
     * |[4]     |RXGDIF    |Receive Good Interrupt
     * |        |          |The RXGDIF high indicates the frame reception has completed.
     * |        |          |If the RXGDIF is high and RXGDIEN (EAMC_MIEN[4]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the RXGDIF status.
     * |        |          |0 = The frame reception has not complete yet.
     * |        |          |1 = The frame reception has completed.
     * |[5]     |ALIEIF    |Alignment Error Interrupt
     * |        |          |The ALIEIF high indicates the length of the incoming frame is not a multiple of byte.
     * |        |          |If the ALIEIF is high and ALIEIEN (EMAC_INTEN[5]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the ALIEIF status.
     * |        |          |0 = The frame length is a multiple of byte.
     * |        |          |1 = The frame length is not a multiple of byte.
     * |[6]     |RPIF      |Runt Packet Interrupt
     * |        |          |The RPIF high indicates the length of the incoming packet is less than 64 bytes and the packet is dropped.
     * |        |          |If the ARP (EMAC_CTL[2]) is set, the short packet is regarded as a good packet and RPIF will not be set.
     * |        |          |If the RPIF is high and RPIEN (EMAC_INTEN[6]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the RPIF status.
     * |        |          |0 = The incoming frame is not a short frame or S/W wants to receive a short frame.
     * |        |          |1 = The incoming frame is a short frame and dropped.
     * |[7]     |MPCOVIF   |Missed Packet Counter Overrun Interrupt Flag
     * |        |          |The MPCOVIF high indicates the MPCNT, Missed Packet Count, has overflow.
     * |        |          |If the MPCOVIF is high and MPCOVIEN (EMAC_INTEN[7]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the MPCOVIF status.
     * |        |          |0 = The MPCNT has not rolled over yet.
     * |        |          |1 = The MPCNT has rolled over yet.
     * |[8]     |MFLEIF    |Maximum Frame Length Exceed Interrupt Flag
     * |        |          |The MFLEIF high indicates the length of the incoming packet has exceeded the length limitation configured in DMARFC register and the incoming packet is dropped.
     * |        |          |If the MFLEIF is high and MFLEIEN (EMAC_INTEN[8]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the MFLEIF status.
     * |        |          |0 = The length of the incoming packet does not exceed the length limitation configured in DMARFC.
     * |        |          |1 = The length of the incoming packet has exceeded the length limitation configured in DMARFC.
     * |[9]     |DENIF     |DMA Early Notification Interrupt
     * |        |          |The DENIF high indicates the EMAC has received the LENGTH field of the incoming packet.
     * |        |          |If the DENIF is high and DENIENI (EMAC_INTEN[9]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the DENIF status.
     * |        |          |0 = The LENGTH field of incoming packet has not received yet.
     * |        |          |1 = The LENGTH field of incoming packet has received.
     * |[10]    |RDUIF     |Receive Descriptor Unavailable Interrupt
     * |        |          |The RDUIF high indicates that there is no available RX descriptor for packet reception and RXDMA will stay at Halt state.
     * |        |          |Once, the RXDMA enters the Halt state, S/W must issues a write command to RSDR register to make RXDMA leave Halt state while new RX descriptor is available.
     * |        |          |If the RDUIF is high and RDUIEN (EMAC_INTEN[10]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the RDUIF status.
     * |        |          |0 = RX descriptor is available.
     * |        |          |1 = RX descriptor is unavailable.
     * |[11]    |RXBEIF    |Receive Bus Error Interrupt
     * |        |          |The RXBEIF high indicates the memory controller replies ERROR response while EMAC access system memory through RXDMA during packet reception process.
     * |        |          |Reset EMAC is recommended while RXBEIF status is high.
     * |        |          |If the RXBEIF is high and RXBEIEN (EMAC_INTEN[11]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the RXBEIF status.
     * |        |          |0 = No ERROR response is received.
     * |        |          |1 = ERROR response is received.
     * |[14]    |CFRIF     |Control Frame Receive Interrupt
     * |        |          |The CFRIF high indicates EMAC receives a flow control frame.
     * |        |          |The CFRIF only available while EMAC is operating on full duplex mode.
     * |        |          |If the CFRIF is high and CFRIEN (EMAC_INTEN[14]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the CFRIF status.
     * |        |          |0 = The EMAC does not receive the flow control frame.
     * |        |          |1 = The EMAC receives a flow control frame.
     * |[15]    |WOLIF     |Wake On LAN Interrupt Flag
     * |        |          |The WOLIF high indicates EMAC receives a Magic Packet.
     * |        |          |The CFRIF only available while system is in power down mode and WOLEN is set high.
     * |        |          |If the WOLIF is high and WOLIEN (EMAC_INTEN[15]) is enabled, the RXIF will be high.
     * |        |          |Write 1 to this bit clears the WOLIF status.
     * |        |          |0 = The EMAC does not receive the Magic Packet.
     * |        |          |1 = The EMAC receives a Magic Packet.
     * |[16]    |TXIF      |Transmit Interrupt
     * |        |          |The TXIF indicates the TX interrupt status.
     * |        |          |If TXIF high and its corresponding enable bit, TXIEN (EMAC_INTEN[16]), is also high indicates the EMAC generates TX interrupt to CPU.
     * |        |          |If TXIF is high but TXIEN (EMAC_INTEN[16]) is disabled, no TX interrupt is generated.
     * |        |          |The TXIF is logic OR result of bit logic AND result of EMAC_INTSTS[28:17] and EMAC_INTEN[28:17].
     * |        |          |In other words, if any bit of EMAC_INTSTS[28:17] is high and its corresponding enable bit in EMAC_INTEN[28:17] is also enabled, the TXIF will be high.
     * |        |          |Because the TXIF is a logic OR result, clears EMAC_INTSTS[28:17] makes TXIF be cleared, too.
     * |        |          |0 = No status bit in EMAC_INTSTS[28:17] is set or no enable bit in EMAC_INTEN[28:17] is enabled.
     * |        |          |1 = At least one status in EMAC_INTSTS[28:17] is set and its corresponding enable bit in EMAC_INTEN[28:17] is enabled, too.
     * |[17]    |TXUDIF    |Transmit FIFO Underflow Interrupt
     * |        |          |The TXUDIF high indicates the TXFIFO underflow occurred during packet transmission.
     * |        |          |While the TXFIFO underflow occurred, the EMAC will retransmit the packet automatically without S/W intervention.
     * |        |          |If the TXFIFO underflow occurred often, it is recommended that modify TXFIFO threshold control, the TXFIFOTH of FFTCR register, to higher level.
     * |        |          |If the TXUDIF is high and TXUDIEN (EMAC_INTEN[17]) is enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the TXUDIF status.
     * |        |          |0 = No TXFIFO underflow occurred during packet transmission.
     * |        |          |1 = TXFIFO underflow occurred during packet transmission.
     * |[18]    |TXCPIF    |Transmit Completion Interrupt
     * |        |          |The TXCPIF indicates the packet transmission has completed correctly.
     * |        |          |If the TXCPIF is high and TXCPIEN (EMAC_INTEN[18]) is enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the TXCPIF status.
     * |        |          |0 = The packet transmission not completed.
     * |        |          |1 = The packet transmission has completed.
     * |[19]    |EXDEFIF   |Defer Exceed Interrupt
     * |        |          |The EXDEFIF high indicates the frame waiting for transmission has deferred over 0.32768ms on 100Mbps mode, or 3.2768ms on 10Mbps mode.
     * |        |          |The deferral exceed check will only be done while bit NODEF of MCMDR is disabled, and EMAC is operating on half-duplex mode.
     * |        |          |If the EXDEFIF is high and EXDEFIEN (EMAC_INTEN[19]) is enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the EXDEFIF status.
     * |        |          |0 = Frame waiting for transmission has not deferred over 0.32768ms (100Mbps) or 3.2768ms (10Mbps).
     * |        |          |1 = Frame waiting for transmission has deferred over 0.32768ms (100Mbps) or 3.2768ms (10Mbps).
     * |[20]    |NCSIF     |No Carrier Sense Interrupt
     * |        |          |The NCSIF high indicates the MII I/F signal CRS does not active at the start of or during the packet transmission.
     * |        |          |The NCSIF is only available while EMAC is operating on half-duplex mode.
     * |        |          |If the NCSIF is high and NCSIEN (EMAC_INTEN[20]) is enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the NCSIF status.
     * |        |          |0 = CRS signal actives correctly.
     * |        |          |1 = CRS signal does not active at the start of or during the packet transmission.
     * |[21]    |TXABTIF   |Transmit Abort Interrupt
     * |        |          |The TXABTIF high indicates the packet incurred 16 consecutive collisions during transmission, and then the transmission process for this packet is aborted.
     * |        |          |The transmission abort is only available while EMAC is operating on half-duplex mode.
     * |        |          |If the TXABTIF is high and TXABTIEN (EMAC_INTEN[21]) is enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the TXABTIF status.
     * |        |          |0 = Packet does not incur 16 consecutive collisions during transmission.
     * |        |          |1 = Packet incurred 16 consecutive collisions during transmission.
     * |[22]    |LCIF      |Late Collision Interrupt
     * |        |          |The LCIF high indicates the collision occurred in the outside of 64 bytes collision window.
     * |        |          |This means after the 64 bytes of a frame has been transmitted out to the network, the collision still occurred.
     * |        |          |The late collision check will only be done while EMAC is operating on half-duplex mode.
     * |        |          |If the LCIF is high and LCIEN (EMAC_INTEN[22]) is enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the LCIF status.
     * |        |          |0 = No collision occurred in the outside of 64 bytes collision window.
     * |        |          |1 = Collision occurred in the outside of 64 bytes collision window.
     * |[23]    |TDUIF     |Transmit Descriptor Unavailable Interrupt
     * |        |          |The TDUIF high indicates that there is no available TX descriptor for packet transmission and TXDMA will stay at Halt state.
     * |        |          |Once, the TXDMA enters the Halt state, S/W must issues a write command to TSDR register to make TXDMA leave Halt state while new TX descriptor is available.
     * |        |          |If the TDUIF is high and TDUIEN (EMAC_INTEN[23]) is enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the TDUIF status.
     * |        |          |0 = TX descriptor is available.
     * |        |          |1 = TX descriptor is unavailable.
     * |[24]    |TXBEIF    |Transmit Bus Error Interrupt
     * |        |          |The TXBEIF high indicates the memory controller replies ERROR response while EMAC access system memory through TXDMA during packet transmission process.
     * |        |          |Reset EMAC is recommended while TXBEIF status is high.
     * |        |          |If the TXBEIF is high and TXBEIEN (EMAC_INTEN[24]) is enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the TXBEIF status.
     * |        |          |0 = No ERROR response is received.
     * |        |          |1 = ERROR response is received.
     * |[28]    |TSALMIF   |Time Stamp Alarm Interrupt
     * |        |          |The TSALMIF high indicates the EMAC_TSSEC register value equals to EMAC_ALMSEC register and EMAC_TSSUBSEC register value equals to register EMAC_TSMLSR.
     * |        |          |If TSALMIF is high and TSALMIEN (EMAC_INTEN[28]) enabled, the TXIF will be high.
     * |        |          |Write 1 to this bit clears the TSALMIF status.
     * |        |          |0 = EMAC_TSSEC did not equal EMAC_ALMSEC or EMAC_TSSUBSEC did not equal EMAC_ALMSUBSEC.
     * |        |          |1 = EMAC_TSSEC equals EMAC_ALMSEC and EMAC_TSSUBSEC equals EMAC_ALMSUBSEC.
    */
    __IO uint32_t INTSTS;

    /**
     * GENSTS
     * ===================================================================================================
     * Offset: 0xB4  MAC General Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CFRIF     |Control Frame Received
     * |        |          |The CFRIF high indicates EMAC receives a flow control frame.
     * |        |          |The CFRIF only available while EMAC is operating on full duplex mode.
     * |        |          |0 = The EMAC does not receive the flow control frame.
     * |        |          |1 = The EMAC receives a flow control frame.
     * |[1]     |RXHALT    |Receive Halted
     * |        |          |The RXHALT high indicates the next normal packet reception process will be halted because the bit RXON of MCMDR is disabled be S/W.
     * |        |          |0 = Next normal packet reception process will go on.
     * |        |          |1 = Next normal packet reception process will be halted.
     * |[2]     |RXFFULL   |RXFIFO Full
     * |        |          |The RXFFULL indicates the RXFIFO is full due to four 64-byte packets are kept in RXFIFO and the following incoming packet will be dropped.
     * |        |          |0 = The RXFIFO is not full.
     * |        |          |1 = The RXFIFO is full and the following incoming packet will be dropped.
     * |[4:7]   |COLCNT    |Collision Count
     * |        |          |The COLCNT indicates that how many collisions occurred consecutively during a packet transmission.
     * |        |          |If the packet incurred 16 consecutive collisions during transmission, the COLCNT will be 0 and bit TXABTIF will be set to 1.
     * |[8]     |DEF       |Deferred Transmission
     * |        |          |The DEF high indicates the packet transmission has deferred once.
     * |        |          |The DEF is only available while EMAC is operating on half-duplex mode.
     * |        |          |0 = Packet transmission does not defer.
     * |        |          |1 = Packet transmission has deferred once.
     * |[9]     |TXPAUSED  |Transmission Paused
     * |        |          |The TXPAUSED high indicates the next normal packet transmission process will be paused temporally because EMAC received a PAUSE control frame.
     * |        |          |0 = Next normal packet transmission process will go on.
     * |        |          |1 = Next normal packet transmission process will be paused.
     * |[10]    |SQE       |Signal Quality Error
     * |        |          |The SQE high indicates the SQE error found at end of packet transmission on 10Mbps half-duplex mode.
     * |        |          |The SQE error check will only be done while both bit SQECHKEN (EMAC_CTL[17]) is enabled and EMAC is operating on 10Mbps half-duplex mode.
     * |        |          |0 = No SQE error found at end of packet transmission.
     * |        |          |1 = SQE error found at end of packet transmission.
     * |[11]    |TXHALT    |Transmission Halted
     * |        |          |The TXHALT high indicates the next normal packet transmission process will be halted because the bit TXON (EMAC_CTL[8]) is disabled be S/W.
     * |        |          |0 = Next normal packet transmission process will go on.
     * |        |          |1 = Next normal packet transmission process will be halted.
     * |[12]    |RPSTS     |Remote Pause Status
     * |        |          |The RPSTS indicates that remote pause counter down counting actives.
     * |        |          |After Ethernet MAC controller sent PAUSE frame out successfully, it starts the remote pause counter down counting.
     * |        |          |When this bit high, it's predictable that remote Ethernet MAC controller wouldn't start the packet transmission until the down counting done.
     * |        |          |0 = Remote pause counter down counting done.
     * |        |          |1 = Remote pause counter down counting actives.
    */
    __IO uint32_t GENSTS;

    /**
     * MPCNT
     * ===================================================================================================
     * Offset: 0xB8  Missed Packet Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |MPCNT     |Miss Packet Count
     * |        |          |The MPCNT indicates the number of packets that were dropped due to various types of receive errors.
     * |        |          |The following type of receiving error makes missed packet counter increase:.
     * |        |          |1. Incoming packet is incurred RXFIFO overflow.
     * |        |          |2. Incoming packet is dropped due to RXON is disabled.
     * |        |          |3. Incoming packet is incurred CRC error.
    */
    __IO uint32_t MPCNT;

    /**
     * RPCNT
     * ===================================================================================================
     * Offset: 0xBC  MAC Receive Pause Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RPCNT     |MAC Receive Pause Count
     * |        |          |The RPCNT keeps the OPERAND field of the PAUSE control frame.
     * |        |          |It indicates how many slot time (512 bit time) the TX of EMAC will be paused.
    */
    __I  uint32_t RPCNT;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[2];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * FRSTS
     * ===================================================================================================
     * Offset: 0xC8  DMA Receive Frame Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RXFLT     |Receive Frame LENGTH
     * |        |          |The RXFLT keeps the LENGTH field of each incoming Ethernet packet.
     * |        |          |If the bit DENIEN (EMAC_INTEN[9]) is enabled and the LENGTH field of incoming packet has received, the bit DENIF (EMAC_INTSTS[9]) will be set and trigger interrupt.
     * |        |          |And, the content of LENGTH field will be stored in RXFLT.
    */
    __IO uint32_t FRSTS;

    /**
     * CTXDSA
     * ===================================================================================================
     * Offset: 0xCC  Current Transmit Descriptor Start Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CTXDSA    |Current Transmit Descriptor Start Address
     * |        |          |The CTXDSA keeps the start address of TX descriptor that is used by TXDMA currently.
     * |        |          |The CTXDSA is read only and write to this register has no effect.
    */
    __I  uint32_t CTXDSA;

    /**
     * CTXBSA
     * ===================================================================================================
     * Offset: 0xD0  Current Transmit Buffer Start Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CTXBSA    |Current Transmit Buffer Start Address
     * |        |          |The CTXDSA keeps the start address of TX frame buffer that is used by TXDMA currently.
     * |        |          |The CTXBSA is read only and write to this register has no effect.
    */
    __I  uint32_t CTXBSA;

    /**
     * CRXDSA
     * ===================================================================================================
     * Offset: 0xD4  Current Receive Descriptor Start Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CRXDSA    |Current Receive Descriptor Start Address
     * |        |          |The CRXDSA keeps the start address of RX descriptor that is used by RXDMA currently.
     * |        |          |The CRXDSA is read only and write to this register has no effect.
    */
    __I  uint32_t CRXDSA;

    /**
     * CRXBSA
     * ===================================================================================================
     * Offset: 0xD8  Current Receive Buffer Start Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |CRXBSA    |Current Receive Buffer Start Address
     * |        |          |The CRXBSA keeps the start address of RX frame buffer that is used by RXDMA currently.
     * |        |          |The CRXBSA is read only and write to this register has no effect.
    */
    __I  uint32_t CRXBSA;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[9];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TSCTL
     * ===================================================================================================
     * Offset: 0x100  Time Stamp Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |TSEN      |Time Stamp Function Enable Control
     * |        |          |This bit controls if the IEEE 1588 PTP time stamp function is enabled or not.
     * |        |          |Set this bit high to enable IEEE 1588 PTP time stamp function while set this bit low to disable IEEE 1588 PTP time stamp function.
     * |        |          |0 = I EEE 1588 PTP time stamp function Disabled.
     * |        |          |1 = IEEE 1588 PTP time stamp function Enabled.
     * |[1]     |TSIEN     |Time Stamp Counter Initialization Enable Control
     * |        |          |Set this bit high enables Ethernet MAC controller to load value of register EMAC_UPDSEC and EMAC_UPDSUBSEC to PTP time stamp counter.
     * |        |          |After the load operation finished, Ethernet MAC controller clear this bit to low automatically.
     * |        |          |0 = Time stamp counter initialization done.
     * |        |          |1 = Time stamp counter initialization Enabled.
     * |[2]     |TSMODE    |Time Stamp Fine Update Enable Control
     * |        |          |This bit chooses the time stamp counter update mode.
     * |        |          |0 = Time stamp counter is in coarse update mode.
     * |        |          |1 = Time stamp counter is in fine update mode.
     * |[3]     |TSUPDATE  |Time Stamp Counter Time Update Enable Control
     * |        |          |Set this bit high enables Ethernet MAC controller to add value of register EMAC_UPDSEC and EMAC_UPDSUBSEC to PTP time stamp counter.
     * |        |          |After the add operation finished, Ethernet MAC controller clear this bit to low automatically.
     * |        |          |0 = No action.
     * |        |          |1 = EMAC_UPDSEC updated to EMAC_TSSEC and EMAC_UPDSUBSEC updated to EMAC_TSSUBSEC.
     * |[5]     |TSALMEN   |Time Stamp Alarm Enable Control
     * |        |          |Set this bit high enable Ethernet MAC controller to set TSALMIF (EMAC_INTSTS[28]) high when EMAC_TSSEC equals to EMAC_ALMSEC and EMAC_TSSUBSEC equals to EMAC_ALMSUBSEC.
     * |        |          |0 = Alarm disabled when EMAC_TSSEC equals to EMAC_ALMSEC and EMAC_TSSUBSEC equals to EMAC_ALMSUBSEC.
     * |        |          |1 = Alarm enabled when EMAC_TSSEC equals to EMAC_ALMSEC and EMAC_TSSUBSEC equals to EMAC_ALMSUBSEC.
    */
    __IO uint32_t TSCTL;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TSSEC
     * ===================================================================================================
     * Offset: 0x110  Time Stamp Most Significant Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SEC       |Time Stamp Counter Second
     * |        |          |This register reflects the bit [63:32] value of 64-bit reference timing counter.
     * |        |          |This 32-bit value is used as the second part of time stamp when TSEN (EMAC_TSCTL[0]) is high.
    */
    __I  uint32_t TSSEC;

    /**
     * TSSUBSEC
     * ===================================================================================================
     * Offset: 0x114  Time Stamp Least Significant Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SUBSEC    |Time Stamp Counter Sub-Second
     * |        |          |This register reflects the bit [31:0] value of 64-bit reference timing counter.
     * |        |          |This 32-bit value is used as the sub-second part of time stamp when TSEN (EMAC_TSCTL[0]) is high.
    */
    __I  uint32_t TSSUBSEC;

    /**
     * TSINC
     * ===================================================================================================
     * Offset: 0x118  Time Stamp Increment Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |CNTINC    |Time Stamp Counter Increment
     * |        |          |Time stamp counter increment value.
     * |        |          |If TSEN (EMAC_TSCTL[0]) is high, EMAC adds EMAC_TSSUBSEC with this 8-bit value every time when it wants to increase the EMAC_TSSUBSEC value.
    */
    __IO uint32_t TSINC;

    /**
     * TSADDEND
     * ===================================================================================================
     * Offset: 0x11C  Time Stamp Addend Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ADDEND    |Time Stamp Counter Addend
     * |        |          |This register keeps a 32-bit value for accumulator to enable increment of EMAC_TSSUBSEC.
     * |        |          |If TSEN (EMAC_TSCTL[0]) and TSMODE (EMAC_TSCTL[2]) are both high, EMAC increases accumulator with this 32-bit value in each HCLK.
     * |        |          |Once the accumulator is overflow, it generates a enable to increase EMAC_TSSUBSEC with an 8-bit value kept in register EMAC_TSINC.
    */
    __IO uint32_t TSADDEND;

    /**
     * UPDSEC
     * ===================================================================================================
     * Offset: 0x120  Time Stamp Most Significant Update Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SEC       |Time Stamp Counter Second Update
     * |        |          |When TSIEN (EMAC_TSCTL[1]) is high.
     * |        |          |EMAC loads this 32-bit value to EMAC_TSSEC directly.
     * |        |          |When TSUPDATE (EMAC_TSCTL[3]) is high, EMAC increases EMAC_TSSEC with this 32-bit value.
    */
    __IO uint32_t UPDSEC;

    /**
     * UPDSUBSEC
     * ===================================================================================================
     * Offset: 0x124  Time Stamp Least Significant Update Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SUBSEC    |Time Stamp Counter Sub-Second Update
     * |        |          |When TSIEN (EMAC_TSCTL[1]) is high.
     * |        |          |EMAC loads this 32-bit value to EMAC_TSSUBSEC directly.
     * |        |          |When TSUPDATE (EMAC_TSCTL[3]) is high, EMAC increases EMAC_TSSUBSEC with this 32-bit value.
    */
    __IO uint32_t UPDSUBSEC;

    /**
     * ALMSEC
     * ===================================================================================================
     * Offset: 0x128  Time Stamp Most Significant Alarm Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SEC       |Time Stamp Counter Second Alarm
     * |        |          |Time stamp counter second part alarm value.
     * |        |          |This value is only useful when ALMEN (EMAC_TSCTL[5]) high.
     * |        |          |If ALMEN (EMAC_TSCTL[5]) is high, EMAC_TSSEC equals to EMAC_ALMSEC and EMAC_TSSUBSEC equals to EMAC_ALMSUBSEC, Ethernet MAC controller set TSALMIF (EMAC_INTSTS[28]) high.
    */
    __IO uint32_t ALMSEC;

    /**
     * ALMSUBSEC
     * ===================================================================================================
     * Offset: 0x12C  Time Stamp Least Significant Alarm Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SUBSEC    |Time Stamp Counter Sub-Second Alarm
     * |        |          |Time stamp counter sub-second part alarm value.
     * |        |          |This value is only useful when ALMEN (EMAC_TSCTL[5]) high.
     * |        |          |If ALMEN (EMAC_TSCTL[5]) is high, EMAC_TSSEC equals to EMAC_ALMSEC and EMAC_TSSUBSEC equals to EMAC_ALMSUBSEC, Ethernet MAC controller set TSALMIF (EMAC_INTSTS[28]) high.
    */
    __IO uint32_t ALMSUBSEC;

} EMAC_T;

/**
    @addtogroup EMAC_CONST EMAC Bit Field Definition
    Constant Definitions for EMAC Controller
@{ */

#define EMAC_CAMCTL_AUP_Pos              (0)                                               /*!< EMAC_T::CAMCTL: AUP Position              */
#define EMAC_CAMCTL_AUP_Msk              (0x1ul << EMAC_CAMCTL_AUP_Pos)                    /*!< EMAC_T::CAMCTL: AUP Mask                  */

#define EMAC_CAMCTL_AMP_Pos              (1)                                               /*!< EMAC_T::CAMCTL: AMP Position              */
#define EMAC_CAMCTL_AMP_Msk              (0x1ul << EMAC_CAMCTL_AMP_Pos)                    /*!< EMAC_T::CAMCTL: AMP Mask                  */

#define EMAC_CAMCTL_ABP_Pos              (2)                                               /*!< EMAC_T::CAMCTL: ABP Position              */
#define EMAC_CAMCTL_ABP_Msk              (0x1ul << EMAC_CAMCTL_ABP_Pos)                    /*!< EMAC_T::CAMCTL: ABP Mask                  */

#define EMAC_CAMCTL_COMPEN_Pos           (3)                                               /*!< EMAC_T::CAMCTL: COMPEN Position           */
#define EMAC_CAMCTL_COMPEN_Msk           (0x1ul << EMAC_CAMCTL_COMPEN_Pos)                 /*!< EMAC_T::CAMCTL: COMPEN Mask               */

#define EMAC_CAMCTL_CMPEN_Pos            (4)                                               /*!< EMAC_T::CAMCTL: CMPEN Position            */
#define EMAC_CAMCTL_CMPEN_Msk            (0x1ul << EMAC_CAMCTL_CMPEN_Pos)                  /*!< EMAC_T::CAMCTL: CMPEN Mask                */

#define EMAC_CAMEN_CAMxEN_Pos            (0)                                               /*!< EMAC_T::CAMEN: CAMxEN Position            */
#define EMAC_CAMEN_CAMxEN_Msk            (0x1ul << EMAC_CAMEN_CAMxEN_Pos)                  /*!< EMAC_T::CAMEN: CAMxEN Mask                */

#define EMAC_CAM0M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM0M: MACADDR2 Position          */
#define EMAC_CAM0M_MACADDR2_Msk          (0xfful << EMAC_CAM0M_MACADDR2_Pos)               /*!< EMAC_T::CAM0M: MACADDR2 Mask              */

#define EMAC_CAM0M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM0M: MACADDR3 Position          */
#define EMAC_CAM0M_MACADDR3_Msk          (0xfful << EMAC_CAM0M_MACADDR3_Pos)               /*!< EMAC_T::CAM0M: MACADDR3 Mask              */

#define EMAC_CAM0M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM0M: MACADDR4 Position          */
#define EMAC_CAM0M_MACADDR4_Msk          (0xfful << EMAC_CAM0M_MACADDR4_Pos)               /*!< EMAC_T::CAM0M: MACADDR4 Mask              */

#define EMAC_CAM0M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM0M: MACADDR5 Position          */
#define EMAC_CAM0M_MACADDR5_Msk          (0xfful << EMAC_CAM0M_MACADDR5_Pos)               /*!< EMAC_T::CAM0M: MACADDR5 Mask              */

#define EMAC_CAM0L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM0L: Rserved Position           */
#define EMAC_CAM0L_Rserved_Msk           (0xfffful << EMAC_CAM0L_Rserved_Pos)              /*!< EMAC_T::CAM0L: Rserved Mask               */

#define EMAC_CAM0L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM0L: MACADDR0 Position          */
#define EMAC_CAM0L_MACADDR0_Msk          (0xfful << EMAC_CAM0L_MACADDR0_Pos)               /*!< EMAC_T::CAM0L: MACADDR0 Mask              */

#define EMAC_CAM0L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM0L: MACADDR1 Position          */
#define EMAC_CAM0L_MACADDR1_Msk          (0xfful << EMAC_CAM0L_MACADDR1_Pos)               /*!< EMAC_T::CAM0L: MACADDR1 Mask              */

#define EMAC_CAM1M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM1M: MACADDR2 Position          */
#define EMAC_CAM1M_MACADDR2_Msk          (0xfful << EMAC_CAM1M_MACADDR2_Pos)               /*!< EMAC_T::CAM1M: MACADDR2 Mask              */

#define EMAC_CAM1M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM1M: MACADDR3 Position          */
#define EMAC_CAM1M_MACADDR3_Msk          (0xfful << EMAC_CAM1M_MACADDR3_Pos)               /*!< EMAC_T::CAM1M: MACADDR3 Mask              */

#define EMAC_CAM1M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM1M: MACADDR4 Position          */
#define EMAC_CAM1M_MACADDR4_Msk          (0xfful << EMAC_CAM1M_MACADDR4_Pos)               /*!< EMAC_T::CAM1M: MACADDR4 Mask              */

#define EMAC_CAM1M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM1M: MACADDR5 Position          */
#define EMAC_CAM1M_MACADDR5_Msk          (0xfful << EMAC_CAM1M_MACADDR5_Pos)               /*!< EMAC_T::CAM1M: MACADDR5 Mask              */

#define EMAC_CAM1L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM1L: Rserved Position           */
#define EMAC_CAM1L_Rserved_Msk           (0xfffful << EMAC_CAM1L_Rserved_Pos)              /*!< EMAC_T::CAM1L: Rserved Mask               */

#define EMAC_CAM1L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM1L: MACADDR0 Position          */
#define EMAC_CAM1L_MACADDR0_Msk          (0xfful << EMAC_CAM1L_MACADDR0_Pos)               /*!< EMAC_T::CAM1L: MACADDR0 Mask              */

#define EMAC_CAM1L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM1L: MACADDR1 Position          */
#define EMAC_CAM1L_MACADDR1_Msk          (0xfful << EMAC_CAM1L_MACADDR1_Pos)               /*!< EMAC_T::CAM1L: MACADDR1 Mask              */

#define EMAC_CAM2M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM2M: MACADDR2 Position          */
#define EMAC_CAM2M_MACADDR2_Msk          (0xfful << EMAC_CAM2M_MACADDR2_Pos)               /*!< EMAC_T::CAM2M: MACADDR2 Mask              */

#define EMAC_CAM2M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM2M: MACADDR3 Position          */
#define EMAC_CAM2M_MACADDR3_Msk          (0xfful << EMAC_CAM2M_MACADDR3_Pos)               /*!< EMAC_T::CAM2M: MACADDR3 Mask              */

#define EMAC_CAM2M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM2M: MACADDR4 Position          */
#define EMAC_CAM2M_MACADDR4_Msk          (0xfful << EMAC_CAM2M_MACADDR4_Pos)               /*!< EMAC_T::CAM2M: MACADDR4 Mask              */

#define EMAC_CAM2M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM2M: MACADDR5 Position          */
#define EMAC_CAM2M_MACADDR5_Msk          (0xfful << EMAC_CAM2M_MACADDR5_Pos)               /*!< EMAC_T::CAM2M: MACADDR5 Mask              */

#define EMAC_CAM2L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM2L: Rserved Position           */
#define EMAC_CAM2L_Rserved_Msk           (0xfffful << EMAC_CAM2L_Rserved_Pos)              /*!< EMAC_T::CAM2L: Rserved Mask               */

#define EMAC_CAM2L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM2L: MACADDR0 Position          */
#define EMAC_CAM2L_MACADDR0_Msk          (0xfful << EMAC_CAM2L_MACADDR0_Pos)               /*!< EMAC_T::CAM2L: MACADDR0 Mask              */

#define EMAC_CAM2L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM2L: MACADDR1 Position          */
#define EMAC_CAM2L_MACADDR1_Msk          (0xfful << EMAC_CAM2L_MACADDR1_Pos)               /*!< EMAC_T::CAM2L: MACADDR1 Mask              */

#define EMAC_CAM3M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM3M: MACADDR2 Position          */
#define EMAC_CAM3M_MACADDR2_Msk          (0xfful << EMAC_CAM3M_MACADDR2_Pos)               /*!< EMAC_T::CAM3M: MACADDR2 Mask              */

#define EMAC_CAM3M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM3M: MACADDR3 Position          */
#define EMAC_CAM3M_MACADDR3_Msk          (0xfful << EMAC_CAM3M_MACADDR3_Pos)               /*!< EMAC_T::CAM3M: MACADDR3 Mask              */

#define EMAC_CAM3M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM3M: MACADDR4 Position          */
#define EMAC_CAM3M_MACADDR4_Msk          (0xfful << EMAC_CAM3M_MACADDR4_Pos)               /*!< EMAC_T::CAM3M: MACADDR4 Mask              */

#define EMAC_CAM3M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM3M: MACADDR5 Position          */
#define EMAC_CAM3M_MACADDR5_Msk          (0xfful << EMAC_CAM3M_MACADDR5_Pos)               /*!< EMAC_T::CAM3M: MACADDR5 Mask              */

#define EMAC_CAM3L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM3L: Rserved Position           */
#define EMAC_CAM3L_Rserved_Msk           (0xfffful << EMAC_CAM3L_Rserved_Pos)              /*!< EMAC_T::CAM3L: Rserved Mask               */

#define EMAC_CAM3L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM3L: MACADDR0 Position          */
#define EMAC_CAM3L_MACADDR0_Msk          (0xfful << EMAC_CAM3L_MACADDR0_Pos)               /*!< EMAC_T::CAM3L: MACADDR0 Mask              */

#define EMAC_CAM3L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM3L: MACADDR1 Position          */
#define EMAC_CAM3L_MACADDR1_Msk          (0xfful << EMAC_CAM3L_MACADDR1_Pos)               /*!< EMAC_T::CAM3L: MACADDR1 Mask              */

#define EMAC_CAM4M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM4M: MACADDR2 Position          */
#define EMAC_CAM4M_MACADDR2_Msk          (0xfful << EMAC_CAM4M_MACADDR2_Pos)               /*!< EMAC_T::CAM4M: MACADDR2 Mask              */

#define EMAC_CAM4M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM4M: MACADDR3 Position          */
#define EMAC_CAM4M_MACADDR3_Msk          (0xfful << EMAC_CAM4M_MACADDR3_Pos)               /*!< EMAC_T::CAM4M: MACADDR3 Mask              */

#define EMAC_CAM4M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM4M: MACADDR4 Position          */
#define EMAC_CAM4M_MACADDR4_Msk          (0xfful << EMAC_CAM4M_MACADDR4_Pos)               /*!< EMAC_T::CAM4M: MACADDR4 Mask              */

#define EMAC_CAM4M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM4M: MACADDR5 Position          */
#define EMAC_CAM4M_MACADDR5_Msk          (0xfful << EMAC_CAM4M_MACADDR5_Pos)               /*!< EMAC_T::CAM4M: MACADDR5 Mask              */

#define EMAC_CAM4L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM4L: Rserved Position           */
#define EMAC_CAM4L_Rserved_Msk           (0xfffful << EMAC_CAM4L_Rserved_Pos)              /*!< EMAC_T::CAM4L: Rserved Mask               */

#define EMAC_CAM4L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM4L: MACADDR0 Position          */
#define EMAC_CAM4L_MACADDR0_Msk          (0xfful << EMAC_CAM4L_MACADDR0_Pos)               /*!< EMAC_T::CAM4L: MACADDR0 Mask              */

#define EMAC_CAM4L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM4L: MACADDR1 Position          */
#define EMAC_CAM4L_MACADDR1_Msk          (0xfful << EMAC_CAM4L_MACADDR1_Pos)               /*!< EMAC_T::CAM4L: MACADDR1 Mask              */

#define EMAC_CAM5M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM5M: MACADDR2 Position          */
#define EMAC_CAM5M_MACADDR2_Msk          (0xfful << EMAC_CAM5M_MACADDR2_Pos)               /*!< EMAC_T::CAM5M: MACADDR2 Mask              */

#define EMAC_CAM5M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM5M: MACADDR3 Position          */
#define EMAC_CAM5M_MACADDR3_Msk          (0xfful << EMAC_CAM5M_MACADDR3_Pos)               /*!< EMAC_T::CAM5M: MACADDR3 Mask              */

#define EMAC_CAM5M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM5M: MACADDR4 Position          */
#define EMAC_CAM5M_MACADDR4_Msk          (0xfful << EMAC_CAM5M_MACADDR4_Pos)               /*!< EMAC_T::CAM5M: MACADDR4 Mask              */

#define EMAC_CAM5M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM5M: MACADDR5 Position          */
#define EMAC_CAM5M_MACADDR5_Msk          (0xfful << EMAC_CAM5M_MACADDR5_Pos)               /*!< EMAC_T::CAM5M: MACADDR5 Mask              */

#define EMAC_CAM5L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM5L: Rserved Position           */
#define EMAC_CAM5L_Rserved_Msk           (0xfffful << EMAC_CAM5L_Rserved_Pos)              /*!< EMAC_T::CAM5L: Rserved Mask               */

#define EMAC_CAM5L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM5L: MACADDR0 Position          */
#define EMAC_CAM5L_MACADDR0_Msk          (0xfful << EMAC_CAM5L_MACADDR0_Pos)               /*!< EMAC_T::CAM5L: MACADDR0 Mask              */

#define EMAC_CAM5L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM5L: MACADDR1 Position          */
#define EMAC_CAM5L_MACADDR1_Msk          (0xfful << EMAC_CAM5L_MACADDR1_Pos)               /*!< EMAC_T::CAM5L: MACADDR1 Mask              */

#define EMAC_CAM6M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM6M: MACADDR2 Position          */
#define EMAC_CAM6M_MACADDR2_Msk          (0xfful << EMAC_CAM6M_MACADDR2_Pos)               /*!< EMAC_T::CAM6M: MACADDR2 Mask              */

#define EMAC_CAM6M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM6M: MACADDR3 Position          */
#define EMAC_CAM6M_MACADDR3_Msk          (0xfful << EMAC_CAM6M_MACADDR3_Pos)               /*!< EMAC_T::CAM6M: MACADDR3 Mask              */

#define EMAC_CAM6M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM6M: MACADDR4 Position          */
#define EMAC_CAM6M_MACADDR4_Msk          (0xfful << EMAC_CAM6M_MACADDR4_Pos)               /*!< EMAC_T::CAM6M: MACADDR4 Mask              */

#define EMAC_CAM6M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM6M: MACADDR5 Position          */
#define EMAC_CAM6M_MACADDR5_Msk          (0xfful << EMAC_CAM6M_MACADDR5_Pos)               /*!< EMAC_T::CAM6M: MACADDR5 Mask              */

#define EMAC_CAM6L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM6L: Rserved Position           */
#define EMAC_CAM6L_Rserved_Msk           (0xfffful << EMAC_CAM6L_Rserved_Pos)              /*!< EMAC_T::CAM6L: Rserved Mask               */

#define EMAC_CAM6L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM6L: MACADDR0 Position          */
#define EMAC_CAM6L_MACADDR0_Msk          (0xfful << EMAC_CAM6L_MACADDR0_Pos)               /*!< EMAC_T::CAM6L: MACADDR0 Mask              */

#define EMAC_CAM6L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM6L: MACADDR1 Position          */
#define EMAC_CAM6L_MACADDR1_Msk          (0xfful << EMAC_CAM6L_MACADDR1_Pos)               /*!< EMAC_T::CAM6L: MACADDR1 Mask              */

#define EMAC_CAM7M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM7M: MACADDR2 Position          */
#define EMAC_CAM7M_MACADDR2_Msk          (0xfful << EMAC_CAM7M_MACADDR2_Pos)               /*!< EMAC_T::CAM7M: MACADDR2 Mask              */

#define EMAC_CAM7M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM7M: MACADDR3 Position          */
#define EMAC_CAM7M_MACADDR3_Msk          (0xfful << EMAC_CAM7M_MACADDR3_Pos)               /*!< EMAC_T::CAM7M: MACADDR3 Mask              */

#define EMAC_CAM7M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM7M: MACADDR4 Position          */
#define EMAC_CAM7M_MACADDR4_Msk          (0xfful << EMAC_CAM7M_MACADDR4_Pos)               /*!< EMAC_T::CAM7M: MACADDR4 Mask              */

#define EMAC_CAM7M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM7M: MACADDR5 Position          */
#define EMAC_CAM7M_MACADDR5_Msk          (0xfful << EMAC_CAM7M_MACADDR5_Pos)               /*!< EMAC_T::CAM7M: MACADDR5 Mask              */

#define EMAC_CAM7L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM7L: Rserved Position           */
#define EMAC_CAM7L_Rserved_Msk           (0xfffful << EMAC_CAM7L_Rserved_Pos)              /*!< EMAC_T::CAM7L: Rserved Mask               */

#define EMAC_CAM7L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM7L: MACADDR0 Position          */
#define EMAC_CAM7L_MACADDR0_Msk          (0xfful << EMAC_CAM7L_MACADDR0_Pos)               /*!< EMAC_T::CAM7L: MACADDR0 Mask              */

#define EMAC_CAM7L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM7L: MACADDR1 Position          */
#define EMAC_CAM7L_MACADDR1_Msk          (0xfful << EMAC_CAM7L_MACADDR1_Pos)               /*!< EMAC_T::CAM7L: MACADDR1 Mask              */

#define EMAC_CAM8M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM8M: MACADDR2 Position          */
#define EMAC_CAM8M_MACADDR2_Msk          (0xfful << EMAC_CAM8M_MACADDR2_Pos)               /*!< EMAC_T::CAM8M: MACADDR2 Mask              */

#define EMAC_CAM8M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM8M: MACADDR3 Position          */
#define EMAC_CAM8M_MACADDR3_Msk          (0xfful << EMAC_CAM8M_MACADDR3_Pos)               /*!< EMAC_T::CAM8M: MACADDR3 Mask              */

#define EMAC_CAM8M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM8M: MACADDR4 Position          */
#define EMAC_CAM8M_MACADDR4_Msk          (0xfful << EMAC_CAM8M_MACADDR4_Pos)               /*!< EMAC_T::CAM8M: MACADDR4 Mask              */

#define EMAC_CAM8M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM8M: MACADDR5 Position          */
#define EMAC_CAM8M_MACADDR5_Msk          (0xfful << EMAC_CAM8M_MACADDR5_Pos)               /*!< EMAC_T::CAM8M: MACADDR5 Mask              */

#define EMAC_CAM8L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM8L: Rserved Position           */
#define EMAC_CAM8L_Rserved_Msk           (0xfffful << EMAC_CAM8L_Rserved_Pos)              /*!< EMAC_T::CAM8L: Rserved Mask               */

#define EMAC_CAM8L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM8L: MACADDR0 Position          */
#define EMAC_CAM8L_MACADDR0_Msk          (0xfful << EMAC_CAM8L_MACADDR0_Pos)               /*!< EMAC_T::CAM8L: MACADDR0 Mask              */

#define EMAC_CAM8L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM8L: MACADDR1 Position          */
#define EMAC_CAM8L_MACADDR1_Msk          (0xfful << EMAC_CAM8L_MACADDR1_Pos)               /*!< EMAC_T::CAM8L: MACADDR1 Mask              */

#define EMAC_CAM9M_MACADDR2_Pos          (0)                                               /*!< EMAC_T::CAM9M: MACADDR2 Position          */
#define EMAC_CAM9M_MACADDR2_Msk          (0xfful << EMAC_CAM9M_MACADDR2_Pos)               /*!< EMAC_T::CAM9M: MACADDR2 Mask              */

#define EMAC_CAM9M_MACADDR3_Pos          (8)                                               /*!< EMAC_T::CAM9M: MACADDR3 Position          */
#define EMAC_CAM9M_MACADDR3_Msk          (0xfful << EMAC_CAM9M_MACADDR3_Pos)               /*!< EMAC_T::CAM9M: MACADDR3 Mask              */

#define EMAC_CAM9M_MACADDR4_Pos          (16)                                              /*!< EMAC_T::CAM9M: MACADDR4 Position          */
#define EMAC_CAM9M_MACADDR4_Msk          (0xfful << EMAC_CAM9M_MACADDR4_Pos)               /*!< EMAC_T::CAM9M: MACADDR4 Mask              */

#define EMAC_CAM9M_MACADDR5_Pos          (24)                                              /*!< EMAC_T::CAM9M: MACADDR5 Position          */
#define EMAC_CAM9M_MACADDR5_Msk          (0xfful << EMAC_CAM9M_MACADDR5_Pos)               /*!< EMAC_T::CAM9M: MACADDR5 Mask              */

#define EMAC_CAM9L_Rserved_Pos           (0)                                               /*!< EMAC_T::CAM9L: Rserved Position           */
#define EMAC_CAM9L_Rserved_Msk           (0xfffful << EMAC_CAM9L_Rserved_Pos)              /*!< EMAC_T::CAM9L: Rserved Mask               */

#define EMAC_CAM9L_MACADDR0_Pos          (16)                                              /*!< EMAC_T::CAM9L: MACADDR0 Position          */
#define EMAC_CAM9L_MACADDR0_Msk          (0xfful << EMAC_CAM9L_MACADDR0_Pos)               /*!< EMAC_T::CAM9L: MACADDR0 Mask              */

#define EMAC_CAM9L_MACADDR1_Pos          (24)                                              /*!< EMAC_T::CAM9L: MACADDR1 Position          */
#define EMAC_CAM9L_MACADDR1_Msk          (0xfful << EMAC_CAM9L_MACADDR1_Pos)               /*!< EMAC_T::CAM9L: MACADDR1 Mask              */

#define EMAC_CAM10M_MACADDR2_Pos         (0)                                               /*!< EMAC_T::CAM10M: MACADDR2 Position         */
#define EMAC_CAM10M_MACADDR2_Msk         (0xfful << EMAC_CAM10M_MACADDR2_Pos)              /*!< EMAC_T::CAM10M: MACADDR2 Mask             */

#define EMAC_CAM10M_MACADDR3_Pos         (8)                                               /*!< EMAC_T::CAM10M: MACADDR3 Position         */
#define EMAC_CAM10M_MACADDR3_Msk         (0xfful << EMAC_CAM10M_MACADDR3_Pos)              /*!< EMAC_T::CAM10M: MACADDR3 Mask             */

#define EMAC_CAM10M_MACADDR4_Pos         (16)                                              /*!< EMAC_T::CAM10M: MACADDR4 Position         */
#define EMAC_CAM10M_MACADDR4_Msk         (0xfful << EMAC_CAM10M_MACADDR4_Pos)              /*!< EMAC_T::CAM10M: MACADDR4 Mask             */

#define EMAC_CAM10M_MACADDR5_Pos         (24)                                              /*!< EMAC_T::CAM10M: MACADDR5 Position         */
#define EMAC_CAM10M_MACADDR5_Msk         (0xfful << EMAC_CAM10M_MACADDR5_Pos)              /*!< EMAC_T::CAM10M: MACADDR5 Mask             */

#define EMAC_CAM10L_Rserved_Pos          (0)                                               /*!< EMAC_T::CAM10L: Rserved Position          */
#define EMAC_CAM10L_Rserved_Msk          (0xfffful << EMAC_CAM10L_Rserved_Pos)             /*!< EMAC_T::CAM10L: Rserved Mask              */

#define EMAC_CAM10L_MACADDR0_Pos         (16)                                              /*!< EMAC_T::CAM10L: MACADDR0 Position         */
#define EMAC_CAM10L_MACADDR0_Msk         (0xfful << EMAC_CAM10L_MACADDR0_Pos)              /*!< EMAC_T::CAM10L: MACADDR0 Mask             */

#define EMAC_CAM10L_MACADDR1_Pos         (24)                                              /*!< EMAC_T::CAM10L: MACADDR1 Position         */
#define EMAC_CAM10L_MACADDR1_Msk         (0xfful << EMAC_CAM10L_MACADDR1_Pos)              /*!< EMAC_T::CAM10L: MACADDR1 Mask             */

#define EMAC_CAM11M_MACADDR2_Pos         (0)                                               /*!< EMAC_T::CAM11M: MACADDR2 Position         */
#define EMAC_CAM11M_MACADDR2_Msk         (0xfful << EMAC_CAM11M_MACADDR2_Pos)              /*!< EMAC_T::CAM11M: MACADDR2 Mask             */

#define EMAC_CAM11M_MACADDR3_Pos         (8)                                               /*!< EMAC_T::CAM11M: MACADDR3 Position         */
#define EMAC_CAM11M_MACADDR3_Msk         (0xfful << EMAC_CAM11M_MACADDR3_Pos)              /*!< EMAC_T::CAM11M: MACADDR3 Mask             */

#define EMAC_CAM11M_MACADDR4_Pos         (16)                                              /*!< EMAC_T::CAM11M: MACADDR4 Position         */
#define EMAC_CAM11M_MACADDR4_Msk         (0xfful << EMAC_CAM11M_MACADDR4_Pos)              /*!< EMAC_T::CAM11M: MACADDR4 Mask             */

#define EMAC_CAM11M_MACADDR5_Pos         (24)                                              /*!< EMAC_T::CAM11M: MACADDR5 Position         */
#define EMAC_CAM11M_MACADDR5_Msk         (0xfful << EMAC_CAM11M_MACADDR5_Pos)              /*!< EMAC_T::CAM11M: MACADDR5 Mask             */

#define EMAC_CAM11L_Rserved_Pos          (0)                                               /*!< EMAC_T::CAM11L: Rserved Position          */
#define EMAC_CAM11L_Rserved_Msk          (0xfffful << EMAC_CAM11L_Rserved_Pos)             /*!< EMAC_T::CAM11L: Rserved Mask              */

#define EMAC_CAM11L_MACADDR0_Pos         (16)                                              /*!< EMAC_T::CAM11L: MACADDR0 Position         */
#define EMAC_CAM11L_MACADDR0_Msk         (0xfful << EMAC_CAM11L_MACADDR0_Pos)              /*!< EMAC_T::CAM11L: MACADDR0 Mask             */

#define EMAC_CAM11L_MACADDR1_Pos         (24)                                              /*!< EMAC_T::CAM11L: MACADDR1 Position         */
#define EMAC_CAM11L_MACADDR1_Msk         (0xfful << EMAC_CAM11L_MACADDR1_Pos)              /*!< EMAC_T::CAM11L: MACADDR1 Mask             */

#define EMAC_CAM12M_MACADDR2_Pos         (0)                                               /*!< EMAC_T::CAM12M: MACADDR2 Position         */
#define EMAC_CAM12M_MACADDR2_Msk         (0xfful << EMAC_CAM12M_MACADDR2_Pos)              /*!< EMAC_T::CAM12M: MACADDR2 Mask             */

#define EMAC_CAM12M_MACADDR3_Pos         (8)                                               /*!< EMAC_T::CAM12M: MACADDR3 Position         */
#define EMAC_CAM12M_MACADDR3_Msk         (0xfful << EMAC_CAM12M_MACADDR3_Pos)              /*!< EMAC_T::CAM12M: MACADDR3 Mask             */

#define EMAC_CAM12M_MACADDR4_Pos         (16)                                              /*!< EMAC_T::CAM12M: MACADDR4 Position         */
#define EMAC_CAM12M_MACADDR4_Msk         (0xfful << EMAC_CAM12M_MACADDR4_Pos)              /*!< EMAC_T::CAM12M: MACADDR4 Mask             */

#define EMAC_CAM12M_MACADDR5_Pos         (24)                                              /*!< EMAC_T::CAM12M: MACADDR5 Position         */
#define EMAC_CAM12M_MACADDR5_Msk         (0xfful << EMAC_CAM12M_MACADDR5_Pos)              /*!< EMAC_T::CAM12M: MACADDR5 Mask             */

#define EMAC_CAM12L_Rserved_Pos          (0)                                               /*!< EMAC_T::CAM12L: Rserved Position          */
#define EMAC_CAM12L_Rserved_Msk          (0xfffful << EMAC_CAM12L_Rserved_Pos)             /*!< EMAC_T::CAM12L: Rserved Mask              */

#define EMAC_CAM12L_MACADDR0_Pos         (16)                                              /*!< EMAC_T::CAM12L: MACADDR0 Position         */
#define EMAC_CAM12L_MACADDR0_Msk         (0xfful << EMAC_CAM12L_MACADDR0_Pos)              /*!< EMAC_T::CAM12L: MACADDR0 Mask             */

#define EMAC_CAM12L_MACADDR1_Pos         (24)                                              /*!< EMAC_T::CAM12L: MACADDR1 Position         */
#define EMAC_CAM12L_MACADDR1_Msk         (0xfful << EMAC_CAM12L_MACADDR1_Pos)              /*!< EMAC_T::CAM12L: MACADDR1 Mask             */

#define EMAC_CAM13M_MACADDR2_Pos         (0)                                               /*!< EMAC_T::CAM13M: MACADDR2 Position         */
#define EMAC_CAM13M_MACADDR2_Msk         (0xfful << EMAC_CAM13M_MACADDR2_Pos)              /*!< EMAC_T::CAM13M: MACADDR2 Mask             */

#define EMAC_CAM13M_MACADDR3_Pos         (8)                                               /*!< EMAC_T::CAM13M: MACADDR3 Position         */
#define EMAC_CAM13M_MACADDR3_Msk         (0xfful << EMAC_CAM13M_MACADDR3_Pos)              /*!< EMAC_T::CAM13M: MACADDR3 Mask             */

#define EMAC_CAM13M_MACADDR4_Pos         (16)                                              /*!< EMAC_T::CAM13M: MACADDR4 Position         */
#define EMAC_CAM13M_MACADDR4_Msk         (0xfful << EMAC_CAM13M_MACADDR4_Pos)              /*!< EMAC_T::CAM13M: MACADDR4 Mask             */

#define EMAC_CAM13M_MACADDR5_Pos         (24)                                              /*!< EMAC_T::CAM13M: MACADDR5 Position         */
#define EMAC_CAM13M_MACADDR5_Msk         (0xfful << EMAC_CAM13M_MACADDR5_Pos)              /*!< EMAC_T::CAM13M: MACADDR5 Mask             */

#define EMAC_CAM13L_Rserved_Pos          (0)                                               /*!< EMAC_T::CAM13L: Rserved Position          */
#define EMAC_CAM13L_Rserved_Msk          (0xfffful << EMAC_CAM13L_Rserved_Pos)             /*!< EMAC_T::CAM13L: Rserved Mask              */

#define EMAC_CAM13L_MACADDR0_Pos         (16)                                              /*!< EMAC_T::CAM13L: MACADDR0 Position         */
#define EMAC_CAM13L_MACADDR0_Msk         (0xfful << EMAC_CAM13L_MACADDR0_Pos)              /*!< EMAC_T::CAM13L: MACADDR0 Mask             */

#define EMAC_CAM13L_MACADDR1_Pos         (24)                                              /*!< EMAC_T::CAM13L: MACADDR1 Position         */
#define EMAC_CAM13L_MACADDR1_Msk         (0xfful << EMAC_CAM13L_MACADDR1_Pos)              /*!< EMAC_T::CAM13L: MACADDR1 Mask             */

#define EMAC_CAM14M_MACADDR2_Pos         (0)                                               /*!< EMAC_T::CAM14M: MACADDR2 Position         */
#define EMAC_CAM14M_MACADDR2_Msk         (0xfful << EMAC_CAM14M_MACADDR2_Pos)              /*!< EMAC_T::CAM14M: MACADDR2 Mask             */

#define EMAC_CAM14M_MACADDR3_Pos         (8)                                               /*!< EMAC_T::CAM14M: MACADDR3 Position         */
#define EMAC_CAM14M_MACADDR3_Msk         (0xfful << EMAC_CAM14M_MACADDR3_Pos)              /*!< EMAC_T::CAM14M: MACADDR3 Mask             */

#define EMAC_CAM14M_MACADDR4_Pos         (16)                                              /*!< EMAC_T::CAM14M: MACADDR4 Position         */
#define EMAC_CAM14M_MACADDR4_Msk         (0xfful << EMAC_CAM14M_MACADDR4_Pos)              /*!< EMAC_T::CAM14M: MACADDR4 Mask             */

#define EMAC_CAM14M_MACADDR5_Pos         (24)                                              /*!< EMAC_T::CAM14M: MACADDR5 Position         */
#define EMAC_CAM14M_MACADDR5_Msk         (0xfful << EMAC_CAM14M_MACADDR5_Pos)              /*!< EMAC_T::CAM14M: MACADDR5 Mask             */

#define EMAC_CAM14L_Rserved_Pos          (0)                                               /*!< EMAC_T::CAM14L: Rserved Position          */
#define EMAC_CAM14L_Rserved_Msk          (0xfffful << EMAC_CAM14L_Rserved_Pos)             /*!< EMAC_T::CAM14L: Rserved Mask              */

#define EMAC_CAM14L_MACADDR0_Pos         (16)                                              /*!< EMAC_T::CAM14L: MACADDR0 Position         */
#define EMAC_CAM14L_MACADDR0_Msk         (0xfful << EMAC_CAM14L_MACADDR0_Pos)              /*!< EMAC_T::CAM14L: MACADDR0 Mask             */

#define EMAC_CAM14L_MACADDR1_Pos         (24)                                              /*!< EMAC_T::CAM14L: MACADDR1 Position         */
#define EMAC_CAM14L_MACADDR1_Msk         (0xfful << EMAC_CAM14L_MACADDR1_Pos)              /*!< EMAC_T::CAM14L: MACADDR1 Mask             */

#define EMAC_CAM15MSB_OPCODE_Pos         (0)                                               /*!< EMAC_T::CAM15MSB: OPCODE Position         */
#define EMAC_CAM15MSB_OPCODE_Msk         (0xfffful << EMAC_CAM15MSB_OPCODE_Pos)            /*!< EMAC_T::CAM15MSB: OPCODE Mask             */

#define EMAC_CAM15MSB_LENGTH_Pos         (16)                                              /*!< EMAC_T::CAM15MSB: LENGTH Position         */
#define EMAC_CAM15MSB_LENGTH_Msk         (0xfffful << EMAC_CAM15MSB_LENGTH_Pos)            /*!< EMAC_T::CAM15MSB: LENGTH Mask             */

#define EMAC_CAM15LSB_OPERAND_Pos        (24)                                              /*!< EMAC_T::CAM15LSB: OPERAND Position        */
#define EMAC_CAM15LSB_OPERAND_Msk        (0xfful << EMAC_CAM15LSB_OPERAND_Pos)             /*!< EMAC_T::CAM15LSB: OPERAND Mask            */

#define EMAC_TXDSA_TXDSA_Pos             (0)                                               /*!< EMAC_T::TXDSA: TXDSA Position             */
#define EMAC_TXDSA_TXDSA_Msk             (0xfffffffful << EMAC_TXDSA_TXDSA_Pos)            /*!< EMAC_T::TXDSA: TXDSA Mask                 */

#define EMAC_RXDSA_RXDSA_Pos             (0)                                               /*!< EMAC_T::RXDSA: RXDSA Position             */
#define EMAC_RXDSA_RXDSA_Msk             (0xfffffffful << EMAC_RXDSA_RXDSA_Pos)            /*!< EMAC_T::RXDSA: RXDSA Mask                 */

#define EMAC_CTL_RXON_Pos                (0)                                               /*!< EMAC_T::CTL: RXON Position                */
#define EMAC_CTL_RXON_Msk                (0x1ul << EMAC_CTL_RXON_Pos)                      /*!< EMAC_T::CTL: RXON Mask                    */

#define EMAC_CTL_ALP_Pos                 (1)                                               /*!< EMAC_T::CTL: ALP Position                 */
#define EMAC_CTL_ALP_Msk                 (0x1ul << EMAC_CTL_ALP_Pos)                       /*!< EMAC_T::CTL: ALP Mask                     */

#define EMAC_CTL_ARP_Pos                 (2)                                               /*!< EMAC_T::CTL: ARP Position                 */
#define EMAC_CTL_ARP_Msk                 (0x1ul << EMAC_CTL_ARP_Pos)                       /*!< EMAC_T::CTL: ARP Mask                     */

#define EMAC_CTL_ACP_Pos                 (3)                                               /*!< EMAC_T::CTL: ACP Position                 */
#define EMAC_CTL_ACP_Msk                 (0x1ul << EMAC_CTL_ACP_Pos)                       /*!< EMAC_T::CTL: ACP Mask                     */

#define EMAC_CTL_AEP_Pos                 (4)                                               /*!< EMAC_T::CTL: AEP Position                 */
#define EMAC_CTL_AEP_Msk                 (0x1ul << EMAC_CTL_AEP_Pos)                       /*!< EMAC_T::CTL: AEP Mask                     */

#define EMAC_CTL_STRIPCRC_Pos            (5)                                               /*!< EMAC_T::CTL: STRIPCRC Position            */
#define EMAC_CTL_STRIPCRC_Msk            (0x1ul << EMAC_CTL_STRIPCRC_Pos)                  /*!< EMAC_T::CTL: STRIPCRC Mask                */

#define EMAC_CTL_WOLEN_Pos               (6)                                               /*!< EMAC_T::CTL: WOLEN Position               */
#define EMAC_CTL_WOLEN_Msk               (0x1ul << EMAC_CTL_WOLEN_Pos)                     /*!< EMAC_T::CTL: WOLEN Mask                   */

#define EMAC_CTL_TXON_Pos                (8)                                               /*!< EMAC_T::CTL: TXON Position                */
#define EMAC_CTL_TXON_Msk                (0x1ul << EMAC_CTL_TXON_Pos)                      /*!< EMAC_T::CTL: TXON Mask                    */

#define EMAC_CTL_NODEF_Pos               (9)                                               /*!< EMAC_T::CTL: NODEF Position               */
#define EMAC_CTL_NODEF_Msk               (0x1ul << EMAC_CTL_NODEF_Pos)                     /*!< EMAC_T::CTL: NODEF Mask                   */

#define EMAC_CTL_SDPZ_Pos                (16)                                              /*!< EMAC_T::CTL: SDPZ Position                */
#define EMAC_CTL_SDPZ_Msk                (0x1ul << EMAC_CTL_SDPZ_Pos)                      /*!< EMAC_T::CTL: SDPZ Mask                    */

#define EMAC_CTL_SQECHKEN_Pos            (17)                                              /*!< EMAC_T::CTL: SQECHKEN Position            */
#define EMAC_CTL_SQECHKEN_Msk            (0x1ul << EMAC_CTL_SQECHKEN_Pos)                  /*!< EMAC_T::CTL: SQECHKEN Mask                */

#define EMAC_CTL_FUDUP_Pos               (18)                                              /*!< EMAC_T::CTL: FUDUP Position               */
#define EMAC_CTL_FUDUP_Msk               (0x1ul << EMAC_CTL_FUDUP_Pos)                     /*!< EMAC_T::CTL: FUDUP Mask                   */

#define EMAC_CTL_RMIIRXCTL_Pos           (19)                                              /*!< EMAC_T::CTL: RMIIRXCTL Position           */
#define EMAC_CTL_RMIIRXCTL_Msk           (0x1ul << EMAC_CTL_RMIIRXCTL_Pos)                 /*!< EMAC_T::CTL: RMIIRXCTL Mask               */

#define EMAC_CTL_OPMODE_Pos              (20)                                              /*!< EMAC_T::CTL: OPMODE Position              */
#define EMAC_CTL_OPMODE_Msk              (0x1ul << EMAC_CTL_OPMODE_Pos)                    /*!< EMAC_T::CTL: OPMODE Mask                  */

#define EMAC_CTL_RMIIEN_Pos              (22)                                              /*!< EMAC_T::CTL: RMIIEN Position              */
#define EMAC_CTL_RMIIEN_Msk              (0x1ul << EMAC_CTL_RMIIEN_Pos)                    /*!< EMAC_T::CTL: RMIIEN Mask                  */

#define EMAC_CTL_RST_Pos                 (24)                                              /*!< EMAC_T::CTL: RST Position                 */
#define EMAC_CTL_RST_Msk                 (0x1ul << EMAC_CTL_RST_Pos)                       /*!< EMAC_T::CTL: RST Mask                     */

#define EMAC_MIIMDAT_DATA_Pos            (0)                                               /*!< EMAC_T::MIIMDAT: DATA Position            */
#define EMAC_MIIMDAT_DATA_Msk            (0xfffful << EMAC_MIIMDAT_DATA_Pos)               /*!< EMAC_T::MIIMDAT: DATA Mask                */

#define EMAC_MIIMCTL_PHYREG_Pos          (0)                                               /*!< EMAC_T::MIIMCTL: PHYREG Position          */
#define EMAC_MIIMCTL_PHYREG_Msk          (0x1ful << EMAC_MIIMCTL_PHYREG_Pos)               /*!< EMAC_T::MIIMCTL: PHYREG Mask              */

#define EMAC_MIIMCTL_PHYADDR_Pos         (8)                                               /*!< EMAC_T::MIIMCTL: PHYADDR Position         */
#define EMAC_MIIMCTL_PHYADDR_Msk         (0x1ful << EMAC_MIIMCTL_PHYADDR_Pos)              /*!< EMAC_T::MIIMCTL: PHYADDR Mask             */

#define EMAC_MIIMCTL_WRITE_Pos           (16)                                              /*!< EMAC_T::MIIMCTL: WRITE Position           */
#define EMAC_MIIMCTL_WRITE_Msk           (0x1ul << EMAC_MIIMCTL_WRITE_Pos)                 /*!< EMAC_T::MIIMCTL: WRITE Mask               */

#define EMAC_MIIMCTL_BUSY_Pos            (17)                                              /*!< EMAC_T::MIIMCTL: BUSY Position            */
#define EMAC_MIIMCTL_BUSY_Msk            (0x1ul << EMAC_MIIMCTL_BUSY_Pos)                  /*!< EMAC_T::MIIMCTL: BUSY Mask                */

#define EMAC_MIIMCTL_PREAMSP_Pos         (18)                                              /*!< EMAC_T::MIIMCTL: PREAMSP Position         */
#define EMAC_MIIMCTL_PREAMSP_Msk         (0x1ul << EMAC_MIIMCTL_PREAMSP_Pos)               /*!< EMAC_T::MIIMCTL: PREAMSP Mask             */

#define EMAC_MIIMCTL_MDCON_Pos           (19)                                              /*!< EMAC_T::MIIMCTL: MDCON Position           */
#define EMAC_MIIMCTL_MDCON_Msk           (0x1ul << EMAC_MIIMCTL_MDCON_Pos)                 /*!< EMAC_T::MIIMCTL: MDCON Mask               */

#define EMAC_FIFOCTL_RXFIFOTH_Pos        (0)                                               /*!< EMAC_T::FIFOCTL: RXFIFOTH Position        */
#define EMAC_FIFOCTL_RXFIFOTH_Msk        (0x3ul << EMAC_FIFOCTL_RXFIFOTH_Pos)              /*!< EMAC_T::FIFOCTL: RXFIFOTH Mask            */

#define EMAC_FIFOCTL_TXFIFOTH_Pos        (8)                                               /*!< EMAC_T::FIFOCTL: TXFIFOTH Position        */
#define EMAC_FIFOCTL_TXFIFOTH_Msk        (0x3ul << EMAC_FIFOCTL_TXFIFOTH_Pos)              /*!< EMAC_T::FIFOCTL: TXFIFOTH Mask            */

#define EMAC_FIFOCTL_BURSTLEN_Pos        (20)                                              /*!< EMAC_T::FIFOCTL: BURSTLEN Position        */
#define EMAC_FIFOCTL_BURSTLEN_Msk        (0x3ul << EMAC_FIFOCTL_BURSTLEN_Pos)              /*!< EMAC_T::FIFOCTL: BURSTLEN Mask            */

#define EMAC_TXST_TXST_Pos               (0)                                               /*!< EMAC_T::TXST: TXST Position               */
#define EMAC_TXST_TXST_Msk               (0xfffffffful << EMAC_TXST_TXST_Pos)              /*!< EMAC_T::TXST: TXST Mask                   */

#define EMAC_RXST_RXST_Pos               (0)                                               /*!< EMAC_T::RXST: RXST Position               */
#define EMAC_RXST_RXST_Msk               (0xfffffffful << EMAC_RXST_RXST_Pos)              /*!< EMAC_T::RXST: RXST Mask                   */

#define EMAC_MRFL_MRFL_Pos               (0)                                               /*!< EMAC_T::MRFL: MRFL Position               */
#define EMAC_MRFL_MRFL_Msk               (0xfffful << EMAC_MRFL_MRFL_Pos)                  /*!< EMAC_T::MRFL: MRFL Mask                   */

#define EMAC_INTEN_RXIEN_Pos             (0)                                               /*!< EMAC_T::INTEN: RXIEN Position             */
#define EMAC_INTEN_RXIEN_Msk             (0x1ul << EMAC_INTEN_RXIEN_Pos)                   /*!< EMAC_T::INTEN: RXIEN Mask                 */

#define EMAC_INTEN_CRCEIEN_Pos           (1)                                               /*!< EMAC_T::INTEN: CRCEIEN Position           */
#define EMAC_INTEN_CRCEIEN_Msk           (0x1ul << EMAC_INTEN_CRCEIEN_Pos)                 /*!< EMAC_T::INTEN: CRCEIEN Mask               */

#define EMAC_INTEN_RXOVIEN_Pos           (2)                                               /*!< EMAC_T::INTEN: RXOVIEN Position           */
#define EMAC_INTEN_RXOVIEN_Msk           (0x1ul << EMAC_INTEN_RXOVIEN_Pos)                 /*!< EMAC_T::INTEN: RXOVIEN Mask               */

#define EMAC_INTEN_LPIEN_Pos             (3)                                               /*!< EMAC_T::INTEN: LPIEN Position             */
#define EMAC_INTEN_LPIEN_Msk             (0x1ul << EMAC_INTEN_LPIEN_Pos)                   /*!< EMAC_T::INTEN: LPIEN Mask                 */

#define EMAC_INTEN_RXGDIEN_Pos           (4)                                               /*!< EMAC_T::INTEN: RXGDIEN Position           */
#define EMAC_INTEN_RXGDIEN_Msk           (0x1ul << EMAC_INTEN_RXGDIEN_Pos)                 /*!< EMAC_T::INTEN: RXGDIEN Mask               */

#define EMAC_INTEN_ALIEIEN_Pos           (5)                                               /*!< EMAC_T::INTEN: ALIEIEN Position           */
#define EMAC_INTEN_ALIEIEN_Msk           (0x1ul << EMAC_INTEN_ALIEIEN_Pos)                 /*!< EMAC_T::INTEN: ALIEIEN Mask               */

#define EMAC_INTEN_RPIEN_Pos             (6)                                               /*!< EMAC_T::INTEN: RPIEN Position             */
#define EMAC_INTEN_RPIEN_Msk             (0x1ul << EMAC_INTEN_RPIEN_Pos)                   /*!< EMAC_T::INTEN: RPIEN Mask                 */

#define EMAC_INTEN_MPCOVIEN_Pos          (7)                                               /*!< EMAC_T::INTEN: MPCOVIEN Position          */
#define EMAC_INTEN_MPCOVIEN_Msk          (0x1ul << EMAC_INTEN_MPCOVIEN_Pos)                /*!< EMAC_T::INTEN: MPCOVIEN Mask              */

#define EMAC_INTEN_MFLEIEN_Pos           (8)                                               /*!< EMAC_T::INTEN: MFLEIEN Position           */
#define EMAC_INTEN_MFLEIEN_Msk           (0x1ul << EMAC_INTEN_MFLEIEN_Pos)                 /*!< EMAC_T::INTEN: MFLEIEN Mask               */

#define EMAC_INTEN_DENIEN_Pos            (9)                                               /*!< EMAC_T::INTEN: DENIEN Position            */
#define EMAC_INTEN_DENIEN_Msk            (0x1ul << EMAC_INTEN_DENIEN_Pos)                  /*!< EMAC_T::INTEN: DENIEN Mask                */

#define EMAC_INTEN_RDUIEN_Pos            (10)                                              /*!< EMAC_T::INTEN: RDUIEN Position            */
#define EMAC_INTEN_RDUIEN_Msk            (0x1ul << EMAC_INTEN_RDUIEN_Pos)                  /*!< EMAC_T::INTEN: RDUIEN Mask                */

#define EMAC_INTEN_RXBEIEN_Pos           (11)                                              /*!< EMAC_T::INTEN: RXBEIEN Position           */
#define EMAC_INTEN_RXBEIEN_Msk           (0x1ul << EMAC_INTEN_RXBEIEN_Pos)                 /*!< EMAC_T::INTEN: RXBEIEN Mask               */

#define EMAC_INTEN_CFRIEN_Pos            (14)                                              /*!< EMAC_T::INTEN: CFRIEN Position            */
#define EMAC_INTEN_CFRIEN_Msk            (0x1ul << EMAC_INTEN_CFRIEN_Pos)                  /*!< EMAC_T::INTEN: CFRIEN Mask                */

#define EMAC_INTEN_WOLIEN_Pos            (15)                                              /*!< EMAC_T::INTEN: WOLIEN Position            */
#define EMAC_INTEN_WOLIEN_Msk            (0x1ul << EMAC_INTEN_WOLIEN_Pos)                  /*!< EMAC_T::INTEN: WOLIEN Mask                */

#define EMAC_INTEN_TXIEN_Pos             (16)                                              /*!< EMAC_T::INTEN: TXIEN Position             */
#define EMAC_INTEN_TXIEN_Msk             (0x1ul << EMAC_INTEN_TXIEN_Pos)                   /*!< EMAC_T::INTEN: TXIEN Mask                 */

#define EMAC_INTEN_TXUDIEN_Pos           (17)                                              /*!< EMAC_T::INTEN: TXUDIEN Position           */
#define EMAC_INTEN_TXUDIEN_Msk           (0x1ul << EMAC_INTEN_TXUDIEN_Pos)                 /*!< EMAC_T::INTEN: TXUDIEN Mask               */

#define EMAC_INTEN_TXCPIEN_Pos           (18)                                              /*!< EMAC_T::INTEN: TXCPIEN Position           */
#define EMAC_INTEN_TXCPIEN_Msk           (0x1ul << EMAC_INTEN_TXCPIEN_Pos)                 /*!< EMAC_T::INTEN: TXCPIEN Mask               */

#define EMAC_INTEN_EXDEFIEN_Pos          (19)                                              /*!< EMAC_T::INTEN: EXDEFIEN Position          */
#define EMAC_INTEN_EXDEFIEN_Msk          (0x1ul << EMAC_INTEN_EXDEFIEN_Pos)                /*!< EMAC_T::INTEN: EXDEFIEN Mask              */

#define EMAC_INTEN_NCSIEN_Pos            (20)                                              /*!< EMAC_T::INTEN: NCSIEN Position            */
#define EMAC_INTEN_NCSIEN_Msk            (0x1ul << EMAC_INTEN_NCSIEN_Pos)                  /*!< EMAC_T::INTEN: NCSIEN Mask                */

#define EMAC_INTEN_TXABTIEN_Pos          (21)                                              /*!< EMAC_T::INTEN: TXABTIEN Position          */
#define EMAC_INTEN_TXABTIEN_Msk          (0x1ul << EMAC_INTEN_TXABTIEN_Pos)                /*!< EMAC_T::INTEN: TXABTIEN Mask              */

#define EMAC_INTEN_LCIEN_Pos             (22)                                              /*!< EMAC_T::INTEN: LCIEN Position             */
#define EMAC_INTEN_LCIEN_Msk             (0x1ul << EMAC_INTEN_LCIEN_Pos)                   /*!< EMAC_T::INTEN: LCIEN Mask                 */

#define EMAC_INTEN_TDUIEN_Pos            (23)                                              /*!< EMAC_T::INTEN: TDUIEN Position            */
#define EMAC_INTEN_TDUIEN_Msk            (0x1ul << EMAC_INTEN_TDUIEN_Pos)                  /*!< EMAC_T::INTEN: TDUIEN Mask                */

#define EMAC_INTEN_TXBEIEN_Pos           (24)                                              /*!< EMAC_T::INTEN: TXBEIEN Position           */
#define EMAC_INTEN_TXBEIEN_Msk           (0x1ul << EMAC_INTEN_TXBEIEN_Pos)                 /*!< EMAC_T::INTEN: TXBEIEN Mask               */

#define EMAC_INTEN_TSALMIEN_Pos          (28)                                              /*!< EMAC_T::INTEN: TSALMIEN Position          */
#define EMAC_INTEN_TSALMIEN_Msk          (0x1ul << EMAC_INTEN_TSALMIEN_Pos)                /*!< EMAC_T::INTEN: TSALMIEN Mask              */

#define EMAC_INTSTS_RXIF_Pos             (0)                                               /*!< EMAC_T::INTSTS: RXIF Position             */
#define EMAC_INTSTS_RXIF_Msk             (0x1ul << EMAC_INTSTS_RXIF_Pos)                   /*!< EMAC_T::INTSTS: RXIF Mask                 */

#define EMAC_INTSTS_CRCEIF_Pos           (1)                                               /*!< EMAC_T::INTSTS: CRCEIF Position           */
#define EMAC_INTSTS_CRCEIF_Msk           (0x1ul << EMAC_INTSTS_CRCEIF_Pos)                 /*!< EMAC_T::INTSTS: CRCEIF Mask               */

#define EMAC_INTSTS_RXOVIF_Pos           (2)                                               /*!< EMAC_T::INTSTS: RXOVIF Position           */
#define EMAC_INTSTS_RXOVIF_Msk           (0x1ul << EMAC_INTSTS_RXOVIF_Pos)                 /*!< EMAC_T::INTSTS: RXOVIF Mask               */

#define EMAC_INTSTS_LPIF_Pos             (3)                                               /*!< EMAC_T::INTSTS: LPIF Position             */
#define EMAC_INTSTS_LPIF_Msk             (0x1ul << EMAC_INTSTS_LPIF_Pos)                   /*!< EMAC_T::INTSTS: LPIF Mask                 */

#define EMAC_INTSTS_RXGDIF_Pos           (4)                                               /*!< EMAC_T::INTSTS: RXGDIF Position           */
#define EMAC_INTSTS_RXGDIF_Msk           (0x1ul << EMAC_INTSTS_RXGDIF_Pos)                 /*!< EMAC_T::INTSTS: RXGDIF Mask               */

#define EMAC_INTSTS_ALIEIF_Pos           (5)                                               /*!< EMAC_T::INTSTS: ALIEIF Position           */
#define EMAC_INTSTS_ALIEIF_Msk           (0x1ul << EMAC_INTSTS_ALIEIF_Pos)                 /*!< EMAC_T::INTSTS: ALIEIF Mask               */

#define EMAC_INTSTS_RPIF_Pos             (6)                                               /*!< EMAC_T::INTSTS: RPIF Position             */
#define EMAC_INTSTS_RPIF_Msk             (0x1ul << EMAC_INTSTS_RPIF_Pos)                   /*!< EMAC_T::INTSTS: RPIF Mask                 */

#define EMAC_INTSTS_MPCOVIF_Pos          (7)                                               /*!< EMAC_T::INTSTS: MPCOVIF Position          */
#define EMAC_INTSTS_MPCOVIF_Msk          (0x1ul << EMAC_INTSTS_MPCOVIF_Pos)                /*!< EMAC_T::INTSTS: MPCOVIF Mask              */

#define EMAC_INTSTS_MFLEIF_Pos           (8)                                               /*!< EMAC_T::INTSTS: MFLEIF Position           */
#define EMAC_INTSTS_MFLEIF_Msk           (0x1ul << EMAC_INTSTS_MFLEIF_Pos)                 /*!< EMAC_T::INTSTS: MFLEIF Mask               */

#define EMAC_INTSTS_DENIF_Pos            (9)                                               /*!< EMAC_T::INTSTS: DENIF Position            */
#define EMAC_INTSTS_DENIF_Msk            (0x1ul << EMAC_INTSTS_DENIF_Pos)                  /*!< EMAC_T::INTSTS: DENIF Mask                */

#define EMAC_INTSTS_RDUIF_Pos            (10)                                              /*!< EMAC_T::INTSTS: RDUIF Position            */
#define EMAC_INTSTS_RDUIF_Msk            (0x1ul << EMAC_INTSTS_RDUIF_Pos)                  /*!< EMAC_T::INTSTS: RDUIF Mask                */

#define EMAC_INTSTS_RXBEIF_Pos           (11)                                              /*!< EMAC_T::INTSTS: RXBEIF Position           */
#define EMAC_INTSTS_RXBEIF_Msk           (0x1ul << EMAC_INTSTS_RXBEIF_Pos)                 /*!< EMAC_T::INTSTS: RXBEIF Mask               */

#define EMAC_INTSTS_CFRIF_Pos            (14)                                              /*!< EMAC_T::INTSTS: CFRIF Position            */
#define EMAC_INTSTS_CFRIF_Msk            (0x1ul << EMAC_INTSTS_CFRIF_Pos)                  /*!< EMAC_T::INTSTS: CFRIF Mask                */

#define EMAC_INTSTS_WOLIF_Pos            (15)                                              /*!< EMAC_T::INTSTS: WOLIF Position            */
#define EMAC_INTSTS_WOLIF_Msk            (0x1ul << EMAC_INTSTS_WOLIF_Pos)                  /*!< EMAC_T::INTSTS: WOLIF Mask                */

#define EMAC_INTSTS_TXIF_Pos             (16)                                              /*!< EMAC_T::INTSTS: TXIF Position             */
#define EMAC_INTSTS_TXIF_Msk             (0x1ul << EMAC_INTSTS_TXIF_Pos)                   /*!< EMAC_T::INTSTS: TXIF Mask                 */

#define EMAC_INTSTS_TXUDIF_Pos           (17)                                              /*!< EMAC_T::INTSTS: TXUDIF Position           */
#define EMAC_INTSTS_TXUDIF_Msk           (0x1ul << EMAC_INTSTS_TXUDIF_Pos)                 /*!< EMAC_T::INTSTS: TXUDIF Mask               */

#define EMAC_INTSTS_TXCPIF_Pos           (18)                                              /*!< EMAC_T::INTSTS: TXCPIF Position           */
#define EMAC_INTSTS_TXCPIF_Msk           (0x1ul << EMAC_INTSTS_TXCPIF_Pos)                 /*!< EMAC_T::INTSTS: TXCPIF Mask               */

#define EMAC_INTSTS_EXDEFIF_Pos          (19)                                              /*!< EMAC_T::INTSTS: EXDEFIF Position          */
#define EMAC_INTSTS_EXDEFIF_Msk          (0x1ul << EMAC_INTSTS_EXDEFIF_Pos)                /*!< EMAC_T::INTSTS: EXDEFIF Mask              */

#define EMAC_INTSTS_NCSIF_Pos            (20)                                              /*!< EMAC_T::INTSTS: NCSIF Position            */
#define EMAC_INTSTS_NCSIF_Msk            (0x1ul << EMAC_INTSTS_NCSIF_Pos)                  /*!< EMAC_T::INTSTS: NCSIF Mask                */

#define EMAC_INTSTS_TXABTIF_Pos          (21)                                              /*!< EMAC_T::INTSTS: TXABTIF Position          */
#define EMAC_INTSTS_TXABTIF_Msk          (0x1ul << EMAC_INTSTS_TXABTIF_Pos)                /*!< EMAC_T::INTSTS: TXABTIF Mask              */

#define EMAC_INTSTS_LCIF_Pos             (22)                                              /*!< EMAC_T::INTSTS: LCIF Position             */
#define EMAC_INTSTS_LCIF_Msk             (0x1ul << EMAC_INTSTS_LCIF_Pos)                   /*!< EMAC_T::INTSTS: LCIF Mask                 */

#define EMAC_INTSTS_TDUIF_Pos            (23)                                              /*!< EMAC_T::INTSTS: TDUIF Position            */
#define EMAC_INTSTS_TDUIF_Msk            (0x1ul << EMAC_INTSTS_TDUIF_Pos)                  /*!< EMAC_T::INTSTS: TDUIF Mask                */

#define EMAC_INTSTS_TXBEIF_Pos           (24)                                              /*!< EMAC_T::INTSTS: TXBEIF Position           */
#define EMAC_INTSTS_TXBEIF_Msk           (0x1ul << EMAC_INTSTS_TXBEIF_Pos)                 /*!< EMAC_T::INTSTS: TXBEIF Mask               */

#define EMAC_INTSTS_TSALMIF_Pos          (28)                                              /*!< EMAC_T::INTSTS: TSALMIF Position          */
#define EMAC_INTSTS_TSALMIF_Msk          (0x1ul << EMAC_INTSTS_TSALMIF_Pos)                /*!< EMAC_T::INTSTS: TSALMIF Mask              */

#define EMAC_GENSTS_CFRIF_Pos            (0)                                               /*!< EMAC_T::GENSTS: CFRIF Position            */
#define EMAC_GENSTS_CFRIF_Msk            (0x1ul << EMAC_GENSTS_CFRIF_Pos)                  /*!< EMAC_T::GENSTS: CFRIF Mask                */

#define EMAC_GENSTS_RXHALT_Pos           (1)                                               /*!< EMAC_T::GENSTS: RXHALT Position           */
#define EMAC_GENSTS_RXHALT_Msk           (0x1ul << EMAC_GENSTS_RXHALT_Pos)                 /*!< EMAC_T::GENSTS: RXHALT Mask               */

#define EMAC_GENSTS_RXFFULL_Pos          (2)                                               /*!< EMAC_T::GENSTS: RXFFULL Position          */
#define EMAC_GENSTS_RXFFULL_Msk          (0x1ul << EMAC_GENSTS_RXFFULL_Pos)                /*!< EMAC_T::GENSTS: RXFFULL Mask              */

#define EMAC_GENSTS_COLCNT_Pos           (4)                                               /*!< EMAC_T::GENSTS: COLCNT Position           */
#define EMAC_GENSTS_COLCNT_Msk           (0xful << EMAC_GENSTS_COLCNT_Pos)                 /*!< EMAC_T::GENSTS: COLCNT Mask               */

#define EMAC_GENSTS_DEF_Pos              (8)                                               /*!< EMAC_T::GENSTS: DEF Position              */
#define EMAC_GENSTS_DEF_Msk              (0x1ul << EMAC_GENSTS_DEF_Pos)                    /*!< EMAC_T::GENSTS: DEF Mask                  */

#define EMAC_GENSTS_TXPAUSED_Pos         (9)                                               /*!< EMAC_T::GENSTS: TXPAUSED Position         */
#define EMAC_GENSTS_TXPAUSED_Msk         (0x1ul << EMAC_GENSTS_TXPAUSED_Pos)               /*!< EMAC_T::GENSTS: TXPAUSED Mask             */

#define EMAC_GENSTS_SQE_Pos              (10)                                              /*!< EMAC_T::GENSTS: SQE Position              */
#define EMAC_GENSTS_SQE_Msk              (0x1ul << EMAC_GENSTS_SQE_Pos)                    /*!< EMAC_T::GENSTS: SQE Mask                  */

#define EMAC_GENSTS_TXHALT_Pos           (11)                                              /*!< EMAC_T::GENSTS: TXHALT Position           */
#define EMAC_GENSTS_TXHALT_Msk           (0x1ul << EMAC_GENSTS_TXHALT_Pos)                 /*!< EMAC_T::GENSTS: TXHALT Mask               */

#define EMAC_GENSTS_RPSTS_Pos            (12)                                              /*!< EMAC_T::GENSTS: RPSTS Position            */
#define EMAC_GENSTS_RPSTS_Msk            (0x1ul << EMAC_GENSTS_RPSTS_Pos)                  /*!< EMAC_T::GENSTS: RPSTS Mask                */

#define EMAC_MPCNT_MPCNT_Pos             (0)                                               /*!< EMAC_T::MPCNT: MPCNT Position             */
#define EMAC_MPCNT_MPCNT_Msk             (0xfffful << EMAC_MPCNT_MPCNT_Pos)                /*!< EMAC_T::MPCNT: MPCNT Mask                 */

#define EMAC_RPCNT_RPCNT_Pos             (0)                                               /*!< EMAC_T::RPCNT: RPCNT Position             */
#define EMAC_RPCNT_RPCNT_Msk             (0xfffful << EMAC_RPCNT_RPCNT_Pos)                /*!< EMAC_T::RPCNT: RPCNT Mask                 */

#define EMAC_FRSTS_RXFLT_Pos             (0)                                               /*!< EMAC_T::FRSTS: RXFLT Position             */
#define EMAC_FRSTS_RXFLT_Msk             (0xfffful << EMAC_FRSTS_RXFLT_Pos)                /*!< EMAC_T::FRSTS: RXFLT Mask                 */

#define EMAC_CTXDSA_CTXDSA_Pos           (0)                                               /*!< EMAC_T::CTXDSA: CTXDSA Position           */
#define EMAC_CTXDSA_CTXDSA_Msk           (0xfffffffful << EMAC_CTXDSA_CTXDSA_Pos)          /*!< EMAC_T::CTXDSA: CTXDSA Mask               */

#define EMAC_CTXBSA_CTXBSA_Pos           (0)                                               /*!< EMAC_T::CTXBSA: CTXBSA Position           */
#define EMAC_CTXBSA_CTXBSA_Msk           (0xfffffffful << EMAC_CTXBSA_CTXBSA_Pos)          /*!< EMAC_T::CTXBSA: CTXBSA Mask               */

#define EMAC_CRXDSA_CRXDSA_Pos           (0)                                               /*!< EMAC_T::CRXDSA: CRXDSA Position           */
#define EMAC_CRXDSA_CRXDSA_Msk           (0xfffffffful << EMAC_CRXDSA_CRXDSA_Pos)          /*!< EMAC_T::CRXDSA: CRXDSA Mask               */

#define EMAC_CRXBSA_CRXBSA_Pos           (0)                                               /*!< EMAC_T::CRXBSA: CRXBSA Position           */
#define EMAC_CRXBSA_CRXBSA_Msk           (0xfffffffful << EMAC_CRXBSA_CRXBSA_Pos)          /*!< EMAC_T::CRXBSA: CRXBSA Mask               */

#define EMAC_TSCTL_TSEN_Pos              (0)                                               /*!< EMAC_T::TSCTL: TSEN Position              */
#define EMAC_TSCTL_TSEN_Msk              (0x1ul << EMAC_TSCTL_TSEN_Pos)                    /*!< EMAC_T::TSCTL: TSEN Mask                  */

#define EMAC_TSCTL_TSIEN_Pos             (1)                                               /*!< EMAC_T::TSCTL: TSIEN Position             */
#define EMAC_TSCTL_TSIEN_Msk             (0x1ul << EMAC_TSCTL_TSIEN_Pos)                   /*!< EMAC_T::TSCTL: TSIEN Mask                 */

#define EMAC_TSCTL_TSMODE_Pos            (2)                                               /*!< EMAC_T::TSCTL: TSMODE Position            */
#define EMAC_TSCTL_TSMODE_Msk            (0x1ul << EMAC_TSCTL_TSMODE_Pos)                  /*!< EMAC_T::TSCTL: TSMODE Mask                */

#define EMAC_TSCTL_TSUPDATE_Pos          (3)                                               /*!< EMAC_T::TSCTL: TSUPDATE Position          */
#define EMAC_TSCTL_TSUPDATE_Msk          (0x1ul << EMAC_TSCTL_TSUPDATE_Pos)                /*!< EMAC_T::TSCTL: TSUPDATE Mask              */

#define EMAC_TSCTL_TSALMEN_Pos           (5)                                               /*!< EMAC_T::TSCTL: TSALMEN Position           */
#define EMAC_TSCTL_TSALMEN_Msk           (0x1ul << EMAC_TSCTL_TSALMEN_Pos)                 /*!< EMAC_T::TSCTL: TSALMEN Mask               */

#define EMAC_TSSEC_SEC_Pos               (0)                                               /*!< EMAC_T::TSSEC: SEC Position               */
#define EMAC_TSSEC_SEC_Msk               (0xfffffffful << EMAC_TSSEC_SEC_Pos)              /*!< EMAC_T::TSSEC: SEC Mask                   */

#define EMAC_TSSUBSEC_SUBSEC_Pos         (0)                                               /*!< EMAC_T::TSSUBSEC: SUBSEC Position         */
#define EMAC_TSSUBSEC_SUBSEC_Msk         (0xfffffffful << EMAC_TSSUBSEC_SUBSEC_Pos)        /*!< EMAC_T::TSSUBSEC: SUBSEC Mask             */

#define EMAC_TSINC_CNTINC_Pos            (0)                                               /*!< EMAC_T::TSINC: CNTINC Position            */
#define EMAC_TSINC_CNTINC_Msk            (0xfful << EMAC_TSINC_CNTINC_Pos)                 /*!< EMAC_T::TSINC: CNTINC Mask                */

#define EMAC_TSADDEND_ADDEND_Pos         (0)                                               /*!< EMAC_T::TSADDEND: ADDEND Position         */
#define EMAC_TSADDEND_ADDEND_Msk         (0xfffffffful << EMAC_TSADDEND_ADDEND_Pos)        /*!< EMAC_T::TSADDEND: ADDEND Mask             */

#define EMAC_UPDSEC_SEC_Pos              (0)                                               /*!< EMAC_T::UPDSEC: SEC Position              */
#define EMAC_UPDSEC_SEC_Msk              (0xfffffffful << EMAC_UPDSEC_SEC_Pos)             /*!< EMAC_T::UPDSEC: SEC Mask                  */

#define EMAC_UPDSUBSEC_SUBSEC_Pos        (0)                                               /*!< EMAC_T::UPDSUBSEC: SUBSEC Position        */
#define EMAC_UPDSUBSEC_SUBSEC_Msk        (0xfffffffful << EMAC_UPDSUBSEC_SUBSEC_Pos)       /*!< EMAC_T::UPDSUBSEC: SUBSEC Mask            */

#define EMAC_ALMSEC_SEC_Pos              (0)                                               /*!< EMAC_T::ALMSEC: SEC Position              */
#define EMAC_ALMSEC_SEC_Msk              (0xfffffffful << EMAC_ALMSEC_SEC_Pos)             /*!< EMAC_T::ALMSEC: SEC Mask                  */

#define EMAC_ALMSUBSEC_SUBSEC_Pos        (0)                                               /*!< EMAC_T::ALMSUBSEC: SUBSEC Position        */
#define EMAC_ALMSUBSEC_SUBSEC_Msk        (0xfffffffful << EMAC_ALMSUBSEC_SUBSEC_Pos)       /*!< EMAC_T::ALMSUBSEC: SUBSEC Mask            */

/**@}*/ /* EMAC_CONST */
/**@}*/ /* end of EMAC register group */


/*---------------------- Enhanced PWM Generator -------------------------*/
/**
    @addtogroup EPWM Enhanced PWM Generator(EPWM)
    Memory Mapped Structure for EPWM Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  PWM Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |MODE      |PWM Mode Selection
     * |        |          |00 = Independent mode.
     * |        |          |01 = Pair/Complementary mode.
     * |        |          |10 = Synchronized mode.
     * |        |          |11 = Reserved.
     * |[2:3]   |CLKDIV    |PWM Clock Pre-Divider Selection
     * |        |          |00 = PWM clock = EPWMx_CLK.
     * |        |          |01 = PWM clock = EPWMx_CLK/2.
     * |        |          |10 = PWM clock = EPWMx_CLK/4.
     * |        |          |11 = PWM clock = EPWMx_CLK/16.
     * |[4]     |PWMIEN    |PWM Interrupt Enable Control
     * |        |          |0 = Disabling flag PIF to trigger PWM interrupt.
     * |        |          |1 = Enabling flag PIF can trigger PWM interrupt.
     * |[5]     |BRKIEN    |Brake0 And Brak1 Interrupt Enable Control
     * |        |          |0 = Disabling flags BFK0 and BFK1 to trigger PWM interrupt.
     * |        |          |1 = Enabling flags BRKIF0 and BRKIF1 can trigger PWM interrupt.
     * |[6]     |LOAD      |Re-Load PWM Period Registers (EPWM_PERIOD) And PWM Duty Registers (PWM0~3) Control
     * |        |          |0 = No action if written with 0.
     * |        |          |The value of PWM period register (EPWM_PERIOD) and PWM duty registers (PWMn_CH0~PWMn_CH3) are not loaded to PWM counter and Comparator registers.
     * |        |          |1 = Hardware will update the value of PWM period register (EPWM_PERIOD) and PWM duty registers (PWMn_CH0~PWMn_CH3) to PWM Counter and Comparator register at the time of PWM Counter matches PERIOD in edge and central aligned modes or at the time of PWM Counter down counts with underflow in central aligned mode.
     * |        |          |Note1: n=0-1 for PWM unit0-1.
     * |        |          |Note2: This bit is software write, hardware clear and always read zero.
     * |[7]     |CNTEN     |Start CNTEN Control
     * |        |          |0 = The PWM stops running.
     * |        |          |1 = The PWM counter starts running.
     * |[8]     |INTTYPE   |PWM Interrupt Type Selection
     * |        |          |0 = PIF will be set if PWM counter underflow.
     * |        |          |1 = PIF will be set if PWM counter matches EPWM_PERIOD register.
     * |        |          |Note: This bit is effective when PWM in central align mode only.
     * |[9]     |PINV      |Inverse PWM Comparator Output
     * |        |          |When PINV is set to high the PWM comparator output signals will be inversed, therefore the PWM Duty (in percentage) is changed to (1-Duty) before PINV is set to high.
     * |        |          |0 = Not inverse PWM comparator output.
     * |        |          |1 = Inverse PWM comparator output.
     * |[11]    |CNTCLR    |Clear PWM Counter Control
     * |        |          |1 = Clear 16-bit PWM counter to 000H.
     * |        |          |Note: It is automatically cleared by hardware.
     * |[12]    |CNTTYPE   |PWM Aligned Type Selection
     * |        |          |0 = Edge-aligned type.
     * |        |          |1 = Centre-aligned type.
     * |[13]    |GROUPEN   |Group Bit
     * |        |          |0 = The signals timing of EPWM_CMPDAT0, EPWM_CMPDAT2 and EPWM_CMPDAT4 are independent.
     * |        |          |1 = Unify the signals timing of EPWM_CMPDAT0, EPWM_CMPDAT2 and EPWM_CMPDAT4 in the same phase which is controlled by EPWM_CMPDAT0.
     * |[14]    |BRKP0INV  |Inverse BKP0 State
     * |        |          |0 = The state of pin BKPx0 is passed to the negative edge detector.
     * |        |          |1 = The inversed state of pin BKPx0 is passed to the negative edge detector.
     * |[15]    |BRKP1INV  |Inverse BKP1 State
     * |        |          |0 = The state of pin BKPx1 is passed to the negative edge detector.
     * |        |          |1 = The inversed state of pin BKPx1 is passed to the negative edge detector.
     * |[16]    |BRKP0EN   |BKPx0 Pin Trigger Brake Function0 Enable Control
     * |        |          |0 = PWMx Brake Function 0 Disabled.
     * |        |          |1 = PWMx Brake Function 0 Enabled.
     * |        |          |Note: x=0~1 for PWM unit0~1.
     * |[17]    |BRKP1EN   |BKPx1 Pin Trigger Brake Function Enable Control
     * |        |          |0 = PWMx Brake Function 1 Disabled.
     * |        |          |1 = PWMx Brake Function 1 Enabled.
     * |        |          |Note: x=0~1 for PWM unit0~1.
     * |[18:19] |BRK1SEL   |Brake Function 1 Source Selection
     * |        |          |00 = From external pin BKPx1 (x=0~1 for unit0~1).
     * |        |          |01 = From analog comparator 0 output (CPO0).
     * |        |          |10 = From analog comparator 1 output (CPO1).
     * |        |          |11 = From analog comparator 2 output (CPO2).
     * |[20:21] |BRK0NFSEL |Brake 0 (BKPx0 Pin) Edge Detector Filter Clock Selection
     * |        |          |00 = Filter clock = HCLK.
     * |        |          |01 = Filter clock = HCLK/2.
     * |        |          |10 = Filter clock = HCLK/4.
     * |        |          |11 = Filter clock = HCLK/16.
     * |[22:23] |BRK1NFSEL |Brake 1 (BKPx1 Pin) Edge Detector Filter Clock Selection
     * |        |          |00 = Filter clock = HCLK.
     * |        |          |01 =Filter clock = HCLK/2.
     * |        |          |10 = Filter clock = HCLK/4.
     * |        |          |11 = Filter clock = HCLK/16.
     * |[24]    |CPO0BKEN  |CPO0 Digital Output As Brake0 Source Enable Control
     * |        |          |1 = CPO0 as one brake source in Brake 0 Enabled.
     * |        |          |0 = CPO0 as one brake source in Brake 0 Disabled.
     * |[25]    |CPO1BKEN  |CPO1 Digital Output As Brake 0 Source Enable Control
     * |        |          |0 = CPO1 as one brake source in Brake 0 Disabled.
     * |        |          |1 = CPO1 as one brake source in Brake 0 Enabled.
     * |[26]    |CPO2BKEN  |CPO2 Digital Output As Brake 0 Source Enable Control
     * |        |          |0 = CPO2 as one brake source in Brake 0 Disabled.
     * |        |          |1 = CPO2 as one brake source in Brake 0 Enabled.
     * |[27]    |LVDBKEN   |Low-Level Detection Trigger PWM Brake Function 1 Enable Control
     * |        |          |0 = Brake Function 1 triggered by Low-level detection Disabled.
     * |        |          |1 = Brake Function 1 triggered by Low-level detection Enabled.
     * |[28]    |BRK0NFDIS |PWM Brake 0 Noise Filter Disable Control
     * |        |          |0 = Noise filter of PWM Brake 0 Enabled.
     * |        |          |1 = Noise filter of PWM Brake 0 Disabled.
     * |[29]    |BRK1NFDIS |PWM Brake 1 Noise Filter Disable Control
     * |        |          |0 = Noise filter of PWM Brake 1 Enabled.
     * |        |          |1 = Noise filter of PWM Brake 1 Disabled.
     * |[31]    |CTRLD     |Center Reload Mode Enable Control
     * |        |          |0 = EPWM reload duty register at the period point of PWM counter.
     * |        |          |1 = EPWM reload duty register at the center point of PWM counter.
     * |        |          |This bit only work when EPWM operation at center aligned mode.
    */
    __IO uint32_t CTL;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x04  PWM Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BRKIF0    |PWM Brake0 Flag
     * |        |          |0 = PWM Brake 0 is able to poll falling signal at BKP0 and has not recognized any one.
     * |        |          |1 = When PWM Brake 0 detects a falling signal at BKP0, this flag will be set to high.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[1]     |BRKIF1    |PWM Brake1 Flag
     * |        |          |0 = PWM Brake 1 is able to poll falling signal at BKP1 and has not recognized any one.
     * |        |          |1 = When PWM Brake 1 detects a falling signal at pin BKP1, this flag will be set to high.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[2]     |PIF       |PWM Period Flag
     * |        |          |0 = PWM Counter has not up counted to the value of PERIOD or down counted with underflow.
     * |        |          |1 = Hardware will set this flag to high at the time of PWM Counter matches PERIOD in edge and Centre aligned modes or at the time of PWM Counter down counts with underflow in Centre aligned mode.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[4]     |EIF0      |PWMx0 Edge Flag
     * |        |          |0 = The PWMx0 doesn't toggle.
     * |        |          |1 = Hardware will set this flag to high at the time of PWMx0 rising or falling.
     * |        |          |If EINTTYPE0 = 0, this bit is set when PWMx0 falling is detected.
     * |        |          |If EINTTYPE0 = 1, this bit is set when PWMx0 rising is detected.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[5]     |EIF2      |PWMx2 Edge Flag
     * |        |          |0 = The PWMx2 doesn't toggle.
     * |        |          |1 = Hardware will set this flag to high at the time of PWMx2 rising or falling.
     * |        |          |If EINTTYPE2 = 0, this bit is set when PWMx2 falling is detected.
     * |        |          |If EINTTYPE2 = 1, this bit is set when PWMx2 rising is detected.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[6]     |EIF4      |PWMx4 Edge Flag
     * |        |          |0 = The PWMx4 doesn't toggle.
     * |        |          |1 = Hardware will set this flag to high at the time of PWMx4 rising or falling.
     * |        |          |If EINTTYPE4 = 0, this bit is set when PWMx4 falling is detected.
     * |        |          |If EINTTYPE4 = 1, this bit is set when PWMx4 rising is detected.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[8]     |BRK0LOCK  |PWM Brake0 Locked
     * |        |          |0 = Brake 0 state is released.
     * |        |          |1 = When PWM Brake detects a falling signal at BKP0, this flag will be set to high to indicate the Brake0 state is locked.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[24]    |BRK0STS   |Brake 0 Status (Read Only)
     * |        |          |0 = PWM had been out of Brake 0 state.
     * |        |          |1 = PWM is in Brake 0 state.
     * |[25]    |BRK1STS   |Brake 1 Status (Read Only)
     * |        |          |0 = PWM had been out of Brake 1 state.
     * |        |          |1 = PWM is in Brake 1 state.
    */
    __IO uint32_t STATUS;

    /**
     * PERIOD
     * ===================================================================================================
     * Offset: 0x08  PWM Period Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |PERIOD    |PWM Period Register
     * |        |          |Edge aligned:
     * |        |          |Period = (PERIOD + 1)* EPWMx_CLK period * pre-scalar.
     * |        |          |Duty = (Duty +1 )* EPWMx_CLK period * pre-scalar.
     * |        |          |Centre aligned:
     * |        |          |Period = (PERIOD * 2)* EPWMx_CLK period * pre-scalar.
     * |        |          |Duty = (Duty *2 + 1) * EPWMx_CLK period * pre-scalar.
    */
    __IO uint32_t PERIOD;

    /**
     * CMPDAT0
     * ===================================================================================================
     * Offset: 0x0C  EPWM_CMPDAT0 Duty Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |CMP       |PWM Duty Register
     * |        |          |Edge aligned:
     * |        |          |Period = (PERIOD + 1)* EPWMx_CLK period * pre-scalar.
     * |        |          |Duty = (Duty +1 )* EPWMx_CLK period * pre-scalar.
     * |        |          |Centre aligned:
     * |        |          |Period = (PERIOD * 2)* EPWMx_CLK period * pre-scalar.
     * |        |          |Duty = (Duty *2 + 1) * EPWMx_CLK period * pre-scalar.
    */
    __IO uint32_t CMPDAT[3];

    /**
     * MSKEN
     * ===================================================================================================
     * Offset: 0x18  PWM Mask Mode Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |MSKEN     |PWM Mask Enable Control
     * |        |          |The PWM generator signal will be masked when this bit is enabled.
     * |        |          |The corresponding PWMn channel will be output with PMD.n data.
     * |        |          |0 = PWM generator signal is output to next stage.
     * |        |          |1 = PWM generator signal is masked and PMD.n is output to next stage.
     * |        |          |Note: n = 0~5.
    */
    __IO uint32_t MSKEN;

    /**
     * MSK
     * ===================================================================================================
     * Offset: 0x1C  PWM Mask Mode Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |MSKDAT    |PWM Mask Data Bit
     * |        |          |This data bit control the state of PWMn output pin, if the corresponding PME.n = 1.
     * |        |          |0 = Output logic low to PWMn.
     * |        |          |1 = Output logic high to PWMn.
     * |        |          |Note: n = 0~5.
    */
    __IO uint32_t MSK;

    /**
     * ASYMCMP0
     * ===================================================================================================
     * Offset: 0x20  Asymmetric EPWM_CMPDAT0 Duty Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |CMP       |Asymmetric PWM Duty Register
     * |        |          |When the asymmetric PWM function is enabled, this 16-bit field determines the second time compared value after PWM counter has matched with PWM_Duty in the first half PWM cycle.
    */
    __IO uint32_t ASYMCMP0;

    /**
     * ASYMCMP2
     * ===================================================================================================
     * Offset: 0x24  Asymmetric EPWM_CMPDAT2 Duty Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |CMP       |Asymmetric PWM Duty Register
     * |        |          |When the asymmetric PWM function is enabled, this 16-bit field determines the second time compared value after PWM counter has matched with PWM_Duty in the first half PWM cycle.
    */
    __IO uint32_t ASYMCMP2;

    /**
     * ASYMCMP4
     * ===================================================================================================
     * Offset: 0x28  Asymmetric EPWM_CMPDAT4 Duty Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |CMP       |Asymmetric PWM Duty Register
     * |        |          |When the asymmetric PWM function is enabled, this 16-bit field determines the second time compared value after PWM counter has matched with PWM_Duty in the first half PWM cycle.
    */
    __IO uint32_t ASYMCMP4;

    /**
     * DTCTL
     * ===================================================================================================
     * Offset: 0x2C  PWM Dead-time Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:10]  |DTCNT     |Dead-Time Counter
     * |        |          |The dead-time can be calculated from the following formula:
     * |        |          |Dead-time = EPWMx_CLK period * (DTCNT.[10:0]+1).
     * |[16]    |DTEN0     |Dead-Time Insertion Enable Control For PWMx Pair (PWM0, PWM1)
     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
     * |        |          |If dead-time insertion is inactive, the outputs of pin pair are complementary without any delay.
     * |        |          |0 = Dead-time insertion Disabled on the pin pair (PWM0, PWM1).
     * |        |          |1 = Dead-time insertion Enabled on the pin pair (PWM0, PWM1).
     * |        |          |Note: x=0~1 for PWM unit0~1.
     * |[17]    |DTEN2     |Dead-Time Insertion Enable Control For PWMx Pair (PWM2, PWM3)
     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
     * |        |          |If dead-time insertion is inactive, the outputs of pin pair are complementary without any delay.
     * |        |          |0 = Dead-time insertion Disabled on the pin pair (PWM2, PWM3).
     * |        |          |1 = Dead-time insertion Enabled on the pin pair (PWM2, PWM3).
     * |        |          |Note: x=0~1 for PWM unit0~1.
     * |[18]    |DTEN4     |Dead-Time Insertion Enable Control For PWMx Pair (PWM4, PWM5)
     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
     * |        |          |If dead-time insertion is inactive, the outputs of pin pair are complementary without any delay.
     * |        |          |0 = Dead-time insertion Disabled on the pin pair (PWM4, PWM5).
     * |        |          |1 = Dead-time insertion Enabled on the pin pair (PWM4, PWM5).
     * |        |          |Note: x=0~1 for PWM unit0~1.
    */
    __IO uint32_t DTCTL;

    /**
     * BRKOUT
     * ===================================================================================================
     * Offset: 0x30  PWM Brake Output
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |BRKOUT    |PWM Brake Output
     * |        |          |When PWM Brake is asserted, the PWM0~5 output state before polarity control will follow PWM1 bit0~5 setting, respectively.
     * |        |          |0 = The PWMn output before polarity control is low when Brake is asserted.
     * |        |          |1 = The PWMn output before polarity control is high when Brake is asserted.
     * |        |          |Note: n = 0~5.
    */
    __IO uint32_t BRKOUT;

    /**
     * NPCTL
     * ===================================================================================================
     * Offset: 0x34  PWM Negative Polarity Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |NEGPOLAR  |PWM Negative Polarity Control
     * |        |          |The register bit controls polarity/active state of real PWM output.
     * |        |          |0 = PWMn output is active high.
     * |        |          |1 = PWMn output is active low.
     * |        |          |Note: n = 0~5.
    */
    __IO uint32_t NPCTL;

    /**
     * ASYMCTL
     * ===================================================================================================
     * Offset: 0x38  Asymmetric PWM Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ASYMEN    |Asymmetric PWM Enable Control
     * |        |          |0 = Asymmetric PWM function Disabled.
     * |        |          |1 = Asymmetric PWM function Enabled.
     * |        |          |Note: This control bit is only valid when PWM module is set in Centre-aligned mode.
     * |[8:9]   |ASYMMODE0 |Asymmetric PWMx0 Reload Mode Setting
     * |        |          |00 = 1. PWM compare register 0 is reload PWM_Duty (PWMx0[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 0 in up-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register 0 is reloaded with CMP (ASPWMx0[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 0 in down-counting cycle.
     * |        |          |01 = 1. PWM compare register 0 is reload PWM_Duty (PWMx0[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 0 in up-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register 0 is reloaded with CMP (ASPWMx0[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 0 in up-counting cycle.
     * |        |          | 5. PWMx0 must be less than ASPWMx0
     * |        |          |10 = 1. PWM compare register 0 is reload PWM_Duty (PWMx0[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 0 in down-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register 0 is reloaded with CMP (ASPWMx0[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 0 in down-counting cycle.
     * |        |          | 5. PWMx0 must be greater than ASPWMx0.
     * |        |          |11 = Reserved.
     * |        |          |Note1: x=0~1 for PWM unit 0~1.
     * |        |          |Note2: This bit field is available only when ASYMEN=1.
     * |        |          |Note3: The setting will be effected at the condition of LOAD=1 and from the start of next PWM cycle.
     * |[16:17] |ASYMMODE2 |Asymmetric PWMx2 Reload Mode Setting
     * |        |          |00 = 1. PWM compare register 2 is reload PWM_Duty (PWMx2[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 2 in up-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register 2 is reloaded with CMP (ASPWMx2[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 2 in down-counting cycle.
     * |        |          |01 = 1. PWM compare register 2 is reload PWM_Duty (PWMx2[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 2 in up-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register2 is reloaded with CMP (ASPWMx2[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 2 in up-counting cycle.
     * |        |          | 5. PWMx2 must be less than ASPWMx2
     * |        |          |10 = 1. PWM compare register 2 is reload PWM_Duty (PWMx2[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 2 in down-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register 2 is reloaded with CMP (ASPWMx2[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 2 in down-counting cycle.
     * |        |          | 5. PWMx2 must be greater than ASPWMx2.
     * |        |          |11 = Reserved.
     * |        |          |Note1: x=0~1 for PWM unit 0~1.
     * |        |          |Note2: This bit field is available only when ASYMEN=1.
     * |        |          |Note3: The setting will be effected at the condition of LOAD=1 and from the start of next PWM cycle.
     * |[24:25] |ASYMMODE4 |Asymmetric PWMx4 Reload Mode Setting
     * |        |          |00 =  1. PWM compare register 4 is reload PWM_Duty (PWMx4[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 4 in up-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register 4 is reloaded with CMP (ASPWMx4[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 4 in down-counting cycle.
     * |        |          |01 = 1. PWM compare register 4 is reload PWM_Duty (PWMx4[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 4 in up-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register 0 is reloaded with CMP (ASPWMx4[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 4 in up-counting cycle.
     * |        |          | 5. PWMx4 must be less than ASPWMx4.
     * |        |          |10 = 1. PWM compare register 4 is reload PWM_Duty (PWMx4[15:0]) at PWM cycle start.
     * |        |          | 2. PWM module compares the PWM counter (PWMCNT) with PWM compare register 4 in down-counting cycle
     * |        |          |3.
     * |        |          |PWM compare output toggles at compare match, in the meanwhile, PWM compare register 4 is reloaded with CMP (ASPWMx4[15:00]).
     * |        |          | 4. PWM module compares the PWM counter (PWMCNT) with PWM compare register 4 in down-counting cycle.
     * |        |          | 5. PWMx4 must be greater than ASPWMx4.
     * |        |          |11= Reserved.
     * |        |          |Note1: x=0~1 for PWM unit 0~1.
     * |        |          |Note2: This bit field is available only when ASYMEN=1.
     * |        |          |Note3: The setting will be effected at the condition of LOAD=1 and from the start of next PWM cycle.
    */
    __IO uint32_t ASYMCTL;

    /**
     * PERIODCNT
     * ===================================================================================================
     * Offset: 0x3C  PIF Compared Counter
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PERIODCNT |PIF Compared Counter
     * |        |          |The register sets the count number which defines how many times of PWM period occurs to set bit PIF to request the PWM period interrupt.
     * |        |          |PIF will be set in every (1 + PERIODCNT[3:0]) times of PWM period or center point defined by INTTYPE when EPWM_CTL [8] occurred.
    */
    __IO uint32_t PERIODCNT;

    /**
     * EINTCTL
     * ===================================================================================================
     * Offset: 0x40  PWM Edge Interrupt Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EDGEIEN0  |PWMx0 Edge Interrupt Enable Control
     * |        |          |0 = Disabling flag EIF0 to trigger PWM interrupt.
     * |        |          |1 = Enabling flag EIF0 can trigger PWM interrupt.
     * |[1]     |EDGEIEN2  |PWMx2 Edge Interrupt Enable Control
     * |        |          |0 = Disabling flag EIF2 can trigger PWM interrupt.
     * |        |          |1 = Enabling flag EIF2 can trigger PWM interrupt.
     * |[2]     |EDGEIEN4  |PWMx4 Edge Interrupt Enable Control
     * |        |          |0 = Disable flag EIF4 to trigger PWM interrupt.
     * |        |          |1 = Enabling flag EIF4 can trigger PWM interrupt.
     * |[8]     |EINTTYPE0 |PWMx0 Edge Interrupt Type
     * |        |          |0 = EIF0 will be set if falling edge is detected at PWMx0.
     * |        |          |1 = EIF0 will be set if rising edge is detected at PWMx0.
     * |[9]     |EINTTYPE2 |PWMx2 Edge Interrupt Type
     * |        |          |0 = EIF2 will be set if falling edge is detected at PWMx2.
     * |        |          |1 = EIF2 will be set if rising edge is detected at PWMx2.
     * |[10]    |EINTTYPE4 |PWMx4 Edge Interrupt Type
     * |        |          |0 = EIF4 will be set if falling edge is detected at PWMx4.
     * |        |          |1 = EIF4 will be set if rising edge is detected at PWMx4.
    */
    __IO uint32_t EINTCTL;

    /**
     * OUTEN0
     * ===================================================================================================
     * Offset: 0x44  PWM Output Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EVENOUTEN |PWM Even Ports Output Enable Control
     * |        |          |0 = PWM even ports output Disabled (PWM even ports at tri-state).
     * |        |          |1 = PWM even ports output Enabled.
     * |[1]     |ODDOUTEN  |PWM Odd Ports Output Enable Control
     * |        |          |0 = PWM odd ports output Disabled (PWM even ports at tri-state).
     * |        |          |1 = PWM odd ports output Enabled.
    */
    __IO uint32_t OUTEN0;

} EPWM_T;

/**
    @addtogroup EPWM_CONST EPWM Bit Field Definition
    Constant Definitions for EPWM Controller
@{ */

#define EPWM_CTL_MODE_Pos                (0)                                               /*!< EPWM_T::CTL: MODE Position                */
#define EPWM_CTL_MODE_Msk                (0x3ul << EPWM_CTL_MODE_Pos)                      /*!< EPWM_T::CTL: MODE Mask                    */

#define EPWM_CTL_CLKDIV_Pos              (2)                                               /*!< EPWM_T::CTL: CLKDIV Position              */
#define EPWM_CTL_CLKDIV_Msk              (0x3ul << EPWM_CTL_CLKDIV_Pos)                    /*!< EPWM_T::CTL: CLKDIV Mask                  */

#define EPWM_CTL_PWMIEN_Pos              (4)                                               /*!< EPWM_T::CTL: PWMIEN Position              */
#define EPWM_CTL_PWMIEN_Msk              (0x1ul << EPWM_CTL_PWMIEN_Pos)                    /*!< EPWM_T::CTL: PWMIEN Mask                  */

#define EPWM_CTL_BRKIEN_Pos              (5)                                               /*!< EPWM_T::CTL: BRKIEN Position              */
#define EPWM_CTL_BRKIEN_Msk              (0x1ul << EPWM_CTL_BRKIEN_Pos)                    /*!< EPWM_T::CTL: BRKIEN Mask                  */

#define EPWM_CTL_LOAD_Pos                (6)                                               /*!< EPWM_T::CTL: LOAD Position                */
#define EPWM_CTL_LOAD_Msk                (0x1ul << EPWM_CTL_LOAD_Pos)                      /*!< EPWM_T::CTL: LOAD Mask                    */

#define EPWM_CTL_CNTEN_Pos               (7)                                               /*!< EPWM_T::CTL: CNTEN Position               */
#define EPWM_CTL_CNTEN_Msk               (0x1ul << EPWM_CTL_CNTEN_Pos)                     /*!< EPWM_T::CTL: CNTEN Mask                   */

#define EPWM_CTL_INTTYPE_Pos             (8)                                               /*!< EPWM_T::CTL: INTTYPE Position             */
#define EPWM_CTL_INTTYPE_Msk             (0x1ul << EPWM_CTL_INTTYPE_Pos)                   /*!< EPWM_T::CTL: INTTYPE Mask                 */

#define EPWM_CTL_PINV_Pos                (9)                                               /*!< EPWM_T::CTL: PINV Position                */
#define EPWM_CTL_PINV_Msk                (0x1ul << EPWM_CTL_PINV_Pos)                      /*!< EPWM_T::CTL: PINV Mask                    */

#define EPWM_CTL_CNTCLR_Pos              (11)                                              /*!< EPWM_T::CTL: CNTCLR Position              */
#define EPWM_CTL_CNTCLR_Msk              (0x1ul << EPWM_CTL_CNTCLR_Pos)                    /*!< EPWM_T::CTL: CNTCLR Mask                  */

#define EPWM_CTL_CNTTYPE_Pos             (12)                                              /*!< EPWM_T::CTL: CNTTYPE Position             */
#define EPWM_CTL_CNTTYPE_Msk             (0x1ul << EPWM_CTL_CNTTYPE_Pos)                   /*!< EPWM_T::CTL: CNTTYPE Mask                 */

#define EPWM_CTL_GROUPEN_Pos             (13)                                              /*!< EPWM_T::CTL: GROUPEN Position             */
#define EPWM_CTL_GROUPEN_Msk             (0x1ul << EPWM_CTL_GROUPEN_Pos)                   /*!< EPWM_T::CTL: GROUPEN Mask                 */

#define EPWM_CTL_BRKP0INV_Pos            (14)                                              /*!< EPWM_T::CTL: BRKP0INV Position            */
#define EPWM_CTL_BRKP0INV_Msk            (0x1ul << EPWM_CTL_BRKP0INV_Pos)                  /*!< EPWM_T::CTL: BRKP0INV Mask                */

#define EPWM_CTL_BRKP1INV_Pos            (15)                                              /*!< EPWM_T::CTL: BRKP1INV Position            */
#define EPWM_CTL_BRKP1INV_Msk            (0x1ul << EPWM_CTL_BRKP1INV_Pos)                  /*!< EPWM_T::CTL: BRKP1INV Mask                */

#define EPWM_CTL_BRKP0EN_Pos             (16)                                              /*!< EPWM_T::CTL: BRKP0EN Position             */
#define EPWM_CTL_BRKP0EN_Msk             (0x1ul << EPWM_CTL_BRKP0EN_Pos)                   /*!< EPWM_T::CTL: BRKP0EN Mask                 */

#define EPWM_CTL_BRKP1EN_Pos             (17)                                              /*!< EPWM_T::CTL: BRKP1EN Position             */
#define EPWM_CTL_BRKP1EN_Msk             (0x1ul << EPWM_CTL_BRKP1EN_Pos)                   /*!< EPWM_T::CTL: BRKP1EN Mask                 */

#define EPWM_CTL_BRK1SEL_Pos             (18)                                              /*!< EPWM_T::CTL: BRK1SEL Position             */
#define EPWM_CTL_BRK1SEL_Msk             (0x3ul << EPWM_CTL_BRK1SEL_Pos)                   /*!< EPWM_T::CTL: BRK1SEL Mask                 */

#define EPWM_CTL_BRK0NFSEL_Pos           (20)                                              /*!< EPWM_T::CTL: BRK0NFSEL Position           */
#define EPWM_CTL_BRK0NFSEL_Msk           (0x3ul << EPWM_CTL_BRK0NFSEL_Pos)                 /*!< EPWM_T::CTL: BRK0NFSEL Mask               */

#define EPWM_CTL_BRK1NFSEL_Pos           (22)                                              /*!< EPWM_T::CTL: BRK1NFSEL Position           */
#define EPWM_CTL_BRK1NFSEL_Msk           (0x3ul << EPWM_CTL_BRK1NFSEL_Pos)                 /*!< EPWM_T::CTL: BRK1NFSEL Mask               */

#define EPWM_CTL_CPO0BKEN_Pos            (24)                                              /*!< EPWM_T::CTL: CPO0BKEN Position            */
#define EPWM_CTL_CPO0BKEN_Msk            (0x1ul << EPWM_CTL_CPO0BKEN_Pos)                  /*!< EPWM_T::CTL: CPO0BKEN Mask                */

#define EPWM_CTL_CPO1BKEN_Pos            (25)                                              /*!< EPWM_T::CTL: CPO1BKEN Position            */
#define EPWM_CTL_CPO1BKEN_Msk            (0x1ul << EPWM_CTL_CPO1BKEN_Pos)                  /*!< EPWM_T::CTL: CPO1BKEN Mask                */

#define EPWM_CTL_CPO2BKEN_Pos            (26)                                              /*!< EPWM_T::CTL: CPO2BKEN Position            */
#define EPWM_CTL_CPO2BKEN_Msk            (0x1ul << EPWM_CTL_CPO2BKEN_Pos)                  /*!< EPWM_T::CTL: CPO2BKEN Mask                */

#define EPWM_CTL_LVDBKEN_Pos             (27)                                              /*!< EPWM_T::CTL: LVDBKEN Position             */
#define EPWM_CTL_LVDBKEN_Msk             (0x1ul << EPWM_CTL_LVDBKEN_Pos)                   /*!< EPWM_T::CTL: LVDBKEN Mask                 */

#define EPWM_CTL_BRK0NFDIS_Pos           (28)                                              /*!< EPWM_T::CTL: BRK0NFDIS Position           */
#define EPWM_CTL_BRK0NFDIS_Msk           (0x1ul << EPWM_CTL_BRK0NFDIS_Pos)                 /*!< EPWM_T::CTL: BRK0NFDIS Mask               */

#define EPWM_CTL_BRK1NFDIS_Pos           (29)                                              /*!< EPWM_T::CTL: BRK1NFDIS Position           */
#define EPWM_CTL_BRK1NFDIS_Msk           (0x1ul << EPWM_CTL_BRK1NFDIS_Pos)                 /*!< EPWM_T::CTL: BRK1NFDIS Mask               */

#define EPWM_CTL_CTRLD_Pos               (31)                                              /*!< EPWM_T::CTL: CTRLD Position               */
#define EPWM_CTL_CTRLD_Msk               (0x1ul << EPWM_CTL_CTRLD_Pos)                     /*!< EPWM_T::CTL: CTRLD Mask                   */

#define EPWM_STATUS_BRKIF0_Pos           (0)                                               /*!< EPWM_T::STATUS: BRKIF0 Position           */
#define EPWM_STATUS_BRKIF0_Msk           (0x1ul << EPWM_STATUS_BRKIF0_Pos)                 /*!< EPWM_T::STATUS: BRKIF0 Mask               */

#define EPWM_STATUS_BRKIF1_Pos           (1)                                               /*!< EPWM_T::STATUS: BRKIF1 Position           */
#define EPWM_STATUS_BRKIF1_Msk           (0x1ul << EPWM_STATUS_BRKIF1_Pos)                 /*!< EPWM_T::STATUS: BRKIF1 Mask               */

#define EPWM_STATUS_PIF_Pos              (2)                                               /*!< EPWM_T::STATUS: PIF Position              */
#define EPWM_STATUS_PIF_Msk              (0x1ul << EPWM_STATUS_PIF_Pos)                    /*!< EPWM_T::STATUS: PIF Mask                  */

#define EPWM_STATUS_EIF0_Pos             (4)                                               /*!< EPWM_T::STATUS: EIF0 Position             */
#define EPWM_STATUS_EIF0_Msk             (0x1ul << EPWM_STATUS_EIF0_Pos)                   /*!< EPWM_T::STATUS: EIF0 Mask                 */

#define EPWM_STATUS_EIF2_Pos             (5)                                               /*!< EPWM_T::STATUS: EIF2 Position             */
#define EPWM_STATUS_EIF2_Msk             (0x1ul << EPWM_STATUS_EIF2_Pos)                   /*!< EPWM_T::STATUS: EIF2 Mask                 */

#define EPWM_STATUS_EIF4_Pos             (6)                                               /*!< EPWM_T::STATUS: EIF4 Position             */
#define EPWM_STATUS_EIF4_Msk             (0x1ul << EPWM_STATUS_EIF4_Pos)                   /*!< EPWM_T::STATUS: EIF4 Mask                 */

#define EPWM_STATUS_BRK0LOCK_Pos         (8)                                               /*!< EPWM_T::STATUS: BRK0LOCK Position         */
#define EPWM_STATUS_BRK0LOCK_Msk         (0x1ul << EPWM_STATUS_BRK0LOCK_Pos)               /*!< EPWM_T::STATUS: BRK0LOCK Mask             */

#define EPWM_STATUS_BRK0STS_Pos          (24)                                              /*!< EPWM_T::STATUS: BRK0STS Position          */
#define EPWM_STATUS_BRK0STS_Msk          (0x1ul << EPWM_STATUS_BRK0STS_Pos)                /*!< EPWM_T::STATUS: BRK0STS Mask              */

#define EPWM_STATUS_BRK1STS_Pos          (25)                                              /*!< EPWM_T::STATUS: BRK1STS Position          */
#define EPWM_STATUS_BRK1STS_Msk          (0x1ul << EPWM_STATUS_BRK1STS_Pos)                /*!< EPWM_T::STATUS: BRK1STS Mask              */

#define EPWM_PERIOD_PERIOD_Pos           (0)                                               /*!< EPWM_T::PERIOD: PERIOD Position           */
#define EPWM_PERIOD_PERIOD_Msk           (0xfffful << EPWM_PERIOD_PERIOD_Pos)              /*!< EPWM_T::PERIOD: PERIOD Mask               */

#define EPWM_CMPDAT0_CMP_Pos             (0)                                               /*!< EPWM_T::CMPDAT0: CMP Position             */
#define EPWM_CMPDAT0_CMP_Msk             (0xfffful << EPWM_CMPDAT0_CMP_Pos)                /*!< EPWM_T::CMPDAT0: CMP Mask                 */

#define EPWM_CMPDAT2_CMP_Pos             (0)                                               /*!< EPWM_T::CMPDAT2: CMP Position             */
#define EPWM_CMPDAT2_CMP_Msk             (0xfffful << EPWM_CMPDAT2_CMP_Pos)                /*!< EPWM_T::CMPDAT2: CMP Mask                 */

#define EPWM_CMPDAT4_CMP_Pos             (0)                                               /*!< EPWM_T::CMPDAT4: CMP Position             */
#define EPWM_CMPDAT4_CMP_Msk             (0xfffful << EPWM_CMPDAT4_CMP_Pos)                /*!< EPWM_T::CMPDAT4: CMP Mask                 */

#define EPWM_MSKEN_MSKEN_Pos             (0)                                               /*!< EPWM_T::MSKEN: MSKEN Position             */
#define EPWM_MSKEN_MSKEN_Msk             (0x3ful << EPWM_MSKEN_MSKEN_Pos)                  /*!< EPWM_T::MSKEN: MSKEN Mask                 */

#define EPWM_MSK_MSKDAT_Pos              (0)                                               /*!< EPWM_T::MSK: MSKDAT Position              */
#define EPWM_MSK_MSKDAT_Msk              (0x3ful << EPWM_MSK_MSKDAT_Pos)                   /*!< EPWM_T::MSK: MSKDAT Mask                  */

#define EPWM_ASYMCMP0_CMP_Pos            (0)                                               /*!< EPWM_T::ASYMCMP0: CMP Position            */
#define EPWM_ASYMCMP0_CMP_Msk            (0xfffful << EPWM_ASYMCMP0_CMP_Pos)               /*!< EPWM_T::ASYMCMP0: CMP Mask                */

#define EPWM_ASYMCMP2_CMP_Pos            (0)                                               /*!< EPWM_T::ASYMCMP2: CMP Position            */
#define EPWM_ASYMCMP2_CMP_Msk            (0xfffful << EPWM_ASYMCMP2_CMP_Pos)               /*!< EPWM_T::ASYMCMP2: CMP Mask                */

#define EPWM_ASYMCMP4_CMP_Pos            (0)                                               /*!< EPWM_T::ASYMCMP4: CMP Position            */
#define EPWM_ASYMCMP4_CMP_Msk            (0xfffful << EPWM_ASYMCMP4_CMP_Pos)               /*!< EPWM_T::ASYMCMP4: CMP Mask                */

#define EPWM_DTCTL_DTCNT_Pos             (0)                                               /*!< EPWM_T::DTCTL: DTCNT Position             */
#define EPWM_DTCTL_DTCNT_Msk             (0x7fful << EPWM_DTCTL_DTCNT_Pos)                 /*!< EPWM_T::DTCTL: DTCNT Mask                 */

#define EPWM_DTCTL_DTEN0_Pos             (16)                                              /*!< EPWM_T::DTCTL: DTEN0 Position             */
#define EPWM_DTCTL_DTEN0_Msk             (0x1ul << EPWM_DTCTL_DTEN0_Pos)                   /*!< EPWM_T::DTCTL: DTEN0 Mask                 */

#define EPWM_DTCTL_DTEN2_Pos             (17)                                              /*!< EPWM_T::DTCTL: DTEN2 Position             */
#define EPWM_DTCTL_DTEN2_Msk             (0x1ul << EPWM_DTCTL_DTEN2_Pos)                   /*!< EPWM_T::DTCTL: DTEN2 Mask                 */

#define EPWM_DTCTL_DTEN4_Pos             (18)                                              /*!< EPWM_T::DTCTL: DTEN4 Position             */
#define EPWM_DTCTL_DTEN4_Msk             (0x1ul << EPWM_DTCTL_DTEN4_Pos)                   /*!< EPWM_T::DTCTL: DTEN4 Mask                 */

#define EPWM_BRKOUT_BRKOUT_Pos           (0)                                               /*!< EPWM_T::BRKOUT: BRKOUT Position           */
#define EPWM_BRKOUT_BRKOUT_Msk           (0x3ful << EPWM_BRKOUT_BRKOUT_Pos)                /*!< EPWM_T::BRKOUT: BRKOUT Mask               */

#define EPWM_NPCTL_NEGPOLAR_Pos          (0)                                               /*!< EPWM_T::NPCTL: NEGPOLAR Position          */
#define EPWM_NPCTL_NEGPOLAR_Msk          (0x3ful << EPWM_NPCTL_NEGPOLAR_Pos)               /*!< EPWM_T::NPCTL: NEGPOLAR Mask              */

#define EPWM_ASYMCTL_ASYMEN_Pos          (0)                                               /*!< EPWM_T::ASYMCTL: ASYMEN Position          */
#define EPWM_ASYMCTL_ASYMEN_Msk          (0x1ul << EPWM_ASYMCTL_ASYMEN_Pos)                /*!< EPWM_T::ASYMCTL: ASYMEN Mask              */

#define EPWM_ASYMCTL_ASYMMODE0_Pos       (8)                                               /*!< EPWM_T::ASYMCTL: ASYMMODE0 Position       */
#define EPWM_ASYMCTL_ASYMMODE0_Msk       (0x3ul << EPWM_ASYMCTL_ASYMMODE0_Pos)             /*!< EPWM_T::ASYMCTL: ASYMMODE0 Mask           */

#define EPWM_ASYMCTL_ASYMMODE2_Pos       (16)                                              /*!< EPWM_T::ASYMCTL: ASYMMODE2 Position       */
#define EPWM_ASYMCTL_ASYMMODE2_Msk       (0x3ul << EPWM_ASYMCTL_ASYMMODE2_Pos)             /*!< EPWM_T::ASYMCTL: ASYMMODE2 Mask           */

#define EPWM_ASYMCTL_ASYMMODE4_Pos       (24)                                              /*!< EPWM_T::ASYMCTL: ASYMMODE4 Position       */
#define EPWM_ASYMCTL_ASYMMODE4_Msk       (0x3ul << EPWM_ASYMCTL_ASYMMODE4_Pos)             /*!< EPWM_T::ASYMCTL: ASYMMODE4 Mask           */

#define EPWM_PERIODCNT_PERIODCNT_Pos     (0)                                               /*!< EPWM_T::PERIODCNT: PERIODCNT Position     */
#define EPWM_PERIODCNT_PERIODCNT_Msk     (0xful << EPWM_PERIODCNT_PERIODCNT_Pos)           /*!< EPWM_T::PERIODCNT: PERIODCNT Mask         */

#define EPWM_EINTCTL_EDGEIEN0_Pos        (0)                                               /*!< EPWM_T::EINTCTL: EDGEIEN0 Position        */
#define EPWM_EINTCTL_EDGEIEN0_Msk        (0x1ul << EPWM_EINTCTL_EDGEIEN0_Pos)              /*!< EPWM_T::EINTCTL: EDGEIEN0 Mask            */

#define EPWM_EINTCTL_EDGEIEN2_Pos        (1)                                               /*!< EPWM_T::EINTCTL: EDGEIEN2 Position        */
#define EPWM_EINTCTL_EDGEIEN2_Msk        (0x1ul << EPWM_EINTCTL_EDGEIEN2_Pos)              /*!< EPWM_T::EINTCTL: EDGEIEN2 Mask            */

#define EPWM_EINTCTL_EDGEIEN4_Pos        (2)                                               /*!< EPWM_T::EINTCTL: EDGEIEN4 Position        */
#define EPWM_EINTCTL_EDGEIEN4_Msk        (0x1ul << EPWM_EINTCTL_EDGEIEN4_Pos)              /*!< EPWM_T::EINTCTL: EDGEIEN4 Mask            */

#define EPWM_EINTCTL_EINTTYPE0_Pos       (8)                                               /*!< EPWM_T::EINTCTL: EINTTYPE0 Position       */
#define EPWM_EINTCTL_EINTTYPE0_Msk       (0x1ul << EPWM_EINTCTL_EINTTYPE0_Pos)             /*!< EPWM_T::EINTCTL: EINTTYPE0 Mask           */

#define EPWM_EINTCTL_EINTTYPE2_Pos       (9)                                               /*!< EPWM_T::EINTCTL: EINTTYPE2 Position       */
#define EPWM_EINTCTL_EINTTYPE2_Msk       (0x1ul << EPWM_EINTCTL_EINTTYPE2_Pos)             /*!< EPWM_T::EINTCTL: EINTTYPE2 Mask           */

#define EPWM_EINTCTL_EINTTYPE4_Pos       (10)                                              /*!< EPWM_T::EINTCTL: EINTTYPE4 Position       */
#define EPWM_EINTCTL_EINTTYPE4_Msk       (0x1ul << EPWM_EINTCTL_EINTTYPE4_Pos)             /*!< EPWM_T::EINTCTL: EINTTYPE4 Mask           */

#define EPWM_OUTEN0_EVENOUTEN_Pos        (0)                                               /*!< EPWM_T::OUTEN0: EVENOUTEN Position        */
#define EPWM_OUTEN0_EVENOUTEN_Msk        (0x1ul << EPWM_OUTEN0_EVENOUTEN_Pos)              /*!< EPWM_T::OUTEN0: EVENOUTEN Mask            */

#define EPWM_OUTEN0_ODDOUTEN_Pos         (1)                                               /*!< EPWM_T::OUTEN0: ODDOUTEN Position         */
#define EPWM_OUTEN0_ODDOUTEN_Msk         (0x1ul << EPWM_OUTEN0_ODDOUTEN_Pos)               /*!< EPWM_T::OUTEN0: ODDOUTEN Mask             */

/**@}*/ /* EPWM_CONST */
/**@}*/ /* end of EPWM register group */


/*---------------------- Flash Memory Controller -------------------------*/
/**
    @addtogroup FMC Flash Memory Controller(FMC)
    Memory Mapped Structure for FMC Controller
@{ */

typedef struct {
    /**
     * ISPCTL
     * ===================================================================================================
     * Offset: 0x00  ISP Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ISPEN     |ISP Enable Control (Write Protect)
     * |        |          |ISP function enable bit. Set this bit to enable ISP function.
     * |        |          |0 = ISP function Disabled.
     * |        |          |1 = ISP function Enabled.
     * |[1]     |BS        |Boot Select (Write Protect)
     * |        |          |Set/clear this bit to select next booting from LDROM/APROM, respectively.
     * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from.
     * |        |          |This bit is initiated with the inversed value of CBS in Config0 after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened.
     * |        |          |0 = Boot from APROM.
     * |        |          |1 = Boot from LDROM.
     * |[3]     |APUEN     |APROM Update Enable Control (Write Protect)
     * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
     * |        |          |1 = APROM can be updated when the chip runs in APROM.
     * |[4]     |CFGUEN    |Config-Bits Update By ISP (Write Protect) Enable Control
     * |        |          |0 = ISP Disabled to update config-bits.
     * |        |          |1 = ISP Enabled to update config-bits at KEYMATCH flag active (bit7 of ISPSTS).
     * |        |          |Note: This bit is fixed to 0 in Secure mode.
     * |[5]     |LDUEN     |LDROM Update Enable Control (Write Protect)
     * |        |          |LDROM update enable bit.
     * |        |          |0 = LDROM cannot be updated.
     * |        |          |1 = LDROM can be updated at KEYMATCH flag active (bit7 of ISPSTS).
     * |        |          |Note: This bit is fixed to 0 in Secure mode.
     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
     * |        |          |(4) Destination address is illegal, such as over an available range.
     * |        |          |Note: This bit needs to be cleared by writing 1 to it.
    */
    __IO uint32_t ISPCTL;

    /**
     * ISPADDR
     * ===================================================================================================
     * Offset: 0x04  ISP Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ISPADR    |ISP Address
     * |        |          |The NUC442/NUC472 series is equipped with an embedded flash and supports word program only.
     * |        |          |ISPADR[1:0] must be kept 00b for ISP operation.
    */
    __IO uint32_t ISPADDR;

    /**
     * ISPDAT
     * ===================================================================================================
     * Offset: 0x08  ISP Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ISPDAT    |ISP Data
     * |        |          |Write data to this register before ISP program operation.
     * |        |          |Read data from this register after ISP read operation.
    */
    __IO uint32_t ISPDAT;

    /**
     * ISPCMD
     * ===================================================================================================
     * Offset: 0x0C  ISP Command Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |CMD       |ISP Command
     * |        |          |Please check the table below for ISP commands.
    */
    __IO uint32_t ISPCMD;

    /**
     * ISPTRG
     * ===================================================================================================
     * Offset: 0x10  ISP Trigger Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ISPGO     |ISP Start Trigger
     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
     * |        |          |0 = ISP operation is finished.
     * |        |          |1 = ISP is progressed.
     * |        |          |This bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
    */
    __IO uint32_t ISPTRG;

    /**
     * DFBA
     * ===================================================================================================
     * Offset: 0x14  Data Flash Base Address
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DFBA      |Data Flash Base Address
     * |        |          |This register indicates data flash start address. It is a read only register.
     * |        |          |The data flash is shared with APROM and data flash size is defined by user configuration and the content of this register is loaded from Config1.
    */
    __I  uint32_t DFBA;

    /**
     * FTCTL
     * ===================================================================================================
     * Offset: 0x18  Flash Access Time Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[4:6]   |FOM       |Frequency Optimization Mode (Write Protect)
     * |        |          |When chip operation frequency is lower, chip can work more efficiently by setting FOM bits
     * |        |          |FOM[2:0]
     * |        |          |Optimized   Frequency (OF)
     * |        |          |001
     * |        |          |0   MHz < OF <= 24 MHz
     * |        |          |010
     * |        |          |24   MHz < OF <= 48 MHz
     * |        |          |011
     * |        |          |48   MHz < OF <= 72 MHz
     * |        |          |others
     * |        |          |Reserved
    */
    __IO uint32_t FTCTL;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[9];
    /// @endcond //HIDDEN_SYMBOLS

    /**
     * ISPSTS
     * ===================================================================================================
     * Offset: 0x40  Flash Access Time Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ISPBUSY   |ISP busy flag
     * |        |          |0 = ISP operation is finished.
     * |        |          |1 = ISP is progressed.
     * |[2:1]   |CBS       |Chip boot selection mode
     * |        |          |This CBS field is just a copy of User-Configuration Config0 CBS[7:6].
     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
     * |        |          |(4) Destination address is illegal, such as over an available range.
     * |        |          |Note: This bit needs to be cleared by writing 1 to it.
     * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
     * |        |          |The current flash address space 0x0000_0000~0x0000_07FF is mapping to
     * |        |          |address {VECMAP[11:2], 11h000} ~ {VECMAP[11:2], 11h7FF}
     * |        |          |VECMAP[1:0] is needed to set 0.
     * |[26]    |CFGCRCF   |User-Configuration CRC Check Flag (Read Only)
     * |        |          |This bit is set by hardware when detecting CONFIG CRC checksum is error
     * |        |          |0 = CONFIG CRC checksum is OK.
     * |        |          |1 = CONFIG CRC checksum error and force chip into LOCK mode.
    */
    __IO uint32_t ISPSTS;

    /**
     * FBWP
     * ===================================================================================================
     * Offset: 0x44  Flash Block Write Protect Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |BWP       |Flash Block Write Protect Control
     * |        |          |If BWP.N bit is set to 0, the APROM memory relative region cannot program and erase by ISP. (N=0~31).
     * |        |          |Bit Block   Protect Region
     * |        |          |BWP0        0x00_0000   ~ 0x00_3FFF
     * |        |          |BWP1        0x00_4000   ~ 0x00_7FFF
     * |        |          |BWP2        0x00_8000   ~ 0x00_BFFF
     * |        |          |BWP3        0x00_C000   ~ 0x00_FFFF
     * |        |          |BWP4        0x01_0000   ~ 0x01_3FFF
     * |        |          |BWP5        0x01_4000   ~ 0x01_7FFF
     * |        |          |BWP6        0x01_8000   ~ 0x01_BFFF
     * |        |          |BWP7        0x01_C000   ~ 0x01_FFFF
     * |        |          |BWP8        0x02_0000   ~ 0x02_3FFF
     * |        |          |BWP9        0x02_4000   ~ 0x02_7FFF
     * |        |          |BWP10       0x02_8000   ~ 0x02_BFFF
     * |        |          |BWP11       0x02_C000   ~ 0x02_FFFF
     * |        |          |BWP12       0x03_0000   ~ 0x03_3FFF
     * |        |          |BWP13       0x03_4000   ~ 0x03_7FFF
     * |        |          |BWP14       0x03_8000   ~ 0x03_BFFF
     * |        |          |BWP15       0x03_C000   ~ 0x03_FFFF
     * |        |          |BWP16       0x04_0000   ~ 0x04_3FFF
     * |        |          |BWP17       0x04_4000   ~ 0x04_7FFF
     * |        |          |BWP18       0x04_8000   ~ 0x04_BFFF
     * |        |          |BWP19       0x04_C000   ~ 0x04_FFFF
     * |        |          |BWP20       0x05_0000   ~ 0x05_3FFF
     * |        |          |BWP21       0x05_4000   ~ 0x05_7FFF
     * |        |          |BWP22       0x05_8000   ~ 0x05_BFFF
     * |        |          |BWP23       0x05_C000   ~ 0x05_FFFF
     * |        |          |BWP24       0x06_0000   ~ 0x06_3FFF
     * |        |          |BWP25       0x06_4000   ~ 0x06_7FFF
     * |        |          |BWP26       0x06_8000   ~ 0x06_BFFF
     * |        |          |BWP27       0x06_C000   ~ 0x06_FFFF
     * |        |          |BWP28       0x07_0000   ~ 0x07_3FFF
     * |        |          |BWP29       0x07_4000   ~ 0x07_7FFF
     * |        |          |BWP30       0x07_8000   ~ 0x07_BFFF
     * |        |          |BWP31       0x07_C000   ~ 0x07_FFFF
     * |        |          |This register is loaded from Config2 when chip is power on.
     * |        |          |It is read only, except the correct Super Key is matched.
     * |        |          |This register is also a protected bit which means programming this bit needs to write "59h", "16h", "88h" to address GCR_BA+0x100 to disable register protection.
     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
    */
    __IO uint32_t FBWP;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[14];
    /// @endcond //HIDDEN_SYMBOLS

    /**
     * MPDAT0
     * ===================================================================================================
     * Offset: 0x80  ISP Data 0 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ISPDAT0   |ISP Data 0
     * |        |          |This register is the first 32-bit data for 32b/64b/multi-word program,
     * |        |          |and it is also the mirror of FMC_ISPDAT register, both registers keep the same data.
    */
    __IO uint32_t MPDAT0;

    /**
     * MPDAT1
     * ===================================================================================================
     * Offset: 0x84  ISP Data 1 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ISPDAT1   |ISP Data 1
     * |        |          |This register is the second 32-bit data for 32b/64b/multi-word program.
    */
    __IO uint32_t MPDAT1;

    /**
     * MPDAT2
     * ===================================================================================================
     * Offset: 0x88  ISP Data 2 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ISPDAT2   |ISP Data 2
     * |        |          |This register is the third 32-bit data for 32b/64b/multi-word program.
    */
    __IO uint32_t MPDAT2;

    /**
     * MPDAT3
     * ===================================================================================================
     * Offset: 0x8C  ISP Data 1 Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ISPDAT3   |ISP Data 3
     * |        |          |This register is the fourth 32-bit data for 32b/64b/multi-word program.
    */
    __IO uint32_t MPDAT3;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[12];
    /// @endcond //HIDDEN_SYMBOLS

    /**
     * MPSTS
     * ===================================================================================================
     * Offset: 0xC0  ISP Multi-Word Program Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |MPBUSY   |ISP Multi-Word Program Busy Flag (Read Only)
     * |        |          |0 = ISP Multi-Word Program operation is aborted or finished.
     * |        |          |1 = ISP Multi-Word Program operation is progressed.
     * |[2]     |ISPFF     |ISP Fail Flag (Read Only)
     * |        |          |This CBS field is just a copy of User-Configuration Config0 CBS[7:6].
     * |[4]     |D0        |ISP DATA 0 Flag (Read Only)
     * |        |          |This bit is set when FMC_MPDAT0 is written and auto-clear to 0
     * |        |          |when the FMC_MPDAT0 is programmed to flash complete.
     * |        |          |0 = FMC_MPDAT0 register is empty, or program to flash complete.
     * |        |          |1 = FMC_MPDAT0 register has been written, and not programmed to flash yet.
     * |[5]     |D1        |ISP DATA 1 Flag (Read Only)
     * |        |          |This bit is set when FMC_MPDAT1 is written and auto-clear to 0
     * |        |          |when the FMC_MPDAT1 is programmed to flash complete.
     * |        |          |0 = FMC_MPDAT1 register is empty, or program to flash complete.
     * |        |          |1 = FMC_MPDAT1 register has been written, and not programmed to flash yet.
     * |[6]     |D2        |ISP DATA 2 Flag (Read Only)
     * |        |          |This bit is set when FMC_MPDAT2 is written and auto-clear to 0
     * |        |          |when the FMC_MPDAT2 is programmed to flash complete.
     * |        |          |0 = FMC_MPDAT2 register is empty, or program to flash complete.
     * |        |          |1 = FMC_MPDAT2 register has been written, and not programmed to flash yet.
     * |[7]     |D3        |ISP DATA 3 Flag (Read Only)
     * |        |          |This bit is set when FMC_MPDAT3 is written and auto-clear to 0
     * |        |          |when the FMC_MPDAT3 is programmed to flash complete.
     * |        |          |0 = FMC_MPDAT3 register is empty, or program to flash complete.
     * |        |          |1 = FMC_MPDAT3 register has been written, and not programmed to flash yet.
    */
    __IO uint32_t MPSTS;

    /**
     * MPADDR
     * ===================================================================================================
     * Offset: 0xC4  ISP Multi-Word Program Address Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |MPADDR    |ISP Multi-Word Program Address Status
     * |        |          |MPADDR is the address of ISP Multi-Word Program operation when
     * |        |          |MPBUSY flag is 1. MPADDR will keep the final address when
     * |        |          |Multi-Word Program is aborted or finished.
    */
    __IO uint32_t MPADDR;

} FMC_T;


/**
    @addtogroup FMC_CONST FMC Bit Field Definition
    Constant Definitions for FMC Controller
@{ */

#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCTL: ISPEN Position             */
#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC_T::ISPCTL: ISPEN Mask                 */

#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC_T::ISPCTL: BS Position                */
#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC_T::ISPCTL: BS Mask                    */

#define FMC_ISPCTL_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCTL: APUEN Position             */
#define FMC_ISPCTL_APUEN_Msk             (0x1ul << FMC_ISPCTL_APUEN_Pos)                   /*!< FMC_T::ISPCTL: APUEN Mask                 */

#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCTL: CFGUEN Position            */
#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC_T::ISPCTL: CFGUEN Mask                */

#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCTL: LDUEN Position             */
#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC_T::ISPCTL: LDUEN Mask                 */

#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCTL: ISPFF Position             */
#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC_T::ISPCTL: ISPFF Mask                 */

#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC_T::ISPADDR: ISPADDR Position          */
#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC_T::ISPADDR: ISPADDR Mask              */

#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position            */
#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask                */

#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC_T::ISPCMD: CMD Position               */
#define FMC_ISPCMD_CMD_Msk               (0x3ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC_T::ISPCMD: CMD Mask                   */

#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position             */
#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask                 */

#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC_T::DFBA: DFBA Position                */
#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC_T::DFBA: DFBA Mask                    */

#define FMC_FTCTL_FOM_Pos                (4)                                               /*!< FMC_T::FTCTL: FOM Position                */
#define FMC_FTCTL_FOM_Msk                (0x7ul << FMC_FTCTL_FOM_Pos)                      /*!< FMC_T::FTCTL: FOM Mask                    */

#define FMC_ISPSTS_ISPBUSY_Pos           (0)                                               /*!< FMC_T::ISPSTS: ISPBUSY Position           */
#define FMC_ISPSTS_ISPBUSY_Msk           (0x1ul << FMC_ISPSTS_ISPBUSY_Pos)                 /*!< FMC_T::ISPSTS: ISPBUSY Mask               */

#define FMC_ISPSTS_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTS: CBS Position               */
#define FMC_ISPSTS_CBS_Msk               (0x3ul << FMC_ISPSTS_CBS_Pos)                     /*!< FMC_T::ISPSTS: CBS Mask                   */

#define FMC_ISPSTS_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTS: ISPFF Position             */
#define FMC_ISPSTS_ISPFF_Msk             (0x1ul << FMC_ISPSTS_ISPFF_Pos)                   /*!< FMC_T::ISPSTS: ISPFF Mask                 */

#define FMC_ISPSTS_VECMAP_Pos            (9)                                               /*!< FMC_T::ISPSTS: VECMAP Position            */
#define FMC_ISPSTS_VECMAP_Msk            (0xffful << FMC_ISPSTS_VECMAP_Pos)                /*!< FMC_T::ISPSTS: VECMAP Mask                */

#define FMC_ISPSTS_CFGCRCF_Pos           (26)                                              /*!< FMC_T::ISPSTS: CFGCRCF Position           */
#define FMC_ISPSTS_CFGCRCF_Msk           (0x1ul << FMC_ISPSTS_CFGCRCF_Pos)                 /*!< FMC_T::ISPSTS: CFGCRCF Mask               */

#define FMC_FBWP_BWP_Pos                 (0)                                               /*!< FMC_T::FBWP: BWP Position                 */
#define FMC_FBWP_BWP_Msk                 (0xfffffffful << FMC_FBWP_BWP_Pos)                /*!< FMC_T::FBWP: BWP Mask                     */

#define FMC_MPDAT0_ISPDAT0_Pos          (0)                                                /*!< FMC_T::MPDAT0: ISPDAT0 Position           */
#define FMC_MPDAT0_ISPDAT0_Msk          (0xfffffffful << FMC_MPDAT0_ISPDAT0_Pos)           /*!< FMC_T::MPDAT0: ISPDAT0 Mask               */

#define FMC_MPDAT1_ISPDAT1_Pos          (0)                                                /*!< FMC_T::MPDAT1: ISPDAT1 Position           */
#define FMC_MPDAT1_ISPDAT1_Msk          (0xfffffffful << FMC_MPDAT1_ISPDAT1_Pos)           /*!< FMC_T::MPDAT1: ISPDAT1 Mask               */

#define FMC_MPDAT2_ISPDAT2_Pos          (0)                                                /*!< FMC_T::MPDAT2: ISPDAT2 Position           */
#define FMC_MPDAT2_ISPDAT2_Msk          (0xfffffffful << FMC_MPDAT2_ISPDAT2_Pos)           /*!< FMC_T::MPDAT2: ISPDAT2 Mask               */

#define FMC_MPDAT3_ISPDAT3_Pos          (0)                                                /*!< FMC_T::MPDAT3: ISPDAT3 Position           */
#define FMC_MPDAT3_ISPDAT3_Msk          (0xfffffffful << FMC_MPDAT3_ISPDAT3_Pos)           /*!< FMC_T::MPDAT3: ISPDAT3 Mask               */

#define FMC_MPSTS_MPBUSY_Pos           (0)                                                 /*!< FMC_T::MPSTS: WMPBUSY Position            */
#define FMC_MPSTS_MPBUSY_Msk           (0x1ul << FMC_MPSTS_MPBUSY_Pos)                     /*!< FMC_T::MPSTS: MPBUSY Mask                 */

#define FMC_MPSTS_ISPFF_Pos             (2)                                                /*!< FMC_T::MPSTS: ISPFF Position              */
#define FMC_MPSTS_ISPFF_Msk             (0x1ul << FMC_MPSTS_ISPFF_Pos)                     /*!< FMC_T::MPSTS: ISPFF Mask                  */

#define FMC_MPSTS_D0_Pos                (4)                                                /*!< FMC_T::MPSTS: D0 Position                 */
#define FMC_MPSTS_D0_Msk                (0x1ul << FMC_MPSTS_D0_Pos)                        /*!< FMC_T::MPSTS: D0 Mask                     */

#define FMC_MPSTS_D1_Pos                (5)                                                /*!< FMC_T::MPSTS: D1 Position                 */
#define FMC_MPSTS_D1_Msk                (0x1ul << FMC_MPSTS_D1_Pos)                        /*!< FMC_T::MPSTS: D1 Mask                     */

#define FMC_MPSTS_D2_Pos                (6)                                                /*!< FMC_T::MPSTS: D2 Position                 */
#define FMC_MPSTS_D2_Msk                (0x1ul << FMC_MPSTS_D2_Pos)                        /*!< FMC_T::MPSTS: D2 Mask                     */

#define FMC_MPSTS_D3_Pos                (7)                                                /*!< FMC_T::MPSTS: D3 Position                 */
#define FMC_MPSTS_D3_Msk                (0x1ul << FMC_MPSTS_D3_Pos)                        /*!< FMC_T::MPSTS: D3 Mask                     */

#define FMC_MPADDR_MPADDR_Pos           (0)                                                /*!< FMC_T::MPADDR: MPADDR Position            */
#define FMC_MPADDR_MPADDR_Msk           (0xfffffffful << FMC_MPADDR_MPADDR_Pos)            /*!< FMC_T::MPADDR: MPADDR Mask                */

/**@}*/ /* FMC_CONST */
/**@}*/ /* end of FMC register group */


/*---------------------- General Purpose Input/Output Controller -------------------------*/
/**
    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
    Memory Mapped Structure for GPIO Controller
@{ */

typedef struct {


    /**
     * Px_MODE
     * ===================================================================================================
     * Offset: 0x00  Px I/O Mode Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |MODE0     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[2:3]   |MODE1     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[4:5]   |MODE2     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[6:7]   |MODE3     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[8:9]   |MODE4     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[10:11] |MODE5     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[12:13] |MODE6     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[14:15] |MODE7     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[16:17] |MODE8     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[18:19] |MODE9     |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[20:21] |MODE10    |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[22:23] |MODE11    |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[24:25] |MODE12    |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[26:27] |MODE13    |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[28:29] |MODE14    |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
     * |[30:31] |MODE15    |Port N Bit M I/O Mode Control
     * |        |          |Determine the I/O mode of port n bit m.
     * |        |          |00 = INPUT only mode.
     * |        |          |01 = OUTPUT mode.
     * |        |          |10 = Open-drain mode.
     * |        |          |11 = Quasi-bidirectional mode.
     * |        |          |Reset value:
     * |        |          |0xFFFF_FFFF when ( cfg_io =1'b0).
     * |        |          |0x0000_00000 when ( cfg_io =1'b1).
    */
    __IO uint32_t MODE;

    /**
     * Px_DINOFF
     * ===================================================================================================
     * Offset: 0x04  Px Digital Input Path Disable Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16]    |DINOFF0   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[17]    |DINOFF1   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[18]    |DINOFF2   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[19]    |DINOFF3   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[20]    |DINOFF4   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[21]    |DINOFF5   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[22]    |DINOFF6   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[23]    |DINOFF7   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[24]    |DINOFF8   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[25]    |DINOFF9   |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[26]    |DINOFF10  |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[27]    |DINOFF11  |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[28]    |DINOFF12  |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[29]    |DINOFF13  |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[30]    |DINOFF14  |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
     * |[31]    |DINOFF15  |Port N Bit M Off Digital Input Path
     * |        |          |Each of these bits is used to turn off the digital input path of port n bit m pin.
     * |        |          |If input is analog signal, users can turn off digital input path to avoid input current leakage.
     * |        |          |0 = Digital input path Enabled.
     * |        |          |1 = Digital input path Disabled (Digital input is tied to low).
    */
    __IO uint32_t DINOFF;

    /**
     * Px_DOUT
     * ===================================================================================================
     * Offset: 0x08  Px Data Output Value
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DOUT0     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[1]     |DOUT1     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[2]     |DOUT2     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[3]     |DOUT3     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[4]     |DOUT4     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[5]     |DOUT5     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[6]     |DOUT6     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[7]     |DOUT7     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[8]     |DOUT8     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[9]     |DOUT9     |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[10]    |DOUT10    |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[11]    |DOUT11    |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[12]    |DOUT12    |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[13]    |DOUT13    |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[14]    |DOUT14    |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
     * |[15]    |DOUT15    |Port N Bit M Output
     * |        |          |Each of these bits control the status of port n bit m when this pin is configures as output, open-drain, or Quasi-bidirectional mode.
     * |        |          |0 = Drive port n bit m high low.
     * |        |          |1 = Drive port n bit m high level.
    */
    __IO uint32_t DOUT;

    /**
     * Px_DATMSK
     * ===================================================================================================
     * Offset: 0x0C  Px Data Output Write Mask
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DATMSK0   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[1]     |DATMSK1   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[2]     |DATMSK2   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[3]     |DATMSK3   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[4]     |DATMSK4   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[5]     |DATMSK5   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[6]     |DATMSK6   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[7]     |DATMSK7   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[8]     |DATMSK8   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[9]     |DATMSK9   |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[10]    |DATMSK10  |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[11]    |DATMSK11  |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[12]    |DATMSK12  |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[13]    |DATMSK13  |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[14]    |DATMSK14  |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
     * |[15]    |DATMSK15  |Port N Bit M Data Output Write Mask
     * |        |          |These bits are used to protect the corresponding register of Px_DOUT[m].
     * |        |          |When set the DATMSK [m] to 1, the writing to Px_DOUT[m] bit is ignored.
     * |        |          |The write to port pin latch is masked.
     * |        |          |0 = Px_DOUT[m] bit writing is valid.
     * |        |          |1 = Px_DOUT[m] bit writing is ignored.
    */
    __IO uint32_t DATMSK;

    /**
     * Px_PIN
     * ===================================================================================================
     * Offset: 0x10  Px Pin Value
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |PIN0      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[1]     |PIN1      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[2]     |PIN2      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[3]     |PIN3      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[4]     |PIN4      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[5]     |PIN5      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[6]     |PIN6      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[7]     |PIN7      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[8]     |PIN8      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[9]     |PIN9      |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[10]    |PIN10     |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[11]    |PIN11     |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[12]    |PIN12     |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[13]    |PIN13     |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[14]    |PIN14     |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
     * |[15]    |PIN15     |Port N Bit M Pin Value
     * |        |          |Each bit of the register reflects the actual status of the respective port pin.
     * |        |          |If bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
    */
    __I  uint32_t PIN;

    /**
     * Px_DBEN
     * ===================================================================================================
     * Offset: 0x14  Px De-Bounce Enable Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DBEN0     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[1]     |DBEN1     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[2]     |DBEN2     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[3]     |DBEN3     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[4]     |DBEN4     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[5]     |DBEN5     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[6]     |DBEN6     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[7]     |DBEN7     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[8]     |DBEN8     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[9]     |DBEN9     |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[10]    |DBEN10    |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[11]    |DBEN11    |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[12]    |DBEN12    |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[13]    |DBEN13    |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[14]    |DBEN14    |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
     * |[15]    |DBEN15    |Port N Bit M Input De-Bounce Enable
     * |        |          |DBEN[m] is used to enable the de-bounce function for each corresponding bit.
     * |        |          |DBEN[m] is valid for "edge-triggered" interrupt only and is ignored for "level triggered" interrupt.
     * |        |          |If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt.
     * |        |          |The de-bounce clock is controlled by GPIO_DBCTL register.
     * |        |          |0 = Port n bit m input de-bounce Disabled.
     * |        |          |1 = Port n bit m input de-bounce Enabled.
    */
    __IO uint32_t DBEN;

    /**
     * Px_INTTYPE
     * ===================================================================================================
     * Offset: 0x18  Px Interrupt Trigger Type Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |TYPE0     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[1]     |TYPE1     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[2]     |TYPE2     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[3]     |TYPE3     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[4]     |TYPE4     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[5]     |TYPE5     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[6]     |TYPE6     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[7]     |TYPE7     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[8]     |TYPE8     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[9]     |TYPE9     |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[10]    |TYPE10    |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[11]    |TYPE11    |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[12]    |TYPE12    |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[13]    |TYPE13    |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[14]    |TYPE14    |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
     * |[15]    |TYPE15    |Port N Bit M Edge Or Level Triggered Interrupt Control
     * |        |          |TYPE[m] decides the pin interrupt triggered by level or edge.
     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
     * |        |          |clock and generates the interrupt.
     * |        |          |0 = Edge triggered interrupt.
     * |        |          |1 = Level triggered interrupt.
     * |        |          |Note1: If pin is set as the level trigger interrupt, only one level can be set on the registers Px_INTEN.
     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
     * |        |          |Note2: The de-bounce function is valid for edge triggered interrupt.
     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
    */
    __IO uint32_t INTTYPE;

    /**
     * Px_INTEN
     * ===================================================================================================
     * Offset: 0x1C  Px Interrupt Enable
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |FLIEN0    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[1]     |FLIEN1    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[2]     |FLIEN2    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[3]     |FLIEN3    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[4]     |FLIEN4    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[5]     |FLIEN5    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[6]     |FLIEN6    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[7]     |FLIEN7    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[8]     |FLIEN8    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[9]     |FLIEN9    |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[10]    |FLIEN10   |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[11]    |FLIEN11   |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[12]    |FLIEN12   |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[13]    |FLIEN13   |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[14]    |FLIEN14   |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[15]    |FLIEN15   |Port N Bit M Interrupt Enable For Falling Edge Or Low Level Input
     * |        |          |FLIEN[n] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m low-level or falling edge interrupt Disabled.
     * |        |          |1 = Port n bit m low-level or falling edge interrupt Enabled.
     * |[16]    |RHIEN0    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[17]    |RHIEN1    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[18]    |RHIEN2    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[19]    |RHIEN3    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[20]    |RHIEN4    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[21]    |RHIEN5    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[22]    |RHIEN6    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[23]    |RHIEN7    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[24]    |RHIEN8    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[25]    |RHIEN9    |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[26]    |RHIEN10   |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[27]    |RHIEN11   |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[28]    |RHIEN12   |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[29]    |RHIEN13   |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[30]    |RHIEN14   |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
     * |[31]    |RHIEN15   |Port N Bit M Interrupt Enable For Rising Edge Or High Level Input
     * |        |          |RHIEN[m] enables the interrupt for each of the corresponding input of Port n.
     * |        |          |Setting this bit to 1 also enables the pin wake-up function.
     * |        |          |0 = Port n bit m high-level or rising edge interrupt Disabled.
     * |        |          |1 = Port n bit m high-level or rising edge interrupt Enabled.
    */
    __IO uint32_t INTEN;

    /**
     * Px_INTSRC
     * ===================================================================================================
     * Offset: 0x20  Px Interrupt Source Flag
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |INTSRC0   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[1]     |INTSRC1   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[2]     |INTSRC2   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[3]     |INTSRC3   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[4]     |INTSRC4   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[5]     |INTSRC5   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[6]     |INTSRC6   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[7]     |INTSRC7   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[8]     |INTSRC8   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[9]     |INTSRC9   |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[10]    |INTSRC10  |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[11]    |INTSRC11  |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[12]    |INTSRC12  |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[13]    |INTSRC13  |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[14]    |INTSRC14  |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
     * |[15]    |INTSRC15  |Port N Bit M Interrupt Trigger Source Indicator
     * |        |          |Read:
     * |        |          |0 = No interrupt at Port n.
     * |        |          |1 = Port n bit m generate an interrupt.
     * |        |          |Write:
     * |        |          |0= No effect.
     * |        |          |1= Clear the correspond pending interrupt.
    */
    __IO uint32_t INTSRC;

    /**
     * Px_SMTEN
     * ===================================================================================================
     * Offset: 0x24  Px Input Schmitt Trigger Enable
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SMTEN0    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[1]     |SMTEN1    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[2]     |SMTEN2    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[3]     |SMTEN3    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[4]     |SMTEN4    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[5]     |SMTEN5    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[6]     |SMTEN6    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[7]     |SMTEN7    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[8]     |SMTEN8    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[9]     |SMTEN9    |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[10]    |SMTEN10   |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[11]    |SMTEN11   |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[12]    |SMTEN12   |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[13]    |SMTEN13   |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[14]    |SMTEN14   |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
     * |[15]    |SMTEN15   |0 = P I/O input Schmitt Trigger function Disabled.
     * |        |          |1 = P I/O input Schmitt Trigger function Enabled.
    */
    __IO uint32_t SMTEN;

    /**
     * Px_SLEWCTL
     * ===================================================================================================
     * Offset: 0x28  Px High Slew Rate Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |HSREN0    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[1]     |HSREN1    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[2]     |HSREN2    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[3]     |HSREN3    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[4]     |HSREN4    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[5]     |HSREN5    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[6]     |HSREN6    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[7]     |HSREN7    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[8]     |HSREN8    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[9]     |HSREN9    |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[10]    |HSREN10   |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[11]    |HSREN11   |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[12]    |HSREN12   |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[13]    |HSREN13   |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[14]    |HSREN14   |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
     * |[15]    |HSREN15   |0 = P I/O output with basic slew rate.
     * |        |          |1 = P I/O output with higher slew rate.
    */
    __IO uint32_t SLEWCTL;

} GPIO_T;


typedef struct {

    /**
     * GPIO_DBCTL
     * ===================================================================================================
     * Offset: 0x000  Interrupt De-bounce Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |DBCLKSEL  |De-Bounce Sampling Cycle Selection
     * |        |          |0000 = Sample interrupt input once per 1 clocks.
     * |        |          |0001 = Sample interrupt input once per 2 clocks.
     * |        |          |0010 = Sample interrupt input once per 4 clocks.
     * |        |          |0011 = Sample interrupt input once per 8 clocks.
     * |        |          |0100 = Sample interrupt input once per 16 clocks.
     * |        |          |0101 = Sample interrupt input once per 32 clocks.
     * |        |          |0110 = Sample interrupt input once per 64 clocks.
     * |        |          |0111 = Sample interrupt input once per 128 clocks.
     * |        |          |1000 = Sample interrupt input once per 256 clocks.
     * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
     * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
     * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
     * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
     * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
     * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
     * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
     * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
     * |        |          |0 = De-bounce counter clock source is the HCLK.
     * |        |          |1 = De-bounce counter clock source is the internal 10 kHz clock.
     * |[5]     |ICLKON    |Interrupt Clock On Mode
     * |        |          |Setting this bit to 0 will disable the interrupt generate circuit clock if the pin[n] interrupt is disabled.
     * |        |          |0 = Disable the clock if the all port interrupts are disabled.
     * |        |          |1 = Interrupt generated circuit clock always Enabled.
    */
    __IO uint32_t DBCTL;

} GPIO_DB_T;

/**
    @addtogroup GPIO_CONST GPIO Bit Field Definition
    Constant Definitions for GPIO Controller
@{ */

#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position              */
#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask                  */

#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position              */
#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask                  */

#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position              */
#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask                  */

#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position              */
#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask                  */

#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position              */
#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask                  */

#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position              */
#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask                  */

#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position              */
#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask                  */

#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position              */
#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask                  */

#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position              */
#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask                  */

#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position              */
#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask                  */

#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position             */
#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask                 */

#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position             */
#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask                 */

#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position             */
#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask                 */

#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position             */
#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask                 */

#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position             */
#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask                 */

#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position             */
#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask                 */

#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position          */
#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask              */

#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position          */
#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask              */

#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position          */
#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask              */

#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position          */
#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask              */

#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position          */
#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask              */

#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position          */
#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask              */

#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position          */
#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask              */

#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position          */
#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask              */

#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position          */
#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask              */

#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position          */
#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask              */

#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position         */
#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask             */

#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position         */
#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask             */

#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position         */
#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask             */

#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position         */
#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask             */

#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position         */
#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask             */

#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position         */
#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask             */

#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position              */
#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask                  */

#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position              */
#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask                  */

#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position              */
#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask                  */

#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position              */
#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask                  */

#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position              */
#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask                  */

#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position              */
#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask                  */

#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position              */
#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask                  */

#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position              */
#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask                  */

#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position              */
#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask                  */

#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position              */
#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask                  */

#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position             */
#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask                 */

#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position             */
#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask                 */

#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position             */
#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask                 */

#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position             */
#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask                 */

#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position             */
#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask                 */

#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position             */
#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask                 */

#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO_T::DATMSK: DATMSK0 Position          */
#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO_T::DATMSK: DATMSK0 Mask              */

#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO_T::DATMSK: DATMSK1 Position          */
#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO_T::DATMSK: DATMSK1 Mask              */

#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO_T::DATMSK: DATMSK2 Position          */
#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO_T::DATMSK: DATMSK2 Mask              */

#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO_T::DATMSK: DATMSK3 Position          */
#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO_T::DATMSK: DATMSK3 Mask              */

#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO_T::DATMSK: DATMSK4 Position          */
#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO_T::DATMSK: DATMSK4 Mask              */

#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO_T::DATMSK: DATMSK5 Position          */
#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO_T::DATMSK: DATMSK5 Mask              */

#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO_T::DATMSK: DATMSK6 Position          */
#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO_T::DATMSK: DATMSK6 Mask              */

#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO_T::DATMSK: DATMSK7 Position          */
#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO_T::DATMSK: DATMSK7 Mask              */

#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO_T::DATMSK: DATMSK8 Position          */
#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO_T::DATMSK: DATMSK8 Mask              */

#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO_T::DATMSK: DATMSK9 Position          */
#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO_T::DATMSK: DATMSK9 Mask              */

#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO_T::DATMSK: DATMSK10 Position         */
#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO_T::DATMSK: DATMSK10 Mask             */

#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO_T::DATMSK: DATMSK11 Position         */
#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO_T::DATMSK: DATMSK11 Mask             */

#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO_T::DATMSK: DATMSK12 Position         */
#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO_T::DATMSK: DATMSK12 Mask             */

#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO_T::DATMSK: DATMSK13 Position         */
#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO_T::DATMSK: DATMSK13 Mask             */

#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO_T::DATMSK: DATMSK14 Position         */
#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO_T::DATMSK: DATMSK14 Mask             */

#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO_T::DATMSK: DATMSK15 Position         */
#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO_T::DATMSK: DATMSK15 Mask             */

#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position                */
#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                    */

#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position                */
#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                    */

#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position                */
#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                    */

#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position                */
#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                    */

#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position                */
#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                    */

#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position                */
#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                    */

#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position                */
#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                    */

#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position                */
#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                    */

#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position                */
#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                    */

#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position                */
#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                    */

#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position               */
#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                   */

#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position               */
#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                   */

#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position               */
#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                   */

#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position               */
#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                   */

#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position               */
#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                   */

#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position               */
#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                   */

#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position              */
#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask                  */

#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position              */
#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask                  */

#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position              */
#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask                  */

#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position              */
#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask                  */

#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position              */
#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask                  */

#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position              */
#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask                  */

#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position              */
#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask                  */

#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position              */
#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask                  */

#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position              */
#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask                  */

#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position              */
#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask                  */

#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position             */
#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask                 */

#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position             */
#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask                 */

#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position             */
#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask                 */

#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position             */
#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask                 */

#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position             */
#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask                 */

#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position             */
#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask                 */

#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position           */
#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask               */

#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position           */
#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask               */

#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position           */
#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask               */

#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position           */
#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask               */

#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position           */
#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask               */

#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position           */
#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask               */

#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position           */
#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask               */

#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position           */
#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask               */

#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position           */
#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask               */

#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position           */
#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask               */

#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position          */
#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask              */

#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position          */
#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask              */

#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position          */
#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask              */

#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position          */
#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask              */

#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position          */
#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask              */

#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position          */
#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask              */

#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position            */
#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask                */

#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position            */
#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask                */

#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position            */
#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask                */

#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position            */
#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask                */

#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position            */
#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask                */

#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position            */
#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask                */

#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position            */
#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask                */

#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position            */
#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask                */

#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position            */
#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask                */

#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position            */
#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask                */

#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position           */
#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask               */

#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position           */
#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask               */

#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position           */
#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask               */

#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position           */
#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask               */

#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position           */
#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask               */

#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position           */
#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask               */

#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position            */
#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask                */

#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position            */
#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask                */

#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position            */
#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask                */

#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position            */
#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask                */

#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position            */
#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask                */

#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position            */
#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask                */

#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position            */
#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask                */

#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position            */
#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask                */

#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position            */
#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask                */

#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position            */
#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask                */

#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position           */
#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask               */

#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position           */
#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask               */

#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position           */
#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask               */

#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position           */
#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask               */

#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position           */
#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask               */

#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position           */
#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask               */

#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position          */
#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask              */

#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position          */
#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask              */

#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position          */
#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask              */

#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position          */
#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask              */

#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position          */
#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask              */

#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position          */
#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask              */

#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position          */
#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask              */

#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position          */
#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask              */

#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position          */
#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask              */

#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position          */
#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask              */

#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position         */
#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask             */

#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position         */
#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask             */

#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position         */
#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask             */

#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position         */
#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask             */

#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position         */
#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask             */

#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position         */
#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask             */

#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position            */
#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask                */

#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position            */
#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask                */

#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position            */
#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask                */

#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position            */
#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask                */

#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position            */
#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask                */

#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position            */
#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask                */

#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position            */
#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask                */

#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position            */
#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask                */

#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position            */
#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask                */

#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position            */
#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask                */

#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position           */
#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask               */

#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position           */
#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask               */

#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position           */
#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask               */

#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position           */
#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask               */

#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position           */
#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask               */

#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position           */
#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask               */

#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position          */
#define GPIO_SLEWCTL_HSREN0_Msk          (0x1ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask              */

#define GPIO_SLEWCTL_HSREN1_Pos          (1)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position          */
#define GPIO_SLEWCTL_HSREN1_Msk          (0x1ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask              */

#define GPIO_SLEWCTL_HSREN2_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position          */
#define GPIO_SLEWCTL_HSREN2_Msk          (0x1ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask              */

#define GPIO_SLEWCTL_HSREN3_Pos          (3)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position          */
#define GPIO_SLEWCTL_HSREN3_Msk          (0x1ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask              */

#define GPIO_SLEWCTL_HSREN4_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position          */
#define GPIO_SLEWCTL_HSREN4_Msk          (0x1ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask              */

#define GPIO_SLEWCTL_HSREN5_Pos          (5)                                               /*!< GPIO_T::SLEWCTL: HSREN5 Position          */
#define GPIO_SLEWCTL_HSREN5_Msk          (0x1ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask              */

#define GPIO_SLEWCTL_HSREN6_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN6 Position          */
#define GPIO_SLEWCTL_HSREN6_Msk          (0x1ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask              */

#define GPIO_SLEWCTL_HSREN7_Pos          (7)                                               /*!< GPIO_T::SLEWCTL: HSREN7 Position          */
#define GPIO_SLEWCTL_HSREN7_Msk          (0x1ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask              */

#define GPIO_SLEWCTL_HSREN8_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN8 Position          */
#define GPIO_SLEWCTL_HSREN8_Msk          (0x1ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask              */

#define GPIO_SLEWCTL_HSREN9_Pos          (9)                                               /*!< GPIO_T::SLEWCTL: HSREN9 Position          */
#define GPIO_SLEWCTL_HSREN9_Msk          (0x1ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask              */

#define GPIO_SLEWCTL_HSREN10_Pos         (10)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position         */
#define GPIO_SLEWCTL_HSREN10_Msk         (0x1ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask             */

#define GPIO_SLEWCTL_HSREN11_Pos         (11)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position         */
#define GPIO_SLEWCTL_HSREN11_Msk         (0x1ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask             */

#define GPIO_SLEWCTL_HSREN12_Pos         (12)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position         */
#define GPIO_SLEWCTL_HSREN12_Msk         (0x1ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask             */

#define GPIO_SLEWCTL_HSREN13_Pos         (13)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position         */
#define GPIO_SLEWCTL_HSREN13_Msk         (0x1ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask             */

#define GPIO_SLEWCTL_HSREN14_Pos         (14)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position         */
#define GPIO_SLEWCTL_HSREN14_Msk         (0x1ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask             */

#define GPIO_SLEWCTL_HSREN15_Pos         (15)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position         */
#define GPIO_SLEWCTL_HSREN15_Msk         (0x1ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask             */

#define GPIO_DBCTL_DBCLKSEL_Pos          (0)                                               /*!< GPIO_DB_T::DBCTL: DBCLKSEL Position          */
#define GPIO_DBCTL_DBCLKSEL_Msk          (0xful << GPIO_DBCTL_DBCLKSEL_Pos)                /*!< GPIO_DB_T::DBCTL: DBCLKSEL Mask              */

#define GPIO_DBCTL_DBCLKSRC_Pos          (4)                                               /*!< GPIO_DB_T::DBCTL: DBCLKSRC Position          */
#define GPIO_DBCTL_DBCLKSRC_Msk          (0x1ul << GPIO_DBCTL_DBCLKSRC_Pos)                /*!< GPIO_DB_T::DBCTL: DBCLKSRC Mask              */

#define GPIO_DBCTL_ICLKON_Pos            (5)                                               /*!< GPIO_DB_T::DBCTL: ICLKON Position            */
#define GPIO_DBCTL_ICLKON_Msk            (0x1ul << GPIO_DBCTL_ICLKON_Pos)                  /*!< GPIO_DB_T::DBCTL: ICLKON Mask                */

/**@}*/ /* GPIO_CONST */
/**@}*/ /* end of GPIO register group */


/*---------------------- Inter-IC Bus Controller -------------------------*/
/**
    @addtogroup I2C Inter-IC Bus Controller(I2C)
    Memory Mapped Structure for I2C Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  I2C Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[2]     |AA        |Assert Acknowledge Control
     * |        |          |When AA =1 prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter.
     * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
     * |[3]     |SI        |I2C Interrupt Flag
     * |        |          |When a new I2C state is present in the I2C_STATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested.
     * |        |          |SI must be cleared by software.
     * |        |          |Clear SI by writing 1 to this bit.
     * |[4]     |STO       |I2C STOP Control
     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically.
     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode.
     * |        |          |This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
     * |[5]     |STA       |I2C START Control
     * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
     * |[6]     |I2CEN     |I2C Controller Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |        |          |Set to enable I2C serial function controller.
     * |        |          |When ENS1=1 the I2C serial function enables.
     * |        |          |The multi-function pin function of SDA and SCL must set to I2C function first.
     * |[7]     |INTEN     |I2C Interrupt Enable Control
     * |        |          |0 = I2C interrupt Disabled.
     * |        |          |1 = I2C interrupt Enabled.
    */
    __IO uint32_t CTL;

    /**
     * ADDR0
     * ===================================================================================================
     * Offset: 0x04  I2C Slave Address Register0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |GC        |General Call Function
     * |        |          |0 = General Call Function Disabled.
     * |        |          |1 = General Call Function Enabled.
     * |[1:7]   |ADDR      |I2C Address Bits
     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
     * |        |          |The I2C hardware will react if either of the address is matched.
    */
    __IO uint32_t ADDR0;

    /**
     * DAT
     * ===================================================================================================
     * Offset: 0x08  I2C Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |DAT       |I2C Data Bits
     * |        |          |Bit [7:0] is located with the 8-bit transferred data of I2C serial port.
    */
    __IO uint32_t DAT;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x0C  I2C Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |STATUS    |I2C Status Bits
     * |        |          |The status register of I2C:
     * |        |          |The three least significant bits are always 0.
     * |        |          |The five most significant bits contain the status code.
     * |        |          |Refer to section 6.15.5.4 for detail description.
    */
    __I  uint32_t STATUS;

    /**
     * CLKDIV
     * ===================================================================================================
     * Offset: 0x10  I2C Clock Divided Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |DIVIDER   |I2C Clock Divided Bits
     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4x (I2CLK+1)).
     * |        |          |Note: The minimum value of I2CLK is 4.
    */
    __IO uint32_t CLKDIV;

    /**
     * TOCTL
     * ===================================================================================================
     * Offset: 0x14  I2C Time-out Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |TOIF      |Time-Out Flag
     * |        |          |This bit is set by H/W when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (EI (I2CON[7])) is set to 1.
     * |        |          |Note: Write 1 to clear this bit.
     * |[1]     |TOCDIV4   |Time-Out Counter Input Clock Divided By 4
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |        |          |When Enabled, The time-out period is extend 4 times.
     * |[2]     |TOCEN     |Time-Out Counter Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI (I2CON[3]) is clear.
     * |        |          |Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
    */
    __IO uint32_t TOCTL;

    /**
     * ADDR1
     * ===================================================================================================
     * Offset: 0x18  I2C Slave Address Register1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |GC        |General Call Function
     * |        |          |0 = General Call Function Disabled.
     * |        |          |1 = General Call Function Enabled.
     * |[1:7]   |ADDR      |I2C Address Bits
     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
     * |        |          |The I2C hardware will react if either of the address is matched.
    */
    __IO uint32_t ADDR1;

    /**
     * ADDR2
     * ===================================================================================================
     * Offset: 0x1C  I2C Slave Address Register2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |GC        |General Call Function
     * |        |          |0 = General Call Function Disabled.
     * |        |          |1 = General Call Function Enabled.
     * |[1:7]   |ADDR      |I2C Address Bits
     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
     * |        |          |The I2C hardware will react if either of the address is matched.
    */
    __IO uint32_t ADDR2;

    /**
     * ADDR3
     * ===================================================================================================
     * Offset: 0x20  I2C Slave Address Register3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |GC        |General Call Function
     * |        |          |0 = General Call Function Disabled.
     * |        |          |1 = General Call Function Enabled.
     * |[1:7]   |ADDR      |I2C Address Bits
     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
     * |        |          |The I2C hardware will react if either of the address is matched.
    */
    __IO uint32_t ADDR3;

    /**
     * ADDRMSK0
     * ===================================================================================================
     * Offset: 0x24  I2C Slave Address Mask Register0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1:7]   |ADDRMSK   |I2C Address Mask Bits
     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
    */
    __IO uint32_t ADDRMSK0;

    /**
     * ADDRMSK1
     * ===================================================================================================
     * Offset: 0x28  I2C Slave Address Mask Register1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1:7]   |ADDRMSK   |I2C Address Mask Bits
     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
    */
    __IO uint32_t ADDRMSK1;

    /**
     * ADDRMSK2
     * ===================================================================================================
     * Offset: 0x2C  I2C Slave Address Mask Register2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1:7]   |ADDRMSK   |I2C Address Mask Bits
     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
    */
    __IO uint32_t ADDRMSK2;

    /**
     * ADDRMSK3
     * ===================================================================================================
     * Offset: 0x30  I2C Slave Address Mask Register3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1:7]   |ADDRMSK   |I2C Address Mask Bits
     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
    */
    __IO uint32_t ADDRMSK3;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[2];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * WKCTL
     * ===================================================================================================
     * Offset: 0x3C  I2C Wake-up Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |WKEN      |I2C Wake-Up Enable Control
     * |        |          |0 = I2C wake-up function Disabled.
     * |        |          |1 = I2C wake-up function Enabled.
    */
    __IO uint32_t WKCTL;

    /**
     * WKSTS
     * ===================================================================================================
     * Offset: 0x40  I2C Wake-up Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |WKIF      |I2C Wake-Up Flag
     * |        |          |0 = No wake up occurred.
     * |        |          |1 = Wake up from Power-down mode.
     * |        |          |Note: Software can write 1 to clear this bit.
    */
    __IO uint32_t WKSTS;

} I2C_T;

/**
    @addtogroup I2C_CONST I2C Bit Field Definition
    Constant Definitions for I2C Controller
@{ */

#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C_T::CTL: AA Position                   */
#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C_T::CTL: AA Mask                       */

#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C_T::CTL: SI Position                   */
#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C_T::CTL: SI Mask                       */

#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C_T::CTL: STO Position                  */
#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C_T::CTL: STO Mask                      */

#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C_T::CTL: STA Position                  */
#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C_T::CTL: STA Mask                      */

#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C_T::CTL: I2CEN Position                */
#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C_T::CTL: I2CEN Mask                    */

#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C_T::CTL: INTEN Position                */
#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C_T::CTL: INTEN Mask                    */

#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C_T::ADDR0: GC Position                 */
#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C_T::ADDR0: GC Mask                     */

#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR0: ADDR Position               */
#define I2C_ADDR0_ADDR_Msk               (0x7ful << I2C_ADDR0_ADDR_Pos)                    /*!< I2C_T::ADDR0: ADDR Mask                   */

#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C_T::DAT: DAT Position                  */
#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C_T::DAT: DAT Mask                      */

#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C_T::STATUS: STATUS Position            */
#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C_T::STATUS: STATUS Mask                */

#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C_T::CLKDIV: DIVIDER Position           */
#define I2C_CLKDIV_DIVIDER_Msk           (0xfful << I2C_CLKDIV_DIVIDER_Pos)                /*!< I2C_T::CLKDIV: DIVIDER Mask               */

#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C_T::TOCTL: TOIF Position               */
#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C_T::TOCTL: TOIF Mask                   */

#define I2C_TOCTL_TOCDIV4_Pos            (1)                                               /*!< I2C_T::TOCTL: TOCDIV4 Position            */
#define I2C_TOCTL_TOCDIV4_Msk            (0x1ul << I2C_TOCTL_TOCDIV4_Pos)                  /*!< I2C_T::TOCTL: TOCDIV4 Mask                */

#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C_T::TOCTL: TOCEN Position              */
#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C_T::TOCTL: TOCEN Mask                  */

#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C_T::ADDR1: GC Position                 */
#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C_T::ADDR1: GC Mask                     */

#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR1: ADDR Position               */
#define I2C_ADDR1_ADDR_Msk               (0x7ful << I2C_ADDR1_ADDR_Pos)                    /*!< I2C_T::ADDR1: ADDR Mask                   */

#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C_T::ADDR2: GC Position                 */
#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C_T::ADDR2: GC Mask                     */

#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR2: ADDR Position               */
#define I2C_ADDR2_ADDR_Msk               (0x7ful << I2C_ADDR2_ADDR_Pos)                    /*!< I2C_T::ADDR2: ADDR Mask                   */

#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C_T::ADDR3: GC Position                 */
#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C_T::ADDR3: GC Mask                     */

#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR3: ADDR Position               */
#define I2C_ADDR3_ADDR_Msk               (0x7ful << I2C_ADDR3_ADDR_Pos)                    /*!< I2C_T::ADDR3: ADDR Mask                   */

#define I2C_ADDRMSK0_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK0: ADDRMSK Position         */
#define I2C_ADDRMSK0_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK0_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK0: ADDRMSK Mask             */

#define I2C_ADDRMSK1_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK1: ADDRMSK Position         */
#define I2C_ADDRMSK1_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK1_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK1: ADDRMSK Mask             */

#define I2C_ADDRMSK2_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK2: ADDRMSK Position         */
#define I2C_ADDRMSK2_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK2_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK2: ADDRMSK Mask             */

#define I2C_ADDRMSK3_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK3: ADDRMSK Position         */
#define I2C_ADDRMSK3_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK3_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK3: ADDRMSK Mask             */

#define I2C_WKCTL_WKEN_Pos               (0)                                               /*!< I2C_T::WKCTL: WKEN Position               */
#define I2C_WKCTL_WKEN_Msk               (0x1ul << I2C_WKCTL_WKEN_Pos)                     /*!< I2C_T::WKCTL: WKEN Mask                   */

#define I2C_WKSTS_WKIF_Pos               (0)                                               /*!< I2C_T::WKSTS: WKIF Position               */
#define I2C_WKSTS_WKIF_Msk               (0x1ul << I2C_WKSTS_WKIF_Pos)                     /*!< I2C_T::WKSTS: WKIF Mask                   */

/**@}*/ /* I2C_CONST */
/**@}*/ /* end of I2C register group */


/*---------------------- I2S Interface Controller -------------------------*/
/**
    @addtogroup I2S I2S Interface Controller(I2S)
    Memory Mapped Structure for I2S Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  I2S Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |I2SEN     |I2S Controller Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |TXEN      |Transmit Enable Control
     * |        |          |0 = Data transmission Disabled.
     * |        |          |1 = Data transmission Enabled.
     * |[2]     |RXEN      |Receive Enable Control
     * |        |          |0 = Data receiving Disabled.
     * |        |          |1 = Data receiving Enabled.
     * |[3]     |MUTE      |Transmit Mute Enable Control
     * |        |          |0 = Transmit data is shifted from buffer.
     * |        |          |1 = Transmit zero data.
     * |[4:5]   |WDWIDTH   |Word Width
     * |        |          |00 = data is 8-bit.
     * |        |          |01 = data is 16-bit.
     * |        |          |10 = data is 24-bit.
     * |        |          |11 = data is 32-bit.
     * |[6]     |MONO      |Monaural Data Control
     * |        |          |0 = Data is stereo format.
     * |        |          |1 = Data is monaural format.
     * |        |          |Note: when chip records data, only right channel data will be saved if monaural format is select.
     * |[7]     |FORMAT    |Data Format Selection
     * |        |          |If PCM=0,
     * |        |          |0 = I2S data format.
     * |        |          |1 = MSB justified data format.
     * |        |          |If PCM=1,
     * |        |          |0 = PCM mode A.
     * |        |          |1 = PCM mode B.
     * |[8]     |SLAVE     |Slave Mode Enable Control
     * |        |          |0 = Master mode.
     * |        |          |1 = Slave mode.
     * |        |          |Note: I2S can operate as master or slave.
     * |        |          |For Master mode, I2S_BCLK and I2S_LRCLK pins are output mode and send bit clock from NuMicro(TM)
     * |        |          |NUC442/NUC472 series to Audio CODEC chip.
     * |        |          |In Slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals are received from outer Audio CODEC chip.
     * |[9:11]  |TXTH      |Transmit FIFO Threshold Level
     * |        |          |000 = 0 word data in transmit FIFO.
     * |        |          |001 = 1 word data in transmit FIFO.
     * |        |          |010 = 2 words data in transmit FIFO.
     * |        |          |011 = 3 words data in transmit FIFO.
     * |        |          |100 = 4 words data in transmit FIFO.
     * |        |          |101 = 5 words data in transmit FIFO.
     * |        |          |110 = 6 words data in transmit FIFO.
     * |        |          |111 = 7 words data in transmit FIFO.
     * |        |          |Note: If remain data word(s) in transmit FIFO is the same or less than threshold level then TXTHF flag is set.
     * |[12:14] |RXTH      |Receive FIFO Threshold Level
     * |        |          |000 = 1 word data in receive FIFO.
     * |        |          |001 = 2 word data in receive FIFO.
     * |        |          |010 = 3 word data in receive FIFO.
     * |        |          |011 = 4 word data in receive FIFO.
     * |        |          |100 = 5 word data in receive FIFO.
     * |        |          |101 = 6 word data in receive FIFO.
     * |        |          |110 = 7 word data in receive FIFO.
     * |        |          |111 = 8 word data in receive FIFO.
     * |        |          |Note: When received data word(s) in buffer is equal to or higher than threshold level then RXTHF flag is set.
     * |[15]    |MCLKEN    |Master Clock Enable Control
     * |        |          |0 = Master clock Disabled.
     * |        |          |1 = Master clock Enabled.
     * |        |          |Note: If the external crystal clock in NuMicro(TM) NUC442/NUC472 series is frequency 2*N*256fs, software can program MCLK_DIV(I2S_CLK[5:0]) to get 256fs clock to audio codec chip.
     * |[16]    |RZCEN     |Right Channel Zero-Cross Detection Enable Control
     * |        |          |0 = Right channel zero-cross detect Disabled.
     * |        |          |1 = Right channel zero-cross detect Enabled.
     * |        |          |Note1: If this bit is set to 1, when right channel data sign bit change or next shift data bits are all zero then RZCF(I2S_STATUS[22]) flag is set to 1.
     * |        |          |Note2: If RZCF Flag is set to 1, the right channel will be mute.
     * |[17]    |LZCEN     |Left Channel Zero-Cross Detect Enable Control
     * |        |          |0 = Left channel zero-cross detect Disabled.
     * |        |          |1 = Left channel zero-cross detect Enabled.
     * |        |          |Note1: If this bit is set to 1, when left channel data sign bit change or next shift data bits are all zero then LZCF(I2S_STATUS[23]) flag is set to 1.
     * |        |          |Note2: If LZCF Flag is set to 1, the left channel will be mute.
     * |[18]    |TXCLR     |Clear Transmit FIFO
     * |        |          |0 = No Effect.
     * |        |          |1 = Clear TX FIFO.
     * |        |          |Note1: Write 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and TXCNT(I2S_STATUS[31:28]) returns 0 and transmit FIFO becomes empty but data in transmit FIFO is not changed.
     * |        |          |Note2: This bit is clear by hardware automatically, read it return zero.
     * |[19]    |RXCLR     |Clear Receive FIFO
     * |        |          |0 = No Effect.
     * |        |          |1 = Clear RX FIFO.
     * |        |          |Note1: Write 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and RXCNT (I2S_STATUS[27:24]) returns 0 and receive FIFO becomes empty.
     * |        |          |Note2: This bit is cleared by hardware automatically, read it return zero.
     * |[20]    |TXPDMAEN  |Transmit DMA Enable Control
     * |        |          |0 = TX DMA Disabled.
     * |        |          |1 = TX DMA Enabled.
     * |        |          |Note: When TX DMA is enables, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO is not full.
     * |[21]    |RXPDMAEN  |Receive DMA Enable Control
     * |        |          |0 = RX DMA Disabled.
     * |        |          |1 = RX DMA Enabled.
     * |        |          |Note: When RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is not empty.
     * |[23]    |RXLCH     |Receive Left Channel Enable Control
     * |        |          |0 = Receives right channel data when monaural format is selected.
     * |        |          |1 = Receives left channel data when monaural format is selected.
     * |        |          |Note: When monaural format is selected (MONO = 1), I2S will receive right channel data if RXLCH is set to 0, and receive left channel data if RXLCH is set to 1.
     * |[24]    |PCMEN     |PCM Interface Enable Control
     * |        |          |0 = I2S Interface.
     * |        |          |1 = PCM Interface.
    */
    __IO uint32_t CTL;

    /**
     * CLKDIV
     * ===================================================================================================
     * Offset: 0x04  I2S Clock Divider Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |MCLKDIV   |Master Clock Divider
     * |        |          |If chip external crystal frequency is (2xMCLKDIV)*256fs then software can program these bits to generate 256fs clock frequency to audio codec chip.
     * |        |          |If MCLKDIV is set to 0, MCLK is the same as external clock input.
     * |        |          |For example, sampling rate is 24 kHz and chip external crystal clock is 12.288 MHz, set MCLKDIV = 1.
     * |        |          |F_MCLK = F_I2SCLK/(2x(MCLKDIV)) (When MCLKDIV is >= 1 ).
     * |        |          |F_MCLK = F_I2SCLK (When MCLKDIV is set to 0 ).
     * |        |          |Note: F_MCLK is the frequency of MCLK, and F_i2SCLK is the frequency of the I2S_CLK
     * |[8:16]  |BCLKDIV   |Bit Clock Divider
     * |        |          |If I2S operates in Master mode, bit clock is provided by the NuMicro(TM) NUC442/NUC472 series.
     * |        |          |Software can program these bits to generate sampling rate clock frequency.
     * |        |          |F_BCLK= F_I2SCLK / (2*(BCLKDIV + 1)).
     * |        |          |Note: F_BCLK is the frequency of BCLK and F_I2SCLK is the frequency of I2S_CLK
    */
    __IO uint32_t CLKDIV;

    /**
     * IEN
     * ===================================================================================================
     * Offset: 0x08  I2S Interrupt Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RXUDIEN   |Receive FIFO Underflow Interrupt E Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: If software reads receive FIFO when it is empty then RXUDIF(I2S_STATUS[8]) flag is set to 1.
     * |[1]     |RXOVIEN   |Receive FIFO Overflow Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: Interrupt occurs if this bit is set to 1 and RXOVIEN(I2S_STATUS[9]) flag is set to 1
     * |[2]     |RXTHIEN   |Receive FIFO Threshold Level Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: When data word in receive FIFO is equal or higher than RXTH(I2S_CTL[14:12]) and the RXTHF bit is set to 1.
     * |        |          |If RXTHIEN bit is enabled, interrupt occur.
     * |[8]     |TXUDIEN   |Transmit FIFO Underflow Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: Interrupt occur if this bit is set to 1 and TXUDIEN(I2S_STATUS[16]) flag is set to 1.
     * |[9]     |TXOVIEN   |Transmit FIFO Overflow Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: Interrupt occurs if this bit is set to 1 and TXOVIEN(I2S_STATUS[17]) flag is set to 1
     * |[10]    |TXTHIEN   |Transmit FIFO Threshold Level Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: Interrupt occurs if this bit is set to 1 and data words in transmit FIFO is less than TXTH(I2S_CTL[11:9]).
     * |[11]    |RZCIEN    |Right Channel Zero-Cross Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: Interrupt occurs if this bit is set to 1 and right channel zero-cross
     * |[12]    |LZCIEN    |Left Channel Zero-Cross Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: Interrupt occurs if this bit is set to 1 and left channel zero-cross
    */
    __IO uint32_t IEN;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x0C  I2S Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |I2SIF     |I2S Interrupt Flag (Read Only)
     * |        |          |0 = No I2S interrupt.
     * |        |          |1 = I2S interrupt.
     * |        |          |Note: It is wire-OR of TXIF and RXIF bits.
     * |[1]     |RXIF      |I2S Receive Interrupt (Read Only)
     * |        |          |0 = No receive interrupt.
     * |        |          |1 = Receive interrupt.
     * |[2]     |TXIF      |I2S Transmit Interrupt (Read Only)
     * |        |          |0 = No transmit interrupt.
     * |        |          |1 = Transmit interrupt.
     * |[3]     |RIGHT     |Right Channel (Read Only)
     * |        |          |0 = Left channel.
     * |        |          |1 = Right channel.
     * |        |          |Note: This bit indicate current transmit data is belong to right channel
     * |[8]     |RXUDIF    |Receive FIFO Underflow Flag
     * |        |          |0 = No underflow occur.
     * |        |          |1 = Underflow occur.
     * |        |          |Note1: When receive FIFO is empty, and software reads the receive FIFO again.
     * |        |          |This bit will be set to 1, and it indicates underflow situation occurs.
     * |        |          |Note2: Write 1 to clear this bit to zero
     * |[9]     |RXOVIF    |Receive FIFO Overflow Flag
     * |        |          |0 = No overflow occur.
     * |        |          |1 = Overflow occur.
     * |        |          |Note1: When receive FIFO is full and receive hardware attempt write to data into receive FIFO then this bit is set to 1, data in 1st buffer is overwrote.
     * |        |          |Note2: Write 1 to clear this bit to 0.
     * |[10]    |RXTHIF    |Receive FIFO Threshold Flag (Read Only)
     * |        |          |0 = Data word(s) in FIFO is lower than threshold level.
     * |        |          |1 = Data word(s) in FIFO is equal or higher than threshold level.
     * |        |          |Note: When data word(s) in receive FIFO is equal or higher than threshold value set in RXTH(I2S_CTL[14:12]) the RXTHIF bit becomes to 1.
     * |        |          |It keeps at 1 till RXCNT less than RXTH after software read RXFIFO register.
     * |[11]    |RXFULL    |Receive FIFO Full (Read Only)
     * |        |          |0 = Not full.
     * |        |          |1 = Full.
     * |        |          |Note: This bit reflects data words number in receive FIFO is 8.
     * |[12]    |RXEMPTY   |Receive FIFO Empty (Read Only)
     * |        |          |0 = Not empty.
     * |        |          |1 = Empty.
     * |        |          |Note: This bit reflects data words number in receive FIFO is zero
     * |[16]    |TXUDIF    |Transmit FIFO Underflow Flag
     * |        |          |0 = No underflow.
     * |        |          |1 = Underflow.
     * |        |          |Note1: When transmit FIFO is empty and shift logic hardware read data from data FIFO causes this set to 1.
     * |        |          |Note2: Write 1 to clear this bit to 0.
     * |[17]    |TXOVIF    |Transmit FIFO Overflow Flag
     * |        |          |0 = No overflow.
     * |        |          |1 = Overflow.
     * |        |          |Note1: Write data to transmit FIFO when it is full and this bit set to 1
     * |        |          |Note2: Write 1 to clear this bit to 0.
     * |[18]    |TXTHIF    |Transmit FIFO Threshold Flag (Read Only)
     * |        |          |0 = Data word(s) in FIFO is higher than threshold level.
     * |        |          |1 = Data word(s) in FIFO is equal or lower than threshold level.
     * |        |          |Note: When data word(s) in transmit FIFO is equal or lower than threshold value set in TXTH(I2S_CTL[11:9]) the TXTHIF bit becomes to 1.
     * |        |          |It keeps at 1 till TXCNT is higher than TXTH after software write TXFIFO register.
     * |[19]    |TXFULL    |Transmit FIFO Full (Read Only)
     * |        |          |This bit reflect data word number in transmit FIFO is 8
     * |        |          |0 = Not full.
     * |        |          |1 = Full.
     * |[20]    |TXEMPTY   |Transmit FIFO Empty (Read Only)
     * |        |          |This bit reflect data word number in transmit FIFO is zero
     * |        |          |0 = Not empty.
     * |        |          |1 = Empty.
     * |[21]    |TXBUSY    |Transmit Busy (Read Only)
     * |        |          |0 = Transmit shift buffer is empty.
     * |        |          |1 = Transmit shift buffer is busy.
     * |        |          |Note: This bit is cleared to 0 when all data in transmit FIFO and shift buffer is shifted out.
     * |        |          |And set to 1 when 1st data is load to shift buffer.
     * |[22]    |RZCIF     |Right Channel Zero-Cross Flag
     * |        |          |It indicates right channel next sample data sign bit is changed or all data bits are zero.
     * |        |          |0 = No zero-cross.
     * |        |          |1 = Right channel zero-cross is detected.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[23]    |LZCIF     |Left Channel Zero-Cross Flag
     * |        |          |It indicates left channel next sample data sign bit is changed or all data bits are zero.
     * |        |          |0 = No zero-cross.
     * |        |          |1 = Left channel zero-cross is detected.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[24:27] |RXCNT     |Receive FIFO Level (Read Only)
     * |        |          |These bits indicate word number in receive FIFO
     * |        |          |0000 = No data.
     * |        |          |0001 = 1 word in receive FIFO.
     * |        |          |....
     * |        |          |1000 = 8 words in receive FIFO.
     * |[28:31] |TXCNT     |Transmit FIFO Level (Read Only)
     * |        |          |These bits indicate word number in transmit FIFO
     * |        |          |0000 = No data.
     * |        |          |0001 = 1 word in transmit FIFO.
     * |        |          |....
     * |        |          |1000 = 8 words in transmit FIFO.
    */
    __IO  uint32_t STATUS;

    /**
     * TX
     * ===================================================================================================
     * Offset: 0x10  I2S Transmit FIFO Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |TX        |Transmit FIFO Bits
     * |        |          |I2S contains 8 words (8x32 bit) data buffer for data transmit.
     * |        |          |Write data to this register to prepare data for transmit.
     * |        |          |The remaining word number is indicated by TXCNT(I2S_STATUS[31:28]).
    */
    __O  uint32_t TX;

    /**
     * RX
     * ===================================================================================================
     * Offset: 0x14  I2S Receive FIFO Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |RX        |Receive FIFO Bits
     * |        |          |I2S contains 8 words (8x32 bit) data buffer for data receive.
     * |        |          |Read this register to get data in FIFO.
     * |        |          |The remaining data word number is indicated by RXCNT(I2S_STATUS[27:24]).
    */
    __I  uint32_t RX;

} I2S_T;

/**
    @addtogroup I2S_CONST I2S Bit Field Definition
    Constant Definitions for I2S Controller
@{ */

#define I2S_CTL_I2SEN_Pos                (0)                                               /*!< I2S_T::CTL: I2SEN Position                */
#define I2S_CTL_I2SEN_Msk                (0x1ul << I2S_CTL_I2SEN_Pos)                      /*!< I2S_T::CTL: I2SEN Mask                    */

#define I2S_CTL_TXEN_Pos                 (1)                                               /*!< I2S_T::CTL: TXEN Position                 */
#define I2S_CTL_TXEN_Msk                 (0x1ul << I2S_CTL_TXEN_Pos)                       /*!< I2S_T::CTL: TXEN Mask                     */

#define I2S_CTL_RXEN_Pos                 (2)                                               /*!< I2S_T::CTL: RXEN Position                 */
#define I2S_CTL_RXEN_Msk                 (0x1ul << I2S_CTL_RXEN_Pos)                       /*!< I2S_T::CTL: RXEN Mask                     */

#define I2S_CTL_MUTE_Pos                 (3)                                               /*!< I2S_T::CTL: MUTE Position                 */
#define I2S_CTL_MUTE_Msk                 (0x1ul << I2S_CTL_MUTE_Pos)                       /*!< I2S_T::CTL: MUTE Mask                     */

#define I2S_CTL_WDWIDTH_Pos              (4)                                               /*!< I2S_T::CTL: WDWIDTH Position              */
#define I2S_CTL_WDWIDTH_Msk              (0x3ul << I2S_CTL_WDWIDTH_Pos)                    /*!< I2S_T::CTL: WDWIDTH Mask                  */

#define I2S_CTL_MONO_Pos                 (6)                                               /*!< I2S_T::CTL: MONO Position                 */
#define I2S_CTL_MONO_Msk                 (0x1ul << I2S_CTL_MONO_Pos)                       /*!< I2S_T::CTL: MONO Mask                     */

#define I2S_CTL_FORMAT_Pos               (7)                                               /*!< I2S_T::CTL: FORMAT Position               */
#define I2S_CTL_FORMAT_Msk               (0x1ul << I2S_CTL_FORMAT_Pos)                     /*!< I2S_T::CTL: FORMAT Mask                   */

#define I2S_CTL_SLAVE_Pos                (8)                                               /*!< I2S_T::CTL: SLAVE Position                */
#define I2S_CTL_SLAVE_Msk                (0x1ul << I2S_CTL_SLAVE_Pos)                      /*!< I2S_T::CTL: SLAVE Mask                    */

#define I2S_CTL_TXTH_Pos                 (9)                                               /*!< I2S_T::CTL: TXTH Position                 */
#define I2S_CTL_TXTH_Msk                 (0x7ul << I2S_CTL_TXTH_Pos)                       /*!< I2S_T::CTL: TXTH Mask                     */

#define I2S_CTL_RXTH_Pos                 (12)                                              /*!< I2S_T::CTL: RXTH Position                 */
#define I2S_CTL_RXTH_Msk                 (0x7ul << I2S_CTL_RXTH_Pos)                       /*!< I2S_T::CTL: RXTH Mask                     */

#define I2S_CTL_MCLKEN_Pos               (15)                                              /*!< I2S_T::CTL: MCLKEN Position               */
#define I2S_CTL_MCLKEN_Msk               (0x1ul << I2S_CTL_MCLKEN_Pos)                     /*!< I2S_T::CTL: MCLKEN Mask                   */

#define I2S_CTL_RZCEN_Pos                (16)                                              /*!< I2S_T::CTL: RZCEN Position                */
#define I2S_CTL_RZCEN_Msk                (0x1ul << I2S_CTL_RZCEN_Pos)                      /*!< I2S_T::CTL: RZCEN Mask                    */

#define I2S_CTL_LZCEN_Pos                (17)                                              /*!< I2S_T::CTL: LZCEN Position                */
#define I2S_CTL_LZCEN_Msk                (0x1ul << I2S_CTL_LZCEN_Pos)                      /*!< I2S_T::CTL: LZCEN Mask                    */

#define I2S_CTL_TXCLR_Pos                (18)                                              /*!< I2S_T::CTL: TXCLR Position                */
#define I2S_CTL_TXCLR_Msk                (0x1ul << I2S_CTL_TXCLR_Pos)                      /*!< I2S_T::CTL: TXCLR Mask                    */

#define I2S_CTL_RXCLR_Pos                (19)                                              /*!< I2S_T::CTL: RXCLR Position                */
#define I2S_CTL_RXCLR_Msk                (0x1ul << I2S_CTL_RXCLR_Pos)                      /*!< I2S_T::CTL: RXCLR Mask                    */

#define I2S_CTL_TXPDMAEN_Pos             (20)                                              /*!< I2S_T::CTL: TXPDMAEN Position             */
#define I2S_CTL_TXPDMAEN_Msk             (0x1ul << I2S_CTL_TXPDMAEN_Pos)                   /*!< I2S_T::CTL: TXPDMAEN Mask                 */

#define I2S_CTL_RXPDMAEN_Pos             (21)                                              /*!< I2S_T::CTL: RXPDMAEN Position             */
#define I2S_CTL_RXPDMAEN_Msk             (0x1ul << I2S_CTL_RXPDMAEN_Pos)                   /*!< I2S_T::CTL: RXPDMAEN Mask                 */

#define I2S_CTL_RXLCH_Pos                (23)                                              /*!< I2S_T::CTL: RXLCH Position                */
#define I2S_CTL_RXLCH_Msk                (0x1ul << I2S_CTL_RXLCH_Pos)                      /*!< I2S_T::CTL: RXLCH Mask                    */

#define I2S_CTL_PCMEN_Pos                (24)                                              /*!< I2S_T::CTL: PCMEN Position                */
#define I2S_CTL_PCMEN_Msk                (0x1ul << I2S_CTL_PCMEN_Pos)                      /*!< I2S_T::CTL: PCMEN Mask                    */

#define I2S_CLKDIV_MCLKDIV_Pos           (0)                                               /*!< I2S_T::CLKDIV: MCLKDIV Position           */
#define I2S_CLKDIV_MCLKDIV_Msk           (0x3ful << I2S_CLKDIV_MCLKDIV_Pos)                /*!< I2S_T::CLKDIV: MCLKDIV Mask               */

#define I2S_CLKDIV_BCLKDIV_Pos           (8)                                               /*!< I2S_T::CLKDIV: BCLKDIV Position           */
#define I2S_CLKDIV_BCLKDIV_Msk           (0x1fful << I2S_CLKDIV_BCLKDIV_Pos)               /*!< I2S_T::CLKDIV: BCLKDIV Mask               */

#define I2S_IEN_RXUDIEN_Pos              (0)                                               /*!< I2S_T::IEN: RXUDIEN Position              */
#define I2S_IEN_RXUDIEN_Msk              (0x1ul << I2S_IEN_RXUDIEN_Pos)                    /*!< I2S_T::IEN: RXUDIEN Mask                  */

#define I2S_IEN_RXOVIEN_Pos              (1)                                               /*!< I2S_T::IEN: RXOVIEN Position              */
#define I2S_IEN_RXOVIEN_Msk              (0x1ul << I2S_IEN_RXOVIEN_Pos)                    /*!< I2S_T::IEN: RXOVIEN Mask                  */

#define I2S_IEN_RXTHIEN_Pos              (2)                                               /*!< I2S_T::IEN: RXTHIEN Position              */
#define I2S_IEN_RXTHIEN_Msk              (0x1ul << I2S_IEN_RXTHIEN_Pos)                    /*!< I2S_T::IEN: RXTHIEN Mask                  */

#define I2S_IEN_TXUDIEN_Pos              (8)                                               /*!< I2S_T::IEN: TXUDIEN Position              */
#define I2S_IEN_TXUDIEN_Msk              (0x1ul << I2S_IEN_TXUDIEN_Pos)                    /*!< I2S_T::IEN: TXUDIEN Mask                  */

#define I2S_IEN_TXOVIEN_Pos              (9)                                               /*!< I2S_T::IEN: TXOVIEN Position              */
#define I2S_IEN_TXOVIEN_Msk              (0x1ul << I2S_IEN_TXOVIEN_Pos)                    /*!< I2S_T::IEN: TXOVIEN Mask                  */

#define I2S_IEN_TXTHIEN_Pos              (10)                                              /*!< I2S_T::IEN: TXTHIEN Position              */
#define I2S_IEN_TXTHIEN_Msk              (0x1ul << I2S_IEN_TXTHIEN_Pos)                    /*!< I2S_T::IEN: TXTHIEN Mask                  */

#define I2S_IEN_RZCIEN_Pos               (11)                                              /*!< I2S_T::IEN: RZCIEN Position               */
#define I2S_IEN_RZCIEN_Msk               (0x1ul << I2S_IEN_RZCIEN_Pos)                     /*!< I2S_T::IEN: RZCIEN Mask                   */

#define I2S_IEN_LZCIEN_Pos               (12)                                              /*!< I2S_T::IEN: LZCIEN Position               */
#define I2S_IEN_LZCIEN_Msk               (0x1ul << I2S_IEN_LZCIEN_Pos)                     /*!< I2S_T::IEN: LZCIEN Mask                   */

#define I2S_STATUS_I2SIF_Pos             (0)                                               /*!< I2S_T::STATUS: I2SIF Position             */
#define I2S_STATUS_I2SIF_Msk             (0x1ul << I2S_STATUS_I2SIF_Pos)                   /*!< I2S_T::STATUS: I2SIF Mask                 */

#define I2S_STATUS_RXIF_Pos              (1)                                               /*!< I2S_T::STATUS: RXIF Position              */
#define I2S_STATUS_RXIF_Msk              (0x1ul << I2S_STATUS_RXIF_Pos)                    /*!< I2S_T::STATUS: RXIF Mask                  */

#define I2S_STATUS_TXIF_Pos              (2)                                               /*!< I2S_T::STATUS: TXIF Position              */
#define I2S_STATUS_TXIF_Msk              (0x1ul << I2S_STATUS_TXIF_Pos)                    /*!< I2S_T::STATUS: TXIF Mask                  */

#define I2S_STATUS_RIGHT_Pos             (3)                                               /*!< I2S_T::STATUS: RIGHT Position             */
#define I2S_STATUS_RIGHT_Msk             (0x1ul << I2S_STATUS_RIGHT_Pos)                   /*!< I2S_T::STATUS: RIGHT Mask                 */

#define I2S_STATUS_RXUDIF_Pos            (8)                                               /*!< I2S_T::STATUS: RXUDIF Position            */
#define I2S_STATUS_RXUDIF_Msk            (0x1ul << I2S_STATUS_RXUDIF_Pos)                  /*!< I2S_T::STATUS: RXUDIF Mask                */

#define I2S_STATUS_RXOVIF_Pos            (9)                                               /*!< I2S_T::STATUS: RXOVIF Position            */
#define I2S_STATUS_RXOVIF_Msk            (0x1ul << I2S_STATUS_RXOVIF_Pos)                  /*!< I2S_T::STATUS: RXOVIF Mask                */

#define I2S_STATUS_RXTHIF_Pos            (10)                                              /*!< I2S_T::STATUS: RXTHIF Position            */
#define I2S_STATUS_RXTHIF_Msk            (0x1ul << I2S_STATUS_RXTHIF_Pos)                  /*!< I2S_T::STATUS: RXTHIF Mask                */

#define I2S_STATUS_RXFULL_Pos            (11)                                              /*!< I2S_T::STATUS: RXFULL Position            */
#define I2S_STATUS_RXFULL_Msk            (0x1ul << I2S_STATUS_RXFULL_Pos)                  /*!< I2S_T::STATUS: RXFULL Mask                */

#define I2S_STATUS_RXEMPTY_Pos           (12)                                              /*!< I2S_T::STATUS: RXEMPTY Position           */
#define I2S_STATUS_RXEMPTY_Msk           (0x1ul << I2S_STATUS_RXEMPTY_Pos)                 /*!< I2S_T::STATUS: RXEMPTY Mask               */

#define I2S_STATUS_TXUDIF_Pos            (16)                                              /*!< I2S_T::STATUS: TXUDIF Position            */
#define I2S_STATUS_TXUDIF_Msk            (0x1ul << I2S_STATUS_TXUDIF_Pos)                  /*!< I2S_T::STATUS: TXUDIF Mask                */

#define I2S_STATUS_TXOVIF_Pos            (17)                                              /*!< I2S_T::STATUS: TXOVIF Position            */
#define I2S_STATUS_TXOVIF_Msk            (0x1ul << I2S_STATUS_TXOVIF_Pos)                  /*!< I2S_T::STATUS: TXOVIF Mask                */

#define I2S_STATUS_TXTHIF_Pos            (18)                                              /*!< I2S_T::STATUS: TXTHIF Position            */
#define I2S_STATUS_TXTHIF_Msk            (0x1ul << I2S_STATUS_TXTHIF_Pos)                  /*!< I2S_T::STATUS: TXTHIF Mask                */

#define I2S_STATUS_TXFULL_Pos            (19)                                              /*!< I2S_T::STATUS: TXFULL Position            */
#define I2S_STATUS_TXFULL_Msk            (0x1ul << I2S_STATUS_TXFULL_Pos)                  /*!< I2S_T::STATUS: TXFULL Mask                */

#define I2S_STATUS_TXEMPTY_Pos           (20)                                              /*!< I2S_T::STATUS: TXEMPTY Position           */
#define I2S_STATUS_TXEMPTY_Msk           (0x1ul << I2S_STATUS_TXEMPTY_Pos)                 /*!< I2S_T::STATUS: TXEMPTY Mask               */

#define I2S_STATUS_TXBUSY_Pos            (21)                                              /*!< I2S_T::STATUS: TXBUSY Position            */
#define I2S_STATUS_TXBUSY_Msk            (0x1ul << I2S_STATUS_TXBUSY_Pos)                  /*!< I2S_T::STATUS: TXBUSY Mask                */

#define I2S_STATUS_RZCIF_Pos             (22)                                              /*!< I2S_T::STATUS: RZCIF Position             */
#define I2S_STATUS_RZCIF_Msk             (0x1ul << I2S_STATUS_RZCIF_Pos)                   /*!< I2S_T::STATUS: RZCIF Mask                 */

#define I2S_STATUS_LZCIF_Pos             (23)                                              /*!< I2S_T::STATUS: LZCIF Position             */
#define I2S_STATUS_LZCIF_Msk             (0x1ul << I2S_STATUS_LZCIF_Pos)                   /*!< I2S_T::STATUS: LZCIF Mask                 */

#define I2S_STATUS_RXCNT_Pos             (24)                                              /*!< I2S_T::STATUS: RXCNT Position             */
#define I2S_STATUS_RXCNT_Msk             (0xful << I2S_STATUS_RXCNT_Pos)                   /*!< I2S_T::STATUS: RXCNT Mask                 */

#define I2S_STATUS_TXCNT_Pos             (28)                                              /*!< I2S_T::STATUS: TXCNT Position             */
#define I2S_STATUS_TXCNT_Msk             (0xful << I2S_STATUS_TXCNT_Pos)                   /*!< I2S_T::STATUS: TXCNT Mask                 */

#define I2S_TX_TX_Pos                    (0)                                               /*!< I2S_T::TX: TX Position                    */
#define I2S_TX_TX_Msk                    (0xfffffffful << I2S_TX_TX_Pos)                   /*!< I2S_T::TX: TX Mask                        */

#define I2S_RX_RX_Pos                    (0)                                               /*!< I2S_T::RX: RX Position                    */
#define I2S_RX_RX_Msk                    (0xfffffffful << I2S_RX_RX_Pos)                   /*!< I2S_T::RX: RX Mask                        */

/**@}*/ /* I2S_CONST */
/**@}*/ /* end of I2S register group */


/*---------------------- OP Amplifier -------------------------*/
/**
    @addtogroup OPA OP Amplifier(OPA)
    Memory Mapped Structure for OPA Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  OP Amplifier Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |OPEN0     |OP Amplifier 0 Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |        |          |Note: OP Amplifier 0 output needs wait stable 20us[MS1] after OPEN0 is first set.
     * |        |          |[MS1]alpha test
     * |[1]     |OPEN1     |OP Amplifier 1 Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |        |          |Note: OP Amplifier 1 output needs wait stable 20us[MS1] after OPEN1 is first set.
     * |        |          |[MS1]alpha test
     * |[4]     |OPSMTEN0  |OP Amplifier 0 Schmitt Trigger Non-Inverting Buffer Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |OPSMTEN1  |OP Amplifier 1 Schmitt Trigger Non-Inverting Buffer Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[8]     |OPAIE0    |OP Amplifier 0 Schmitt Trigger Digital Output Interrupt Enable Control
     * |        |          |0 = OP Amplifier 0 digital output interrupt function Disabled.
     * |        |          |1 = OP Amplifier 0 digital output interrupt function Enabled.
     * |        |          |The OPDF0 interrupt flag is set by hardware whenever the OP amplifier 0 Schmitt trigger non-inverting buffer digital output changes state, in the meanwhile, if OPAIE0 is set to 1, a comparator interrupt request is generated.
     * |[9]     |OPAIE1    |OP Amplifier 1 Schmitt Trigger Digital Output Interrupt Enable Control
     * |        |          |0 = OP Amplifier 1 digital output interrupt function Disabled.
     * |        |          |1 = OP Amplifier 1 digital output interrupt function Enabled.
     * |        |          |OPDF1 interrupt flag is set by hardware whenever the OP amplifier 1 Schmitt trigger non-inverting buffer digital output changes state, in the meanwhile, if OPAIE1 is set to 1, a comparator interrupt request is generated.
    */
    __IO uint32_t CTL;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x04  OP Amplifier Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |OPDO0     |OP Amplifier 0 Digital Output
     * |        |          |Synchronized to the APB clock to allow reading by software.
     * |        |          |Cleared when the Schmitt trigger buffer is disabled (OPSMTEN0 = 0).
     * |[1]     |OPDO1     |OP Amplifier 1 Digital Output
     * |        |          |Synchronized to the APB clock to allow reading by software.
     * |        |          |Cleared when the Schmitt trigger buffer is disabled (OPSMTEN1 = 0).
     * |[4]     |OPDF0     |OP Amplifier 0 Schmitt Trigger Digital Output Interrupt Flag
     * |        |          |OPDF0 interrupt flag is set by hardware whenever the OP amplifier 0 Schmitt trigger non-inverting buffer digital output changes state.
     * |        |          |This bit is cleared by writing 1 to it.
     * |[5]     |OPDF1     |OP Amplifier 1 Schmitt Trigger Digital Output Interrupt Flag
     * |        |          |OPDF1 interrupt flag is set by hardware whenever the OP amplifier 1 Schmitt trigger non-inverting buffer digital output changes state.
     * |        |          |This bit is cleared by writing 1 to it.
    */
    __IO uint32_t STATUS;

} OPA_T;

/**
    @addtogroup OPA_CONST OPA Bit Field Definition
    Constant Definitions for OPA Controller
@{ */

#define OPA_CTL_OPEN0_Pos                (0)                                               /*!< OPA_T::CTL: OPEN0 Position                */
#define OPA_CTL_OPEN0_Msk                (0x1ul << OPA_CTL_OPEN0_Pos)                      /*!< OPA_T::CTL: OPEN0 Mask                    */

#define OPA_CTL_OPEN1_Pos                (1)                                               /*!< OPA_T::CTL: OPEN1 Position                */
#define OPA_CTL_OPEN1_Msk                (0x1ul << OPA_CTL_OPEN1_Pos)                      /*!< OPA_T::CTL: OPEN1 Mask                    */

#define OPA_CTL_OPSMTEN0_Pos             (4)                                               /*!< OPA_T::CTL: OPSMTEN0 Position             */
#define OPA_CTL_OPSMTEN0_Msk             (0x1ul << OPA_CTL_OPSMTEN0_Pos)                   /*!< OPA_T::CTL: OPSMTEN0 Mask                 */

#define OPA_CTL_OPSMTEN1_Pos             (5)                                               /*!< OPA_T::CTL: OPSMTEN1 Position             */
#define OPA_CTL_OPSMTEN1_Msk             (0x1ul << OPA_CTL_OPSMTEN1_Pos)                   /*!< OPA_T::CTL: OPSMTEN1 Mask                 */

#define OPA_CTL_OPAIE0_Pos               (8)                                               /*!< OPA_T::CTL: OPAIE0 Position               */
#define OPA_CTL_OPAIE0_Msk               (0x1ul << OPA_CTL_OPAIE0_Pos)                     /*!< OPA_T::CTL: OPAIE0 Mask                   */

#define OPA_CTL_OPAIE1_Pos               (9)                                               /*!< OPA_T::CTL: OPAIE1 Position               */
#define OPA_CTL_OPAIE1_Msk               (0x1ul << OPA_CTL_OPAIE1_Pos)                     /*!< OPA_T::CTL: OPAIE1 Mask                   */

#define OPA_STATUS_OPDO0_Pos             (0)                                               /*!< OPA_T::STATUS: OPDO0 Position             */
#define OPA_STATUS_OPDO0_Msk             (0x1ul << OPA_STATUS_OPDO0_Pos)                   /*!< OPA_T::STATUS: OPDO0 Mask                 */

#define OPA_STATUS_OPDO1_Pos             (1)                                               /*!< OPA_T::STATUS: OPDO1 Position             */
#define OPA_STATUS_OPDO1_Msk             (0x1ul << OPA_STATUS_OPDO1_Pos)                   /*!< OPA_T::STATUS: OPDO1 Mask                 */

#define OPA_STATUS_OPDF0_Pos             (4)                                               /*!< OPA_T::STATUS: OPDF0 Position             */
#define OPA_STATUS_OPDF0_Msk             (0x1ul << OPA_STATUS_OPDF0_Pos)                   /*!< OPA_T::STATUS: OPDF0 Mask                 */

#define OPA_STATUS_OPDF1_Pos             (5)                                               /*!< OPA_T::STATUS: OPDF1 Position             */
#define OPA_STATUS_OPDF1_Msk             (0x1ul << OPA_STATUS_OPDF1_Pos)                   /*!< OPA_T::STATUS: OPDF1 Mask                 */

/**@}*/ /* OPA_CONST */
/**@}*/ /* end of OPA register group */


/*---------------------- USB On-The-Go Controller -------------------------*/
/**
    @addtogroup OTG USB On-The-Go Controller(OTG)
    Memory Mapped Structure for OTG Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  OTG Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |VBUSDROP  |Drop The VUSB Bus
     * |        |          |If user application running on this OTG A-device wants to conserve power consumption, set this bit to high When set this bit to TRUE, BUSREQ shall be cleared as well.
     * |        |          |0 = Did Not drop the VBUS and keep going on USB data transfers.
     * |        |          |1 = Drop the VBUS to conserve power consumption.
     * |[1]     |BUSREQ    |OTG A-Device Bus Request
     * |        |          |If user application of an OTG A-device wants to do data transfers via USB bus, set this bit to high Otherwise if user application won't use the bus any more, set this bit to low.
     * |        |          |This bit will be automatically cleared if VBUSDROP bit is set to TRUE.
     * |[2]     |HNPREQEN  |OTG B-Device HNP Enable/Request
     * |        |          |Set this bit to TRUE after the OTG A-device successfully sends a SetFeature(b_hnp_enable) command to the OTG B-device This bit will be cleared automatically when a bus reset or SESS_VLD goes from TRUE to FALSE.
     * |[4]     |OTGEN     |OTG Function Enable Control
     * |        |          |If USB is configured as OTG device, this bit must set high.
     * |        |          |0= OTG function Disabled.
     * |        |          |1 = OTG function Enabled.
     * |[7]     |PDEVCKON  |Force OTG PHY Output Clock To USB Device
     * |        |          |If software configures OTG controller as OTG device and OTG device as A-device, OTG controller will output OTG PHY clock (30 MHz) to USB device only when OTG device as A-peripheral.
     * |        |          |If software needs to configure USB device before role change (from A-Host to A-Peripheral), software can set this bit high to output OTG PHY clock to USB device.
     * |        |          |0= USB device clock is available only when OTG device as a peripheral.
     * |        |          |1 = Force output OTG PHY clock to USB device.
     * |[8]     |WKEN      |OTG Wake-Up Enable Control
     * |        |          |0= OTG ID pin status change wake-up Disabled.
     * |        |          |1 = OTG ID pin status change wake-up Enabled.
    */
    __IO uint32_t CTL;

    /**
     * PHYCTL
     * ===================================================================================================
     * Offset: 0x04  OTG PHY Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SWPDEN    |Software Control Pull-Down On Data Lines Enable Control
     * |        |          |0 = Pull-down resistors on data lines is controlled by OTG control logic.
     * |        |          |1 = Pull-down resistors on data lines is controlled by software.
     * |        |          |Note: Software must set this bit high before controlling DPPDEN and DMPDEN.
     * |[1]     |DPPDEN    |D+ Pull-Down Enable Control Set SWPDEN to TRUE before using this function
     * |        |          |0 = 15 kOhm resistor pull-down on D+ pin Disabled.
     * |        |          |1 = 15 kOhm resistor pull-down on D+ pin Enabled.
     * |[2]     |DMPDEN    |D- Pull-Down Enable Control Set SWPDEN to TRUE before using this function
     * |        |          |0 = 15 kOhm resistor pull-down on D- pin Disabled.
     * |        |          |1 = 15 kOhm resistor pull-down on D- pin Enabled.
     * |[5]     |VBSTSPOL  |Off-Chip USB VBUS Power Status Polarity
     * |        |          |The polarity of off-chip USB VBUS LDO valid depends on the selected component.
     * |        |          |This bit provides the inversed option of off-chip USB VBUS LDO valid.
     * |        |          |0 = The polarity of off-chip USB VBUS LDO valid not inversed.
     * |        |          |1 = The polarity of off-chip USB VBUS LDO valid inversed.
     * |[6]     |VBENPOL   |Off-Chip USB VBUS Power Enable Polarity
     * |        |          |The OTG controller will enable off-chip USB VBUS LDO to provide VBUS power when need.
     * |        |          |The polarity of enabling off-chip BSU VBUS LDO (high active or low active) depends on the selected component.
     * |        |          |This bit provides the inverse option of off-chip USB VBUS LDO enable.
     * |        |          |0 = The polarity of enabling off-chip USB VBUS LDO from the OTG controller not inversed.
     * |        |          |1 = The polarity of enabling off-chip USB VBUS LDO from the OTG controller inversed.
     * |[7]     |IDDETEN   |ID Detection Enable
     * |        |          |0 = Sampling on ID pin Enabled.
     * |        |          |1 = Sampling on ID pin Disabled.
     * |[8]     |PHYCLK    |PHY Input Clock Selection
     * |        |          |0 = PHY input clock is12 MHz.
     * |        |          |1 = PHY input clock is 24 MHz.
     * |[9]     |OTGPHYEN  |OTG PHY Enable Control When Device Configured As OTG-Device
     * |        |          |When device is configured as OTG-device, hardware will not enable OTG PHY automatically.
     * |        |          |Software can set OTG_EN to enable OTG PHY.
     * |        |          |0 = OTG PHY Disabled.
     * |        |          |1 = OTG PHY Enabled.
    */
    __IO uint32_t PHYCTL;

    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0x08  OTG Interrupt Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ROLECHGIEN|Role(Host Or Peripheral) Changed Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |[1]     |VBEIEN    |VBUS Error Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: VBUS error means going to a_vbus_err state. Please refer to A-device state diagram in OTG spec.
     * |[2]     |SRPFIEN   |SRP Fail Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |[3]     |HNPFIEN   |HNP Fail Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |[4]     |GOIDLEIEN |OTG Device Goes IDLE State Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |        |          |Note: Going to idle state means going to a_idle or b_idle state.
     * |        |          |Please refer to A-device state diagram and B-device state diagram in OTG spec.
     * |[5]     |IDCHGIEN  |IDSTS Changed Interrupt Enable
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |[6]     |PDEVIEN   |Act As Peripheral Interrupt Enable Control
     * |        |          |0 = This device as a peripheral interrupt Disabled.
     * |        |          |1 = This device as a peripheral interrupt Enabled.
     * |[7]     |HOSTIEN   |Act As Host Interrupt Enable Control
     * |        |          |0= This device as a host interrupt Disabled.
     * |        |          |1 = This device as a host interrupt Enabled.
     * |[8]     |BVLDCHGIEN|B-Device Session Valid Status Change (From High To Low Or From Low To High) Interrupt Enable Control
     * |        |          |0 =Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |[9]     |AVLDCHGIEN|A-Device Session Valid Status Change (From High To Low Or From Low To High) Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |[10]    |VBCHGIEN  |VBVALID Status Changed Interrupt Enable
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |[11]    |SECHGIEN  |SESSEND Status Changed Interrupt Enable Control 0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
     * |[13]    |SRPDETIEN |SRP Detected Interrupt Enable Control
     * |        |          |0 = Interrupt Disabled.
     * |        |          |1 = Interrupt Enabled.
    */
    __IO uint32_t INTEN;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x0C  OTG Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ROLECHGIF |OTG Role Change Interrupt Status
     * |        |          |This flag is set when the role of an OTG device changed from a host to a peripheral, or changed from a peripheral to a host
     * |        |          |Note: Write 1 to clear this flag.
     * |[1]     |VBEIF     |VBUS Error Interrupt Status
     * |        |          |This flag will be set in one of two conditions
     * |        |          |l One case is that voltage on VBUS cannot reach a minimum valid threshold 4.4V within a maximum time of 100ms after OTG A device starting to drive.
     * |        |          |l The other case is that the supplied VBUS drops below a minimum valid threshold due to the overcurrent condition.
     * |        |          |Note: Write 1 to clear this flag and recover from the VBUS error state.
     * |[2]     |SRPFIF    |SRP Fail Interrupt Status
     * |        |          |After initiating SRP, an OTG B-device will wait at least TB_SRP_FAIL min, defined in OTG specification, for the OTG A-device respond This flag is set when the OTG B-device didn't get the response from the remote A-device to turn VBUS on and generate a bus reset.
     * |        |          |Note: Write 1 to clear this flag.
     * |[3]     |HNPFIF    |HNP Fail Interrupt Status
     * |        |          |When A-device has granted B-device to be host and USB bus in SE0 state, this bit will be set in specified interval (b_ase0_brst_tmr, defined in OTG spec.
     * |        |          |specification), A-device does not signal connect signal.
     * |        |          |Note: Write 1 to clear this flag.
     * |[4]     |GOIDLEIF  |OTG Device Goes IDLE Interrupt Status
     * |        |          |Flag is set if the OTG device transfers from non-idle state to idle state.
     * |        |          |The OTG device will be neither a host nor a peripheral.
     * |        |          |0 = OTG device does not go back to idle state(a_idle or b_idle).
     * |        |          |1 = OTG device go back to idle state(a_idle or b_idle).
     * |        |          |Note: Write 1 to clear this flag.
     * |[5]     |IDCHGIF   |ID State Change Interrupt Status
     * |        |          |0 = IDSTS not toggled.
     * |        |          |1 = IDSTS from high to low or from low to high.
     * |        |          |Note1: OTG_CTL[BUSREQ] will be cleared when IDDIG is high.
     * |        |          |Note2: Write 1 to clear this flag.
     * |[6]     |PDEVIF    |Act As Peripheral Interrupt Status
     * |        |          |0= This device does not act as a peripheral.
     * |        |          |1 = This device acts as a peripheral.
     * |        |          |Note: Write 1 to clear this flag.
     * |[7]     |HOSTIF    |Act As Host Interrupt Status
     * |        |          |0= This device does not act as a host.
     * |        |          |1 = This device acts as a host.
     * |        |          |Note: Write 1 to clear this flag.
     * |[8]     |BVLDCHGIF |B-Device Session Valid State Change Interrupt Status
     * |        |          |0 = BVLD not toggled.
     * |        |          |1 = BVLD from high to low or low to high.
     * |        |          |Note: Write 1 to clear this status.
     * |[9]     |AVLDCHGIF |A-Device Session Valid State Change Interrupt Status
     * |        |          |0 = AVLD not toggled.
     * |        |          |1 = AVLD from high to low or low to high.
     * |        |          |Note: Write 1 to clear this flag.
     * |[10]    |VBCHGIF   |VBVALID State Change Interrupt Status
     * |        |          |0 = VBUS_VLD not toggled.
     * |        |          |1 = VBUSVLD from high to low or from low to high.
     * |        |          |Note: Write 1 to clear this flag.
     * |[11]    |SECHGIF   |SESSEND State Change Interrupt Status
     * |        |          |0 = Session end not toggled.
     * |        |          |1 = SESSEND from high to low or from low to high.
     * |        |          |Note: Write 1 to clear this flag.
     * |[13]    |SRPDETIF  |SRP Detected Interrupt Status
     * |        |          |0 = SRP not detected.
     * |        |          |1 = SRP detected.
     * |        |          |Note: Write 1 to clear this status.
    */
    __IO uint32_t INTSTS;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x10  Functional Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |OVERCUR   |Over current Condition
     * |        |          |The voltage on VBUS cannot reach a minimum VBUS valid threshold, 4.4V minimum, within a maximum time of 100ms after OTG A device starting to drive
     * |        |          |0 = OTG A-device drives VBUS successfully.
     * |        |          |1 = Over current condition occurred.
     * |[1]     |IDSTS     |ID Pin State Of Mini-B/Micro-Plug
     * |        |          |0 = Mini-A/Micro-A plug is attached.
     * |        |          |1 = Mini-B/Micro-B plug is attached.
     * |[2]     |SESSEND   |Session End Status
     * |        |          |0 = VBUS > 0.8V.
     * |        |          |1 = VBUS < 0.2V.
     * |[3]     |BVLID     |B-Device Session Valid Status
     * |        |          |0 = VBUS < 0.8V.
     * |        |          |1 = VBUS > 4V.
     * |[4]     |AVLD      |A-Device Session Valid Status
     * |        |          |0 = VBUS < 0.8V.
     * |        |          |1 = VBUS > 2V.
     * |[5]     |VBUSVLD   |VBUS Valid Status
     * |        |          |0 = VBUS < 4.4V.
     * |        |          |1 = VBUS > 4.75V.
    */
    __I  uint32_t STATUS;

} OTG_T;

/**
    @addtogroup OTG_CONST OTG Bit Field Definition
    Constant Definitions for OTG Controller
@{ */

#define OTG_CTL_VBUSDROP_Pos             (0)                                               /*!< OTG_T::CTL: VBUSDROP Position             */
#define OTG_CTL_VBUSDROP_Msk             (0x1ul << OTG_CTL_VBUSDROP_Pos)                   /*!< OTG_T::CTL: VBUSDROP Mask                 */

#define OTG_CTL_BUSREQ_Pos               (1)                                               /*!< OTG_T::CTL: BUSREQ Position               */
#define OTG_CTL_BUSREQ_Msk               (0x1ul << OTG_CTL_BUSREQ_Pos)                     /*!< OTG_T::CTL: BUSREQ Mask                   */

#define OTG_CTL_HNPREQEN_Pos             (2)                                               /*!< OTG_T::CTL: HNPREQEN Position             */
#define OTG_CTL_HNPREQEN_Msk             (0x1ul << OTG_CTL_HNPREQEN_Pos)                   /*!< OTG_T::CTL: HNPREQEN Mask                 */

#define OTG_CTL_OTGEN_Pos                (4)                                               /*!< OTG_T::CTL: OTGEN Position                */
#define OTG_CTL_OTGEN_Msk                (0x1ul << OTG_CTL_OTGEN_Pos)                      /*!< OTG_T::CTL: OTGEN Mask                    */

#define OTG_CTL_PDEVCKON_Pos             (7)                                               /*!< OTG_T::CTL: PDEVCKON Position             */
#define OTG_CTL_PDEVCKON_Msk             (0x1ul << OTG_CTL_PDEVCKON_Pos)                   /*!< OTG_T::CTL: PDEVCKON Mask                 */

#define OTG_CTL_WKEN_Pos                 (8)                                               /*!< OTG_T::CTL: WKEN Position                 */
#define OTG_CTL_WKEN_Msk                 (0x1ul << OTG_CTL_WKEN_Pos)                       /*!< OTG_T::CTL: WKEN Mask                     */

#define OTG_PHYCTL_SWPDEN_Pos            (0)                                               /*!< OTG_T::PHYCTL: SWPDEN Position            */
#define OTG_PHYCTL_SWPDEN_Msk            (0x1ul << OTG_PHYCTL_SWPDEN_Pos)                  /*!< OTG_T::PHYCTL: SWPDEN Mask                */

#define OTG_PHYCTL_DPPDEN_Pos            (1)                                               /*!< OTG_T::PHYCTL: DPPDEN Position            */
#define OTG_PHYCTL_DPPDEN_Msk            (0x1ul << OTG_PHYCTL_DPPDEN_Pos)                  /*!< OTG_T::PHYCTL: DPPDEN Mask                */

#define OTG_PHYCTL_DMPDEN_Pos            (2)                                               /*!< OTG_T::PHYCTL: DMPDEN Position            */
#define OTG_PHYCTL_DMPDEN_Msk            (0x1ul << OTG_PHYCTL_DMPDEN_Pos)                  /*!< OTG_T::PHYCTL: DMPDEN Mask                */

#define OTG_PHYCTL_VBSTSPOL_Pos          (5)                                               /*!< OTG_T::PHYCTL: VBSTSPOL Position          */
#define OTG_PHYCTL_VBSTSPOL_Msk          (0x1ul << OTG_PHYCTL_VBSTSPOL_Pos)                /*!< OTG_T::PHYCTL: VBSTSPOL Mask              */

#define OTG_PHYCTL_VBENPOL_Pos           (6)                                               /*!< OTG_T::PHYCTL: VBUSPOL Position           */
#define OTG_PHYCTL_VBENPOL_Msk           (0x1ul << OTG_PHYCTL_VBENPOL_Pos)                 /*!< OTG_T::PHYCTL: VBUSPOL Mask               */

#define OTG_PHYCTL_IDDETEN_Pos           (7)                                               /*!< OTG_T::PHYCTL: IDDETEN Position           */
#define OTG_PHYCTL_IDDETEN_Msk           (0x1ul << OTG_PHYCTL_IDDETEN_Pos)                 /*!< OTG_T::PHYCTL: IDDETEN Mask               */

#define OTG_PHYCTL_PHYCLK_Pos            (8)                                               /*!< OTG_T::PHYCTL: PHYCLK Position            */
#define OTG_PHYCTL_PHYCLK_Msk            (0x1ul << OTG_PHYCTL_PHYCLK_Pos)                  /*!< OTG_T::PHYCTL: PHYCLK Mask                */

#define OTG_PHYCTL_OTGPHYEN_Pos          (9)                                               /*!< OTG_T::PHYCTL: OTGPHYEN Position          */
#define OTG_PHYCTL_OTGPHYEN_Msk          (0x1ul << OTG_PHYCTL_OTGPHYEN_Pos)                /*!< OTG_T::PHYCTL: OTGPHYEN Mask              */

#define OTG_INTEN_ROLECHGIEN_Pos         (0)                                               /*!< OTG_T::INTEN: ROLECHGIEN Position         */
#define OTG_INTEN_ROLECHGIEN_Msk         (0x1ul << OTG_INTEN_ROLECHGIEN_Pos)               /*!< OTG_T::INTEN: ROLECHGIEN Mask             */

#define OTG_INTEN_VBEIEN_Pos             (1)                                               /*!< OTG_T::INTEN: VBEIEN Position             */
#define OTG_INTEN_VBEIEN_Msk             (0x1ul << OTG_INTEN_VBEIEN_Pos)                   /*!< OTG_T::INTEN: VBEIEN Mask                 */

#define OTG_INTEN_SRPFIEN_Pos            (2)                                               /*!< OTG_T::INTEN: SRPFIEN Position            */
#define OTG_INTEN_SRPFIEN_Msk            (0x1ul << OTG_INTEN_SRPFIEN_Pos)                  /*!< OTG_T::INTEN: SRPFIEN Mask                */

#define OTG_INTEN_HNPFIEN_Pos            (3)                                               /*!< OTG_T::INTEN: HNPFIEN Position            */
#define OTG_INTEN_HNPFIEN_Msk            (0x1ul << OTG_INTEN_HNPFIEN_Pos)                  /*!< OTG_T::INTEN: HNPFIEN Mask                */

#define OTG_INTEN_GOIDLEIEN_Pos          (4)                                               /*!< OTG_T::INTEN: GOIDLEIEN Position          */
#define OTG_INTEN_GOIDLEIEN_Msk          (0x1ul << OTG_INTEN_GOIDLEIEN_Pos)                /*!< OTG_T::INTEN: GOIDLEIEN Mask              */

#define OTG_INTEN_IDCHGIEN_Pos           (5)                                               /*!< OTG_T::INTEN: IDCHGIEN Position           */
#define OTG_INTEN_IDCHGIEN_Msk           (0x1ul << OTG_INTEN_IDCHGIEN_Pos)                 /*!< OTG_T::INTEN: IDCHGIEN Mask               */

#define OTG_INTEN_PDEVIEN_Pos            (6)                                               /*!< OTG_T::INTEN: PDEVIEN Position            */
#define OTG_INTEN_PDEVIEN_Msk            (0x1ul << OTG_INTEN_PDEVIEN_Pos)                  /*!< OTG_T::INTEN: PDEVIEN Mask                */

#define OTG_INTEN_HOSTIEN_Pos            (7)                                               /*!< OTG_T::INTEN: HOSTIEN Position            */
#define OTG_INTEN_HOSTIEN_Msk            (0x1ul << OTG_INTEN_HOSTIEN_Pos)                  /*!< OTG_T::INTEN: HOSTIEN Mask                */

#define OTG_INTEN_BVLDCHGIEN_Pos         (8)                                               /*!< OTG_T::INTEN: BVLDCHGIEN Position         */
#define OTG_INTEN_BVLDCHGIEN_Msk         (0x1ul << OTG_INTEN_BVLDCHGIEN_Pos)               /*!< OTG_T::INTEN: BVLDCHGIEN Mask             */

#define OTG_INTEN_AVLDCHGIEN_Pos         (9)                                               /*!< OTG_T::INTEN: AVLDCHGIEN Position         */
#define OTG_INTEN_AVLDCHGIEN_Msk         (0x1ul << OTG_INTEN_AVLDCHGIEN_Pos)               /*!< OTG_T::INTEN: AVLDCHGIEN Mask             */

#define OTG_INTEN_VBCHGIEN_Pos           (10)                                              /*!< OTG_T::INTEN: VBCHGIEN Position           */
#define OTG_INTEN_VBCHGIEN_Msk           (0x1ul << OTG_INTEN_VBCHGIEN_Pos)                 /*!< OTG_T::INTEN: VBCHGIEN Mask               */

#define OTG_INTEN_SECHGIEN_Pos           (11)                                              /*!< OTG_T::INTEN: SECHGIEN Position           */
#define OTG_INTEN_SECHGIEN_Msk           (0x1ul << OTG_INTEN_SECHGIEN_Pos)                 /*!< OTG_T::INTEN: SECHGIEN Mask               */

#define OTG_INTEN_SRPDETIEN_Pos          (13)                                              /*!< OTG_T::INTEN: SRPDETIEN Position          */
#define OTG_INTEN_SRPDETIEN_Msk          (0x1ul << OTG_INTEN_SRPDETIEN_Pos)                /*!< OTG_T::INTEN: SRPDETIEN Mask              */

#define OTG_INTSTS_ROLECHGIF_Pos         (0)                                               /*!< OTG_T::INTSTS: ROLECHGIF Position         */
#define OTG_INTSTS_ROLECHGIF_Msk         (0x1ul << OTG_INTSTS_ROLECHGIF_Pos)               /*!< OTG_T::INTSTS: ROLECHGIF Mask             */

#define OTG_INTSTS_VBEIF_Pos             (1)                                               /*!< OTG_T::INTSTS: VBEIF Position             */
#define OTG_INTSTS_VBEIF_Msk             (0x1ul << OTG_INTSTS_VBEIF_Pos)                   /*!< OTG_T::INTSTS: VBEIF Mask                 */

#define OTG_INTSTS_SRPFIF_Pos            (2)                                               /*!< OTG_T::INTSTS: SRPFIF Position            */
#define OTG_INTSTS_SRPFIF_Msk            (0x1ul << OTG_INTSTS_SRPFIF_Pos)                  /*!< OTG_T::INTSTS: SRPFIF Mask                */

#define OTG_INTSTS_HNPFIF_Pos            (3)                                               /*!< OTG_T::INTSTS: HNPFIF Position            */
#define OTG_INTSTS_HNPFIF_Msk            (0x1ul << OTG_INTSTS_HNPFIF_Pos)                  /*!< OTG_T::INTSTS: HNPFIF Mask                */

#define OTG_INTSTS_GOIDLEIF_Pos          (4)                                               /*!< OTG_T::INTSTS: GOIDLEIF Position          */
#define OTG_INTSTS_GOIDLEIF_Msk          (0x1ul << OTG_INTSTS_GOIDLEIF_Pos)                /*!< OTG_T::INTSTS: GOIDLEIF Mask              */

#define OTG_INTSTS_IDCHGIF_Pos           (5)                                               /*!< OTG_T::INTSTS: IDCHGIF Position           */
#define OTG_INTSTS_IDCHGIF_Msk           (0x1ul << OTG_INTSTS_IDCHGIF_Pos)                 /*!< OTG_T::INTSTS: IDCHGIF Mask               */

#define OTG_INTSTS_PDEVIF_Pos            (6)                                               /*!< OTG_T::INTSTS: PDEVIF Position            */
#define OTG_INTSTS_PDEVIF_Msk            (0x1ul << OTG_INTSTS_PDEVIF_Pos)                  /*!< OTG_T::INTSTS: PDEVIF Mask                */

#define OTG_INTSTS_HOSTIF_Pos            (7)                                               /*!< OTG_T::INTSTS: HOSTIF Position            */
#define OTG_INTSTS_HOSTIF_Msk            (0x1ul << OTG_INTSTS_HOSTIF_Pos)                  /*!< OTG_T::INTSTS: HOSTIF Mask                */

#define OTG_INTSTS_BVLDCHGIF_Pos         (8)                                               /*!< OTG_T::INTSTS: BVLDCHGIF Position         */
#define OTG_INTSTS_BVLDCHGIF_Msk         (0x1ul << OTG_INTSTS_BVLDCHGIF_Pos)               /*!< OTG_T::INTSTS: BVLDCHGIF Mask             */

#define OTG_INTSTS_AVLDCHGIF_Pos         (9)                                               /*!< OTG_T::INTSTS: AVLDCHGIF Position         */
#define OTG_INTSTS_AVLDCHGIF_Msk         (0x1ul << OTG_INTSTS_AVLDCHGIF_Pos)               /*!< OTG_T::INTSTS: AVLDCHGIF Mask             */

#define OTG_INTSTS_VBCHGIF_Pos           (10)                                              /*!< OTG_T::INTSTS: VBCHGIF Position           */
#define OTG_INTSTS_VBCHGIF_Msk           (0x1ul << OTG_INTSTS_VBCHGIF_Pos)                 /*!< OTG_T::INTSTS: VBCHGIF Mask               */

#define OTG_INTSTS_SECHGIF_Pos           (11)                                              /*!< OTG_T::INTSTS: SECHGIF Position           */
#define OTG_INTSTS_SECHGIF_Msk           (0x1ul << OTG_INTSTS_SECHGIF_Pos)                 /*!< OTG_T::INTSTS: SECHGIF Mask               */

#define OTG_INTSTS_SRPDETIF_Pos          (13)                                              /*!< OTG_T::INTSTS: SRPDETIF Position          */
#define OTG_INTSTS_SRPDETIF_Msk          (0x1ul << OTG_INTSTS_SRPDETIF_Pos)                /*!< OTG_T::INTSTS: SRPDETIF Mask              */

#define OTG_STATUS_OVERCUR_Pos           (0)                                               /*!< OTG_T::STATUS: OVERCUR Position           */
#define OTG_STATUS_OVERCUR_Msk           (0x1ul << OTG_STATUS_OVERCUR_Pos)                 /*!< OTG_T::STATUS: OVERCUR Mask               */

#define OTG_STATUS_IDSTS_Pos             (1)                                               /*!< OTG_T::STATUS: IDSTS Position             */
#define OTG_STATUS_IDSTS_Msk             (0x1ul << OTG_STATUS_IDSTS_Pos)                   /*!< OTG_T::STATUS: IDSTS Mask                 */

#define OTG_STATUS_SESSEND_Pos           (2)                                               /*!< OTG_T::STATUS: SESSEND Position           */
#define OTG_STATUS_SESSEND_Msk           (0x1ul << OTG_STATUS_SESSEND_Pos)                 /*!< OTG_T::STATUS: SESSEND Mask               */

#define OTG_STATUS_BVLD_Pos              (3)                                               /*!< OTG_T::STATUS: BVLD Position            */
#define OTG_STATUS_BVLD_Msk              (0x1ul << OTG_STATUS_BVLD_Pos)                    /*!< OTG_T::STATUS: BVLD Mask                */

#define OTG_STATUS_AVLD_Pos              (4)                                               /*!< OTG_T::STATUS: AVLD Position              */
#define OTG_STATUS_AVLD_Msk              (0x1ul << OTG_STATUS_AVLD_Pos)                    /*!< OTG_T::STATUS: AVLD Mask                  */

#define OTG_STATUS_VBUSVLD_Pos           (5)                                               /*!< OTG_T::STATUS: VBUSVLD Position           */
#define OTG_STATUS_VBUSVLD_Msk           (0x1ul << OTG_STATUS_VBUSVLD_Pos)                 /*!< OTG_T::STATUS: VBUSVLD Mask               */

/**@}*/ /* OTG_CONST */
/**@}*/ /* end of OTG register group */


/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
/**
    @addtogroup PDMA Peripheral Direct Memory Access Controller(PDMA)
    Memory Mapped Structure for PDMA Controller
@{ */

typedef struct {

    /**
     * DSCTx_CTL
     * ===================================================================================================
     * Offset: 0x00  Descriptor Table Control Register of PDMA Channel x
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |OPMODE    |PDMA Operation Mode Selection
     * |        |          |00 = Stop Mode.
     * |        |          |Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to stop mode automatically.
     * |        |          |01 = Basic Mode.
     * |        |          |The descriptor table only has one task.
     * |        |          |When this task is finished, the PDMA_INTSTS[x] will be asserted.
     * |        |          |10 = Scatter-Gather Mode.
     * |        |          |When operating in this mode, user must give the next descriptor table address in EMBTA_NTAAR register; PDMA will ignore this task, and then load the next task to execute.
     * |        |          |Note: Before filling transfer task in the descriptor table, user must check if the descriptor table is complete.
     * |[2]     |TXTYPE    |Request Type
     * |        |          |0 = Burst request type.
     * |        |          |1 = Single request type.
     * |[4:6]   |BURSIZE   |Burst Size
     * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
     * |        |          |But if in Single Request Type, this field is not useful and only 1 transfer item been transmitted for each transfer.
     * |        |          |000 = 128 transfers.
     * |        |          |001 = 64 transfers.
     * |        |          |010 = 32 transfers.
     * |        |          |011 = 16 transfers.
     * |        |          |100 = 8 transfers.
     * |        |          |101 = 4 transfers.
     * |        |          |110 = 2 transfers.
     * |        |          |111 = 1 transfers.
     * |[7]     |TBINTDIS  |Table Interrupt Disable Control
     * |        |          |This field can be used to decide whether to enable table interrupt or not.
     * |        |          |When with transfer done flag, this bit is only used for scatter-gather mode.
     * |        |          |If the TBINTDIS bit is enabled when PDMA finishes this task, there will no any interrupt generated.
     * |        |          |However, with the table empty flag, this bit is also useful.
     * |        |          |If it is set to '1', the TEMPTYF will not be set when this situation has happened.
     * |        |          |0 = Table interrupt Enabled.
     * |        |          |1 = Table interrupt Disabled.
     * |[8:9]   |SAINC     |Source Address Increment
     * |        |          |This field is used to set the source address increment size
     * |        |          |11 = No Increment (Fixed Address.).
     * |        |          |Other = Increment and size is depended on TXWIDTH selection.
     * |[10:11] |DAINC     |Destination Address Increment
     * |        |          |This field is used to set the destination address increment size
     * |        |          |11 = No Increment (Fixed Address.).
     * |        |          |Other = Increment and size is depended on TXWIDTH selection.
     * |[12:13] |TXWIDTH   |Transfer Width Selection
     * |        |          |This field is used for transfer width.
     * |        |          |00 = 8 bits for every transfer item.
     * |        |          |01 = 16 bits for every transfer item.
     * |        |          |10 = 32 bits for every transfer item.
     * |        |          |11 = Reserved.
     * |        |          |Note: The PDMA transfer source address (EMBTA_ENDSAR) and PDMA transfer destination address (EMBTA_ENDDAR) should be alignment under the TXWIDTH selection
     * |[16:29] |TXCNT     |Transfer Count
     * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
     * |        |          |Note: When PDMA finish each transfer item, this field will be decrease imminently
    */
    __IO uint32_t CTL;

    /**
     * DSCTx_ENDSA
     * ===================================================================================================
     * Offset: 0x04  End Source Address Register of PDMA Channel x
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ENDSA     |PDMA Transfer Ending Source Address Bits
     * |        |          |This field indicates a 32-bit ending source address of PDMA.
     * |        |          |Note: If the source start address is 0x2000_0000, the transfer count is 0x100 and the source address increment is word, this field must be filled 0x2000_0400.
     * |        |          |The equation is "0x2000_0400 = 0x2000_0000 + 0x100*4(word)".
    */
    __IO uint32_t ENDSA;

    /**
     * DSCTx_ENDDA
     * ===================================================================================================
     * Offset: 0x08  End Destination Address Register of PDMA Channel x
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ENDDA     |PDMA Transfer Ending Destination Address Bits
     * |        |          |This field indicates a 32-bit ending destination address of PDMA.
     * |        |          |Note: If the destination start address is 0x2000_0000, the transfer count is 0x100 and the destination address increment is word, this field must be filled 0x2000_0400.
     * |        |          |The equation is "0x2000_0400 = 0x2000_0000 + 0x100*4(word)".
    */
    __IO uint32_t ENDDA;

    /**
     * DSCTx_NEXT
     * ===================================================================================================
     * Offset: 0x0C  Scatter-Gather Descriptor Table Offset Address of PDMA Channel x
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[2:15]  |NEXT      |PDMA Next Description Table Offset Address Bits
     * |        |          |This field indicates the offset of next descriptor table address in system memory.
     * |        |          |Note1: The next descriptor table address must be word boundary.
     * |        |          |Note2: The system memory based address is 0x2000_0000 (PDMA_ETADDR), if the next descriptor table is 0x2000_0100, that this field must fill 0x0100.
     * |        |          |Note3: Before filled transfer task in the description table, user must check if the descriptor table is complete.
    */
    __IO uint32_t NEXT;

} DSCT_T;

typedef struct {
    DSCT_T DSCT[16];
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[192];
    /// @endcond //HIDDEN_SYMBOLS

    /**
     * CHCTL
     * ===================================================================================================
     * Offset: 0x400  PDMA Channel Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |CHEN      |PDMA Channel Enable Control Bit[X]
     * |        |          |Set this bit to 1 to enable PDMA[x] operation.
     * |        |          |0 = PDMA channel [x] Disabled.
     * |        |          |1 = PDMA channel [x] Enabled.
     * |        |          |Note1: If software stops each PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
     * |        |          |Note2: Software reset (writing 0xFFFF_FFF to PDMA_STOP register) will clear this bit.
     * |        |          |Note3: If each channel is not set as enabled, each channel cannot be active.
    */
    __IO uint32_t CHCTL;

    /**
     * STOP
     * ===================================================================================================
     * Offset: 0x404  PDMA Stop Transfer Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |STOP      |PDMA Stop Transfer Bit [X]
     * |        |          |User can stop the PDMA transfer by software reset (writing all '1' to PDMA_STOP register) or by PDMA_STOP register.
     * |        |          |The difference between software reset and PDMA_STOP register is when software set software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit and request active flag will be cleared to '0'.
     * |        |          |When software set PDMA_STOP bit, the operation will finish the on-going transfer channel and then clear the channel enable bit and request active flag.
     * |        |          |Software can poll channel enable bit to know if the on-going transfer is finished.
     * |        |          |0 = No effect.
     * |        |          |1 = Stop PDMA transfer[x].
     * |        |          |Note1: This field is Write-Only
     * |        |          |Note2: Setting all PDMA_STOP bit to "1" will generate software reset to reset internal state machine (the embedded table will not be reset).
    */
    __O  uint32_t STOP;

    /**
     * SWREQ
     * ===================================================================================================
     * Offset: 0x408  PDMA Software Request Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |SWREQ     |PDMA Software Request Bit [X]
     * |        |          |Set this bit to 1 to generate a software request to PDMA [x].
     * |        |          |0 = No effect.
     * |        |          |1 = Generate a software request.
     * |        |          |Note1: This field is Write-Only.
     * |        |          |Software can indicate which channel is on active by reading PDMA_TRGSTS register.
     * |        |          |Active flag may be triggered by software request or peripheral request.
     * |        |          |Note2: If user does not enable each PDMA channel, the software request will be ignored.
    */
    __O  uint32_t SWREQ;

    /**
     * TRGSTS
     * ===================================================================================================
     * Offset: 0x40C  PDMA Request Active Flag Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |REQSTS    |PDMA Request Active Flag [X]
     * |        |          |This flag indicates whether channel[x] have a request or not.
     * |        |          |0 = Have no requests.
     * |        |          |1 = Have a request.
     * |        |          |Note1: The request may come from software request (SWREQ) or peripheral request.
     * |        |          |Note2: When PDMA finishes channel transfer, this bit will be cleared automatically
     * |        |          |Note3: Software reset (setting PDMA_STOP to 0xFFFF_FFFF) will clear this bit.
    */
    __I  uint32_t TRGSTS;

    /**
     * PRISET
     * ===================================================================================================
     * Offset: 0x410  PDMA Fixed Priority Setting Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FPRISET   |PDMA Fixed Priority Setting Bit[X]
     * |        |          |Set this bit to 1 to enable fix priority level.
     * |        |          |0 = No effect.
     * |        |          |1 = Set PDMA channel [x] be fixed priority channel.
     * |        |          |The PDMA channel priority is shown in the following table.
    */
    __IO uint32_t PRISET;

    /**
     * PRICLR
     * ===================================================================================================
     * Offset: 0x414  PDMA Fixed Priority Clear Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FPRICLR   |PDMA Fix Priority Clear Bit [X]
     * |        |          |Set this bit to 1 to clear fixed priority level.
     * |        |          |0 = No effect.
     * |        |          |1 = Set PDMA channel [x] to be round-robin priority channel.
     * |        |          |Note: This field is Write-Only, and software can indicate the channel priority by reading PDMA_FPIOSEL register.
    */
    __O  uint32_t PRICLR;

    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0x418  PDMA Interrupt Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |INTEN     |PDMA Interrupt Enable Control Register [X]
     * |        |          |This field is used for enabling PDMA channel[x] interrupt.
     * |        |          |0 = PDMA channel [x] interrupt Disabled.
     * |        |          |1 = PDMA channel [x] interrupt Enabled.
    */
    __IO uint32_t INTEN;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x41C  PDMA Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ABTIF     |PDMA Read/Write Target Abort Interrupt Status Flag
     * |        |          |This bit indicates that PDMA has target abort error; Software can read PDMA_TABORTF register to find which channel has target abort error.
     * |        |          |0 = No bus ERROR response received.
     * |        |          |1 = Bus ERROR response received.
     * |        |          |Note: This field is read only.
     * |[1]     |TDIF      |Transfer Done Interrupt Status Flag
     * |        |          |This bit indicates that PDMA has finished transmission; Software can read PDMA_TDSTS register to indicate which channel finished transfer.
     * |        |          |0 = Not finished yet.
     * |        |          |1 = PDMA channel has finished transmission.
     * |        |          |Note: This field is Read only.
     * |[2]     |TEIF      |Table Empty Interrupt Status Flag
     * |        |          |This bit indicates that PDMA has finished each table transmission and the operation is Stop mode.
     * |        |          |Software can read TEIF register to indicate which channel finished transfer.
     * |        |          |0 = Not finished yet.
     * |        |          |1 = PDMA channel has finished and the operation is Stop mode.
     * |        |          |Note: This field is Read only.
    */
    __IO uint32_t INTSTS;

    /**
     * ABTSTS
     * ===================================================================================================
     * Offset: 0x420  PDMA Read/Write Target Abort Flag Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |ABTIF     |PDMA Read/Write Target Abort Interrupt Status Flag
     * |        |          |This bit indicates which PDMA has target abort error
     * |        |          |0 = No bus ERROR response received.
     * |        |          |1 = Bus ERROR response received.
     * |        |          |Note: This field is read only, but software can write 1 to clear it.
    */
    __IO uint32_t ABTSTS;

    /**
     * TDSTS
     * ===================================================================================================
     * Offset: 0x424  PDMA Transfer Done Flag Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |TDIF      |Transfer Done Flag [X]
     * |        |          |This bit indicates which PDMA channel has finished transmission.
     * |        |          |0 = Not finished yet.
     * |        |          |1 = PDMA channel has finished transmission.
     * |        |          |Note: This field is read only, but software can write 1 to clear.
    */
    __IO uint32_t TDSTS;

    /**
     * SCATSTS
     * ===================================================================================================
     * Offset: 0x428  PDMA Scatter-Gather Transfer Done Flag Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |TEMPTYF   |Table Empty Flag Bit [X]
     * |        |          |This bit indicates which PDMA channel table has finished transmission and the operation mode is Stop mode
     * |        |          |0 = Not finished or not in Stop mode.
     * |        |          |1 = PDMA channel has finished transmission and the operation is Stop mode.
     * |        |          |Note: This field is read only, but software can write 1 to clear.
    */
    __IO uint32_t SCATSTS;

    /**
     * TACTSTS
     * ===================================================================================================
     * Offset: 0x42C  PDMA Transfer on Active Flag Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |TXACTF    |Transfer On Active Flag Bit [X]
     * |        |          |This bit indicates which PDMA channel is on active.
     * |        |          |0 = PDMA channel is not finished.
     * |        |          |1 = PDMA channel is on active.
    */
    __I  uint32_t TACTSTS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * SCATBA
     * ===================================================================================================
     * Offset: 0x43C  PDMA Scatter-Gather Descriptor Table  Base Address  Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[16:31] |SCATBA    |PDMA Scatter-Gather Descriptor Table Base Address Bits
     * |        |          |In Scatter-Gather mode, this is the base address for calculating the next link - list address.
     * |        |          |The next link address equation is.
     * |        |          |Next Link Address = { SCATBA[15:0], EMBTA_NTAAR[15:2], 2'b00}.
     * |        |          |Note: Only useful in Scatter-Gather mode.
    */
    __IO uint32_t SCATBA;

    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[16];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * REQSEL0_3
     * ===================================================================================================
     * Offset: 0x480  PDMA Source Module Select Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:4]   |REQSRC0   |Channel 0 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 0.
     * |        |          |Software can configure the peripheral by setting REQSRC0.
     * |        |          |00000 = Connect to SPI0_TX.
     * |        |          |00001 = Connect to SPI1_TX.
     * |        |          |00010 = Connect to SPI2_TX.
     * |        |          |00011 = Connect to SPI3_TX.
     * |        |          |00100 = Connect to UART0_TX.
     * |        |          |00101 = Connect to UART1_TX.
     * |        |          |00110 = Connect to UART2_TX.
     * |        |          |00111 = Connect to UART3_TX.
     * |        |          |01000 = Connect to UART4_TX.
     * |        |          |01001 = Connect to UART5_TX.
     * |        |          |01010 = Reserved.
     * |        |          |01011 = Connect to I2S_TX.
     * |        |          |01100 = Connect to I2S1_TX.
     * |        |          |01101 = Connect to SPI0_RX.
     * |        |          |01110 = Connect to SPI1_RX.
     * |        |          |01111 = Connect to SPI2_RX.
     * |        |          |10000 = Connect to SPI3_RX.
     * |        |          |10001 = Connect to UART0_RX.
     * |        |          |10010 = Connect to UART1_RX.
     * |        |          |10011 = Connect to UART2_RX.
     * |        |          |10100 = Connect to UART3_RX.
     * |        |          |10101 = Connect to UART4_RX.
     * |        |          |10110 = Connect to UART5_RX.
     * |        |          |10111 = Reserved.
     * |        |          |11000 = Connect to ADC.
     * |        |          |11001 = Connect to I2S_RX.
     * |        |          |11010 = Connect to I2S1_RX.
     * |        |          |Other = Reserved.
     * |[8:12]  |REQSRC1   |Channel 1 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 1.
     * |        |          |Software can configure the peripheral setting by REQSRC1.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[16:20] |REQSRC2   |Channel 2 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 2.
     * |        |          |Software can configure the peripheral setting by REQSRC2.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[24:28] |REQSRC3   |Channel 3 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 3.
     * |        |          |Software can configure the peripheral setting by REQSRC3.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
    */
    __IO uint32_t REQSEL0_3;

    /**
     * REQSEL4_7
     * ===================================================================================================
     * Offset: 0x484  PDMA Source Module Select Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:4]   |REQSRC4   |Channel 0 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 4.
     * |        |          |Software can configure the peripheral setting by REQSRC4.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[8:12]  |REQSRC5   |Channel 1 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 5.
     * |        |          |Software can configure the peripheral setting by REQSRC5.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[16:20] |REQSRC6   |Channel 6 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 6.
     * |        |          |Software can configure the peripheral setting by REQSRC6.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[24:28] |REQSRC7   |Channel 7 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 7.
     * |        |          |Software can configure the peripheral setting by REQSRC7.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
    */
    __IO uint32_t REQSEL4_7;

    /**
     * REQSEL8_11
     * ===================================================================================================
     * Offset: 0x488  PDMA Source Module Select Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:4]   |REQSRC8   |Channel 8 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 8.
     * |        |          |Software can configure the peripheral setting by REQSRC8.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[8:12]  |REQSRC9   |Channel 9 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 9.
     * |        |          |Software can configure the peripheral setting by REQSRC9.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[16:20] |REQSRC10  |Channel 10 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 10.
     * |        |          |Software can configure the peripheral setting by REQSRC10.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[24:28] |REQSRC11  |Channel 11 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 11.
     * |        |          |Software can configure the peripheral setting by REQSRC11.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
    */
    __IO uint32_t REQSEL8_11;

    /**
     * REQSEL12_15
     * ===================================================================================================
     * Offset: 0x48C  PDMA Source Module Select Register 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:4]   |REQSRC12  |Channel 12 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 12.
     * |        |          |Software can configure the peripheral setting by REQSRC12.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[8:12]  |REQSRC13  |Channel 13 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 13.
     * |        |          |Software can configure the peripheral setting by REQSRC13.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[16:20] |REQSRC14  |Channel 14 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 14.
     * |        |          |Software can configure the peripheral setting by REQSRC14.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
     * |[24:28] |REQSRC15  |Channel 15 Selection
     * |        |          |This filed defines which peripheral is connected to PDMA channel 15.
     * |        |          |Software can configure the peripheral setting by REQSRC15.
     * |        |          |The channel configuration is the same as REQSRC0 field.
     * |        |          |Please refer to the explanation of REQSRC0.
    */
    __IO uint32_t REQSEL12_15;

} PDMA_T;

/**
    @addtogroup PDMA_CONST PDMA Bit Field Definition
    Constant Definitions for PDMA Controller
@{ */

#define PDMA_DSCT_CTL_OPMODE_Pos         (0)                                               /*!< DSCT_T::CTL: OPMODE Position        */
#define PDMA_DSCT_CTL_OPMODE_Msk         (0x3ul << PDMA_DSCT_CTL_OPMODE_Pos)               /*!< DSCT_T::CTL: OPMODE Mask            */

#define PDMA_DSCT_CTL_TXTYPE_Pos         (2)                                               /*!< DSCT_T::CTL: TXTYPE Position        */
#define PDMA_DSCT_CTL_TXTYPE_Msk         (0x1ul << PDMA_DSCT_CTL_TXTYPE_Pos)               /*!< DSCT_T::CTL: TXTYPE Mask            */

#define PDMA_DSCT_CTL_BURSIZE_Pos        (4)                                               /*!< DSCT_T::CTL: BURSIZE Position       */
#define PDMA_DSCT_CTL_BURSIZE_Msk        (0x7ul << PDMA_DSCT_CTL_BURSIZE_Pos)              /*!< DSCT_T::CTL: BURSIZE Mask           */

#define PDMA_DSCT_CTL_TBINTDIS_Pos       (7)                                               /*!< DSCT_T::CTL: TBINTDIS Position      */
#define PDMA_DSCT_CTL_TBINTDIS_Msk       (0x1ul << PDMA_DSCT_CTL_TBINTDIS_Pos)             /*!< DSCT_T::CTL: TBINTDIS Mask          */

#define PDMA_DSCT_CTL_SAINC_Pos          (8)                                               /*!< DSCT_T::CTL: SAINC Position         */
#define PDMA_DSCT_CTL_SAINC_Msk          (0x3ul << PDMA_DSCT_CTL_SAINC_Pos)                /*!< DSCT_T::CTL: SAINC Mask             */

#define PDMA_DSCT_CTL_DAINC_Pos          (10)                                              /*!< DSCT_T::CTL: DAINC Position         */
#define PDMA_DSCT_CTL_DAINC_Msk          (0x3ul << PDMA_DSCT_CTL_DAINC_Pos)                /*!< DSCT_T::CTL: DAINC Mask             */

#define PDMA_DSCT_CTL_TXWIDTH_Pos        (12)                                              /*!< DSCT_T::CTL: TXWIDTH Position       */
#define PDMA_DSCT_CTL_TXWIDTH_Msk        (0x3ul << PDMA_DSCT_CTL_TXWIDTH_Pos)              /*!< DSCT_T::CTL: TXWIDTH Mask           */

#define PDMA_DSCT_CTL_TXCNT_Pos          (16)                                              /*!< DSCT_T::CTL: TXCNT Position         */
#define PDMA_DSCT_CTL_TXCNT_Msk          (0x3ffful << PDMA_DSCT_CTL_TXCNT_Pos)             /*!< DSCT_T::CTL: TXCNT Mask             */

#define PDMA_DSCT_ENDSA_ENDSA_Pos        (0)                                               /*!< DSCT_T::ENDSA: ENDSA Position       */
#define PDMA_DSCT_ENDSA_ENDSA_Msk        (0xfffffffful << PDMA_DSCT_ENDSA_ENDSA_Pos)       /*!< DSCT_T::ENDSA: ENDSA Mask           */

#define PDMA_DSCT_ENDDA_ENDDA_Pos        (0)                                               /*!< DSCT_T::ENDDA: ENDDA Position       */
#define PDMA_DSCT_ENDDA_ENDDA_Msk        (0xfffffffful << PDMA_DSCT_ENDDA_ENDDA_Pos)       /*!< DSCT_T::ENDDA: ENDDA Mask           */

#define PDMA_DSCT_NEXT_NEXT_Pos          (2)                                               /*!< DSCT_T::NEXT: NEXT Position         */
#define PDMA_DSCT_NEXT_NEXT_Msk          (0x3ffful << PDMA_DSCT_NEXT_NEXT_Pos)             /*!< DSCT_T::NEXT: NEXT Mask             */

#define PDMA_CHCTL_CHEN_Pos              (0)                                               /*!< PDMA_T::CHCTL: CHEN Position              */
#define PDMA_CHCTL_CHEN_Msk              (0xfffful << PDMA_CHCTL_CHEN_Pos)                 /*!< PDMA_T::CHCTL: CHEN Mask                  */

#define PDMA_STOP_STOP_Pos               (0)                                               /*!< PDMA_T::STOP: STOP Position               */
#define PDMA_STOP_STOP_Msk               (0xfffful << PDMA_STOP_STOP_Pos)                  /*!< PDMA_T::STOP: STOP Mask                   */

#define PDMA_SWREQ_SWREQ_Pos             (0)                                               /*!< PDMA_T::SWREQ: SWREQ Position             */
#define PDMA_SWREQ_SWREQ_Msk             (0xffful << PDMA_SWREQ_SWREQ_Pos)                 /*!< PDMA_T::SWREQ: SWREQ Mask                 */

#define PDMA_TRGSTS_REQSTS_Pos           (0)                                               /*!< PDMA_T::TRGSTS: REQSTS Position           */
#define PDMA_TRGSTS_REQSTS_Msk           (0xfffful << PDMA_TRGSTS_REQSTS_Pos)              /*!< PDMA_T::TRGSTS: REQSTS Mask               */

#define PDMA_PRISET_FPRISET_Pos          (0)                                               /*!< PDMA_T::PRISET: FPRISET Position          */
#define PDMA_PRISET_FPRISET_Msk          (0xfffful << PDMA_PRISET_FPRISET_Pos)             /*!< PDMA_T::PRISET: FPRISET Mask              */

#define PDMA_PRICLR_FPRICLR_Pos          (0)                                               /*!< PDMA_T::PRICLR: FPRICLR Position          */
#define PDMA_PRICLR_FPRICLR_Msk          (0xfffful << PDMA_PRICLR_FPRICLR_Pos)             /*!< PDMA_T::PRICLR: FPRICLR Mask              */

#define PDMA_INTEN_INTEN_Pos             (0)                                               /*!< PDMA_T::INTEN: INTEN Position             */
#define PDMA_INTEN_INTEN_Msk             (0xfffful << PDMA_INTEN_INTEN_Pos)                /*!< PDMA_T::INTEN: INTEN Mask                 */

#define PDMA_INTSTS_ABTIF_Pos            (0)                                               /*!< PDMA_T::INTSTS: ABTIF Position            */
#define PDMA_INTSTS_ABTIF_Msk            (0x1ul << PDMA_INTSTS_ABTIF_Pos)                  /*!< PDMA_T::INTSTS: ABTIF Mask                */

#define PDMA_INTSTS_TDIF_Pos             (1)                                               /*!< PDMA_T::INTSTS: TDIF Position             */
#define PDMA_INTSTS_TDIF_Msk             (0x1ul << PDMA_INTSTS_TDIF_Pos)                   /*!< PDMA_T::INTSTS: TDIF Mask                 */

#define PDMA_INTSTS_TEIF_Pos             (2)                                               /*!< PDMA_T::INTSTS: TEIF Position             */
#define PDMA_INTSTS_TEIF_Msk             (0x1ul << PDMA_INTSTS_TEIF_Pos)                   /*!< PDMA_T::INTSTS: TEIF Mask                 */

#define PDMA_ABTSTS_ABTIF_Pos            (0)                                               /*!< PDMA_T::ABTSTS: ABTIF Position            */
#define PDMA_ABTSTS_ABTIF_Msk            (0xfffful << PDMA_ABTSTS_ABTIF_Pos)               /*!< PDMA_T::ABTSTS: ABTIF Mask                */

#define PDMA_TDSTS_TDIF_Pos              (0)                                               /*!< PDMA_T::TDSTS: TDIF Position              */
#define PDMA_TDSTS_TDIF_Msk              (0xfffful << PDMA_TDSTS_TDIF_Pos)                 /*!< PDMA_T::TDSTS: TDIF Mask                  */

#define PDMA_SCATSTS_TEMPTYF_Pos         (0)                                               /*!< PDMA_T::SCATSTS: TEMPTYF Position         */
#define PDMA_SCATSTS_TEMPTYF_Msk         (0xfffful << PDMA_SCATSTS_TEMPTYF_Pos)            /*!< PDMA_T::SCATSTS: TEMPTYF Mask             */

#define PDMA_TACTSTS_TXACTF_Pos          (0)                                               /*!< PDMA_T::TACTSTS: TXACTF Position          */
#define PDMA_TACTSTS_TXACTF_Msk          (0xfffful << PDMA_TACTSTS_TXACTF_Pos)             /*!< PDMA_T::TACTSTS: TXACTF Mask              */

#define PDMA_SCATBA_SCATBA_Pos           (16)                                              /*!< PDMA_T::SCATBA: SCATBA Position           */
#define PDMA_SCATBA_SCATBA_Msk           (0xfffful << PDMA_SCATBA_SCATBA_Pos)              /*!< PDMA_T::SCATBA: SCATBA Mask               */

#define PDMA_REQSEL0_3_REQSRC0_Pos       (0)                                               /*!< PDMA_T::REQSEL0_3: REQSRC0 Position       */
#define PDMA_REQSEL0_3_REQSRC0_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC0_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC0 Mask           */

#define PDMA_REQSEL0_3_REQSRC1_Pos       (8)                                               /*!< PDMA_T::REQSEL0_3: REQSRC1 Position       */
#define PDMA_REQSEL0_3_REQSRC1_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC1_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC1 Mask           */

#define PDMA_REQSEL0_3_REQSRC2_Pos       (16)                                              /*!< PDMA_T::REQSEL0_3: REQSRC2 Position       */
#define PDMA_REQSEL0_3_REQSRC2_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC2_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC2 Mask           */

#define PDMA_REQSEL0_3_REQSRC3_Pos       (24)                                              /*!< PDMA_T::REQSEL0_3: REQSRC3 Position       */
#define PDMA_REQSEL0_3_REQSRC3_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC3_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC3 Mask           */

#define PDMA_REQSEL4_7_REQSRC4_Pos       (0)                                               /*!< PDMA_T::REQSEL4_7: REQSRC4 Position       */
#define PDMA_REQSEL4_7_REQSRC4_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC4_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC4 Mask           */

#define PDMA_REQSEL4_7_REQSRC5_Pos       (8)                                               /*!< PDMA_T::REQSEL4_7: REQSRC5 Position       */
#define PDMA_REQSEL4_7_REQSRC5_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC5_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC5 Mask           */

#define PDMA_REQSEL4_7_REQSRC6_Pos       (16)                                              /*!< PDMA_T::REQSEL4_7: REQSRC6 Position       */
#define PDMA_REQSEL4_7_REQSRC6_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC6_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC6 Mask           */

#define PDMA_REQSEL4_7_REQSRC7_Pos       (24)                                              /*!< PDMA_T::REQSEL4_7: REQSRC7 Position       */
#define PDMA_REQSEL4_7_REQSRC7_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC7_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC7 Mask           */

#define PDMA_REQSEL8_11_REQSRC8_Pos      (0)                                               /*!< PDMA_T::REQSEL8_11: REQSRC8 Position      */
#define PDMA_REQSEL8_11_REQSRC8_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC8_Pos)           /*!< PDMA_T::REQSEL8_11: REQSRC8 Mask          */

#define PDMA_REQSEL8_11_REQSRC9_Pos      (8)                                               /*!< PDMA_T::REQSEL8_11: REQSRC9 Position      */
#define PDMA_REQSEL8_11_REQSRC9_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC9_Pos)           /*!< PDMA_T::REQSEL8_11: REQSRC9 Mask          */

#define PDMA_REQSEL8_11_REQSRC10_Pos     (16)                                              /*!< PDMA_T::REQSEL8_11: REQSRC10 Position     */
#define PDMA_REQSEL8_11_REQSRC10_Msk     (0x1ful << PDMA_REQSEL8_11_REQSRC10_Pos)          /*!< PDMA_T::REQSEL8_11: REQSRC10 Mask         */

#define PDMA_REQSEL8_11_REQSRC11_Pos     (24)                                              /*!< PDMA_T::REQSEL8_11: REQSRC11 Position     */
#define PDMA_REQSEL8_11_REQSRC11_Msk     (0x1ful << PDMA_REQSEL8_11_REQSRC11_Pos)          /*!< PDMA_T::REQSEL8_11: REQSRC11 Mask         */

#define PDMA_REQSEL12_15_REQSRC12_Pos    (0)                                               /*!< PDMA_T::REQSEL12_15: REQSRC12 Position    */
#define PDMA_REQSEL12_15_REQSRC12_Msk    (0x1ful << PDMA_REQSEL12_15_REQSRC12_Pos)         /*!< PDMA_T::REQSEL12_15: REQSRC12 Mask        */

#define PDMA_REQSEL12_15_REQSRC13_Pos    (8)                                               /*!< PDMA_T::REQSEL12_15: REQSRC13 Position    */
#define PDMA_REQSEL12_15_REQSRC13_Msk    (0x1ful << PDMA_REQSEL12_15_REQSRC13_Pos)         /*!< PDMA_T::REQSEL12_15: REQSRC13 Mask        */

#define PDMA_REQSEL12_15_REQSRC14_Pos    (16)                                              /*!< PDMA_T::REQSEL12_15: REQSRC14 Position    */
#define PDMA_REQSEL12_15_REQSRC14_Msk    (0x1ful << PDMA_REQSEL12_15_REQSRC14_Pos)         /*!< PDMA_T::REQSEL12_15: REQSRC14 Mask        */

#define PDMA_REQSEL12_15_REQSRC15_Pos    (24)                                              /*!< PDMA_T::REQSEL12_15: REQSRC15 Position    */
#define PDMA_REQSEL12_15_REQSRC15_Msk    (0x1ful << PDMA_REQSEL12_15_REQSRC15_Pos)         /*!< PDMA_T::REQSEL12_15: REQSRC15 Mask        */

/**@}*/ /* PDMA_CONST */
/**@}*/ /* end of PDMA register group */


/*---------------------- PS/2 Device Controller -------------------------*/
/**
    @addtogroup PS2 PS/2 Device Controller(PS2)
    Memory Mapped Structure for PS2 Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  PS/2 Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |PS2EN     |PS/2 Device Enable Control
     * |        |          |Enable PS/2 device controller.
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[1]     |TXIEN     |Transmit Interrupt Enable Control
     * |        |          |0 = Data transmit complete interrupt Disabled.
     * |        |          |1 = Data transmit complete interrupt Enabled.
     * |[2]     |RXIEN     |Receive Interrupt Enable Control
     * |        |          |0 = Data receive complete interrupt Disabled.
     * |        |          |1 = Data receive complete interrupt Enabled.
     * |[3:6]   |TXFDEPTH  |Transmit Data FIFO Depth
     * |        |          |There is 16-byte buffer for data transmit.
     * |        |          |Software can define the FIFO depth from 1 to 16 bytes depending on the application.
     * |        |          |0 = 1 byte.
     * |        |          |1 = 2 bytes.
     * |        |          |...
     * |        |          |14 = 15 bytes.
     * |        |          |15 = 16 bytes.
     * |[7]     |ACK       |Acknowledge Enable Control
     * |        |          |0 = Always sends acknowledge to host at 12th clock for host to device communication.
     * |        |          |1 = If parity error or stop bit is not received correctly, acknowledge bit will not be sent to host at 12th clock.
     * |[8]     |CLRFIFO   |Clear TX FIFO
     * |        |          |Write 1 to this bit to terminate device to host transmission.
     * |        |          |The TXEMPTY(PS2_STATUS[7]) bit will be set to 1 and pointer BYTEIDEX(PS2_STATUS[11:8]) is reset to 0 regardless there is residue data in buffer or not.
     * |        |          |The buffer content is not been cleared.
     * |        |          |0 = Not active.
     * |        |          |1 = Clear FIFO.
     * |[9]     |OVERRIDE  |Software Override PS/2 CLK/DATA Pin State
     * |        |          |0 = CLKSTAT and DATSTAT pins are controlled by internal state machine.
     * |        |          |1 = CLKSTAT and DATSTAT pins are controlled by software.
     * |[10]    |FPS2CLK   |Force CLKSTAT Line
     * |        |          |It forces CLKSTAT line high or low regardless of the internal state of the device controller if OVERRIDE is set to high.
     * |        |          |0 = Force CLKSTAT line low.
     * |        |          |1 = Force CLKSTAT line high.
     * |[11]    |FPS2DAT   |Force DATSTAT Line
     * |        |          |It forces DATSTAT high or low regardless of the internal state of the device controller if OVERRIDE is set to high.
     * |        |          |0 = Force DATSTAT low.
     * |        |          |1 = Force DATSTAT high.
    */
    __IO uint32_t CTL;

    /**
     * TXDAT0
     * ===================================================================================================
     * Offset: 0x04  PS/2 Transmit DATA Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DAT       |Transmit Data
     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state.
     * |        |          |Software must enable PS2EN(PS2_CTL[0]) before writing data to TX buffer.
    */
    __IO uint32_t TXDAT0;

    /**
     * TXDAT1
     * ===================================================================================================
     * Offset: 0x08  PS/2 Transmit DATA Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DAT       |Transmit Data
     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state.
     * |        |          |Software must enable PS2EN(PS2_CTL[0]) before writing data to TX buffer.
    */
    __IO uint32_t TXDAT1;

    /**
     * TXDAT2
     * ===================================================================================================
     * Offset: 0x0C  PS/2 Transmit DATA Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DAT       |Transmit Data
     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state.
     * |        |          |Software must enable PS2EN(PS2_CTL[0]) before writing data to TX buffer.
    */
    __IO uint32_t TXDAT2;

    /**
     * TXDAT3
     * ===================================================================================================
     * Offset: 0x10  PS/2 Transmit DATA Register 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DAT       |Transmit Data
     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state.
     * |        |          |Software must enable PS2EN(PS2_CTL[0]) before writing data to TX buffer.
    */
    __IO uint32_t TXDAT3;

    /**
     * RXDAT
     * ===================================================================================================
     * Offset: 0x14  PS/2 Receive DATA Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |DAT       |Received Data
     * |        |          |For host to device communication, after acknowledge bit is sent, the received data is copied from receive shift register to PS2_RXDAT register.
     * |        |          |CPU must read this register before next byte reception complete; otherwise, the data will be overwritten and RXOV(PS2_STATUS[6]) bit will be set to 1.
    */
    __I  uint32_t RXDAT;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x18  PS/2 Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CLKSTAT   |CLK Pin State
     * |        |          |This bit reflects the status of the CLKSTAT line after synchronizing.
     * |[1]     |DATSTAT   |DATA Pin State
     * |        |          |This bit reflects the status of the DATSTAT line after synchronizing and sampling.
     * |[2]     |FRAMEERR  |Frame Error
     * |        |          |For host to device communication, if STOP bit (logic 1) is not received it is a frame error.
     * |        |          |If frame error occurs, DATA line may keep at low state after 12th clock.
     * |        |          |At this moment, software overrides CLKSTAT to send clock till DATSTAT release to high state.
     * |        |          |After that, device sends a "Resend" command to host.
     * |        |          |0 = No frame error.
     * |        |          |1 = Frame error occurred .
     * |        |          |Note: Write 1 to clear this bit.
     * |[3]     |RXPARITY  |Received Parity
     * |        |          |This bit reflects the parity bit for the last received data byte (odd parity).
     * |        |          |Note: This bit is read only.
     * |[4]     |RXBUSY    |Receive Busy
     * |        |          |This bit indicates that the PS/2 device is currently receiving data.
     * |        |          |0 = Idle.
     * |        |          |1 = Currently receiving data.
     * |        |          |Note: This bit is read only.
     * |[5]     |TXBUSY    |Transmit Busy
     * |        |          |This bit indicates that the PS/2 device is currently sending data.
     * |        |          |0 = Idle.
     * |        |          |1 = Currently sending data.
     * |        |          |Note: This bit is read only.
     * |[6]     |RXOV      |RX Buffer Overwrite
     * |        |          |0 = No overwrite.
     * |        |          |1 = Data in PS2_RXDAT register is overwritten by new received data.
     * |        |          |Note: Write 1 to clear this bit.
     * |[7]     |TXEMPTY   |TX FIFO Empty
     * |        |          |When software writes any data to PS2_TXDAT0-3 the TXEMPTY bit is cleared to 0 immediately if PS2EN is enabled.
     * |        |          |When transmitted data byte number is equal to FIFODEPTH then TXEMPTY bit is set to 1.
     * |        |          |0 = There is data to be transmitted.
     * |        |          |1 = FIFO is empty.
     * |        |          |Note: This bit is read only.
     * |[8:11]  |BYTEIDX   |Byte Index
     * |        |          |It indicates which data byte in transmit data shift register.
     * |        |          |When all data in FIFO is transmitted and it will be cleared to 0.
     * |        |          |Note: This bit is read only.
     * |        |          |BYTEIDX        DATA Transmit
     * |        |          |0000           TXDATA0[7:0]
     * |        |          |0001           TXDATA0[15:8]
     * |        |          |0010           TXDATA0[23:16]
     * |        |          |0011           TXDATA0[31:24]
     * |        |          |0100           TXDATA1[7:0]
     * |        |          |0101           TXDATA1[15:8]
     * |        |          |0110           TXDATA1[23:16]
     * |        |          |0111           TXDATA1[31:24]
     * |        |          |1000           TXDATA2[7:0]
     * |        |          |1001           TXDATA2[15:8]
     * |        |          |1010           TXDATA2[23:16]
     * |        |          |1011           TXDATA2[31:24]
     * |        |          |1100           TXDATA3[7:0]
     * |        |          |1101           TXDATA3[15:8]
     * |        |          |1110           TXDATA3[23:16]
     * |        |          |1111           TXDATA3[31:24]
    */
    __IO uint32_t STATUS;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x1C  PS/2 Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RXIF      |Receive Interrupt
     * |        |          |This bit is set to 1 when acknowledge bit is sent for Host to device communication.
     * |        |          |Interrupt occurs if RXIEN(PS2_CTL[2]) bit is set to 1.
     * |        |          |0 = No interrupt.
     * |        |          |1 = Receive interrupt occurred.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[1]     |TXIF      |Transmit Interrupt
     * |        |          |This bit is set to 1 after STOP bit is transmitted. Interrupt occurs if TXIEN(PS2_CTL[1]) bit is set
     * |        |          |to 1.
     * |        |          |0 = No interrupt.
     * |        |          |1 = Transmit interrupt occurred.
     * |        |          |Note: Write 1 to clear this bit to 0.
    */
    __IO uint32_t INTSTS;

} PS2_T;

/**
    @addtogroup PS2_CONST PS2 Bit Field Definition
    Constant Definitions for PS2 Controller
@{ */

#define PS2_CTL_PS2EN_Pos                (0)                                               /*!< PS2_T::CTL: PS2EN Position                */
#define PS2_CTL_PS2EN_Msk                (0x1ul << PS2_CTL_PS2EN_Pos)                      /*!< PS2_T::CTL: PS2EN Mask                    */

#define PS2_CTL_TXIEN_Pos                (1)                                               /*!< PS2_T::CTL: TXIEN Position                */
#define PS2_CTL_TXIEN_Msk                (0x1ul << PS2_CTL_TXIEN_Pos)                      /*!< PS2_T::CTL: TXIEN Mask                    */

#define PS2_CTL_RXIEN_Pos                (2)                                               /*!< PS2_T::CTL: RXIEN Position                */
#define PS2_CTL_RXIEN_Msk                (0x1ul << PS2_CTL_RXIEN_Pos)                      /*!< PS2_T::CTL: RXIEN Mask                    */

#define PS2_CTL_TXFDEPTH_Pos             (3)                                               /*!< PS2_T::CTL: TXFDEPTH Position             */
#define PS2_CTL_TXFDEPTH_Msk             (0xful << PS2_CTL_TXFDEPTH_Pos)                   /*!< PS2_T::CTL: TXFDEPTH Mask                 */

#define PS2_CTL_ACK_Pos                  (7)                                               /*!< PS2_T::CTL: ACK Position                  */
#define PS2_CTL_ACK_Msk                  (0x1ul << PS2_CTL_ACK_Pos)                        /*!< PS2_T::CTL: ACK Mask                      */

#define PS2_CTL_CLRFIFO_Pos              (8)                                               /*!< PS2_T::CTL: CLRFIFO Position              */
#define PS2_CTL_CLRFIFO_Msk              (0x1ul << PS2_CTL_CLRFIFO_Pos)                    /*!< PS2_T::CTL: CLRFIFO Mask                  */

#define PS2_CTL_OVERRIDE_Pos             (9)                                               /*!< PS2_T::CTL: OVERRIDE Position             */
#define PS2_CTL_OVERRIDE_Msk             (0x1ul << PS2_CTL_OVERRIDE_Pos)                   /*!< PS2_T::CTL: OVERRIDE Mask                 */

#define PS2_CTL_FPS2CLK_Pos              (10)                                              /*!< PS2_T::CTL: FPS2CLK Position              */
#define PS2_CTL_FPS2CLK_Msk              (0x1ul << PS2_CTL_FPS2CLK_Pos)                    /*!< PS2_T::CTL: FPS2CLK Mask                  */

#define PS2_CTL_FPS2DAT_Pos              (11)                                              /*!< PS2_T::CTL: FPS2DAT Position              */
#define PS2_CTL_FPS2DAT_Msk              (0x1ul << PS2_CTL_FPS2DAT_Pos)                    /*!< PS2_T::CTL: FPS2DAT Mask                  */

#define PS2_TXDAT0_DAT_Pos               (0)                                               /*!< PS2_T::TXDAT0: DAT Position               */
#define PS2_TXDAT0_DAT_Msk               (0xfffffffful << PS2_TXDAT0_DAT_Pos)              /*!< PS2_T::TXDAT0: DAT Mask                   */

#define PS2_TXDAT1_DAT_Pos               (0)                                               /*!< PS2_T::TXDAT1: DAT Position               */
#define PS2_TXDAT1_DAT_Msk               (0xfffffffful << PS2_TXDAT1_DAT_Pos)              /*!< PS2_T::TXDAT1: DAT Mask                   */

#define PS2_TXDAT2_DAT_Pos               (0)                                               /*!< PS2_T::TXDAT2: DAT Position               */
#define PS2_TXDAT2_DAT_Msk               (0xfffffffful << PS2_TXDAT2_DAT_Pos)              /*!< PS2_T::TXDAT2: DAT Mask                   */

#define PS2_TXDAT3_DAT_Pos               (0)                                               /*!< PS2_T::TXDAT3: DAT Position               */
#define PS2_TXDAT3_DAT_Msk               (0xfffffffful << PS2_TXDAT3_DAT_Pos)              /*!< PS2_T::TXDAT3: DAT Mask                   */

#define PS2_RXDAT_DAT_Pos                (0)                                               /*!< PS2_T::RXDAT: DAT Position                */
#define PS2_RXDAT_DAT_Msk                (0xfful << PS2_RXDAT_DAT_Pos)                     /*!< PS2_T::RXDAT: DAT Mask                    */

#define PS2_STATUS_CLKSTAT_Pos           (0)                                               /*!< PS2_T::STATUS: CLKSTAT Position           */
#define PS2_STATUS_CLKSTAT_Msk           (0x1ul << PS2_STATUS_CLKSTAT_Pos)                 /*!< PS2_T::STATUS: CLKSTAT Mask               */

#define PS2_STATUS_DATSTAT_Pos           (1)                                               /*!< PS2_T::STATUS: DATSTAT Position           */
#define PS2_STATUS_DATSTAT_Msk           (0x1ul << PS2_STATUS_DATSTAT_Pos)                 /*!< PS2_T::STATUS: DATSTAT Mask               */

#define PS2_STATUS_FRAMEERR_Pos          (2)                                               /*!< PS2_T::STATUS: FRAMEERR Position          */
#define PS2_STATUS_FRAMEERR_Msk          (0x1ul << PS2_STATUS_FRAMEERR_Pos)                /*!< PS2_T::STATUS: FRAMEERR Mask              */

#define PS2_STATUS_RXPARITY_Pos          (3)                                               /*!< PS2_T::STATUS: RXPARITY Position          */
#define PS2_STATUS_RXPARITY_Msk          (0x1ul << PS2_STATUS_RXPARITY_Pos)                /*!< PS2_T::STATUS: RXPARITY Mask              */

#define PS2_STATUS_RXBUSY_Pos            (4)                                               /*!< PS2_T::STATUS: RXBUSY Position            */
#define PS2_STATUS_RXBUSY_Msk            (0x1ul << PS2_STATUS_RXBUSY_Pos)                  /*!< PS2_T::STATUS: RXBUSY Mask                */

#define PS2_STATUS_TXBUSY_Pos            (5)                                               /*!< PS2_T::STATUS: TXBUSY Position            */
#define PS2_STATUS_TXBUSY_Msk            (0x1ul << PS2_STATUS_TXBUSY_Pos)                  /*!< PS2_T::STATUS: TXBUSY Mask                */

#define PS2_STATUS_RXOV_Pos              (6)                                               /*!< PS2_T::STATUS: RXOV Position              */
#define PS2_STATUS_RXOV_Msk              (0x1ul << PS2_STATUS_RXOV_Pos)                    /*!< PS2_T::STATUS: RXOV Mask                  */

#define PS2_STATUS_TXEMPTY_Pos           (7)                                               /*!< PS2_T::STATUS: TXEMPTY Position           */
#define PS2_STATUS_TXEMPTY_Msk           (0x1ul << PS2_STATUS_TXEMPTY_Pos)                 /*!< PS2_T::STATUS: TXEMPTY Mask               */

#define PS2_STATUS_BYTEIDX_Pos           (8)                                               /*!< PS2_T::STATUS: BYTEIDX Position           */
#define PS2_STATUS_BYTEIDX_Msk           (0xful << PS2_STATUS_BYTEIDX_Pos)                 /*!< PS2_T::STATUS: BYTEIDX Mask               */

#define PS2_INTSTS_RXIF_Pos              (0)                                               /*!< PS2_T::INTSTS: RXIF Position              */
#define PS2_INTSTS_RXIF_Msk              (0x1ul << PS2_INTSTS_RXIF_Pos)                    /*!< PS2_T::INTSTS: RXIF Mask                  */

#define PS2_INTSTS_TXIF_Pos              (1)                                               /*!< PS2_T::INTSTS: TXIF Position              */
#define PS2_INTSTS_TXIF_Msk              (0x1ul << PS2_INTSTS_TXIF_Pos)                    /*!< PS2_T::INTSTS: TXIF Mask                  */

/**@}*/ /* PS2_CONST */
/**@}*/ /* end of PS2 register group */


/*---------------------- Pulse Width Modulation Controller -------------------------*/
/**
    @addtogroup PWM Pulse Width Modulation Controller(PWM)
    Memory Mapped Structure for PWM Controller
@{ */

typedef struct {


    /**
     * CLKPSC
     * ===================================================================================================
     * Offset: 0x00  PWM Clock Prescale Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |CLKPSC01  |PWM Counter Base-Clock Prescale For PWM Pair Of Channel 0 And Channel 1
     * |        |          |The base-clock of PWM counter is decided by clock pre-scalar and clock divider.
     * |        |          |Each PWM pair share one PWM counter base-clock prescaler.
     * |        |          |The base-clock of PWM counter is divided by (CLKPSC01 + 1).
     * |        |          |If the value of CLKPSC01 is zero, the base-clock prescaler will stop output clock and corresponding PWM counter will also stop.
     * |[8:15]  |CLKPSC23  |PWM Counter Base-Clock Prescale For PWM Pair Of Channel 2 And Channel 3
     * |        |          |The base-clock of PWM counter is decided by clock pre-scalar and clock divider.
     * |        |          |Each PWM pair share one PWM counter base-clock prescaler.
     * |        |          |The base-clock of PWM counter is divided by (CLKPSC23 + 1).
     * |        |          |If the value of CLKPSC23 is zero, the base-clock prescaler will stop output clock and corresponding PWM counter will also stop.
     * |[16:23] |CLKPSC45  |PWM Counter Base-Clock Prescale For PWM Pair Of Channel 4 And Channel 5
     * |        |          |The base-clock of PWM counter is decided by clock pre-scalar and clock divider.
     * |        |          |Each PWM pair share one PWM counter base-clock prescaler.
     * |        |          |The base-clock of PWM counter is divided by (CLKPSC45 + 1).
     * |        |          |If the value of CLKPSC45 is zero, the base-clock prescaler will stop output clock and corresponding PWM counter will also stop.
    */
    __IO uint32_t CLKPSC;

    /**
     * CLKDIV
     * ===================================================================================================
     * Offset: 0x04  PWM Clock Divide Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |CLKDIV0   |PWM Counter Base-Clock Divide For PWMx_CH0
     * |        |          |(Table is the same as CLKDIV5)
     * |[4:6]   |CLKDIV1   |PWM Counter Base-Clock Divide For PWMx_CH1
     * |        |          |(Table is the same as CLKDIV5)
     * |[8:10]  |CLKDIV2   |PWM Counter Base-Clock Divide For PWMx_CH2
     * |        |          |(Table is the same as CLKDIV5)
     * |[12:14] |CLKDIV3   |PWM Counter Base-Clock Divide For PWMx_CH3
     * |        |          |(Table is the same as CLKDIV5)
     * |[16:18] |CLKDIV4   |PWM Counter Base-Clock Divide For PWMx_CH4
     * |        |          |(Table is the same as CLKDIV5)
     * |[20:22] |CLKDIV5   |PWM Counter Base-Clock Divide For PWMx_CH5
     * |        |          |The base-clock of PWM counter is decided by clock pre-scalar and clock divider.
     * |        |          |Each PWM counter has independent clock divider control register and the divided value is listed in the table below:.
     * |        |          |000 = 2.
     * |        |          |001 = 4.
     * |        |          |010 = 8.
     * |        |          |011 = 16.
     * |        |          |100 = 1.
    */
    __IO uint32_t CLKDIV;

    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x08  PWM Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |CMPINV    |PWM Comparator Output Inverter Enable Control
     * |        |          |When CMPINV is set to high, the PWM comparator output signals will be inversed,
     * |        |          |0 = Comparator output inverter Disabled.
     * |        |          |1 = Comparator output inverter Enabled.
     * |        |          |Note: Each bit control corresponding PWM channel
     * |[6]     |OUTMODE   |PWM Output Mode
     * |        |          |The register controls the output mode of PWM
     * |        |          |0 = PWM output at independent mode.
     * |        |          |1 = PWM output at complementary mode.
     * |[7]     |GROUPEN   |Group Mode Enable Control
     * |        |          |0 = The signals timing of each PWM channel are independent.
     * |        |          |1 = Unify the signals timing of PWM0, PWM2 and PWM4 in the same phase which is controlled by PWM0 and unify the signals timing of PWM1, PWM3 and PWM5 in the same phase which is controlled by PWM1.
     * |[8:13]  |PINV      |PWM Output Polar Inverse Enable Control
     * |        |          |The register controls polarity state of PWM output
     * |        |          |0 = PWM output polar inverse Disabled.
     * |        |          |1 = PWM output polar inverse Enabled.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
     * |[15]    |SYNCEN    |Synchronous Mode Enable Control
     * |        |          |0 = The signals timing of each PWM channel are independent.
     * |        |          |1 = Unify the signals timing of PWM0 and PWM1 in the same phase which is controlled by PWM0 and so as another two PWM pair.
     * |        |          |Note: If Group and Synchronous mode are enabled simultaneously, the Synchronous mode will be inactive.
     * |[16:21] |CNTMODE   |PWM Counter Operation Mode
     * |        |          |0 = PWM counter working as One-shot mode.
     * |        |          |1 = PWM counter working as Auto-reload mode.
     * |        |          |Note: Each bit control corresponding PWM channel
     * |        |          |Note: If there is a transition at this bit, it will cause PWM_PERIODn and PWM_CMPDATn be cleared.
     * |[24:29] |CNTTYPE   |PWM Counter Operation Aligned Type
     * |        |          |0 = PWM counter operating as Edge-aligned type.
     * |        |          |1 = PWM counter operating as Center-aligned type.
     * |        |          |Note: Each bit control corresponding PWM channel
     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable Control (Write Protect)
     * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
     * |        |          |PWM pin will be forced as tri-state while ICE debug mode acknowledged.
     * |        |          |1 = ICE debug mode acknowledgement disabled.
     * |        |          |PWM pin will keep output no matter ICE debug mode acknowledged or not.
    */
    __IO uint32_t CTL;

    /**
     * CNTEN
     * ===================================================================================================
     * Offset: 0x0C  PWM Counter Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |CNTEN     |PWM Counter Enable Control
     * |        |          |0 = PWM Counter Stop Running.
     * |        |          |1 = PWM Counter Start Running.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t CNTEN;

    /**
     * PERIOD
     * ===================================================================================================
     * Offset: 0x10 ~ 0x24 PWM Counter Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |PERIOD    |PWM Period Register
     * |        |          |PERIOD determines the PWM period.
     * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(PERIOD+1)]; where xy, could be 01, 23 or 45, depends on selected PWM channel.
     * |        |          |For Edge-aligned mode:
     * |        |          |l Duty ratio = (CMP+1)/(PERIOD+1).
     * |        |          |l CMP >= PERIOD: PWM output is always high.
     * |        |          |l CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
     * |        |          |l CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit.
     * |        |          |For Center-aligned mode:
     * |        |          |l Duty ratio = [(2 x CMP) + 1]/[2 x (PERIOD+1)].
     * |        |          |l CMP > PERIOD: PWM output is always high.
     * |        |          |l CMP <= PERIOD: PWM low width = 2 x (PERIOD-CMP) + 1 unit; PWM high width = (2 x CMP) + 1 unit.
     * |        |          |l CMP = 0: PWM low width = 2 x PERIOD + 1 unit; PWM high width = 1 unit.
     * |        |          |(Unit = one PWM clock cycle).
     * |        |          |Note1: Any write to PERIOD will take effect in next PWM cycle.
     * |        |          |Note2: When PWM operating at center-aligned type, PERIOD value should be set between 0x0000 to 0xFFFE.
     * |        |          |If PERIOD equal to 0xFFFF, the PWM will work unpredictable.
     * |        |          |Note3: When PERIOD value is set to 0, PWM output is always high.
    */
    __IO uint32_t PERIOD[6];

    /**
     * CMPDAT
     * ===================================================================================================
     * Offset: 0x28 ~0x3C PWM Comparator Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |CMP       |PWM Duty Register
     * |        |          |CMP determines the PWM duty.
     * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(PERIOD+1)]; where xy, could be 01, 23 or, 45, depends on selected PWM channel.
     * |        |          |For Edge-aligned mode:
     * |        |          |l Duty ratio = (CMP+1)/(PERIOD+1).
     * |        |          |l CMP >= PERIOD: PWM output is always high.
     * |        |          |l CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
     * |        |          |l CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit.
     * |        |          |For Center-aligned mode:
     * |        |          |l Duty ratio = [(2 x CMP) + 1]/[2 x (PERIOD+1)].
     * |        |          |l CMP > PERIOD: PWM output is always high.
     * |        |          |l CMP <= PERIOD: PWM low width = 2 x (PERIOD-CMP) + 1 unit; PWM high width = (2 x CMP) + 1 unit.
     * |        |          |l CMP = 0: PWM low width = 2 x PERIOD + 1 unit; PWM high width = 1 unit.
     * |        |          |(Unit = one PWM clock cycle).
     * |        |          |Note: Any write to CMP will take effect in next PWM cycle.
    */
    __IO uint32_t CMPDAT[6];

    /**
     * CNT
     * ===================================================================================================
     * Offset: 0x40 ~ 0x54 PWM Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |CNT       |PWM Data Register
     * |        |          |User can monitor CNT to know the current value in 16-bit down counter.
     * |        |          |Note: It is recommended that read this register when PWM engine clock is source from system clock, otherwise a transition value of PWM counter may be read.
    */
    __I  uint32_t CNT[6];

    /**
     * MSKEN
     * ===================================================================================================
     * Offset: 0x58  PWM Mask Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |MSKEN     |PWM Mask Enable Control
     * |        |          |The PWM output signal will be masked when this bit is enabled.
     * |        |          |The corresponding PWMn channel will be output with MSKDAT data.
     * |        |          |0 = PWM output signal is non-masked.
     * |        |          |1 = PWM output signal is masked and output with MSKDAT data.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t MSKEN;

    /**
     * MSK
     * ===================================================================================================
     * Offset: 0x5C  PWM Mask Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |MSKDAT    |PWM Mask Data Bit:
     * |        |          |This data bit control the state of PWMn output pin, if corresponding mask function is enabled.
     * |        |          |0 = Output logic low to PWMn.
     * |        |          |1 = Output logic high to PWMn.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t MSK;

    /**
     * DTCTL
     * ===================================================================================================
     * Offset: 0x60  PWM Dead-zone Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |DTCNT01   |Dead-Zone Interval For PWM Pair Of Channel 0 And Channel 1
     * |        |          |These 8-bit determine the Dead-zone length.
     * |        |          |The unit time of Dead-zone length is received from corresponding PWM_CLKDIV.
     * |[8:15]  |DTCNT23   |Dead-Zone Interval For PWM Pair Of Channel 2 And Channel 3
     * |        |          |These 8-bit determine the Dead-zone length.
     * |        |          |The unit time of Dead-zone length is received from corresponding PWM_CLKDIV.
     * |[16:23] |DTCNT45   |Dead-Zone Interval For PWM Pair Of Channel 4 And Channel 5
     * |        |          |These 8-bit determine the Dead-zone length.
     * |        |          |The unit time of Dead-zone length is received from corresponding PWM_CLKDIV.
     * |[24:25] |DTDIV     |Dead-Zone Generator Divider
     * |        |          |00 = Dead-zone clock equal to PWM base clock divide 1.
     * |        |          |01 = Dead-zone clock equal to PWM base clock divide 2.
     * |        |          |10 = Dead-zone clock equal to PWM base clock divide 4.
     * |        |          |11 = Dead-zone clock equal to PWM base clock divide 8.
     * |[28]    |DTEN01    |Dead-Zone Enable Control For PWM Pair Of Channel 0 And Channel 1
     * |        |          |Dead-zone insertion is only active when this pair of complementary PWM is enabled.
     * |        |          |If Dead-zone insertion is inactive, the outputs of pin pair are complementary without any delay.
     * |        |          |0 = Dead-zone insertion Disabled.
     * |        |          |1 = Dead-zone insertion Enabled.
     * |[29]    |DTEN23    |Dead-Zone Enable Control For PWM Pair Of Channel 2 And Channel 3
     * |        |          |Dead-zone insertion is only active when this pair of complementary PWM is enabled.
     * |        |          |If Dead-zone insertion is inactive, the outputs of pin pair are complementary without any delay.
     * |        |          |0 = Dead-zone insertion Disabled.
     * |        |          |1 = Dead-zone insertion Enabled.
     * |[30]    |DTEN45    |Dead-Zone Enable Control For PWM Pair Of Channel 4 And Channel 5
     * |        |          |Dead-zone insertion is only active when this pair of complementary PWM is enabled.
     * |        |          |If Dead-zone insertion is inactive, the outputs of pin pair are complementary without any delay.
     * |        |          |0 = Dead-zone insertion Disabled.
     * |        |          |1 = Dead-zone insertion Enabled.
    */
    __IO uint32_t DTCTL;

    /**
     * TRGADCTL
     * ===================================================================================================
     * Offset: 0x64  PWM Trigger Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |PTRGEN    |PWM Period Point Trigger Enable Control
     * |        |          |0 = PWM period point trigger ADC function Disabled.
     * |        |          |1 = PWM period point trigger ADC function Enabled.
     * |        |          |PWM can trigger ADC to start conversion when PWM counter down count to zero if this bit is set to1.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
     * |[8:13]  |CTRGEN    |PWM Center Point Trigger Enable Control
     * |        |          |0 = PWM center point trigger ADC function Disabled.
     * |        |          |1 = PWM center point trigger ADC function Enabled.
     * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to (PERIODn+1) if this bit is set to1.
     * |        |          |Note1: This bit should keep at 0 when PWM counter operating in Edge-aligned type.
     * |        |          |Note2: Each bit controls the corresponding PWM channel.
     * |[16:21] |FTRGEN    |PWM Falling Edge Point Trigger Enable Control
     * |        |          |0 = PWM falling edge point trigger ADC function Disabled.
     * |        |          |1 = PWM falling edge point trigger ADC function Enabled.
     * |        |          |PWM can trigger ADC to start conversion when PWM output pin falling edge is detected if this bit is set to1.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
     * |[24:29] |RTRGEN    |PWM Rising Edge Point Trigger Enable Control
     * |        |          |0 = PWM rising edge point trigger ADC function Disabled.
     * |        |          |1 = PWM rising edge point trigger ADC function Enabled.
     * |        |          |PWM can trigger ADC to start conversion when PWM output pin rising edge is detected if this bit is set to1.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t TRGADCTL;

    /**
     * TRGADCSTS
     * ===================================================================================================
     * Offset: 0x68  PWM Trigger ADC Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |PTRGF     |PWM Period Point Trigger Flag
     * |        |          |This bit is set to 1 by hardware when PWM counter down count to zero if corresponding PTRGEN bit is 1.
     * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.
     * |        |          |Note1: Write 1 to clear this bit.
     * |        |          |Note2: Each bit controls the corresponding PWM channel.
     * |[8:13]  |CTRGF     |PWM Center Point Trigger Flag
     * |        |          |This bit is set to 1 by hardware when PWM counter up counts to (PERIODn+1) if the corresponding CTRGEN bit is 1.
     * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.
     * |        |          |Note1: Write 1 to clear this bit.
     * |        |          |Note2: Each bit controls the corresponding PWM channel.
     * |[16:21] |FTRGF     |PWM Falling Edge Point Trigger Indicator
     * |        |          |This bit is set to 1 by hardware when PWM output pin falling edge is detected if corresponding FETRGEN bit is 1.
     * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.
     * |        |          |Note1: Write 1 to clear this bit.
     * |        |          |Note2: Each bit controls the corresponding PWM channel.
     * |[24:29] |RTRGF     |PWM Rising Edge Point Trigger Indicator
     * |        |          |This bit is set to 1 by hardware when PWM output pin rising edge is detected if corresponding RETRGEN bit is 1.
     * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.
     * |        |          |Note1: Write 1 to clear this bit.
     * |        |          |Note2: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t TRGADCSTS;

    /**
     * BRKCTL
     * ===================================================================================================
     * Offset: 0x6C  PWM Brake Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BRKP0EN   |Brake0 Function Enable Control
     * |        |          |0 = Brake0 detect function Disabled.
     * |        |          |1 = Brake0 detect function Enabled.
     * |[1]     |BRK0NFDIS |PWM Brake 0 Noise Filter Disable Control
     * |        |          |0 = Noise filter of PWM Brake 0 Enabled.
     * |        |          |1 = Noise filter of PWM Brake 0 Disabled.
     * |[2]     |BRK0INV   |Inverse BKP0 State
     * |        |          |0 = The state of pin BKPx0 is passed to the negative edge detector.
     * |        |          |1 = The inversed state of pin BKPx0 is passed to the negative edge detector.
     * |[6:7]   |BRK0NFSEL |Brake 0 (BKPx0 Pin) Edge Detector Filter Clock Selection
     * |        |          |00 = Filter clock = HCLK.
     * |        |          |01 = Filter clock = HCLK/2.
     * |        |          |10 = Filter clock = HCLK/4.
     * |        |          |11 = Filter clock = HCLK/16.
     * |[8]     |BRKP1EN   |Brake1 Function Enable Control
     * |        |          |0 = Brake1 function Disabled.
     * |        |          |1 = Brake1 function Enabled.
     * |[9]     |BRK1NFDIS |PWM Brake 1 Noise Filter Disable Control
     * |        |          |0 = Noise filter of PWM Brake 1 Enabled.
     * |        |          |1 = Noise filter of PWM Brake 1 Disabled.
     * |[10]    |BRK1INV   |Inverse BKP1 State
     * |        |          |0 = The state of pin BKPx1 is passed to the negative edge detector.
     * |        |          |1 = The inversed state of pin BKPx1 is passed to the negative edge detector.
     * |[12:13] |BK1SEL    |Brake Function 1 Source Selection
     * |        |          |00 = From external pin BKP1.
     * |        |          |01 = From analog comparator 0 output (CPO0).
     * |        |          |10 = From analog comparator 1 output (CPO1).
     * |        |          |11 = Reserved.
     * |[14:15] |BRK1NFSEL |Brake 1 (BKPx1 Pin) Edge Detector Filter Clock Selection
     * |        |          |00 = Filter clock = HCLK.
     * |        |          |01 = Filter clock = HCLK/2.
     * |        |          |10 = Filter clock = HCLK/4.
     * |        |          |11 = Filter clock = HCLK/16.
     * |[16]    |CPO0BKEN  |CPO0 Digital Output As Brake0 Source Enable Control
     * |        |          |0 = CPO0 as one brake source in Brake 0 Disabled.
     * |        |          |1 = CPO0 as one brake source in Brake 0 Enabled.
     * |[17]    |CPO1BKEN  |CPO1 Digital Output As Brake 0 Source Enable Control
     * |        |          |0 = CPO1 as one brake source in Brake 0 Disabled.
     * |        |          |1 = CPO1 as one brake source in Brake 0 Enabled.
     * |[18]    |CPO2BKEN  |CPO2 Digital Output As Brake 0 Source Enable Control
     * |        |          |0 = CPO2 as one brake source in Brake 0 Disabled.
     * |        |          |1 = CPO2 as one brake source in Brake 0 Enabled.
     * |[19]    |LVDBKEN   |Low-Level Detection Trigger PWM Brake Function 1 Enable Control
     * |        |          |0 = Brake Function 1 triggered by Low-level detection Disabled.
     * |        |          |1 = Brake Function 1 triggered by Low-level detection Enabled.
     * |[24:29] |BKOD      |PWM Brake Output Data Register
     * |        |          |0 = PWM output low when fault brake conditions asserted.
     * |        |          |1 = PWM output high when fault brake conditions asserted.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t BRKCTL;

    /**
     * INTCTL
     * ===================================================================================================
     * Offset: 0x70  PWM Interrupt Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |PINTTYPE  |PWM Period Interrupt Type Selection
     * |        |          |0 = PIF[n] will be set if PWM counter underflow.
     * |        |          |1 = PIF[n] will be set if PWM counter matches PWM_PERIODn register.
     * |        |          |Note1: This bit should keep at 0 when PWM counter operating in Edge-aligned type.
     * |        |          |Note2: Each bit controls the corresponding PWM channel.
     * |[8:13]  |DINTTYPE  |PWM Duty Interrupt Type Selection
     * |        |          |0 = DIF[n] will be set if PWM counter matches PWM_CMPDATn register during down counting.
     * |        |          |1 = DIF[n] will be set if PWM counter matches PWM_CMPDATn register during up counting.
     * |        |          |Note1: This bit should keep at 0 when PWM counter operating in Edge-aligned type.
     * |        |          |Note2: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t INTCTL;

    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0x74  PWM Interrupt Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |PIEN      |PWM Period Interrupt Enable Control
     * |        |          |0 = Period interrupt Disabled.
     * |        |          |1 = Period interrupt Enabled.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
     * |[6]     |BRKIEN    |Brake0 And Brak1 Interrupt Enable Control
     * |        |          |0 = Disabling flags BFK0 and BFK1 to trigger PWM interrupt.
     * |        |          |1 = Enabling flags BRKIF0 and BRKIF1 can trigger PWM interrupt.
     * |[8:13]  |DIEN      |PWM Duty Interrupt Enable Control
     * |        |          |0 = Duty interrupt Disabled.
     * |        |          |1 = Duty interrupt Enabled.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
     * |[16:21] |RLIEN     |Rising Latch Interrupt Enable Control
     * |        |          |0 = Rising latch interrupt Disabled.
     * |        |          |1 = Rising latch interrupt Enabled.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
     * |[24:29] |FLIEN     |Falling Latch Interrupt Enable Control
     * |        |          |0 = Falling latch interrupt Disabled.
     * |        |          |1 = Falling latch interrupt Enabled.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t INTEN;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x78  PWM Interrupt Flag Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |PIF       |PWM Period Interrupt Flag
     * |        |          |This bit is set by hardware when PWM counter reaches the requirement condition of interrupt (depending on PINTTYPE (PWM_INTCTL[n]) ).
     * |        |          |Software can write 1 to clear this bit to 0.
     * |[6]     |BRKIF0    |PWM Brake0 Flag
     * |        |          |0 = PWM Brake 0 is able to poll falling signal at BKP0 and has not recognized any one.
     * |        |          |1 = When PWM Brake 0 detects a falling signal at BKP0, this flag will be set to high.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[7]     |BRKIF1    |PWM Brake1 Flag
     * |        |          |0 = PWM Brake 1 is able to poll falling signal at BKP1 and has not recognized any one.
     * |        |          |1 = When PWM Brake 1 detects a falling signal at pin BKP1, this flag will be set to high.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[8:13]  |DIF       |PWM Duty Interrupt Flag
     * |        |          |Flag is set by hardware when channel 0 PWM counter down count and reaches CMP0.
     * |        |          |Software can clear this bit by writing 1 to it.
     * |        |          |Note: If CMP is equal to PERIOD, this flag is not working in edge-aligned type selection.
     * |[14]    |BRKLK0    |PWM Brake0 Locked
     * |        |          |0 = Brake 0 state is released.
     * |        |          |1 = When PWM Brake detects a falling signal at BKP0, this flag will be set to high to indicate the Brake0 state is locked.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[16:21] |CRLIF     |Capture Rising Latch Interrupt Flag
     * |        |          |0 = No capture rising latch condition happened.
     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
     * |[22]    |BRKSTS0   |Brake 0 Status (Read Only)
     * |        |          |0 = PWM had been out of Brake 0 state.
     * |        |          |1 = PWM is in Brake 0 state.
     * |[23]    |BRKSTS1   |Brake 1 Status (Read Only)
     * |        |          |0 = PWM had been out of Brake 1 state.
     * |        |          |1 = PWM is in Brake 1 state.
     * |[24:29] |CFLIF     |Capture Falling Latch Interrupt Flag
     * |        |          |0 = No capture falling latch condition happened.
     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
     * |        |          |Note: This bit must be cleared by writing 1 to it.
    */
    __IO uint32_t INTSTS;

    /**
     * POEN
     * ===================================================================================================
     * Offset: 0x7C  PWM Output Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |POEN      |PWM Pin Output Enable Control
     * |        |          |0 = PWM pin at tri-state.
     * |        |          |1 = PWM pin in output mode.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t POEN;

    /**
     * CAPCTL
     * ===================================================================================================
     * Offset: 0x80  PWM Capture Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |CAPEN     |Capture Function Enable Control
     * |        |          |0 = Capture function Disabled. RCAPDAT and FCAPDAT will not be updated.
     * |        |          |1 = Capture function Enabled.
     * |        |          |Capture latched the PWM counter value and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
     * |        |          |Note: Each bit controls the corresponding PWM channel.
     * |[8:13]  |CAPINV    |Capture Inverter Enable Control
     * |        |          |0 = Capture source inverter Disabled.
     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO
     * |        |          |Note: Each bit controls the corresponding PWM channel.
     * |[16:21] |RCRLDEN   |Rising Latch Reload Enable Control
     * |        |          |0 = Rising latch reload counter Enabled.
     * |        |          |1 = Rising latch reload counter Enabled.
     * |[24:29] |FCRLDEN   |Falling Latch Reload Enable Control
     * |        |          |0 = Falling latch reload counter Disabled.
     * |        |          |1 = Falling latch
     * |        |          |reload counter Enabled.
    */
    __IO uint32_t CAPCTL;

    /**
     * CAPINEN
     * ===================================================================================================
     * Offset: 0x84  PWM Capture Input Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |CAPINEN   |Capture Input Enable Control
     * |        |          |0 = PWM Channel capture input path Disabled.
     * |        |          |The input of PWM channel capture function is always regarded as 0.
     * |        |          |1 = PWM Channel capture input path Enabled.
     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
     * |        |          |Note: Each bit controls the corresponding PWM channel.
    */
    __IO uint32_t CAPINEN;

    /**
     * CAPSTS
     * ===================================================================================================
     * Offset: 0x88  PWM Capture Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |CRIFOV    |Rising Latch Interrupt Flag Overrun Status
     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1
     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
     * |[8:13]  |FLIFOV    |Falling Latch Interrupt Flag Overrun Status
     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1
     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
    */
    __I  uint32_t CAPSTS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * RCAPDAT0
     * ===================================================================================================
     * Offset: 0x90  PWM Capture Rising Latch Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has rising transition.
    */
    __I  uint32_t RCAPDAT0;

    /**
     * FCAPDAT0
     * ===================================================================================================
     * Offset: 0x94  PWM Capture Falling Latch Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has Falling transition.
    */
    __I  uint32_t FCAPDAT0;

    /**
     * RCAPDAT1
     * ===================================================================================================
     * Offset: 0x98  PWM Capture Rising Latch Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has rising transition.
    */
    __I  uint32_t RCAPDAT1;

    /**
     * FCAPDAT1
     * ===================================================================================================
     * Offset: 0x9C  PWM Capture Falling Latch Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has Falling transition.
    */
    __I  uint32_t FCAPDAT1;

    /**
     * RCAPDAT2
     * ===================================================================================================
     * Offset: 0xA0  PWM Capture Rising Latch Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has rising transition.
    */
    __I  uint32_t RCAPDAT2;

    /**
     * FCAPDAT2
     * ===================================================================================================
     * Offset: 0xA4  PWM Capture Falling Latch Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has Falling transition.
    */
    __I  uint32_t FCAPDAT2;

    /**
     * RCAPDAT3
     * ===================================================================================================
     * Offset: 0xA8  PWM Capture Rising Latch Register 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has rising transition.
    */
    __I  uint32_t RCAPDAT3;

    /**
     * FCAPDAT3
     * ===================================================================================================
     * Offset: 0xAC  PWM Capture Falling Latch Register 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has Falling transition.
    */
    __I  uint32_t FCAPDAT3;

    /**
     * RCAPDAT4
     * ===================================================================================================
     * Offset: 0xB0  PWM Capture Rising Latch Register 4
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has rising transition.
    */
    __I  uint32_t RCAPDAT4;

    /**
     * FCAPDAT4
     * ===================================================================================================
     * Offset: 0xB4  PWM Capture Falling Latch Register 4
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has Falling transition.
    */
    __I  uint32_t FCAPDAT4;

    /**
     * RCAPDAT5
     * ===================================================================================================
     * Offset: 0xB8  PWM Capture Rising Latch Register 5
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has rising transition.
    */
    __I  uint32_t RCAPDAT5;

    /**
     * FCAPDAT5
     * ===================================================================================================
     * Offset: 0xBC  PWM Capture Falling Latch Register 5
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
     * |        |          |Latch the PWM counter when Channel 0/1/2/3/4/5 has Falling transition.
    */
    __I  uint32_t FCAPDAT5;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[8];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * SBS0
     * ===================================================================================================
     * Offset: 0xE0  PWM0 Synchronous Busy Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SYNCBUSY  |PWM Synchronous Busy
     * |        |          |When software writes PWM_PERIOD0/PWM_CMPDAT0/PWM_CLKPSC or switch PWM0 counter operation mode CNTMOD (CONR[16]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain.
     * |        |          |Software needs to check this busy status before writes PWM_PERIOD0/PWM_CMPDAT0/ PWM_CLKPSC or switch PWM0 counter operation mode to make sure previous setting has been update completely.
     * |        |          |This bit will be set when software writes PWM_PERIOD0/PWM_CMPDAT0/PWM_CLKPSC or switch PWM0 operation mode CNTMOD (CONR[16]) and will be cleared by hardware automatically when PWM update these value completely.
    */
    __I  uint32_t SBS[6];

} PWM_T;

/**
    @addtogroup PWM_CONST PWM Bit Field Definition
    Constant Definitions for PWM Controller
@{ */

#define PWM_CLKPSC_CLKPSC01_Pos          (0)                                               /*!< PWM_T::CLKPSC: CLKPSC01 Position          */
#define PWM_CLKPSC_CLKPSC01_Msk          (0xfful << PWM_CLKPSC_CLKPSC01_Pos)               /*!< PWM_T::CLKPSC: CLKPSC01 Mask              */

#define PWM_CLKPSC_CLKPSC23_Pos          (8)                                               /*!< PWM_T::CLKPSC: CLKPSC23 Position          */
#define PWM_CLKPSC_CLKPSC23_Msk          (0xfful << PWM_CLKPSC_CLKPSC23_Pos)               /*!< PWM_T::CLKPSC: CLKPSC23 Mask              */

#define PWM_CLKPSC_CLKPSC45_Pos          (16)                                              /*!< PWM_T::CLKPSC: CLKPSC45 Position          */
#define PWM_CLKPSC_CLKPSC45_Msk          (0xfful << PWM_CLKPSC_CLKPSC45_Pos)               /*!< PWM_T::CLKPSC: CLKPSC45 Mask              */

#define PWM_CLKDIV_CLKDIV0_Pos           (0)                                               /*!< PWM_T::CLKDIV: CLKDIV0 Position           */
#define PWM_CLKDIV_CLKDIV0_Msk           (0x7ul << PWM_CLKDIV_CLKDIV0_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV0 Mask               */

#define PWM_CLKDIV_CLKDIV1_Pos           (4)                                               /*!< PWM_T::CLKDIV: CLKDIV1 Position           */
#define PWM_CLKDIV_CLKDIV1_Msk           (0x7ul << PWM_CLKDIV_CLKDIV1_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV1 Mask               */

#define PWM_CLKDIV_CLKDIV2_Pos           (8)                                               /*!< PWM_T::CLKDIV: CLKDIV2 Position           */
#define PWM_CLKDIV_CLKDIV2_Msk           (0x7ul << PWM_CLKDIV_CLKDIV2_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV2 Mask               */

#define PWM_CLKDIV_CLKDIV3_Pos           (12)                                              /*!< PWM_T::CLKDIV: CLKDIV3 Position           */
#define PWM_CLKDIV_CLKDIV3_Msk           (0x7ul << PWM_CLKDIV_CLKDIV3_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV3 Mask               */

#define PWM_CLKDIV_CLKDIV4_Pos           (16)                                              /*!< PWM_T::CLKDIV: CLKDIV4 Position           */
#define PWM_CLKDIV_CLKDIV4_Msk           (0x7ul << PWM_CLKDIV_CLKDIV4_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV4 Mask               */

#define PWM_CLKDIV_CLKDIV5_Pos           (20)                                              /*!< PWM_T::CLKDIV: CLKDIV5 Position           */
#define PWM_CLKDIV_CLKDIV5_Msk           (0x7ul << PWM_CLKDIV_CLKDIV5_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV5 Mask               */

#define PWM_CTL_CMPINV_Pos               (0)                                               /*!< PWM_T::CTL: CMPINV Position               */
#define PWM_CTL_CMPINV_Msk               (0x3ful << PWM_CTL_CMPINV_Pos)                    /*!< PWM_T::CTL: CMPINV Mask                   */

#define PWM_CTL_OUTMODE_Pos              (6)                                               /*!< PWM_T::CTL: OUTMODE Position              */
#define PWM_CTL_OUTMODE_Msk              (0x1ul << PWM_CTL_OUTMODE_Pos)                    /*!< PWM_T::CTL: OUTMODE Mask                  */

#define PWM_CTL_GROUPEN_Pos              (7)                                               /*!< PWM_T::CTL: GROUPEN Position              */
#define PWM_CTL_GROUPEN_Msk              (0x1ul << PWM_CTL_GROUPEN_Pos)                    /*!< PWM_T::CTL: GROUPEN Mask                  */

#define PWM_CTL_PINV_Pos                 (8)                                               /*!< PWM_T::CTL: PINV Position                 */
#define PWM_CTL_PINV_Msk                 (0x3ful << PWM_CTL_PINV_Pos)                      /*!< PWM_T::CTL: PINV Mask                     */

#define PWM_CTL_SYNCEN_Pos               (15)                                              /*!< PWM_T::CTL: SYNCEN Position               */
#define PWM_CTL_SYNCEN_Msk               (0x1ul << PWM_CTL_SYNCEN_Pos)                     /*!< PWM_T::CTL: SYNCEN Mask                   */

#define PWM_CTL_CNTMODE_Pos              (16)                                              /*!< PWM_T::CTL: CNTMODE Position              */
#define PWM_CTL_CNTMODE_Msk              (0x3ful << PWM_CTL_CNTMODE_Pos)                   /*!< PWM_T::CTL: CNTMODE Mask                  */

#define PWM_CTL_CNTTYPE_Pos              (24)                                              /*!< PWM_T::CTL: CNTTYPE Position              */
#define PWM_CTL_CNTTYPE_Msk              (0x3ful << PWM_CTL_CNTTYPE_Pos)                   /*!< PWM_T::CTL: CNTTYPE Mask                  */

#define PWM_CTL_DBGTRIOFF_Pos            (31)                                              /*!< PWM_T::CTL: DBGTRIOFF Position            */
#define PWM_CTL_DBGTRIOFF_Msk            (0x1ul << PWM_CTL_DBGTRIOFF_Pos)                  /*!< PWM_T::CTL: DBGTRIOFF Mask                */

#define PWM_CNTEN_CNTEN_Pos              (0)                                               /*!< PWM_T::CNTEN: CNTEN Position              */
#define PWM_CNTEN_CNTEN_Msk              (0x3ful << PWM_CNTEN_CNTEN_Pos)                   /*!< PWM_T::CNTEN: CNTEN Mask                  */

#define PWM_PERIOD0_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD: PERIOD Position           */
#define PWM_PERIOD0_PERIOD_Msk           (0xfffful << PWM_PERIOD0_PERIOD_Pos)              /*!< PWM_T::PERIOD: PERIOD Mask               */

#define PWM_PERIOD1_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD: PERIOD Position           */
#define PWM_PERIOD1_PERIOD_Msk           (0xfffful << PWM_PERIOD1_PERIOD_Pos)              /*!< PWM_T::PERIOD: PERIOD Mask               */

#define PWM_PERIOD2_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD: PERIOD Position           */
#define PWM_PERIOD2_PERIOD_Msk           (0xfffful << PWM_PERIOD2_PERIOD_Pos)              /*!< PWM_T::PERIOD: PERIOD Mask               */

#define PWM_PERIOD3_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD: PERIOD Position           */
#define PWM_PERIOD3_PERIOD_Msk           (0xfffful << PWM_PERIOD3_PERIOD_Pos)              /*!< PWM_T::PERIOD: PERIOD Mask               */

#define PWM_PERIOD4_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD: PERIOD Position           */
#define PWM_PERIOD4_PERIOD_Msk           (0xfffful << PWM_PERIOD4_PERIOD_Pos)              /*!< PWM_T::PERIOD: PERIOD Mask               */

#define PWM_PERIOD5_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD: PERIOD Position           */
#define PWM_PERIOD5_PERIOD_Msk           (0xfffful << PWM_PERIOD5_PERIOD_Pos)              /*!< PWM_T::PERIOD: PERIOD Mask               */

#define PWM_CMPDAT0_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT: CMP Position              */
#define PWM_CMPDAT0_CMP_Msk              (0xfffful << PWM_CMPDAT0_CMP_Pos)                 /*!< PWM_T::CMPDAT: CMP Mask                  */

#define PWM_CMPDAT1_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT: CMP Position              */
#define PWM_CMPDAT1_CMP_Msk              (0xfffful << PWM_CMPDAT1_CMP_Pos)                 /*!< PWM_T::CMPDAT: CMP Mask                  */

#define PWM_CMPDAT2_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT: CMP Position              */
#define PWM_CMPDAT2_CMP_Msk              (0xfffful << PWM_CMPDAT2_CMP_Pos)                 /*!< PWM_T::CMPDAT: CMP Mask                  */

#define PWM_CMPDAT3_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT: CMP Position              */
#define PWM_CMPDAT3_CMP_Msk              (0xfffful << PWM_CMPDAT3_CMP_Pos)                 /*!< PWM_T::CMPDAT: CMP Mask                  */

#define PWM_CMPDAT4_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT: CMP Position              */
#define PWM_CMPDAT4_CMP_Msk              (0xfffful << PWM_CMPDAT4_CMP_Pos)                 /*!< PWM_T::CMPDAT: CMP Mask                  */

#define PWM_CMPDAT5_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT: CMP Position              */
#define PWM_CMPDAT5_CMP_Msk              (0xfffful << PWM_CMPDAT5_CMP_Pos)                 /*!< PWM_T::CMPDAT: CMP Mask                  */

#define PWM_CNT0_CNT_Pos                 (0)                                               /*!< PWM_T::CNT: CNT Position                 */
#define PWM_CNT0_CNT_Msk                 (0xfffful << PWM_CNT0_CNT_Pos)                    /*!< PWM_T::CNT: CNT Mask                     */

#define PWM_CNT1_CNT_Pos                 (0)                                               /*!< PWM_T::CNT: CNT Position                 */
#define PWM_CNT1_CNT_Msk                 (0xfffful << PWM_CNT1_CNT_Pos)                    /*!< PWM_T::CNT: CNT Mask                     */

#define PWM_CNT2_CNT_Pos                 (0)                                               /*!< PWM_T::CNT: CNT Position                 */
#define PWM_CNT2_CNT_Msk                 (0xfffful << PWM_CNT2_CNT_Pos)                    /*!< PWM_T::CNT: CNT Mask                     */

#define PWM_CNT3_CNT_Pos                 (0)                                               /*!< PWM_T::CNT: CNT Position                 */
#define PWM_CNT3_CNT_Msk                 (0xfffful << PWM_CNT3_CNT_Pos)                    /*!< PWM_T::CNT: CNT Mask                     */

#define PWM_CNT4_CNT_Pos                 (0)                                               /*!< PWM_T::CNT: CNT Position                 */
#define PWM_CNT4_CNT_Msk                 (0xfffful << PWM_CNT4_CNT_Pos)                    /*!< PWM_T::CNT: CNT Mask                     */

#define PWM_CNT5_CNT_Pos                 (0)                                               /*!< PWM_T::CNT: CNT Position                 */
#define PWM_CNT5_CNT_Msk                 (0xfffful << PWM_CNT5_CNT_Pos)                    /*!< PWM_T::CNT: CNT Mask                     */

#define PWM_MSKEN_MSKEN_Pos              (0)                                               /*!< PWM_T::MSKEN: MSKEN Position              */
#define PWM_MSKEN_MSKEN_Msk              (0x3ful << PWM_MSKEN_MSKEN_Pos)                   /*!< PWM_T::MSKEN: MSKEN Mask                  */

#define PWM_MSK_MSKDAT_Pos               (0)                                               /*!< PWM_T::MSK: MSKDAT Position               */
#define PWM_MSK_MSKDAT_Msk               (0x3ful << PWM_MSK_MSKDAT_Pos)                    /*!< PWM_T::MSK: MSKDAT Mask                   */

#define PWM_DTCTL_DTCNT01_Pos            (0)                                               /*!< PWM_T::DTCTL: DTCNT01 Position            */
#define PWM_DTCTL_DTCNT01_Msk            (0xfful << PWM_DTCTL_DTCNT01_Pos)                 /*!< PWM_T::DTCTL: DTCNT01 Mask                */

#define PWM_DTCTL_DTCNT23_Pos            (8)                                               /*!< PWM_T::DTCTL: DTCNT23 Position            */
#define PWM_DTCTL_DTCNT23_Msk            (0xfful << PWM_DTCTL_DTCNT23_Pos)                 /*!< PWM_T::DTCTL: DTCNT23 Mask                */

#define PWM_DTCTL_DTCNT45_Pos            (16)                                              /*!< PWM_T::DTCTL: DTCNT45 Position            */
#define PWM_DTCTL_DTCNT45_Msk            (0xfful << PWM_DTCTL_DTCNT45_Pos)                 /*!< PWM_T::DTCTL: DTCNT45 Mask                */

#define PWM_DTCTL_DTDIV_Pos              (24)                                              /*!< PWM_T::DTCTL: DTDIV Position              */
#define PWM_DTCTL_DTDIV_Msk              (0x3ul << PWM_DTCTL_DTDIV_Pos)                    /*!< PWM_T::DTCTL: DTDIV Mask                  */

#define PWM_DTCTL_DTEN01_Pos             (28)                                              /*!< PWM_T::DTCTL: DTEN01 Position             */
#define PWM_DTCTL_DTEN01_Msk             (0x1ul << PWM_DTCTL_DTEN01_Pos)                   /*!< PWM_T::DTCTL: DTEN01 Mask                 */

#define PWM_DTCTL_DTEN23_Pos             (29)                                              /*!< PWM_T::DTCTL: DTEN23 Position             */
#define PWM_DTCTL_DTEN23_Msk             (0x1ul << PWM_DTCTL_DTEN23_Pos)                   /*!< PWM_T::DTCTL: DTEN23 Mask                 */

#define PWM_DTCTL_DTEN45_Pos             (30)                                              /*!< PWM_T::DTCTL: DTEN45 Position             */
#define PWM_DTCTL_DTEN45_Msk             (0x1ul << PWM_DTCTL_DTEN45_Pos)                   /*!< PWM_T::DTCTL: DTEN45 Mask                 */

#define PWM_TRGADCTL_PTRGEN_Pos          (0)                                               /*!< PWM_T::TRGADCTL: PTRGEN Position          */
#define PWM_TRGADCTL_PTRGEN_Msk          (0x3ful << PWM_TRGADCTL_PTRGEN_Pos)               /*!< PWM_T::TRGADCTL: PTRGEN Mask              */

#define PWM_TRGADCTL_CTRGEN_Pos          (8)                                               /*!< PWM_T::TRGADCTL: CTRGEN Position          */
#define PWM_TRGADCTL_CTRGEN_Msk          (0x3ful << PWM_TRGADCTL_CTRGEN_Pos)               /*!< PWM_T::TRGADCTL: CTRGEN Mask              */

#define PWM_TRGADCTL_FTRGEN_Pos          (16)                                              /*!< PWM_T::TRGADCTL: FTRGEN Position          */
#define PWM_TRGADCTL_FTRGEN_Msk          (0x3ful << PWM_TRGADCTL_FTRGEN_Pos)               /*!< PWM_T::TRGADCTL: FTRGEN Mask              */

#define PWM_TRGADCTL_RTRGEN_Pos          (24)                                              /*!< PWM_T::TRGADCTL: RTRGEN Position          */
#define PWM_TRGADCTL_RTRGEN_Msk          (0x3ful << PWM_TRGADCTL_RTRGEN_Pos)               /*!< PWM_T::TRGADCTL: RTRGEN Mask              */

#define PWM_TRGADCSTS_PTRGF_Pos          (0)                                               /*!< PWM_T::TRGADCSTS: PTRGF Position          */
#define PWM_TRGADCSTS_PTRGF_Msk          (0x3ful << PWM_TRGADCSTS_PTRGF_Pos)               /*!< PWM_T::TRGADCSTS: PTRGF Mask              */

#define PWM_TRGADCSTS_CTRGF_Pos          (8)                                               /*!< PWM_T::TRGADCSTS: CTRGF Position          */
#define PWM_TRGADCSTS_CTRGF_Msk          (0x3ful << PWM_TRGADCSTS_CTRGF_Pos)               /*!< PWM_T::TRGADCSTS: CTRGF Mask              */

#define PWM_TRGADCSTS_FTRGF_Pos          (16)                                              /*!< PWM_T::TRGADCSTS: FTRGF Position          */
#define PWM_TRGADCSTS_FTRGF_Msk          (0x3ful << PWM_TRGADCSTS_FTRGF_Pos)               /*!< PWM_T::TRGADCSTS: FTRGF Mask              */

#define PWM_TRGADCSTS_RTRGF_Pos          (24)                                              /*!< PWM_T::TRGADCSTS: RTRGF Position          */
#define PWM_TRGADCSTS_RTRGF_Msk          (0x3ful << PWM_TRGADCSTS_RTRGF_Pos)               /*!< PWM_T::TRGADCSTS: RTRGF Mask              */

#define PWM_BRKCTL_BRK0EN_Pos            (0)                                               /*!< PWM_T::BRKCTL: BRK0EN Position           */
#define PWM_BRKCTL_BRK0EN_Msk            (0x1ul << PWM_BRKCTL_BRK0EN_Pos)                  /*!< PWM_T::BRKCTL: BRK0EN Mask               */

#define PWM_BRKCTL_BRK0NFDIS_Pos         (1)                                               /*!< PWM_T::BRKCTL: BRK0NFDIS Position         */
#define PWM_BRKCTL_BRK0NFDIS_Msk         (0x1ul << PWM_BRKCTL_BRK0NFDIS_Pos)               /*!< PWM_T::BRKCTL: BRK0NFDIS Mask             */

#define PWM_BRKCTL_BRK0INV_Pos           (2)                                               /*!< PWM_T::BRKCTL: BRK0INV Position           */
#define PWM_BRKCTL_BRK0INV_Msk           (0x1ul << PWM_BRKCTL_BRK0INV_Pos)                 /*!< PWM_T::BRKCTL: BRK0INV Mask               */

#define PWM_BRKCTL_BRK0NFSEL_Pos         (6)                                               /*!< PWM_T::BRKCTL: BRK0NFSEL Position         */
#define PWM_BRKCTL_BRK0NFSEL_Msk         (0x3ul << PWM_BRKCTL_BRK0NFSEL_Pos)               /*!< PWM_T::BRKCTL: BRK0NFSEL Mask             */

#define PWM_BRKCTL_BRK1EN_Pos            (8)                                               /*!< PWM_T::BRKCTL: BRK1EN Position           */
#define PWM_BRKCTL_BRK1EN_Msk            (0x1ul << PWM_BRKCTL_BRK1EN_Pos)                  /*!< PWM_T::BRKCTL: BRK1EN Mask               */

#define PWM_BRKCTL_BRK1NFDIS_Pos         (9)                                               /*!< PWM_T::BRKCTL: BRK1NFDIS Position         */
#define PWM_BRKCTL_BRK1NFDIS_Msk         (0x1ul << PWM_BRKCTL_BRK1NFDIS_Pos)               /*!< PWM_T::BRKCTL: BRK1NFDIS Mask             */

#define PWM_BRKCTL_BRK1INV_Pos           (10)                                              /*!< PWM_T::BRKCTL: BRK1INV Position           */
#define PWM_BRKCTL_BRK1INV_Msk           (0x1ul << PWM_BRKCTL_BRK1INV_Pos)                 /*!< PWM_T::BRKCTL: BRK1INV Mask               */

#define PWM_BRKCTL_BK1SEL_Pos            (12)                                              /*!< PWM_T::BRKCTL: BK1SEL Position            */
#define PWM_BRKCTL_BK1SEL_Msk            (0x3ul << PWM_BRKCTL_BK1SEL_Pos)                  /*!< PWM_T::BRKCTL: BK1SEL Mask                */

#define PWM_BRKCTL_BRK1NFSEL_Pos         (14)                                              /*!< PWM_T::BRKCTL: BRK1NFSEL Position         */
#define PWM_BRKCTL_BRK1NFSEL_Msk         (0x3ul << PWM_BRKCTL_BRK1NFSEL_Pos)               /*!< PWM_T::BRKCTL: BRK1NFSEL Mask             */

#define PWM_BRKCTL_CPO0BKEN_Pos          (16)                                              /*!< PWM_T::BRKCTL: CPO0BKEN Position          */
#define PWM_BRKCTL_CPO0BKEN_Msk          (0x1ul << PWM_BRKCTL_CPO0BKEN_Pos)                /*!< PWM_T::BRKCTL: CPO0BKEN Mask              */

#define PWM_BRKCTL_CPO1BKEN_Pos          (17)                                              /*!< PWM_T::BRKCTL: CPO1BKEN Position          */
#define PWM_BRKCTL_CPO1BKEN_Msk          (0x1ul << PWM_BRKCTL_CPO1BKEN_Pos)                /*!< PWM_T::BRKCTL: CPO1BKEN Mask              */

#define PWM_BRKCTL_CPO2BKEN_Pos          (18)                                              /*!< PWM_T::BRKCTL: CPO2BKEN Position          */
#define PWM_BRKCTL_CPO2BKEN_Msk          (0x1ul << PWM_BRKCTL_CPO2BKEN_Pos)                /*!< PWM_T::BRKCTL: CPO2BKEN Mask              */

#define PWM_BRKCTL_LVDBKEN_Pos           (19)                                              /*!< PWM_T::BRKCTL: LVDBKEN Position           */
#define PWM_BRKCTL_LVDBKEN_Msk           (0x1ul << PWM_BRKCTL_LVDBKEN_Pos)                 /*!< PWM_T::BRKCTL: LVDBKEN Mask               */

#define PWM_BRKCTL_BKOD_Pos              (24)                                              /*!< PWM_T::BRKCTL: BKOD Position              */
#define PWM_BRKCTL_BKOD_Msk              (0x3ful << PWM_BRKCTL_BKOD_Pos)                   /*!< PWM_T::BRKCTL: BKOD Mask                  */

#define PWM_INTCTL_PINTTYPE_Pos          (0)                                               /*!< PWM_T::INTCTL: PINTTYPE Position          */
#define PWM_INTCTL_PINTTYPE_Msk          (0x3ful << PWM_INTCTL_PINTTYPE_Pos)               /*!< PWM_T::INTCTL: PINTTYPE Mask              */

#define PWM_INTCTL_DINTTYPE_Pos          (8)                                               /*!< PWM_T::INTCTL: DINTTYPE Position          */
#define PWM_INTCTL_DINTTYPE_Msk          (0x3ful << PWM_INTCTL_DINTTYPE_Pos)               /*!< PWM_T::INTCTL: DINTTYPE Mask              */

#define PWM_INTEN_PIEN_Pos               (0)                                               /*!< PWM_T::INTEN: PIEN Position               */
#define PWM_INTEN_PIEN_Msk               (0x3ful << PWM_INTEN_PIEN_Pos)                    /*!< PWM_T::INTEN: PIEN Mask                   */

#define PWM_INTEN_BRKIEN_Pos             (6)                                               /*!< PWM_T::INTEN: BRKIEN Position             */
#define PWM_INTEN_BRKIEN_Msk             (0x1ul << PWM_INTEN_BRKIEN_Pos)                   /*!< PWM_T::INTEN: BRKIEN Mask                 */

#define PWM_INTEN_DIEN_Pos               (8)                                               /*!< PWM_T::INTEN: DIEN Position               */
#define PWM_INTEN_DIEN_Msk               (0x3ful << PWM_INTEN_DIEN_Pos)                    /*!< PWM_T::INTEN: DIEN Mask                   */

#define PWM_INTEN_RLIEN_Pos              (16)                                              /*!< PWM_T::INTEN: RLIEN Position              */
#define PWM_INTEN_RLIEN_Msk              (0x3ful << PWM_INTEN_RLIEN_Pos)                   /*!< PWM_T::INTEN: RLIEN Mask                  */

#define PWM_INTEN_FLIEN_Pos              (24)                                              /*!< PWM_T::INTEN: FLIEN Position              */
#define PWM_INTEN_FLIEN_Msk              (0x3ful << PWM_INTEN_FLIEN_Pos)                   /*!< PWM_T::INTEN: FLIEN Mask                  */

#define PWM_INTSTS_PIF_Pos               (0)                                               /*!< PWM_T::INTSTS: PIF Position               */
#define PWM_INTSTS_PIF_Msk               (0x3ful << PWM_INTSTS_PIF_Pos)                    /*!< PWM_T::INTSTS: PIF Mask                   */

#define PWM_INTSTS_BRKIF0_Pos            (6)                                               /*!< PWM_T::INTSTS: BRKIF0 Position            */
#define PWM_INTSTS_BRKIF0_Msk            (0x1ul << PWM_INTSTS_BRKIF0_Pos)                  /*!< PWM_T::INTSTS: BRKIF0 Mask                */

#define PWM_INTSTS_BRKIF1_Pos            (7)                                               /*!< PWM_T::INTSTS: BRKIF1 Position            */
#define PWM_INTSTS_BRKIF1_Msk            (0x1ul << PWM_INTSTS_BRKIF1_Pos)                  /*!< PWM_T::INTSTS: BRKIF1 Mask                */

#define PWM_INTSTS_DIF_Pos               (8)                                               /*!< PWM_T::INTSTS: DIF Position               */
#define PWM_INTSTS_DIF_Msk               (0x3ful << PWM_INTSTS_DIF_Pos)                    /*!< PWM_T::INTSTS: DIF Mask                   */

#define PWM_INTSTS_BRKLK0_Pos            (14)                                              /*!< PWM_T::INTSTS: BRKLK0 Position            */
#define PWM_INTSTS_BRKLK0_Msk            (0x1ul << PWM_INTSTS_BRKLK0_Pos)                  /*!< PWM_T::INTSTS: BRKLK0 Mask                */

#define PWM_INTSTS_CRLIF_Pos             (16)                                              /*!< PWM_T::INTSTS: CRLIF Position             */
#define PWM_INTSTS_CRLIF_Msk             (0x3ful << PWM_INTSTS_CRLIF_Pos)                  /*!< PWM_T::INTSTS: CRLIF Mask                 */

#define PWM_INTSTS_BRKSTS0_Pos           (22)                                              /*!< PWM_T::INTSTS: BRKSTS0 Position           */
#define PWM_INTSTS_BRKSTS0_Msk           (0x1ul << PWM_INTSTS_BRKSTS0_Pos)                 /*!< PWM_T::INTSTS: BRKSTS0 Mask               */

#define PWM_INTSTS_BRKSTS1_Pos           (23)                                              /*!< PWM_T::INTSTS: BRKSTS1 Position           */
#define PWM_INTSTS_BRKSTS1_Msk           (0x1ul << PWM_INTSTS_BRKSTS1_Pos)                 /*!< PWM_T::INTSTS: BRKSTS1 Mask               */

#define PWM_INTSTS_CFLIF_Pos             (24)                                              /*!< PWM_T::INTSTS: CFLIF Position             */
#define PWM_INTSTS_CFLIF_Msk             (0x3ful << PWM_INTSTS_CFLIF_Pos)                  /*!< PWM_T::INTSTS: CFLIF Mask                 */

#define PWM_POEN_POEN_Pos                (0)                                               /*!< PWM_T::POEN: POEN Position                */
#define PWM_POEN_POEN_Msk                (0x3ful << PWM_POEN_POEN_Pos)                     /*!< PWM_T::POEN: POEN Mask                    */

#define PWM_CAPCTL_CAPEN_Pos             (0)                                               /*!< PWM_T::CAPCTL: CAPEN Position             */
#define PWM_CAPCTL_CAPEN_Msk             (0x3ful << PWM_CAPCTL_CAPEN_Pos)                  /*!< PWM_T::CAPCTL: CAPEN Mask                 */

#define PWM_CAPCTL_CAPINV_Pos            (8)                                               /*!< PWM_T::CAPCTL: CAPINV Position            */
#define PWM_CAPCTL_CAPINV_Msk            (0x3ful << PWM_CAPCTL_CAPINV_Pos)                 /*!< PWM_T::CAPCTL: CAPINV Mask                */

#define PWM_CAPCTL_RCRLDEN_Pos           (16)                                              /*!< PWM_T::CAPCTL: RCRLDEN Position           */
#define PWM_CAPCTL_RCRLDEN_Msk           (0x3ful << PWM_CAPCTL_RCRLDEN_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN Mask               */

#define PWM_CAPCTL_FCRLDEN_Pos           (24)                                              /*!< PWM_T::CAPCTL: FCRLDEN Position           */
#define PWM_CAPCTL_FCRLDEN_Msk           (0x3ful << PWM_CAPCTL_FCRLDEN_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN Mask               */

#define PWM_CAPINEN_CAPINEN_Pos          (0)                                               /*!< PWM_T::CAPINEN: CAPINEN Position          */
#define PWM_CAPINEN_CAPINEN_Msk          (0x3ful << PWM_CAPINEN_CAPINEN_Pos)               /*!< PWM_T::CAPINEN: CAPINEN Mask              */

#define PWM_CAPSTS_CRIFOV_Pos            (0)                                               /*!< PWM_T::CAPSTS: CRIFOV Position            */
#define PWM_CAPSTS_CRIFOV_Msk            (0x3ful << PWM_CAPSTS_CRIFOV_Pos)                 /*!< PWM_T::CAPSTS: CRIFOV Mask                */

#define PWM_CAPSTS_FLIFOV_Pos            (8)                                               /*!< PWM_T::CAPSTS: FLIFOV Position            */
#define PWM_CAPSTS_FLIFOV_Msk            (0x3ful << PWM_CAPSTS_FLIFOV_Pos)                 /*!< PWM_T::CAPSTS: FLIFOV Mask                */

#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT0: RCAPDAT Position         */
#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT0: RCAPDAT Mask             */

#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT0: FCAPDAT Position         */
#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT0: FCAPDAT Mask             */

#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT1: RCAPDAT Position         */
#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT1: RCAPDAT Mask             */

#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT1: FCAPDAT Position         */
#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT1: FCAPDAT Mask             */

#define PWM_RCAPDAT2_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT2: RCAPDAT Position         */
#define PWM_RCAPDAT2_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT2_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT2: RCAPDAT Mask             */

#define PWM_FCAPDAT2_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT2: FCAPDAT Position         */
#define PWM_FCAPDAT2_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT2_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT2: FCAPDAT Mask             */

#define PWM_RCAPDAT3_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT3: RCAPDAT Position         */
#define PWM_RCAPDAT3_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT3_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT3: RCAPDAT Mask             */

#define PWM_FCAPDAT3_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT3: FCAPDAT Position         */
#define PWM_FCAPDAT3_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT3_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT3: FCAPDAT Mask             */

#define PWM_RCAPDAT4_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT4: RCAPDAT Position         */
#define PWM_RCAPDAT4_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT4_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT4: RCAPDAT Mask             */

#define PWM_FCAPDAT4_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT4: FCAPDAT Position         */
#define PWM_FCAPDAT4_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT4_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT4: FCAPDAT Mask             */

#define PWM_RCAPDAT5_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT5: RCAPDAT Position         */
#define PWM_RCAPDAT5_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT5_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT5: RCAPDAT Mask             */

#define PWM_FCAPDAT5_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT5: FCAPDAT Position         */
#define PWM_FCAPDAT5_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT5_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT5: FCAPDAT Mask             */

#define PWM_SBS0_SYNCBUSY_Pos            (0)                                               /*!< PWM_T::SBS: SYNCBUSY Position            */
#define PWM_SBS0_SYNCBUSY_Msk            (0x1ul << PWM_SBS0_SYNCBUSY_Pos)                  /*!< PWM_T::SBS: SYNCBUSY Mask                */

#define PWM_SBS1_SYNCBUSY_Pos            (0)                                               /*!< PWM_T::SBS: SYNCBUSY Position            */
#define PWM_SBS1_SYNCBUSY_Msk            (0x1ul << PWM_SBS1_SYNCBUSY_Pos)                  /*!< PWM_T::SBS: SYNCBUSY Mask                */

#define PWM_SBS2_SYNCBUSY_Pos            (0)                                               /*!< PWM_T::SBS: SYNCBUSY Position            */
#define PWM_SBS2_SYNCBUSY_Msk            (0x1ul << PWM_SBS2_SYNCBUSY_Pos)                  /*!< PWM_T::SBS: SYNCBUSY Mask                */

#define PWM_SBS3_SYNCBUSY_Pos            (0)                                               /*!< PWM_T::SBS: SYNCBUSY Position            */
#define PWM_SBS3_SYNCBUSY_Msk            (0x1ul << PWM_SBS3_SYNCBUSY_Pos)                  /*!< PWM_T::SBS: SYNCBUSY Mask                */

#define PWM_SBS4_SYNCBUSY_Pos            (0)                                               /*!< PWM_T::SBS: SYNCBUSY Position            */
#define PWM_SBS4_SYNCBUSY_Msk            (0x1ul << PWM_SBS4_SYNCBUSY_Pos)                  /*!< PWM_T::SBS: SYNCBUSY Mask                */

#define PWM_SBS5_SYNCBUSY_Pos            (0)                                               /*!< PWM_T::SBS: SYNCBUSY Position            */
#define PWM_SBS5_SYNCBUSY_Msk            (0x1ul << PWM_SBS5_SYNCBUSY_Pos)                  /*!< PWM_T::SBS: SYNCBUSY Mask                */

/**@}*/ /* PWM_CONST */
/**@}*/ /* end of PWM register group */


/*---------------------- Quadrature Encoder Interface -------------------------*/
/**
    @addtogroup QEI Quadrature Encoder Interface(QEI)
    Memory Mapped Structure for QEI Controller
@{ */

typedef struct {


    /**
     * CNT
     * ===================================================================================================
     * Offset: 0x00  QEI Pulse Counter
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |VAL       |Quadrature Encoder Pulse Counter
     * |        |          |A 32-bit up/down counter.
     * |        |          |When an effective phase pulse is detected, this counter is increased by one if the bit DIRF (QEI_STATUS[27]) is one or decreased by one if the bit DIRF is zero.
     * |        |          |This register performs an integrator which count value is proportional to the encoder position.
     * |        |          |The pulse counter may be initialized to a predetermined value by one of three events occurs:.
     * |        |          |1. Software written if QEIEN (QEI_CTR[29]) = 0.
     * |        |          |2. Compare-match event if QEIEN=1 and QEI is in compare-counting mode.
     * |        |          |3. Index signal change if QEIEN=1 and IDXRLDEN (QEI_CTR[27])=1.
    */
    __IO uint32_t CNT;

    /**
     * CNTHOLD
     * ===================================================================================================
     * Offset: 0x04  QEI Pulse Counter Hold Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |VAL       |Quadrature Encoder Pulse Counter Hold Register
     * |        |          |When bit HOLDCNT (QEIx_CTR[24]) goes from low to high, the QEI_CNT value is copied into QEI_CNTHOLD register.
    */
    __IO uint32_t CNTHOLD;

    /**
     * CNTLATCH
     * ===================================================================================================
     * Offset: 0x08  QEI Pulse Counter Index Latch Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |VAL       |Quadrature Encoder Pulse Counter Index Latch
     * |        |          |When the IDXF (QEI_STATUS[18]) bit is set, the QEI_CNT value is copied into QEI_CNTLATCH register.
    */
    __IO uint32_t CNTLATCH;

    /**
     * CNTCMP
     * ===================================================================================================
     * Offset: 0x0C  QEI Pulse Counter Compare Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |VAL       |Quadrature Encoder Pulse Counter Compare
     * |        |          |if the QEI controller is in the compare-counting mode CMPENN (QEI_CTR[28]) =1, when the value of QEI_CNT matches the value of VAL the bit CMPF will be set.
     * |        |          |This register is software writeable.
    */
    __IO uint32_t CNTCMP;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * MAXCNT
     * ===================================================================================================
     * Offset: 0x14  QEI Pre-set Maximum Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |VAL       |Quadrature Encoder Preset Maximum Count
     * |        |          |This register value determined by user stores the maximum value which may be the number of the quadrature encoder pulses in a revolution for the QEI controller compare-counting mode
    */
    __IO uint32_t CNTMAX;

    /**
     * CTR
     * ===================================================================================================
     * Offset: 0x18  QEI Controller Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |NFCLKSEL  |Noise Filter Clock Pre-Divide Selection
     * |        |          |To determine the sampling frequency of the Noise Filter clock .
     * |        |          |00 = QEI_CLK.
     * |        |          |01 = QEI_CLK/2.
     * |        |          |10 = QEI_CLK/4.
     * |        |          |11 = QEI_CLK/16.
     * |[3]     |NFDIS     |QEI Controller Input Noise Filter Disable Control
     * |        |          |0 = The noise filter of QEI controller Enabled.
     * |        |          |1 = The noise filter of QEI controller Disabled.
     * |[4]     |CHAEN     |QEA Input To QEI Controller Enable Control
     * |        |          |0 = QEA input to QEI Controller Disabled.
     * |        |          |1 = QEA input to QEI Controller Enabled.
     * |[5]     |CHBEN     |QEB Input To QEI Controller Enable Control
     * |        |          |0 = QEB input to QEI Controller Disabled.
     * |        |          |1 = QEB input to QEI Controller Enabled.
     * |[6]     |IDXEN     |IDX Input To QEI Controller Enable Control
     * |        |          |0 = IDX input to QEI Controller Disabled.
     * |        |          |1 = IDX input to QEI Controller Enabled.
     * |[8:9]   |MODE      |QEI Counting Mode Selection
     * |        |          |There are four quadrature encoder pulse counter operation modes.
     * |        |          |00 = X4 Free-counting Mode.
     * |        |          |01 = X2 Free-counting Mode.
     * |        |          |10 = X4 Compare-counting Mode.
     * |        |          |11 = X2 Compare-counting Mode.
     * |[12]    |CHAINV    |Inverse QEA Input Polarity
     * |        |          |0 = Not inverse QEA input polarity.
     * |        |          |1 = QEA input polarity is inversed to QEI controller.
     * |[13]    |CHBINV    |Inverse QEB Input Polarity
     * |        |          |0 = Not inverse QEB input polarity.
     * |        |          |1 = QEB input polarity is inversed to QEI controller.
     * |[14]    |IDXINV    |Inverse IDX Input Polarity
     * |        |          |0 = Not inverse IDX input polarity.
     * |        |          |1 = IDX input polarity is inversed to QEI controller.
     * |[16]    |OVUNIEN   |OVUNF Trigger QEI Interrupt Enable Control
     * |        |          |0 = OVUNF can trigger QEI controller interrupt Disabled.
     * |        |          |1 = OVUNF can trigger QEI controller interrupt Enabled.
     * |[17]    |DIRIEN    |DIRCHGF Trigger QEI Interrupt Enable Control
     * |        |          |0 = DIRCHGF can trigger QEI controller interrupt Disabled.
     * |        |          |1 = DIRCHGF can trigger QEI controller interrupt Enabled.
     * |[18]    |CMPIEN    |CMPF Trigger QEI Interrupt Enable Control
     * |        |          |0 = CMPF can trigger QEI controller interrupt Disabled.
     * |        |          |1 = CMPF can trigger QEI controller interrupt Enabled.
     * |[19]    |IDXIEN    |IDXF Trigger QEI Interrupt Enable Control
     * |        |          |0 = The IDXF can trigger QEI interrupt Disabled.
     * |        |          |1 = The IDXF can trigger QEI interrupt Enabled.
     * |[20]    |HOLDTMR0  |Hold QEI_CNT By Timer 0
     * |        |          |0 = TIF (TISR0[0]) has no effect on HOLDCNT.
     * |        |          |1 = A rising edge of bit TIF (TISR0[0]) in timer 0 sets HOLDCNT to 1.
     * |[21]    |HOLDTMR1  |Hold QEI_CNT By Timer 1
     * |        |          |0 = TIF (TISR1[0]) has no effect on HOLDCNT.
     * |        |          |1 = A rising edge of bit TIF (TISR1[0]) in timer 1 sets HOLDCNT to 1.
     * |[22]    |HOLDTMR2  |Hold QEI_CNT By Timer 2
     * |        |          |0 = TIF (TISR2[0]) has no effect on HOLDCNT.
     * |        |          |1 = A rising edge of bit TIF (TISR2[0]) in timer 2 sets HOLDCNT to 1.
     * |[23]    |HOLDTMR3  |Hold QEI_CNT By Timer 3
     * |        |          |0 = TIF (TISR3[0]) has no effect on HOLDCNT.
     * |        |          |1 = A rising edge of bit TIF (TISR3[0]) in timer 3 sets HOLDCNT to 1.
     * |[24]    |HOLDCNT   |Hold QEI_CNT Control
     * |        |          |When this bit is set from low to high, the QEI_CNT value is copied into QEI_CNTHOLD.
     * |        |          |This bit may be set by writing 1 to it or Timer0~Timer3 interrupt flag TIF (TISTRx[0]).
     * |        |          |0 = No operation.
     * |        |          |1 = QEI_CNT content is captured and stored in QEI_CNTHOLD.
     * |        |          |Note: This bit is automatically cleared after QEI_CNTHOLD holds QEI_CNT value.
     * |[25]    |IDXLATEN  |Index Latch QEI_CNT Enable Control
     * |        |          |If this bit is set to high, the QEI_CNT content will be latched into QEI_CNTLATCH at every rising on signal CHX.
     * |        |          |0 = The index signal latch QEI counter function Disabled.
     * |        |          |1 = The index signal latch QEI counter function Enabled.
     * |[27]    |IDXRLDEN  |Index Trigger QEI_CNT Reload Enable Control
     * |        |          |When this bit is high and a rising edge comes on signal CHX, the QEI_CNT will be reset to zero if the counter is in up-counting type (DIRF = 1); while the QEI_CNT will be reloaded with QEI_MAXCNT content if the counter is in down-counting type (DIRF = 0).
     * |        |          |0 = Reload function Disabled.
     * |        |          |1 = QEI_CNT re-initialized by Index signal Enabled.
     * |[28]    |CMPENN    |The Compare Function Enable Control
     * |        |          |The compare function in QEI controller is to compare the dynamic counting QEI_CNT with the compare register QEI_CNTCMP, if QEI_CNT value reaches QEI_CNTCMP, the flag CMPF will be set.
     * |        |          |0 = Compare function Disabled.
     * |        |          |1 = Compare function Enabled.
     * |[29]    |QEIEN     |Quadrature Encoder Interface Controller Enable Control
     * |        |          |0 = QEI controller function Disabled.
     * |        |          |1 = QEI controller function Enabled.
    */
    __IO uint32_t CTR;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[4];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x2C  QEI Controller Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |IDXF      |IDX Detected Flag
     * |        |          |When the QEI controller detects a rising edge on signal CHX it will set flag IDXF to high.
     * |        |          |0 = No rising edge detected on signal CHX.
     * |        |          |1 = A rising edge occurs on signal CHX.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
     * |[1]     |CMPF      |Compare-Match Flag
     * |        |          |If the QEI compare function is enabled, the flag is set by hardware while QEI counter up or down counts and reach to the QEI_CNTCMP value.
     * |        |          |0 = QEI counter does not match with QEI_CNTCMP value.
     * |        |          |1 = QEI counter counts to the same as QEI_CNTCMP value.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
     * |[2]     |OVUNF     |QEI Counter Overflow Or Underflow Flag
     * |        |          |Flag is set by hardware while QEI_CNT overflows from 0xFFFF_FFFF to zero in free-counting mode or from the QEI_MAXCNT value to zero in compare-counting mode.
     * |        |          |Similarly, the flag is set wile QEI counter underflows from zero to 0xFFFF_FFFF or QEI_MAXCNT.
     * |        |          |0 = No overflow or underflow occurs in QEI counter.
     * |        |          |1 = QEI counter occurs counting overflow or underflow.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
     * |[3]     |DIRCHGF   |Direction Change Flag
     * |        |          |Flag is set by hardware while QEI counter counting direction is changed.
     * |        |          |Software can clear this bit by writing 1 to it.
     * |        |          |0 = No change in QEI counter counting direction.
     * |        |          |1 = QEI counter counting direction is changed.
     * |        |          |Note: This bit is only cleared by writing 1 to it.
     * |[8]     |DIRF      |QEI Counter Counting Direction Indication
     * |        |          |0 = QEI Counter is in down-counting.
     * |        |          |1 = QEI Counter is in up-counting.
     * |        |          |Note: This bit is set/reset by hardware according to the phase detection between CHA and CHB.
    */
    __IO uint32_t STATUS;

} QEI_T;

/**
    @addtogroup QEI_CONST QEI Bit Field Definition
    Constant Definitions for QEI Controller
@{ */

#define QEI_CNT_VAL_Pos                  (0)                                               /*!< QEI_T::CNT: VAL Position                  */
#define QEI_CNT_VAL_Msk                  (0xfffffffful << QEI_CNT_VAL_Pos)                 /*!< QEI_T::CNT: VAL Mask                      */

#define QEI_CNTHOLD_VAL_Pos              (0)                                               /*!< QEI_T::CNTHOLD: VAL Position              */
#define QEI_CNTHOLD_VAL_Msk              (0xfffffffful << QEI_CNTHOLD_VAL_Pos)             /*!< QEI_T::CNTHOLD: VAL Mask                  */

#define QEI_CNTLATCH_VAL_Pos             (0)                                               /*!< QEI_T::CNTLATCH: VAL Position             */
#define QEI_CNTLATCH_VAL_Msk             (0xfffffffful << QEI_CNTLATCH_VAL_Pos)            /*!< QEI_T::CNTLATCH: VAL Mask                 */

#define QEI_CNTCMP_VAL_Pos               (0)                                               /*!< QEI_T::CNTCMP: VAL Position               */
#define QEI_CNTCMP_VAL_Msk               (0xfffffffful << QEI_CNTCMP_VAL_Pos)              /*!< QEI_T::CNTCMP: VAL Mask                   */

#define QEI_CNTMAX_VAL_Pos               (0)                                               /*!< QEI_T::CNTMAX: VAL Position               */
#define QEI_CNTMAX_VAL_Msk               (0xfffffffful << QEI_CNTMAX_VAL_Pos)              /*!< QEI_T::CNTMAX: VAL Mask                   */

#define QEI_CTR_NFCLKSEL_Pos             (0)                                               /*!< QEI_T::CTR: NFCLKSEL Position             */
#define QEI_CTR_NFCLKSEL_Msk             (0x3ul << QEI_CTR_NFCLKSEL_Pos)                   /*!< QEI_T::CTR: NFCLKSEL Mask                 */

#define QEI_CTR_NFDIS_Pos                (3)                                               /*!< QEI_T::CTR: NFDIS Position                */
#define QEI_CTR_NFDIS_Msk                (0x1ul << QEI_CTR_NFDIS_Pos)                      /*!< QEI_T::CTR: NFDIS Mask                    */

#define QEI_CTR_CHAEN_Pos                (4)                                               /*!< QEI_T::CTR: CHAEN Position                */
#define QEI_CTR_CHAEN_Msk                (0x1ul << QEI_CTR_CHAEN_Pos)                      /*!< QEI_T::CTR: CHAEN Mask                    */

#define QEI_CTR_CHBEN_Pos                (5)                                               /*!< QEI_T::CTR: CHBEN Position                */
#define QEI_CTR_CHBEN_Msk                (0x1ul << QEI_CTR_CHBEN_Pos)                      /*!< QEI_T::CTR: CHBEN Mask                    */

#define QEI_CTR_IDXEN_Pos                (6)                                               /*!< QEI_T::CTR: IDXEN Position                */
#define QEI_CTR_IDXEN_Msk                (0x1ul << QEI_CTR_IDXEN_Pos)                      /*!< QEI_T::CTR: IDXEN Mask                    */

#define QEI_CTR_MODE_Pos                 (8)                                               /*!< QEI_T::CTR: MODE Position                 */
#define QEI_CTR_MODE_Msk                 (0x3ul << QEI_CTR_MODE_Pos)                       /*!< QEI_T::CTR: MODE Mask                     */

#define QEI_CTR_CHAINV_Pos               (12)                                              /*!< QEI_T::CTR: CHAINV Position               */
#define QEI_CTR_CHAINV_Msk               (0x1ul << QEI_CTR_CHAINV_Pos)                     /*!< QEI_T::CTR: CHAINV Mask                   */

#define QEI_CTR_CHBINV_Pos               (13)                                              /*!< QEI_T::CTR: CHBINV Position               */
#define QEI_CTR_CHBINV_Msk               (0x1ul << QEI_CTR_CHBINV_Pos)                     /*!< QEI_T::CTR: CHBINV Mask                   */

#define QEI_CTR_IDXINV_Pos               (14)                                              /*!< QEI_T::CTR: IDXINV Position               */
#define QEI_CTR_IDXINV_Msk               (0x1ul << QEI_CTR_IDXINV_Pos)                     /*!< QEI_T::CTR: IDXINV Mask                   */

#define QEI_CTR_OVUNIEN_Pos              (16)                                              /*!< QEI_T::CTR: OVUNIEN Position              */
#define QEI_CTR_OVUNIEN_Msk              (0x1ul << QEI_CTR_OVUNIEN_Pos)                    /*!< QEI_T::CTR: OVUNIEN Mask                  */

#define QEI_CTR_DIRIEN_Pos               (17)                                              /*!< QEI_T::CTR: DIRIEN Position               */
#define QEI_CTR_DIRIEN_Msk               (0x1ul << QEI_CTR_DIRIEN_Pos)                     /*!< QEI_T::CTR: DIRIEN Mask                   */

#define QEI_CTR_CMPIEN_Pos               (18)                                              /*!< QEI_T::CTR: CMPIEN Position               */
#define QEI_CTR_CMPIEN_Msk               (0x1ul << QEI_CTR_CMPIEN_Pos)                     /*!< QEI_T::CTR: CMPIEN Mask                   */

#define QEI_CTR_IDXIEN_Pos               (19)                                              /*!< QEI_T::CTR: IDXIEN Position               */
#define QEI_CTR_IDXIEN_Msk               (0x1ul << QEI_CTR_IDXIEN_Pos)                     /*!< QEI_T::CTR: IDXIEN Mask                   */

#define QEI_CTR_HOLDTMR0_Pos             (20)                                              /*!< QEI_T::CTR: HOLDTMR0 Position             */
#define QEI_CTR_HOLDTMR0_Msk             (0x1ul << QEI_CTR_HOLDTMR0_Pos)                   /*!< QEI_T::CTR: HOLDTMR0 Mask                 */

#define QEI_CTR_HOLDTMR1_Pos             (21)                                              /*!< QEI_T::CTR: HOLDTMR1 Position             */
#define QEI_CTR_HOLDTMR1_Msk             (0x1ul << QEI_CTR_HOLDTMR1_Pos)                   /*!< QEI_T::CTR: HOLDTMR1 Mask                 */

#define QEI_CTR_HOLDTMR2_Pos             (22)                                              /*!< QEI_T::CTR: HOLDTMR2 Position             */
#define QEI_CTR_HOLDTMR2_Msk             (0x1ul << QEI_CTR_HOLDTMR2_Pos)                   /*!< QEI_T::CTR: HOLDTMR2 Mask                 */

#define QEI_CTR_HOLDTMR3_Pos             (23)                                              /*!< QEI_T::CTR: HOLDTMR3 Position             */
#define QEI_CTR_HOLDTMR3_Msk             (0x1ul << QEI_CTR_HOLDTMR3_Pos)                   /*!< QEI_T::CTR: HOLDTMR3 Mask                 */

#define QEI_CTR_HOLDCNT_Pos              (24)                                              /*!< QEI_T::CTR: HOLDCNT Position              */
#define QEI_CTR_HOLDCNT_Msk              (0x1ul << QEI_CTR_HOLDCNT_Pos)                    /*!< QEI_T::CTR: HOLDCNT Mask                  */

#define QEI_CTR_IDXLATEN_Pos             (25)                                              /*!< QEI_T::CTR: IDXLATEN Position             */
#define QEI_CTR_IDXLATEN_Msk             (0x1ul << QEI_CTR_IDXLATEN_Pos)                   /*!< QEI_T::CTR: IDXLATEN Mask                 */

#define QEI_CTR_IDXRLDEN_Pos             (27)                                              /*!< QEI_T::CTR: IDXRLDEN Position             */
#define QEI_CTR_IDXRLDEN_Msk             (0x1ul << QEI_CTR_IDXRLDEN_Pos)                   /*!< QEI_T::CTR: IDXRLDEN Mask                 */

#define QEI_CTR_CMPENN_Pos               (28)                                              /*!< QEI_T::CTR: CMPENN Position               */
#define QEI_CTR_CMPENN_Msk               (0x1ul << QEI_CTR_CMPENN_Pos)                     /*!< QEI_T::CTR: CMPENN Mask                   */

#define QEI_CTR_QEIEN_Pos                (29)                                              /*!< QEI_T::CTR: QEIEN Position                */
#define QEI_CTR_QEIEN_Msk                (0x1ul << QEI_CTR_QEIEN_Pos)                      /*!< QEI_T::CTR: QEIEN Mask                    */

#define QEI_STATUS_IDXF_Pos              (0)                                               /*!< QEI_T::STATUS: IDXF Position              */
#define QEI_STATUS_IDXF_Msk              (0x1ul << QEI_STATUS_IDXF_Pos)                    /*!< QEI_T::STATUS: IDXF Mask                  */

#define QEI_STATUS_CMPF_Pos              (1)                                               /*!< QEI_T::STATUS: CMPF Position              */
#define QEI_STATUS_CMPF_Msk              (0x1ul << QEI_STATUS_CMPF_Pos)                    /*!< QEI_T::STATUS: CMPF Mask                  */

#define QEI_STATUS_OVUNF_Pos             (2)                                               /*!< QEI_T::STATUS: OVUNF Position             */
#define QEI_STATUS_OVUNF_Msk             (0x1ul << QEI_STATUS_OVUNF_Pos)                   /*!< QEI_T::STATUS: OVUNF Mask                 */

#define QEI_STATUS_DIRCHGF_Pos           (3)                                               /*!< QEI_T::STATUS: DIRCHGF Position           */
#define QEI_STATUS_DIRCHGF_Msk           (0x1ul << QEI_STATUS_DIRCHGF_Pos)                 /*!< QEI_T::STATUS: DIRCHGF Mask               */

#define QEI_STATUS_DIRF_Pos              (8)                                               /*!< QEI_T::STATUS: DIRF Position              */
#define QEI_STATUS_DIRF_Msk              (0x1ul << QEI_STATUS_DIRF_Pos)                    /*!< QEI_T::STATUS: DIRF Mask                  */

/**@}*/ /* QEI_CONST */
/**@}*/ /* end of QEI register group */


/*---------------------- Real Time Clock Controller -------------------------*/
/**
    @addtogroup RTC Real Time Clock Controller(RTC)
    Memory Mapped Structure for RTC Controller
@{ */

typedef struct {

    /**
     * INIT
     * ===================================================================================================
     * Offset: 0x00  RTC Initiation Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |INIT_Active|RTC Active Status (Read Only)
     * |        |          |0 = RTC is at reset state.
     * |        |          |1 = RTC is at normal active state.
     * |[1:31]  |INIT      |RTC Initiation
     * |        |          |When RTC block is powered on, RTC is at reset state.
     * |        |          |User has to write a number (0x a5eb1357) to INIT to make RTC leaving reset state.
     * |        |          |Once the INIT is written as 0xa5eb1357, the RTC will be in un-reset state permanently.
     * |        |          |The INIT is a write-only field and read value will be always "0".
    */
    __IO uint32_t INIT;

    /**
     * RWEN
     * ===================================================================================================
     * Offset: 0x04  RTC Access Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |RWEN      |RTC Register Access Enable Password (Write Only)
     * |        |          |Writing 0xA965 to this register will enable RTC access and keep 1024 RTC clock.
     * |[16]    |RWENF     |RTC Register Access Enable Flag (Read Only)
     * |        |          |0 = RTC register read/write Disabled.
     * |        |          |1 = RTC register read/write Enabled.
     * |        |          |This bit will be set after RTC_RWEN[15:0] register is load a 0xA965, and be cleared automatically after 1024 RTC clock.
    */
    __O  uint32_t RWEN;

    /**
     * FREQADJ
     * ===================================================================================================
     * Offset: 0x08  RTC Frequency Compensation Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |FRACTION  |Fraction Part
     * |        |          |Formula = (fraction part of detected value) x 60.
     * |        |          |Note: Digit in RTC_FREQADJ must be expressed as hexadecimal number.
     * |[8:11]  |INTEGER   |Integer Part
    */
    __IO uint32_t FREQADJ;

    /**
     * TIME
     * ===================================================================================================
     * Offset: 0x0C  Time Loading Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |SEC       |1-Sec Time Digit (0~9)
     * |[4:6]   |TENSEC    |10-Sec Time Digit (0~5)
     * |[8:11]  |MIN       |1-Min Time Digit (0~9)
     * |[12:14] |TENMIN    |10-Min Time Digit (0~5)
     * |[16:19] |HR        |1-Hour Time Digit (0~9)
     * |[20:21] |TENHR     |10-Hour Time Digit (0~2)
    */
    __IO uint32_t TIME;

    /**
     * CAL
     * ===================================================================================================
     * Offset: 0x10  Calendar Loading Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |DAY       |1-Day Calendar Digit (0~9)
     * |[4:5]   |TENDAY    |10-Day Calendar Digit (0~3)
     * |[8:11]  |MON       |1-Month Calendar Digit (0~9)
     * |[12]    |TENMON    |10-Month Calendar Digit (0~1)
     * |[16:19] |YEAR      |1-Year Calendar Digit (0~9)
     * |[20:23] |TENYEAR   |10-Year Calendar Digit (0~9)
    */
    __IO uint32_t CAL;

    /**
     * CLKFMT
     * ===================================================================================================
     * Offset: 0x14  Time Scale Selection Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |24HEN     |24-Hour / 12-Hour Time Scale Selection
     * |        |          |Indicates that RTC_TIME and RTC_TALM are in 24-hour time scale or 12-hour time scale
     * |        |          |0 = 12-hour time scale with AM and PM indication selected.
     * |        |          |1 = 24-hour time scale selected.
    */
    __IO uint32_t CLKFMT;

    /**
     * WEEKDAY
     * ===================================================================================================
     * Offset: 0x18  Day of the Week Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |WEEKDAY   |Day Of The Week Bits
     * |        |          |000 = Sunday.
     * |        |          |001 = Monday.
     * |        |          |010 = Tuesday.
     * |        |          |011 = Wednesday.
     * |        |          |100 = Thursday.
     * |        |          |101 = Friday.
     * |        |          |110 = Saturday.
     * |        |          |111 = Reserved
    */
    __IO uint32_t WEEKDAY;

    /**
     * TALM
     * ===================================================================================================
     * Offset: 0x1C  Time Alarm Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |SEC       |1-Sec Time Digit of Alarm Setting (0~9)
     * |[4:6]   |TENSEC    |10-Sec Time Digit of Alarm Setting (0~5)
     * |[8:11]  |MIN       |1-Min Time Digit of Alarm Setting (0~9)
     * |[12:14] |TENMIN    |10-Min Time Digit of Alarm Setting (0~5)
     * |[16:19] |HR        |1-Hour Time Digit of Alarm Setting (0~9)
     * |[20:21] |TENHR     |10-Hour Time Digit of Alarm Setting (0~2)
    */
    __IO uint32_t TALM;

    /**
     * CALM
     * ===================================================================================================
     * Offset: 0x20  Calendar Alarm Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |DAY       |1-Day Calendar Digit of Alarm Setting (0~9)
     * |[4:5]   |TENDAY    |10-Day Calendar Digit of Alarm Setting (0~3)
     * |[8:11]  |MON       |1-Month Calendar Digit of Alarm Setting (0~9)
     * |[12]    |TENMON    |10-Month Calendar Digit of Alarm Setting (0~1)
     * |[16:19] |YEAR      |1-Year Calendar Digit of Alarm Setting (0~9)
     * |[20:23] |TENYEAR   |10-Year Calendar Digit of Alarm Setting (0~9)
    */
    __IO uint32_t CALM;

    /**
     * LEAPYEAR
     * ===================================================================================================
     * Offset: 0x24  Leap Year Indication Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |LEAPYEAR  |Leap Year Indicator (Read Only)
     * |        |          |0 = This year is not a leap year.
     * |        |          |1 = This year is leap year.
    */
    __I  uint32_t LEAPYEAR;

    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0x28  RTC Interrupt Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ALMIEN    |Alarm Interrupt Enable Control
     * |        |          |0 = RTC Alarm Interrupt Disabled.
     * |        |          |1 = RTC Alarm Interrupt Enabled.
     * |[1]     |TICKIEN   |Time Tick Interrupt Enable Control
     * |        |          |0 = RTC Time Tick Interrupt Disabled.
     * |        |          |1 = RTC Time Tick Interrupt Enabled.
    */
    __IO uint32_t INTEN;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x2C  RTC Interrupt Indicator Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ALMIF     |RTC Alarm Interrupt Flag
     * |        |          |When RTC real time counters RTC_TIME and RTC_CAL reach the alarm setting time registers RTC_TALM and RTC_CALM, this bit will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled (ALMIEN (RTC_INTEN(0)) is set to 1.
     * |        |          |Chip will also be waken up if RTC Alarm Interrupt is enabled and this bit is set to 1 when chip is running at Power-down mode.
     * |        |          |Note: This bit can be cleared by writing 1 to it.
     * |[1]     |TICKIF    |RTC Time Tick Interrupt Flag
     * |        |          |When RTC Time Tick happened, this bit will be set to 1 and an interrupt will be generated if RTC Tick Interrupt enabled (TICKIEN (RTC_INTEN[1])) is set to 1.
     * |        |          |Chip will also be waken up if RTC Tick Interrupt is enabled and this bit is set to 1 when chip is running at Power-down mode.
     * |        |          |Note: This bit can be cleared by writing 1 to it.
    */
    __IO uint32_t INTSTS;

    /**
     * TICK
     * ===================================================================================================
     * Offset: 0x30  RTC Time Tick Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |TICKSEL   |Time Tick Bits
     * |        |          |The RTC time tick period for Periodic Time Tick Interrupt request.
     * |        |          |000 = Time tick is 1 second.
     * |        |          |001 = Time tick is 1/2 second.
     * |        |          |010 = Time tick is 1/4 second.
     * |        |          |011 = Time tick is 1/8 second.
     * |        |          |100 = Time tick is 1/16 second.
     * |        |          |101 = Time tick is 1/32 second.
     * |        |          |110 = Time tick is 1/64 second.
     * |        |          |111 = Time tick is 1/128 second.
     * |        |          |Note: These bits can be read back after the RTC register access enable bit RWENF (RTC_RWEN[16]) is active.
    */
    __IO uint32_t TICK;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[2];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * SPRCTL
     * ===================================================================================================
     * Offset: 0x3C  RTC Spare Functional Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[2]     |SPRRWEN   |SPR Register Enable Control
     * |        |          |This bit controls the spare register to be enabled or not.
     * |        |          |0 = Spare register Disabled and RTC_SPR0 ~ RTC_SPR23 cannot be accessed.
     * |        |          |1 = Spare register Enabled and RTC_SPR0 ~ RTC_SPR23 can be accessed.
     * |[7]     |SPRRWRDY  |SPR Register Ready
     * |        |          |This bit indicates if the registers RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR23 are ready to be accessed.
     * |        |          |After CPU writing registers RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR23, polling this bit to check if these registers are updated done is necessary.
     * |        |          |This bit is read only and any write to it won't take any effect.
     * |        |          |0 = RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR23 updating is in progress.
     * |        |          |1 = RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR23 are updated done and ready to be accessed.
    */
    __IO uint32_t SPRCTL;

    /**
     * SPRx
     * ===================================================================================================
     * Offset: 0x40  RTC Spare Register 0 ~ 23
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SPARE     |SPARE Bits
     * |        |          |This field is used to store back-up information defined by software.
     * |        |          |This field will be cleared by hardware automatically once a snooper pin event is detected.
     * |        |          |Before storing back-up information in to SPARE register, software should write 0xA965 to RTC_RWEN to make sure register read/write enabled.
    */
    __IO uint32_t SPR[24];
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[28];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TAMPCTL
     * ===================================================================================================
     * Offset: 0x110  Tamper Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |TIEN      |Tamper Interrupt Enable Control
     * |        |          |0 = Tamper interrupt Disabled.
     * |        |          |1 = Tamper interrupt Enabled.
     * |[1]     |DESTROYEN |Destroy Spare Register Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[2]     |TAMPEN0   |Tamper0 Detect Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[3]     |TAMPEN1   |Tamper1 Detect Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[4]     |TAMPDBEN0 |Tamper0 De-Bounce Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[5]     |TAMPDBEN1 |Tamper1 De-Bounce Enable Control
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[6]     |TAMPLV0   |Tamper0 Level
     * |        |          |0 = Low.
     * |        |          |1 = High.
     * |[7]     |TAMPLV1   |Tamper1 Level
     * |        |          |0 = Low.
     * |        |          |1 = High.
    */
    __IO uint32_t TAMPCTL;

    /**
     * TAMPSTS
     * ===================================================================================================
     * Offset: 0x114  Tamper Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |TAMPSTS0  |Tamper0 Sense Flag
     * |        |          |0 = No invasion.
     * |        |          |1 = Tamper0 detect invasion.
     * |        |          |Note: Write 1 to clear it
     * |[1]     |TAMPSTS1  |Tamper1 Sense Flag
     * |        |          |0 = No invasion.
     * |        |          |1 = Tamper1 detect invasion.
     * |        |          |Note: Write 1 to clear it
    */
    __IO uint32_t TAMPSTS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TAMP0PCTL
     * ===================================================================================================
     * Offset: 0x124  TAMPER0 Pin I/O Mode Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |OUTLV     |Output Level
     * |        |          |0 = Low.
     * |        |          |1 = High.
     * |[1]     |OUTEN     |Output Enable Control
     * |        |          |0 = Output Enabled.
     * |        |          |1 = Output Disabled.
     * |[2]     |TRIEN     |Tri-State
     * |        |          |0 = Tri-state Disabled.
     * |        |          |1 = Tri-state Enabled.
     * |[3]     |TYPE      |Type
     * |        |          |0 = Input Schmitt Trigger function Disabled.
     * |        |          |1 = Input Schmitt Trigger function Enabled.
     * |[4]     |DINOFF    |Off Digital
     * |        |          |0 = Off digital Disabled.
     * |        |          |1 = Off digital Enabled.
    */
    __IO uint32_t TAMP0PCTL;

    /**
     * TAMP1PCTL
     * ===================================================================================================
     * Offset: 0x128  TAMPER1 Pin I/O Mode Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |OUTLV     |Output Level
     * |        |          |0 = Low.
     * |        |          |1 = High.
     * |[1]     |OUTEN     |Output Enable Control
     * |        |          |0 = Output Enabled.
     * |        |          |1 = Output Disabled.
     * |[2]     |TRIEN     |Tri-State
     * |        |          |0 = Tri-state Disabled.
     * |        |          |1 = Tri-state Enabled.
     * |[3]     |TYPE      |Type
     * |        |          |0 = Input Schmitt Trigger function Disabled.
     * |        |          |1 = Input Schmitt Trigger function Enabled.
     * |[4]     |DINOFF    |Off Digital
     * |        |          |0 = Off digital Disabled.
     * |        |          |1 = Off digital Enabled.
    */
    __IO uint32_t TAMP1PCTL;

    /**
     * LXTIPCTL
     * ===================================================================================================
     * Offset: 0x12C  32K Input Pin I/O Mode Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |OUTLV     |Output Level
     * |        |          |0 = Low.
     * |        |          |1 = High.
     * |[1]     |OUTEN     |Output Enable Control
     * |        |          |0 = Output Enabled.
     * |        |          |1 = Output Disabled.
     * |[2]     |TRIEN     |Tri-State
     * |        |          |0 = Tri-state Disabled.
     * |        |          |1 = Tri-state Enabled.
     * |[3]     |TYPE      |Type
     * |        |          |0 = Input Schmitt Trigger function Disabled.
     * |        |          |1 = Input Schmitt Trigger function Enabled.
     * |[4]     |DINOFF    |Off Digital
     * |        |          |0 = Off digital Disabled.
     * |        |          |1 = Off digital Enabled.
    */
    __IO uint32_t LXTIPCTL;

    /**
     * LXTOPCTL
     * ===================================================================================================
     * Offset: 0x130  32K Output Pin I/O Mode Control
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |OUTLV     |Output Level
     * |        |          |0 = Low.
     * |        |          |1 = High.
     * |[1]     |OUTEN     |Output Enable Control
     * |        |          |0 = Output Enabled.
     * |        |          |1 = Output Disabled.
     * |[2]     |TRIEN     |Tri-State
     * |        |          |0 = Tri-state Disabled.
     * |        |          |1 = Tri-state Enabled.
     * |[3]     |TYPE      |Type
     * |        |          |0 = Input Schmitt Trigger function Disabled.
     * |        |          |1 = Input Schmitt Trigger function Enabled.
     * |[4]     |DINOFF    |Off Digital
     * |        |          |0 = Off digital Disabled.
     * |        |          |1 = Off digital Enabled.
    */
    __IO uint32_t LXTOPCTL;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE3[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TAMSK
     * ===================================================================================================
     * Offset: 0x140  Time Alarm MASK Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |MSEC      |Mask 1-Sec Time Digit of Alarm Setting (0~9)
     * |[1]     |MTENSEC   |Mask 10-Sec Time Digit of Alarm Setting (0~5)
     * |[2]     |MMIN      |Mask 1-Min Time Digit of Alarm Setting (0~9)
     * |[3]     |MTENMIN   |Mask 10-Min Time Digit of Alarm Setting (0~5)
     * |[4]     |MHR       |Mask 1-Hour Time Digit of Alarm Setting (0~9)
     * |[5]     |MTENHR    |Mask 10-Hour Time Digit of Alarm Setting (0~2)
    */
    __IO uint32_t TAMSK;

    /**
     * CAMSK
     * ===================================================================================================
     * Offset: 0x144  Calendar Alarm MASK Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |MDAY      |Mask 1-Day Calendar Digit of Alarm Setting (0~9)
     * |[1]     |MTENDAY   |Mask 10-Day Calendar Digit of Alarm Setting (0~3)
     * |[2]     |MMON      |Mask 1-Month Calendar Digit of Alarm Setting (0~9)
     * |[3]     |MTENMON   |Mask 10-Month Calendar Digit of Alarm Setting (0~1)
     * |[4]     |MYEAR     |Mask 1-Year Calendar Digit of Alarm Setting (0~9)
     * |[5]     |MTENYEAR  |Mask 10-Year Calendar Digit of Alarm Setting (0~9)
    */
    __IO uint32_t CAMSK;

} RTC_T;

/**
    @addtogroup RTC_CONST RTC Bit Field Definition
    Constant Definitions for RTC Controller
@{ */

#define RTC_INIT_INIT_Active_Pos         (0)                                               /*!< RTC_T::INIT: INIT_Active Position         */
#define RTC_INIT_INIT_Active_Msk         (0x1ul << RTC_INIT_INIT_Active_Pos)               /*!< RTC_T::INIT: INIT_Active Mask             */

#define RTC_INIT_INIT_Pos                (1)                                               /*!< RTC_T::INIT: INIT Position                */
#define RTC_INIT_INIT_Msk                (0x7ffffffful << RTC_INIT_INIT_Pos)               /*!< RTC_T::INIT: INIT Mask                    */

#define RTC_RWEN_RWEN_Pos                (0)                                               /*!< RTC_T::RWEN: RWEN Position                */
#define RTC_RWEN_RWEN_Msk                (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC_T::RWEN: RWEN Mask                    */

#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC_T::RWEN: RWENF Position               */
#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC_T::RWEN: RWENF Mask                   */

#define RTC_FREQADJ_FRACTION_Pos         (0)                                               /*!< RTC_T::FREQADJ: FRACTION Position         */
#define RTC_FREQADJ_FRACTION_Msk         (0x3ful << RTC_FREQADJ_FRACTION_Pos)              /*!< RTC_T::FREQADJ: FRACTION Mask             */

#define RTC_FREQADJ_INTEGER_Pos          (8)                                               /*!< RTC_T::FREQADJ: INTEGER Position          */
#define RTC_FREQADJ_INTEGER_Msk          (0xful << RTC_FREQADJ_INTEGER_Pos)                /*!< RTC_T::FREQADJ: INTEGER Mask              */

#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC_T::TIME: SEC Position                 */
#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC_T::TIME: SEC Mask                     */

#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC_T::TIME: TENSEC Position              */
#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC_T::TIME: TENSEC Mask                  */

#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC_T::TIME: MIN Position                 */
#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC_T::TIME: MIN Mask                     */

#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC_T::TIME: TENMIN Position              */
#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC_T::TIME: TENMIN Mask                  */

#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC_T::TIME: HR Position                  */
#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC_T::TIME: HR Mask                      */

#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC_T::TIME: TENHR Position               */
#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC_T::TIME: TENHR Mask                   */

#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC_T::CAL: DAY Position                  */
#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC_T::CAL: DAY Mask                      */

#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC_T::CAL: TENDAY Position               */
#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC_T::CAL: TENDAY Mask                   */

#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC_T::CAL: MON Position                  */
#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC_T::CAL: MON Mask                      */

#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC_T::CAL: TENMON Position               */
#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC_T::CAL: TENMON Mask                   */

#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC_T::CAL: YEAR Position                 */
#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC_T::CAL: YEAR Mask                     */

#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC_T::CAL: TENYEAR Position              */
#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC_T::CAL: TENYEAR Mask                  */

#define RTC_CLKFMT_24HEN_Pos             (0)                                               /*!< RTC_T::CLKFMT: 24HEN Position             */
#define RTC_CLKFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC_T::CLKFMT: 24HEN Mask                 */

#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC_T::WEEKDAY: WEEKDAY Position          */
#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC_T::WEEKDAY: WEEKDAY Mask              */

#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC_T::TALM: SEC Position                 */
#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC_T::TALM: SEC Mask                     */

#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC_T::TALM: TENSEC Position              */
#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC_T::TALM: TENSEC Mask                  */

#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC_T::TALM: MIN Position                 */
#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC_T::TALM: MIN Mask                     */

#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC_T::TALM: TENMIN Position              */
#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC_T::TALM: TENMIN Mask                  */

#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC_T::TALM: HR Position                  */
#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC_T::TALM: HR Mask                      */

#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC_T::TALM: TENHR Position               */
#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC_T::TALM: TENHR Mask                   */

#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC_T::CALM: DAY Position                 */
#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC_T::CALM: DAY Mask                     */

#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC_T::CALM: TENDAY Position              */
#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC_T::CALM: TENDAY Mask                  */

#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC_T::CALM: MON Position                 */
#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC_T::CALM: MON Mask                     */

#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC_T::CALM: TENMON Position              */
#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC_T::CALM: TENMON Mask                  */

#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC_T::CALM: YEAR Position                */
#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC_T::CALM: YEAR Mask                    */

#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC_T::CALM: TENYEAR Position             */
#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC_T::CALM: TENYEAR Mask                 */

#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC_T::LEAPYEAR: LEAPYEAR Position        */
#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC_T::LEAPYEAR: LEAPYEAR Mask            */

#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC_T::INTEN: ALMIEN Position             */
#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC_T::INTEN: ALMIEN Mask                 */

#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC_T::INTEN: TICKIEN Position            */
#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC_T::INTEN: TICKIEN Mask                */

#define RTC_INTSTS_ALMIF_Pos             (0)                                               /*!< RTC_T::INTSTS: ALMIF Position             */
#define RTC_INTSTS_ALMIF_Msk             (0x1ul << RTC_INTSTS_ALMIF_Pos)                   /*!< RTC_T::INTSTS: ALMIF Mask                 */

#define RTC_INTSTS_TICKIF_Pos            (1)                                               /*!< RTC_T::INTSTS: TICKIF Position            */
#define RTC_INTSTS_TICKIF_Msk            (0x1ul << RTC_INTSTS_TICKIF_Pos)                  /*!< RTC_T::INTSTS: TICKIF Mask                */

#define RTC_TICK_TICKSEL_Pos             (0)                                               /*!< RTC_T::TICK: TICKSEL Position             */
#define RTC_TICK_TICKSEL_Msk             (0x7ul << RTC_TICK_TICKSEL_Pos)                   /*!< RTC_T::TICK: TICKSEL Mask                 */

#define RTC_SPRCTL_SPRRWEN_Pos           (2)                                               /*!< RTC_T::SPRCTL: SPRRWEN Position           */
#define RTC_SPRCTL_SPRRWEN_Msk           (0x1ul << RTC_SPRCTL_SPRRWEN_Pos)                 /*!< RTC_T::SPRCTL: SPRRWEN Mask               */

#define RTC_SPRCTL_SPRRWRDY_Pos          (7)                                               /*!< RTC_T::SPRCTL: SPRRWRDY Position          */
#define RTC_SPRCTL_SPRRWRDY_Msk          (0x1ul << RTC_SPRCTL_SPRRWRDY_Pos)                /*!< RTC_T::SPRCTL: SPRRWRDY Mask              */

#define RTC_TAMPCTL_TIEN_Pos             (0)                                               /*!< RTC_T::TAMPCTL: TIEN Position             */
#define RTC_TAMPCTL_TIEN_Msk             (0x1ul << RTC_TAMPCTL_TIEN_Pos)                   /*!< RTC_T::TAMPCTL: TIEN Mask                 */

#define RTC_TAMPCTL_DESTROYEN_Pos        (1)                                               /*!< RTC_T::TAMPCTL: DESTROYEN Position        */
#define RTC_TAMPCTL_DESTROYEN_Msk        (0x1ul << RTC_TAMPCTL_DESTROYEN_Pos)              /*!< RTC_T::TAMPCTL: DESTROYEN Mask            */

#define RTC_TAMPCTL_TAMPEN0_Pos          (2)                                               /*!< RTC_T::TAMPCTL: TAMPEN0 Position          */
#define RTC_TAMPCTL_TAMPEN0_Msk          (0x1ul << RTC_TAMPCTL_TAMPEN0_Pos)                /*!< RTC_T::TAMPCTL: TAMPEN0 Mask              */

#define RTC_TAMPCTL_TAMPEN1_Pos          (3)                                               /*!< RTC_T::TAMPCTL: TAMPEN1 Position          */
#define RTC_TAMPCTL_TAMPEN1_Msk          (0x1ul << RTC_TAMPCTL_TAMPEN1_Pos)                /*!< RTC_T::TAMPCTL: TAMPEN1 Mask              */

#define RTC_TAMPCTL_TAMPDBEN0_Pos        (4)                                               /*!< RTC_T::TAMPCTL: TAMPDBEN0 Position        */
#define RTC_TAMPCTL_TAMPDBEN0_Msk        (0x1ul << RTC_TAMPCTL_TAMPDBEN0_Pos)              /*!< RTC_T::TAMPCTL: TAMPDBEN0 Mask            */

#define RTC_TAMPCTL_TAMPDBEN1_Pos        (5)                                               /*!< RTC_T::TAMPCTL: TAMPDBEN1 Position        */
#define RTC_TAMPCTL_TAMPDBEN1_Msk        (0x1ul << RTC_TAMPCTL_TAMPDBEN1_Pos)              /*!< RTC_T::TAMPCTL: TAMPDBEN1 Mask            */

#define RTC_TAMPCTL_TAMPLV0_Pos          (6)                                               /*!< RTC_T::TAMPCTL: TAMPLV0 Position          */
#define RTC_TAMPCTL_TAMPLV0_Msk          (0x1ul << RTC_TAMPCTL_TAMPLV0_Pos)                /*!< RTC_T::TAMPCTL: TAMPLV0 Mask              */

#define RTC_TAMPCTL_TAMPLV1_Pos          (7)                                               /*!< RTC_T::TAMPCTL: TAMPLV1 Position          */
#define RTC_TAMPCTL_TAMPLV1_Msk          (0x1ul << RTC_TAMPCTL_TAMPLV1_Pos)                /*!< RTC_T::TAMPCTL: TAMPLV1 Mask              */

#define RTC_TAMPSTS_TAMPSTS0_Pos         (0)                                               /*!< RTC_T::TAMPSTS: TAMPSTS0 Position         */
#define RTC_TAMPSTS_TAMPSTS0_Msk         (0x1ul << RTC_TAMPSTS_TAMPSTS0_Pos)               /*!< RTC_T::TAMPSTS: TAMPSTS0 Mask             */

#define RTC_TAMPSTS_TAMPSTS1_Pos         (1)                                               /*!< RTC_T::TAMPSTS: TAMPSTS1 Position         */
#define RTC_TAMPSTS_TAMPSTS1_Msk         (0x1ul << RTC_TAMPSTS_TAMPSTS1_Pos)               /*!< RTC_T::TAMPSTS: TAMPSTS1 Mask             */

#define RTC_TAMP0PCTL_OUTLV_Pos          (0)                                               /*!< RTC_T::TAMP0PCTL: OUTLV Position          */
#define RTC_TAMP0PCTL_OUTLV_Msk          (0x1ul << RTC_TAMP0PCTL_OUTLV_Pos)                /*!< RTC_T::TAMP0PCTL: OUTLV Mask              */

#define RTC_TAMP0PCTL_OUTEN_Pos          (1)                                               /*!< RTC_T::TAMP0PCTL: OUTEN Position          */
#define RTC_TAMP0PCTL_OUTEN_Msk          (0x1ul << RTC_TAMP0PCTL_OUTEN_Pos)                /*!< RTC_T::TAMP0PCTL: OUTEN Mask              */

#define RTC_TAMP0PCTL_TRIEN_Pos          (2)                                               /*!< RTC_T::TAMP0PCTL: TRIEN Position          */
#define RTC_TAMP0PCTL_TRIEN_Msk          (0x1ul << RTC_TAMP0PCTL_TRIEN_Pos)                /*!< RTC_T::TAMP0PCTL: TRIEN Mask              */

#define RTC_TAMP0PCTL_TYPE_Pos           (3)                                               /*!< RTC_T::TAMP0PCTL: TYPE Position           */
#define RTC_TAMP0PCTL_TYPE_Msk           (0x1ul << RTC_TAMP0PCTL_TYPE_Pos)                 /*!< RTC_T::TAMP0PCTL: TYPE Mask               */

#define RTC_TAMP0PCTL_DINOFF_Pos         (4)                                               /*!< RTC_T::TAMP0PCTL: DINOFF Position         */
#define RTC_TAMP0PCTL_DINOFF_Msk         (0x1ul << RTC_TAMP0PCTL_DINOFF_Pos)               /*!< RTC_T::TAMP0PCTL: DINOFF Mask             */

#define RTC_TAMP1PCTL_OUTLV_Pos          (0)                                               /*!< RTC_T::TAMP1PCTL: OUTLV Position          */
#define RTC_TAMP1PCTL_OUTLV_Msk          (0x1ul << RTC_TAMP1PCTL_OUTLV_Pos)                /*!< RTC_T::TAMP1PCTL: OUTLV Mask              */

#define RTC_TAMP1PCTL_OUTEN_Pos          (1)                                               /*!< RTC_T::TAMP1PCTL: OUTEN Position          */
#define RTC_TAMP1PCTL_OUTEN_Msk          (0x1ul << RTC_TAMP1PCTL_OUTEN_Pos)                /*!< RTC_T::TAMP1PCTL: OUTEN Mask              */

#define RTC_TAMP1PCTL_TRIEN_Pos          (2)                                               /*!< RTC_T::TAMP1PCTL: TRIEN Position          */
#define RTC_TAMP1PCTL_TRIEN_Msk          (0x1ul << RTC_TAMP1PCTL_TRIEN_Pos)                /*!< RTC_T::TAMP1PCTL: TRIEN Mask              */

#define RTC_TAMP1PCTL_TYPE_Pos           (3)                                               /*!< RTC_T::TAMP1PCTL: TYPE Position           */
#define RTC_TAMP1PCTL_TYPE_Msk           (0x1ul << RTC_TAMP1PCTL_TYPE_Pos)                 /*!< RTC_T::TAMP1PCTL: TYPE Mask               */

#define RTC_TAMP1PCTL_DINOFF_Pos         (4)                                               /*!< RTC_T::TAMP1PCTL: DINOFF Position         */
#define RTC_TAMP1PCTL_DINOFF_Msk         (0x1ul << RTC_TAMP1PCTL_DINOFF_Pos)               /*!< RTC_T::TAMP1PCTL: DINOFF Mask             */

#define RTC_LXTIPCTL_OUTLV_Pos           (0)                                               /*!< RTC_T::LXTIPCTL: OUTLV Position           */
#define RTC_LXTIPCTL_OUTLV_Msk           (0x1ul << RTC_LXTIPCTL_OUTLV_Pos)                 /*!< RTC_T::LXTIPCTL: OUTLV Mask               */

#define RTC_LXTIPCTL_OUTEN_Pos           (1)                                               /*!< RTC_T::LXTIPCTL: OUTEN Position           */
#define RTC_LXTIPCTL_OUTEN_Msk           (0x1ul << RTC_LXTIPCTL_OUTEN_Pos)                 /*!< RTC_T::LXTIPCTL: OUTEN Mask               */

#define RTC_LXTIPCTL_TRIEN_Pos           (2)                                               /*!< RTC_T::LXTIPCTL: TRIEN Position           */
#define RTC_LXTIPCTL_TRIEN_Msk           (0x1ul << RTC_LXTIPCTL_TRIEN_Pos)                 /*!< RTC_T::LXTIPCTL: TRIEN Mask               */

#define RTC_LXTIPCTL_TYPE_Pos            (3)                                               /*!< RTC_T::LXTIPCTL: TYPE Position            */
#define RTC_LXTIPCTL_TYPE_Msk            (0x1ul << RTC_LXTIPCTL_TYPE_Pos)                  /*!< RTC_T::LXTIPCTL: TYPE Mask                */

#define RTC_LXTIPCTL_DINOFF_Pos          (4)                                               /*!< RTC_T::LXTIPCTL: DINOFF Position          */
#define RTC_LXTIPCTL_DINOFF_Msk          (0x1ul << RTC_LXTIPCTL_DINOFF_Pos)                /*!< RTC_T::LXTIPCTL: DINOFF Mask              */

#define RTC_LXTOPCTL_OUTLV_Pos           (0)                                               /*!< RTC_T::LXTOPCTL: OUTLV Position           */
#define RTC_LXTOPCTL_OUTLV_Msk           (0x1ul << RTC_LXTOPCTL_OUTLV_Pos)                 /*!< RTC_T::LXTOPCTL: OUTLV Mask               */

#define RTC_LXTOPCTL_OUTEN_Pos           (1)                                               /*!< RTC_T::LXTOPCTL: OUTEN Position           */
#define RTC_LXTOPCTL_OUTEN_Msk           (0x1ul << RTC_LXTOPCTL_OUTEN_Pos)                 /*!< RTC_T::LXTOPCTL: OUTEN Mask               */

#define RTC_LXTOPCTL_TRIEN_Pos           (2)                                               /*!< RTC_T::LXTOPCTL: TRIEN Position           */
#define RTC_LXTOPCTL_TRIEN_Msk           (0x1ul << RTC_LXTOPCTL_TRIEN_Pos)                 /*!< RTC_T::LXTOPCTL: TRIEN Mask               */

#define RTC_LXTOPCTL_TYPE_Pos            (3)                                               /*!< RTC_T::LXTOPCTL: TYPE Position            */
#define RTC_LXTOPCTL_TYPE_Msk            (0x1ul << RTC_LXTOPCTL_TYPE_Pos)                  /*!< RTC_T::LXTOPCTL: TYPE Mask                */

#define RTC_LXTOPCTL_DINOFF_Pos          (4)                                               /*!< RTC_T::LXTOPCTL: DINOFF Position          */
#define RTC_LXTOPCTL_DINOFF_Msk          (0x1ul << RTC_LXTOPCTL_DINOFF_Pos)                /*!< RTC_T::LXTOPCTL: DINOFF Mask              */

#define RTC_TAMSK_MSEC_Pos               (0)                                               /*!< RTC_T::TAMSK: MSEC Position            */
#define RTC_TAMSK_MSEC_Msk               (0x1ul << RTC_TAMSK_MSEC_Pos)                     /*!< RTC_T::TAMSK: MSEC Mask                */

#define RTC_TAMSK_MTENSEC_Pos            (1)                                               /*!< RTC_T::TAMSK: MTENSEC Position           */
#define RTC_TAMSK_MTENSEC_Msk            (0x1ul << RTC_TAMSK_MTENSEC_Pos)                  /*!< RTC_T::TAMSK: MTENSEC Mask               */

#define RTC_TAMSK_MMIN_Pos               (2)                                               /*!< RTC_T::TAMSK: MMIN Position            */
#define RTC_TAMSK_MMIN_Msk               (0x1ul << RTC_TAMSK_MMIN_Pos)                     /*!< RTC_T::TAMSK: MMIN Mask                */

#define RTC_TAMSK_MTENMIN_Pos            (3)                                               /*!< RTC_T::TAMSK: MTENMIN Position           */
#define RTC_TAMSK_MTENMIN_Msk            (0x1ul << RTC_TAMSK_MTENMIN_Pos)                  /*!< RTC_T::TAMSK: MTENMIN Mask               */

#define RTC_TAMSK_MHR_Pos                (4)                                               /*!< RTC_T::TAMSK: MHR Position             */
#define RTC_TAMSK_MHR_Msk                (0x1ul << RTC_TAMSK_MHR_Pos)                      /*!< RTC_T::TAMSK: MHR Mask                 */

#define RTC_TAMSK_MTENHR_Pos             (5)                                               /*!< RTC_T::TAMSK: MTENHR Position            */
#define RTC_TAMSK_MTENHR_Msk             (0x1ul << RTC_TAMSK_MTENHR_Pos)                   /*!< RTC_T::TAMSK: MTENHR Mask                */

#define RTC_CAMSK_MDAY_Pos               (0)                                               /*!< RTC_T::CAMSK: MDAY Position            */
#define RTC_CAMSK_MDAY_Msk               (0x1ul << RTC_CAMSK_MDAY_Pos)                     /*!< RTC_T::CAMSK: MDAY Mask                */

#define RTC_CAMSK_MTENDAY_Pos            (1)                                               /*!< RTC_T::CAMSK: MTENDAY Position           */
#define RTC_CAMSK_MTENDAY_Msk            (0x1ul << RTC_CAMSK_MTENDAY_Pos)                  /*!< RTC_T::CAMSK: MTENDAY Mask               */

#define RTC_CAMSK_MMON_Pos               (2)                                               /*!< RTC_T::CAMSK: MMON Position            */
#define RTC_CAMSK_MMON_Msk               (0x1ul << RTC_CAMSK_MMON_Pos)                     /*!< RTC_T::CAMSK: MMON Mask                */

#define RTC_CAMSK_MTENMON_Pos            (3)                                               /*!< RTC_T::CAMSK: MTENMON Position           */
#define RTC_CAMSK_MTENMON_Msk            (0x1ul << RTC_CAMSK_MTENMON_Pos)                  /*!< RTC_T::CAMSK: MTENMON Mask               */

#define RTC_CAMSK_MYEAR_Pos              (4)                                               /*!< RTC_T::CAMSK: MYEAR Position           */
#define RTC_CAMSK_MYEAR_Msk              (0x1ul << RTC_CAMSK_MYEAR_Pos)                    /*!< RTC_T::CAMSK: MYEAR Mask               */

#define RTC_CAMSK_MTENYEAR_Pos           (5)                                               /*!< RTC_T::CAMSK: MTENYEAR Position          */
#define RTC_CAMSK_MTENYEAR_Msk           (0x1ul << RTC_CAMSK_MTENYEAR_Pos)                 /*!< RTC_T::CAMSK: MTENYEAR Mask              */

/**@}*/ /* RTC_CONST */
/**@}*/ /* end of RTC register group */


/*---------------------- Smart Card Host Interface Controller -------------------------*/
/**
    @addtogroup SC Smart Card Host Interface Controller(SC)
    Memory Mapped Structure for SC Controller
@{ */

typedef struct {


    /**
     * DAT
     * ===================================================================================================
     * Offset: 0x00  SC Receive and Transmit Buffer Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |DAT       |Receiving/ Transmit Buffer
     * |        |          |Write Operation:
     * |        |          |By writing data to DAT, the SC will send out an 8-bit data.
     * |        |          |Note: If SCEN(SC_CTL[0]) is not enabled, DAT cannot be programmed.
     * |        |          |Read Operation:
     * |        |          |By reading DAT, the SC will return an 8-bit received data.
    */
    __IO uint32_t DAT;

    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x04  SC Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SCEN      |SC Engine Enable Control
     * |        |          |Set this bit to 1 to enable SC operation.
     * |        |          |If this bit is cleared, SC will force all transition to IDLE state.
     * |[1]     |RXOFF     |RX Transition Disable Control
     * |        |          |0 = The receiver Enabled.
     * |        |          |1 = The receiver Disabled.
     * |        |          |Note: If AUTOCEN is enabled, this fields must be ignored.
     * |[2]     |TXOFF     |TX Transition Disable Control
     * |        |          |0 = The transceiver Enabled.
     * |        |          |1 = The transceiver Disabled.
     * |[3]     |AUTOCEN   |Auto Convention Enable Control
     * |        |          |0 = Auto-convention Disabled.
     * |        |          |1 = Auto-convention Enabled.
     * |        |          |When hardware receives TS in answer to reset state and the TS is direct convention, CONSEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CONSEL (SC_CTL[5:4]) will be set to 11.
     * |        |          |If software enables auto convention function, the setting step must be done before Answer to Reset state and the first data must be 3B or 3F.
     * |        |          |After hardware received first data and stored it at buffer, hardware will decided the convention and change the CONSEL (SC_CTL[5:4]) bits automatically.
     * |        |          |If the first data is not 3B or 3F, hardware will generate an interrupt INT_ACON_ERR (if ACON_ERR IE (SC_INTEN[10]) = 1 to CPU.
     * |[4:5]   |CONSEL    |Convention Selection
     * |        |          |00 = Direct convention.
     * |        |          |01 = Reserved.
     * |        |          |10 = Reserved.
     * |        |          |11 = Inverse convention.
     * |        |          |Note: If AUTOCEN(SC_CTL[3]) enabled, this fields are ignored.
     * |[6:7]   |RXTRGLV   |Rx Buffer Trigger Level
     * |        |          |When the number of bytes in the receiving buffer equals the RXTRGLV, the RDA_IF will be set (if IER [RDAIENN] is enabled, an interrupt will be generated).
     * |        |          |00 = INTR_RDA Trigger Level with 01 Bytes.
     * |        |          |01 = INTR_RDA Trigger Level with 02 Bytes.
     * |        |          |10 = INTR_RDA Trigger Level with 03 Bytes.
     * |        |          |11 = Reserved.
     * |[8:12]  |BGT       |Block Guard Time (BGT)
     * |        |          |Block guard time means the minimum bit length between the leading edges of two consecutive characters between different transfer directions.
     * |        |          |This field indicates the counter for the bit length of block guard time.
     * |        |          |According to ISO7816-3, in T = 0 mode, software must fill 15 (real block guard time = 16.5) to this field; in T = 1 mode, software must fill 21 (real block guard time = 22.5) to it.
     * |        |          |In RX mode, software can enable SC_ALTCTL [RXBGTEN] to detect the first coming character timing.
     * |        |          |If the incoming data timing less than BGT, an interrupt will be generated.
     * |        |          |Note: The real block guard time is BGT + 1.
     * |[13:14] |TMRSEL    |Timer Selection
     * |        |          |00 = All internal timer function Disabled.
     * |        |          |01 = Internal 24 bit timer Enabled.
     * |        |          |Software can configure it by setting SC_TMRCTL0 [23:0].
     * |        |          |SC_TMRCTL1 and SC_TMRCTL2 will be ignored in this mode.
     * |        |          |10 = internal 24 bit timer and 8 bit internal timer Enabled.
     * |        |          |Software can configure the 24 bit timer by setting SC_TMRCTL0 [23:0] and configure the 8 bit timer by setting SC_TMRCTL1[7:0].
     * |        |          |SC_TMRCTL2 will be ignored in this mode.
     * |        |          |11 = Internal 24 bit timer and two 8 bit timers Enabled.
     * |        |          |Software can configure them by setting SC_TMRCTL0 [23:0], SC_TMRCTL1 [7:0] and SC_TMRCTL2 [7:0].
     * |[15]    |NSB       |Stop Bit Length
     * |        |          |This field indicates the length of stop bit.
     * |        |          |0 = The stop bit length is 2 ETU.
     * |        |          |1= The stop bit length is 1 ETU.
     * |        |          |Note: The default stop bit length is 2. SMC and UART adopts NSB to program the stop bit length
     * |[16:18] |RXRTY     |RX Error Retry Count Number
     * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity error has occurred
     * |        |          |Note1: The real retry number is RXRTY + 1, so 8 is the maximum retry number.
     * |        |          |Note2: This field cannot be changed when RXRTYEN enabled.
     * |        |          |The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.
     * |[19]    |RXRTYEN   |RX Error Retry Enable Control
     * |        |          |This bit enables receiver retry function   when parity error has occurred.
     * |        |          |1 = RX error retry function Enabled.
     * |        |          |0 = RX error retry function Disabled.
     * |        |          |Note: Software must fill in the RXRTY value before   enabling this bit.
     * |[20:22] |TXRTY     |TX Error Retry Count Number
     * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.
     * |        |          |Note1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.
     * |        |          |Note2: This field cannot be changed when TXRTYEN enabled.
     * |        |          |The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.
     * |[23]    |TXRTYEN   |TX Error Retry Enable Control
     * |        |          |This bit enables transmitter retry function when parity error has occurred.
     * |        |          |0 = TX error retry function Disabled.
     * |        |          |1 = TX error retry function Enabled.
     * |[24:25] |CDDBSEL   |Card Detect De-Bounce Selection
     * |        |          |This field indicates the card detect de-bounce selection.
     * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card removal once per 128 engine clocks.
     * |        |          |01 = De-bounce sample card insert once per 192 (64 * 3) engine clocks and de-bounce sample card removal once per 64 engine clocks.
     * |        |          |10 = De-bounce sample card insert once per 96 (32 * 3) engine clocks and de-bounce sample card removal once per 32 engine clocks.
     * |        |          |11 = De-bounce sample card insert once per 48 (16 * 3) engine clocks and de-bounce sample card removal once per 16 engine clocks.
     * |[26]    |CDLV      |Card Detect Level
     * |        |          |0 = When hardware detects the card detect pin from high to low, it indicates a card is detected.
     * |        |          |1 = When hardware detects the card detect pin from low to high, it indicates a card is detected.
     * |        |          |Note: Software must select card detect level before Smart Card engine enabled.
     * |[30]    |SYNC      |SYNC Flag Indicator
     * |        |          |Due to synchronization, software should check this bit before writing a new value to RXRTY and TXRTY.
     * |        |          |0 = synchronizing is completion, user can write new data to SC_PINCTL register.
     * |        |          |1 = Last value is synchronizing.
     * |        |          |Note: This bit is read only.
    */
    __IO uint32_t CTL;

    /**
     * ALTCTL
     * ===================================================================================================
     * Offset: 0x08  SC Alternate Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |TXRST     |TX Software Reset
     * |        |          |When TXRST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.
     * |        |          |0 = No effect.
     * |        |          |1 = Reset the TX internal state machine and pointers.
     * |        |          |Note: This bit will be auto cleared after reset is complete.
     * |[1]     |RXRST     |Rx Software Reset
     * |        |          |When RXRST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.
     * |        |          |0 = No effect.
     * |        |          |1 = Reset the Rx internal state machine and pointers.
     * |        |          |Note: This bit will be auto cleared after reset is complete.
     * |[2]     |DACTEN    |Deactivation Sequence Generator Enable Control
     * |        |          |This bit enables SC controller to initiate the card by deactivation sequence
     * |        |          |0 = No effect.
     * |        |          |1 = Deactivation sequence generator Enabled.
     * |        |          |Note1: When the deactivation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
     * |        |          |Note2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
     * |        |          |So don't fill this bit, TXRST, and RXRST at the same time.
     * |        |          |Note3: If SC_CTL [SCEN] not enabled, this filed cannot be programmed.
     * |[3]     |ACTEN     |Activation Sequence Generator Enable Control
     * |        |          |This bit enables SC controller to initiate the card by activation sequence
     * |        |          |0 = No effect.
     * |        |          |1 = Activation sequence generator Enabled.
     * |        |          |Note1: When the activation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
     * |        |          |Note2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
     * |        |          |Note3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
     * |[4]     |WARSTEN   |Warm Reset Sequence Generator Enable Control
     * |        |          |This bit enables SC controller to initiate the card by warm reset sequence
     * |        |          |0 = No effect.
     * |        |          |1 = Warm reset sequence generator Enabled.
     * |        |          |Note1: When the warm reset sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
     * |        |          |Note2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST, and RXRST at the same time.
     * |        |          |Note3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
     * |[5]     |CNTEN0    |Internal Timer0 Start Enable Control
     * |        |          |This bit enables Timer 0 to start counting.
     * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
     * |        |          |0 = Stops counting.
     * |        |          |1 = Start counting.
     * |        |          |Note1: This field is used for internal 24 bit timer when TMRSEL (SC_CTL[14:13]) = 01.
     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_TMRCTL0[26] = 0), this bit will be auto-cleared by hardware.
     * |        |          |Note3: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
     * |        |          |So don't fill this bit, TXRST and RXRST at the same time.
     * |        |          |Note4: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
     * |[6]     |CNTEN1    |Internal Timer1 Start Enable Control
     * |        |          |This bit enables Timer 1 to start counting.
     * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
     * |        |          |0 = Stops counting.
     * |        |          |1 = Start counting.
     * |        |          |Note1: This field is used for internal 8 bit timer when TMRSEL(SC_CTL[14:13]) = 10 or TMRSEL(SC_CTL[14:13]) = 11.
     * |        |          |Don't filled CNTEN1 when SC_CTL([TMRSEL] = 00 or SC_CTL[TMRSEL] = 01.
     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_TMRCTL1[26] = 0), this bit will be auto-cleared by hardware.
     * |        |          |Note3: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
     * |        |          |Note4: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
     * |[7]     |CNTEN2    |Internal Timer2 Start Enable Control
     * |        |          |This bit enables Timer 2 to start counting.
     * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
     * |        |          |0 = Stops counting.
     * |        |          |1 = Start counting.
     * |        |          |Note1: This field is used for internal 8 bit timer when TMRSEL(SC_CTL[14:13]) = 11.
     * |        |          |Don't filled CNTEN2 when TMRSEL(SC_CTL[14:13]) = 00 or TMRSEL(SC_CTL[14:13]) = 01 or TMRSEL(SC_CTL[14:13]) = 10.
     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_TMRCTL2[26] = 0), this bit will be auto-cleared by hardware.
     * |        |          |Note3: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
     * |        |          |So don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
     * |        |          |Note4: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
     * |[8:9]   |INITSEL   |Initial Timing Selection
     * |        |          |This fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).
     * |        |          |Unit: SC clock
     * |        |          |Activation: refer to SC Activation Sequence in Figure 5.19-4.
     * |        |          |Warm-reset: refer to Warm-Reset Sequence in Figure 5.19-5
     * |        |          |Deactivation: refer to Deactivation Sequence in Figure 5.19-6
     * |[11]    |ADACEN    |Auto Deactivation When Card Removal
     * |        |          |0 = Auto deactivation Disabled when hardware detected the card removal.
     * |        |          |1 = Auto deactivation Enabled when hardware detected the card removal.
     * |        |          |Note: When the card is removed, hardware will stop any process and then do deactivation sequence (if this bit is set).
     * |        |          |If this process completes, hardware will generate an interrupt INT_INIT to CPU.
     * |[12]    |RXBGTEN   |Receiver Block Guard Time Function Enable Control
     * |        |          |0 = Receiver block guard time function Disabled.
     * |        |          |1 = Receiver block guard time function Enabled.
     * |[13]    |ACTSTS0   |Internal Timer0 Active State (Read Only)
     * |        |          |This bit indicates the timer counter status of timer0.
     * |        |          |0 = Timer0 is not active.
     * |        |          |1 = Timer0 is active.
     * |[14]    |ACTSTS1   |Internal Timer1 Active State (Read Only)
     * |        |          |This bit indicates the timer counter status of timer1.
     * |        |          |0 = Timer1 is not active.
     * |        |          |1 = Timer1 is active.
     * |[15]    |ACTSTS2   |Internal Timer2 Active State (Read Only)
     * |        |          |This bit indicates the timer counter status of timer2.
     * |        |          |0 = Timer2 is not active.
     * |        |          |1 = Timer2 is active.
    */
    __IO uint32_t ALTCTL;

    /**
     * EGT
     * ===================================================================================================
     * Offset: 0x0C  SC Extend Guard Time Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |EGT       |Extended Guard Time
     * |        |          |This field indicates the extended guard timer value.
     * |        |          |Note: The counter is ETU base and the real extended guard time is EGT.
    */
    __IO uint32_t EGT;

    /**
     * RXTOUT
     * ===================================================================================================
     * Offset: 0x10  SC Receive Buffer Time-out Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:8]   |RFTM      |SC Receiver Buffer Time-Out (ETU Base)
     * |        |          |The time-out counter resets and starts counting whenever the RX buffer received a new data word.
     * |        |          |Once the counter decrease to 1 and no new data is received or CPU does not read data by reading SC_DAT buffer, a receiver time-out interrupt INT_RTMR will be generated(if RXTOIF(SC_INTEN[9]) = 1 ).
     * |        |          |Note1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5
     * |        |          |Note2: Fill all 0 to this field indicates to disable this function.
    */
    __IO uint32_t RXTOUT;

    /**
     * ETUCTL
     * ===================================================================================================
     * Offset: 0x14  SC ETU Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |ETURDIV   |ETU Rate Divider
     * |        |          |The field indicates the clock rate divider.
     * |        |          |The real ETU is ETURDIV + 1.
     * |        |          |Note: Software can configure this field, but this field must be greater than 0x004.
     * |[15]    |CMPEN     |Compensation Mode Enable Control
     * |        |          |This bit enables clock compensation function.
     * |        |          |When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles, where n is the value to be written into the ETURDIV .
     * |        |          |0 = Compensation function Disabled.
     * |        |          |1 = Compensation function Enabled.
    */
    __IO uint32_t ETUCTL;

    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0x18  SC Interrupt Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RDAIEN    |Receive Data Reach Interrupt Enable Control
     * |        |          |This field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt enable.
     * |        |          |0 = Receive data reach trigger level interrupt Disabled.
     * |        |          |1 = Receive data reach trigger level interrupt Enabled.
     * |[1]     |TBEIEN    |Transmit Buffer Empty Interrupt Enable Control
     * |        |          |This field is used for transmit buffer empty interrupt enable.
     * |        |          |0 = Transmit buffer empty interrupt Disabled.
     * |        |          |1 = Transmit buffer empty interrupt Enabled.
     * |[2]     |TERRIEN   |Transfer Error Interrupt Enable Control
     * |        |          |This field is used for transfer error interrupt enable.
     * |        |          |The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5]), parity error PEF(SC_STATUS[4]), receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOVER(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22] and transmitter retry over limit error TXOVERR(SC_STATUS[30].
     * |        |          |0 = Transfer error interrupt Disabled.
     * |        |          |1 = Transfer error interrupt Enabled.
     * |[3]     |TMR0IEN   |Timer0 Interrupt Enable Control
     * |        |          |This field is used to enable TMR0 interrupt enable.
     * |        |          |0 = Timer0 interrupt Disabled.
     * |        |          |1 = Timer0 interrupt Enabled.
     * |[4]     |TMR1IEN   |Timer1 Interrupt Enable Control
     * |        |          |This field is used to enable the TMR1 interrupt.
     * |        |          |0 = Timer1 interrupt Disabled.
     * |        |          |1 = Timer1 interrupt Enabled.
     * |[5]     |TMR2IEN   |Timer2 Interrupt Enable Control
     * |        |          |This field is used for TMR2 interrupt enable.
     * |        |          |0 = Timer2 interrupt Disabled.
     * |        |          |1 = Timer2 interrupt Enabled.
     * |[6]     |BGTIEN    |Block Guard Time Interrupt Enable Control
     * |        |          |This field is used for block guard time interrupt enable.
     * |        |          |0 = Block guard time Disabled.
     * |        |          |1 = Block guard time Enabled.
     * |[7]     |CDIEN     |Card Detect Interrupt Enable Control
     * |        |          |This field is used for card detect interrupt enable. The card detect status is CINSERT(SC_STATUS[12])
     * |        |          |0 = Card detect interrupt Disabled.
     * |        |          |1 = Card detect interrupt Enabled.
     * |[8]     |INITIEN   |Initial End Interrupt Enable Control
     * |        |          |This field is used for activation (ACTEN(SC_ALTCTL[3] = 1)), deactivation (DACTEN SC_ALTCTL[2] = 1) and warm reset (SC_ALTCTL [WARSTEN]) sequence interrupt enable.
     * |        |          |0 = Initial end interrupt Disabled.
     * |        |          |1 = Initial end interrupt Enabled.
     * |[9]     |RXTOIF    |Receiver Buffer Time-Out Interrupt Enable Control
     * |        |          |This field is used for receiver buffer time-out interrupt enable.
     * |        |          |0 = Receiver buffer time-out interrupt Disabled.
     * |        |          |1 = Receiver buffer time-out interrupt Enabled.
     * |[10]    |ACERRIEN  |Auto Convention Error Interrupt Enable Control
     * |        |          |This field is used for auto-convention error interrupt enable.
     * |        |          |0 = Auto-convention error interrupt Disabled.
     * |        |          |1 = Auto-convention error interrupt Enabled.
    */
    __IO uint32_t INTEN;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x1C  SC Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RDAIF     |Receive Data Reach Interrupt Status Flag (Read Only)
     * |        |          |This field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt status flag.
     * |        |          |Note: This field is the status flag of received data reaching RXTRGLV (SC_CTL[7:6]).
     * |        |          |If software reads data from SC_DAT and receiver buffer data byte number is less than RXTRGLV (SC_CTL[7:6]), this bit will be cleared automatically.
     * |[1]     |TBEIF     |Transmit Buffer Empty Interrupt Status Flag (Read Only)
     * |        |          |This field is used for transmit buffer empty interrupt status flag.
     * |        |          |Note: This field is the status flag of transmit buffer empty state.
     * |        |          |If software wants to clear this bit, software must write data to SC_DAT buffer and then this bit will be cleared automatically.
     * |[2]     |TERRIF    |Transfer Error Interrupt Status Flag (Read Only)
     * |        |          |This field is used for transfer error interrupt status flag.
     * |        |          |The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5], parity error PEF(SC_STATUS[4] and receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOVER(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22] and transmitter retry over limit error TXOVERR(SC_SC[30]).
     * |        |          |Note: This field is the status flag of BEF(SC_STATUS[6]), FEF(SC_STATUS[5], PEF(SC_STATUS[4], RXOV(SC_STATUS[0]), TXOVER(SC_STATUS[8]), RXOVERR(SC_STATUS[22] or TXOVERR(SC_SC[30]).
     * |        |          |So, if software wants to clear this bit, software must write 1 to each field.
     * |[3]     |TMR0IF    |Timer0 Interrupt Status Flag (Read Only)
     * |        |          |This field is used for TMR0 interrupt status flag.
     * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
     * |[4]     |TMR1IF    |Timer1 Interrupt Status Flag (Read Only)
     * |        |          |This field is used for TMR1 interrupt status flag.
     * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
     * |[5]     |TMR2IF    |Timer2 Interrupt Status Flag (Read Only)
     * |        |          |This field is used for TMR2 interrupt status flag.
     * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
     * |[6]     |BGTIF     |Block   Guard Time Interrupt Status Flag (Read Only)
     * |        |          |This field is   used for block guard time interrupt status flag.
     * |        |          |Note1: This bit is valid when RXBGTEN (SC_ALTCTL[12])   is enabled.
     * |        |          |Note2: This bit is read only, but it can be cleared by   writing "1" to it.
     * |[7]     |CDIF      |Card Detect Interrupt Status Flag (Read Only)
     * |        |          |This field is used for card detect interrupt status flag.
     * |        |          |The card detect status is CINSERT (SC_STATUS[12])] and CREMOVE(SC_STATUS[11]).
     * |        |          |Note: This field is the status flag of CINSERT SC_STATUS[12]) SC_PINCTL[CINSERT] or CREMOVE(SC_STATUS[11])].
     * |        |          |So if software wants to clear this bit, software must write 1 to this field.
     * |[8]     |INITIF    |Initial End Interrupt Status Flag (Read Only)
     * |        |          |This field is used for activation (ACTEN(SC_ALTCTL[3])), deactivation (DACTEN (SC_ALTCTL[2])) and warm reset (WARSTEN (SC_ALTCTL[4])) sequence interrupt status flag.
     * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
     * |[9]     |RBTOIF    |Receiver Buffer Time-Out Interrupt Status Flag (Read Only)
     * |        |          |This field is used for receiver buffer time-out interrupt status flag.
     * |        |          |Note: This field is the status flag of receiver buffer time-out state.
     * |        |          |If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_DAT buffer,.
     * |[10]    |ACERRIF   |Auto Convention Error Interrupt Status Flag (Read Only)
     * |        |          |This field indicates auto convention sequence error.
     * |        |          |If the received TS at ATR state is neither 3B nor 3F, this bit will be set.
     * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
    */
    __IO  uint32_t INTSTS;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x20  SC Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RXOV      |RX Overflow Error Status Flag (Read Only)
     * |        |          |This bit is set when RX buffer overflow.
     * |        |          |If the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.
     * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
     * |[1]     |RXEMPTY   |Receiver Buffer Empty Status Flag(Read Only)
     * |        |          |This bit indicates RX buffer empty or not.
     * |        |          |When the last byte of Rx buffer has been read by CPU, hardware sets this bit high.
     * |        |          |It will be cleared when SC receives any new data.
     * |[2]     |RXFULL    |Receiver Buffer Full Status Flag (Read Only)
     * |        |          |This bit indicates RX buffer full or not.
     * |        |          |This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
     * |[4]     |PEF       |Receiver Parity Error Status Flag (Read Only)
     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid
     * |        |          |"parity bit".
     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
     * |        |          |Note2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
     * |[5]     |FEF       |Receiver Frame Error Status Flag (Read Only)
     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0).
     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
     * |        |          |Note2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
     * |[6]     |BEF       |Receiver Break Error Status Flag (Read Only)
     * |        |          |This bit is set to a logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
     * |        |          |.
     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
     * |        |          |Note2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
     * |[8]     |TXOV      |TX Overflow Error Interrupt Status Flag (Read Only)
     * |        |          |If TX buffer is full, an additional write to SC_DAT will cause this bit be set to "1" by hardware.
     * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
     * |[9]     |TXEMPTY   |Transmit Buffer Empty Status Flag (Read Only)
     * |        |          |This bit indicates TX buffer empty or not.
     * |        |          |When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high.
     * |        |          |It will be cleared when writing data into SC_DAT (TX buffer not empty).
     * |[10]    |TXFULL    |Transmit Buffer Full Status Flag (Read Only)
     * |        |          |This bit indicates TX buffer full or not.
     * |        |          |This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.
     * |[11]    |CREMOVE   |Card Detect Removal Status Of SC_CD Pin (Read Only)
     * |        |          |This bit is set whenever card has been removal.
     * |        |          |0 = No effect.
     * |        |          |1 = Card removed.
     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
     * |        |          |Note2: Card detect engine will start after SCEN (SC_CTL[0])set.
     * |[12]    |CINSERT   |Card Detect Insert Status Of SC_CD Pin (Read Only)
     * |        |          |This bit is set whenever card has been inserted.
     * |        |          |0 = No effect.1 = Card insert.
     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
     * |        |          |Note2: The card detect engine will start after SCEN (SC_CTL[0]) set.
     * |[13]    |CDPINSTS  |Card Detect Status Of SC_CD Pin Status (Read Only)
     * |        |          |This bit is the pin status flag of SC_CD
     * |        |          |0 = The SC_CD pin state at low.
     * |        |          |1 = The SC_CD pin state at high.
     * |[16:17] |RXPOINT   |Receiver Buffer Pointer Status Flag (Read Only)
     * |        |          |This field indicates the RX buffer pointer status flag.
     * |        |          |When SC receives one byte from external device, RXPOINT(SC_STATUS[17:16]) increases one.
     * |        |          |When one byte of RX buffer is read by CPU, RXPOINT(SC_STATUS[17:16]) decreases one.
     * |[21]    |RXRERR    |Receiver Retry Error (Read Only)
     * |        |          |This bit is set by hardware when RX has any error and retries transfer.
     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
     * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
     * |        |          |Note3: If CPU enables receiver retry function by setting RXRTYEN (SC_CTL[19]) , the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).
     * |[22]    |RXOVERR   |Receiver Over Retry Error (Read Only)
     * |        |          |This bit is set by hardware when RX transfer error retry over retry number limit.
     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
     * |        |          |Note2: If CPU enables receiver retries function by setting RXRTYEN (SC_CTL[19]), the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).
     * |[23]    |RXACT     |Receiver In Active Status Flag (Read Only)
     * |        |          |This bit is set by hardware when RX transfer is in active.
     * |        |          |This bit is cleared automatically when RX transfer is finished.
     * |[24:25] |TXPOINT   |Transmit Buffer Pointer Status Flag (Read Only)
     * |        |          |This field indicates the TX buffer pointer status flag.
     * |        |          |When CPU writes data into SC_DAT, TXPOINT increases one.
     * |        |          |When one byte of TX Buffer is transferred to transmitter shift register, TXPOINT decreases one.
     * |[29]    |TXRERR    |Transmitter Retry Error (Read Only)
     * |        |          |This bit is set by hardware when transmitter re-transmits.
     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
     * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
     * |[30]    |TXOVERR   |Transmitter Over Retry Error (Read Only)
     * |        |          |This bit is set by hardware when transmitter re-transmits over retry number limitation.
     * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
     * |[31]    |TXACT     |Transmit In Active Status Flag (Read Only)
     * |        |          |0 = This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed.
     * |        |          |1 = This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted.
    */
    __IO  uint32_t STATUS;

    /**
     * PINCTL
     * ===================================================================================================
     * Offset: 0x24  SC Pin Control State Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |PWREN     |SC_PWREN Pin Signal
     * |        |          |Software can set PWREN and PWRINV to decide SC_PWR pin is in high or low level.
     * |        |          |Write this field to drive SC_PWR pin
     * |        |          |Refer PWRINV description for programming SC_PWR pin voltage level.
     * |        |          |Read this field to get SC_PWR pin status.
     * |        |          |0 = SC_PWR pin status is low.
     * |        |          |1 = SC_PWR pin status is high.
     * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically.
     * |        |          |So don't fill this field when operating in these modes.
     * |[1]     |SCRST     |SCRST Pin Signal
     * |        |          |This bit is the pin status of SCRST but user can drive SCRST pin to high or low by setting this bit.
     * |        |          |Write this field to drive SCRST pin.
     * |        |          |0 = Drive SCRST pin to low.
     * |        |          |1 = Drive SCRST pin to high.
     * |        |          |Read this
     * |        |          |field to get SCRST pin status.
     * |        |          |0 = SCRST pin status is low.
     * |        |          |1 = SCRST pin status is high.
     * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically.
     * |        |          |So don't fill this field when operating in these modes.
     * |[6]     |CLKKEEP   |SC Clock Enable Control
     * |        |          |0 = SC clock generation Disabled.
     * |        |          |1 = SC clock always keeps free running.
     * |        |          |Note: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically.
     * |        |          |So don't fill this field when operating in these modes.
     * |[9]     |SCDOOUT   |SC Data Output Pin
     * |        |          |This bit is the pin status of SCDOOUT but user can drive SCDOOUT pin to high or low by setting this bit.
     * |        |          |0 = Drive SCDOOUT pin to low.
     * |        |          |1 = Drive SCDOOUT pin to high.
     * |        |          |Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically.
     * |        |          |So don't fill this field when SC is in these modes.
     * |[11]    |PWRINV    |SC_POW Pin Inverse
     * |        |          |This bit is used for inverse the SC_POW pin.
     * |        |          |There are four kinds of combination for SC_POW pin setting by PWRINV and PWREN(SC_PINCTL[0]).
     * |        |          |PWRINV is bit 1 and PWREN is bit 0 for SC_POW_Pin as high or low voltage selection.
     * |        |          |PWRINV is 0 and PWREN is 0, than SC_POW Pin output 0.
     * |        |          |PWRINV is 0 and PWREN is 1, than SC_POW Pin output 1.
     * |        |          |PWRINV is 1 and PWREN is 0, than SC_POW Pin output 1.
     * |        |          |PWRINV is 1 and PWREN is 1, than SC_POW Pin output 0.
     * |        |          |Note: Software must select PWRINV before Smart Card is enabled by SCEN (SC_CTL[0]).
     * |[16]    |DATSTS    |This bit   is the pin status of SC_DAT
     * |        |          |0 = The SC_DAT pin is low.
     * |        |          |1 = The SC_DAT pin is high.
     * |[17]    |PWRSTS    |SC_PWR Pin   Signal
     * |        |          |This bit is   the pin status of SC_PWR
     * |        |          |0 = SC_PWR pin to low.
     * |        |          |1 = SC_PWR pin to high.
     * |        |          |Note: When SC is operated at activation, warm reset or deactivation mode, this bit will be changed automatically.
     * |        |          |This bit is not allowed to program when SC is operated at these modes.
     * |[18]    |RSTSTS    |SC_RST Pin Signals
     * |        |          |This bit is the pin status of SC_RST
     * |        |          |0 = SC_RST pin is low.
     * |        |          |1 = SC_RST pin is high.
     * |        |          |Note: When SC is operated at activation, warm reset or deactivation mode, this bit will be changed automatically.
     * |        |          |This bit is not allowed to program when SC is operated at these modes.
     * |[30]    |SYNC      |SYNC Flag Indicator
     * |        |          |Due to synchronization, software should check this bit when writing a new value to SC_PINCTL register.
     * |        |          |0 = Synchronizing is completion, user can write new data to SC_PINCTL register.
     * |        |          |1 = Last value is synchronizing.
     * |        |          |Note: This bit is read only.
    */
    __IO uint32_t PINCTL;

    /**
     * TMRCTL0
     * ===================================================================================================
     * Offset: 0x28  SC Internal Timer Control Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |CNT       |Timer 0 Counter Value (ETU Base)
     * |        |          |This field indicates the internal timer operation values.
     * |[24:27] |OPMODE    |Timer 0 Operation Mode Selection
     * |        |          |This field indicates the internal 24-bit timer operation selection.
     * |        |          |Refer to 6.25.4.4 for programming Timer0.
    */
    __IO uint32_t TMRCTL0;

    /**
     * TMRCTL1
     * ===================================================================================================
     * Offset: 0x2C  SC Internal Timer Control Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |CNT       |Timer 1 Counter Value (ETU Base)
     * |        |          |This field indicates the internal timer operation values.
     * |[24:27] |OPMODE    |Timer 1 Operation Mode Selection
     * |        |          |This field indicates the internal 8-bit timer operation selection.
     * |        |          |Refer to 6.25.4.4 for programming Timer1.
    */
    __IO uint32_t TMRCTL1;

    /**
     * TMRCTL2
     * ===================================================================================================
     * Offset: 0x30  SC Internal Timer Control Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |CNT       |Timer 2 Counter Value (ETU Base)
     * |        |          |This field indicates the internal timer operation values.
     * |[24:27] |OPMODE    |Timer 2 Operation Mode Selection
     * |        |          |This field indicates the internal 8-bit timer operation selection
     * |        |          |Refer to 6.25.4.4 for programming Timer2
    */
    __IO uint32_t TMRCTL2;

    /**
     * UARTCTL
     * ===================================================================================================
     * Offset: 0x34  SC UART Mode Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |UARTEN    |UART Mode Enable Control
     * |        |          |0 = Smart Card mode.
     * |        |          |1 = UART mode.
     * |        |          |Note1: When operating in UART mode, user must set CONSEL (SC_CTL[5:4]) = 00 and AUTOCEN(SC_CTL[3]) = 0.
     * |        |          |Note2: When operating in Smart Card mode, user must set SC_UARTCTL [7:0] = 00.
     * |        |          |Note3: When UART is enabled, hardware will generate a reset to resetFIFO and internal state machine.
     * |[4:5]   |WLS       |Data Length
     * |        |          |00 = Character Data Length is 8 bits.
     * |        |          |01 = Character Data Length is 7 bits.
     * |        |          |10 = Character Data length is 6 bits.
     * |        |          |11 = Character Data Length is 5 bits.
     * |        |          |Note: In smart card mode, this WLS must be '00'
     * |[6]     |PBOFF     |Parity Bit Disable Control
     * |        |          |0 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
     * |        |          |1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
     * |        |          |Note: In smart card mode, this field must be '0' (default setting is with parity bit)
     * |[7]     |OPE       |Odd Parity Enable Control
     * |        |          |0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
     * |        |          |1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
     * |        |          |Note: This bit has effect only when PBOFF bit is '0'.
    */
    __IO uint32_t UARTCTL;

    /**
     * TMRDAT0
     * ===================================================================================================
     * Offset: 0x38  SC Timer 0 Current Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |CNT0      |Timer0 Current Counter Value (Read Only)
     * |        |          |This field indicates the current count values of timer0.
    */
    __I  uint32_t TMRDAT0;

    /**
     * TMRDAT1_2
     * ===================================================================================================
     * Offset: 0x3C  SC Timer 1 and 2 Current Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |CNT1      |Timer1 Current Counter Value (Read Only)
     * |        |          |This field indicates the current count values of timer1.
     * |[8:15]  |CNT2      |Timer2 Current Counter Value (Read Only)
     * |        |          |This field indicates the current count values of timer2.
    */
    __I  uint32_t TMRDAT1_2;

} SC_T;

/**
    @addtogroup SC_CONST SC Bit Field Definition
    Constant Definitions for SC Controller
@{ */

#define SC_DAT_DAT_Pos                   (0)                                               /*!< SC_T::DAT: DAT Position                   */
#define SC_DAT_DAT_Msk                   (0xfful << SC_DAT_DAT_Pos)                        /*!< SC_T::DAT: DAT Mask                       */

#define SC_CTL_SCEN_Pos                  (0)                                               /*!< SC_T::CTL: SCEN Position                  */
#define SC_CTL_SCEN_Msk                  (0x1ul << SC_CTL_SCEN_Pos)                        /*!< SC_T::CTL: SCEN Mask                      */

#define SC_CTL_RXOFF_Pos                 (1)                                               /*!< SC_T::CTL: RXOFF Position                 */
#define SC_CTL_RXOFF_Msk                 (0x1ul << SC_CTL_RXOFF_Pos)                       /*!< SC_T::CTL: RXOFF Mask                     */

#define SC_CTL_TXOFF_Pos                 (2)                                               /*!< SC_T::CTL: TXOFF Position                 */
#define SC_CTL_TXOFF_Msk                 (0x1ul << SC_CTL_TXOFF_Pos)                       /*!< SC_T::CTL: TXOFF Mask                     */

#define SC_CTL_AUTOCEN_Pos               (3)                                               /*!< SC_T::CTL: AUTOCEN Position               */
#define SC_CTL_AUTOCEN_Msk               (0x1ul << SC_CTL_AUTOCEN_Pos)                     /*!< SC_T::CTL: AUTOCEN Mask                   */

#define SC_CTL_CONSEL_Pos                (4)                                               /*!< SC_T::CTL: CONSEL Position                */
#define SC_CTL_CONSEL_Msk                (0x3ul << SC_CTL_CONSEL_Pos)                      /*!< SC_T::CTL: CONSEL Mask                    */

#define SC_CTL_RXTRGLV_Pos               (6)                                               /*!< SC_T::CTL: RXTRGLV Position               */
#define SC_CTL_RXTRGLV_Msk               (0x3ul << SC_CTL_RXTRGLV_Pos)                     /*!< SC_T::CTL: RXTRGLV Mask                   */

#define SC_CTL_BGT_Pos                   (8)                                               /*!< SC_T::CTL: BGT Position                   */
#define SC_CTL_BGT_Msk                   (0x1ful << SC_CTL_BGT_Pos)                        /*!< SC_T::CTL: BGT Mask                       */

#define SC_CTL_TMRSEL_Pos                (13)                                              /*!< SC_T::CTL: TMRSEL Position                */
#define SC_CTL_TMRSEL_Msk                (0x3ul << SC_CTL_TMRSEL_Pos)                      /*!< SC_T::CTL: TMRSEL Mask                    */

#define SC_CTL_NSB_Pos                   (15)                                              /*!< SC_T::CTL: NSB Position                   */
#define SC_CTL_NSB_Msk                   (0x1ul << SC_CTL_NSB_Pos)                         /*!< SC_T::CTL: NSB Mask                       */

#define SC_CTL_RXRTY_Pos                 (16)                                              /*!< SC_T::CTL: RXRTY Position                 */
#define SC_CTL_RXRTY_Msk                 (0x7ul << SC_CTL_RXRTY_Pos)                       /*!< SC_T::CTL: RXRTY Mask                     */

#define SC_CTL_RXRTYEN_Pos               (19)                                              /*!< SC_T::CTL: RXRTYEN Position               */
#define SC_CTL_RXRTYEN_Msk               (0x1ul << SC_CTL_RXRTYEN_Pos)                     /*!< SC_T::CTL: RXRTYEN Mask                   */

#define SC_CTL_TXRTY_Pos                 (20)                                              /*!< SC_T::CTL: TXRTY Position                 */
#define SC_CTL_TXRTY_Msk                 (0x7ul << SC_CTL_TXRTY_Pos)                       /*!< SC_T::CTL: TXRTY Mask                     */

#define SC_CTL_TXRTYEN_Pos               (23)                                              /*!< SC_T::CTL: TXRTYEN Position               */
#define SC_CTL_TXRTYEN_Msk               (0x1ul << SC_CTL_TXRTYEN_Pos)                     /*!< SC_T::CTL: TXRTYEN Mask                   */

#define SC_CTL_CDDBSEL_Pos               (24)                                              /*!< SC_T::CTL: CDDBSEL Position               */
#define SC_CTL_CDDBSEL_Msk               (0x3ul << SC_CTL_CDDBSEL_Pos)                     /*!< SC_T::CTL: CDDBSEL Mask                   */

#define SC_CTL_CDLV_Pos                  (26)                                              /*!< SC_T::CTL: CDLV Position                  */
#define SC_CTL_CDLV_Msk                  (0x1ul << SC_CTL_CDLV_Pos)                        /*!< SC_T::CTL: CDLV Mask                      */

#define SC_CTL_SYNC_Pos                  (30)                                              /*!< SC_T::CTL: SYNC Position                  */
#define SC_CTL_SYNC_Msk                  (0x1ul << SC_CTL_SYNC_Pos)                        /*!< SC_T::CTL: SYNC Mask                      */

#define SC_ALTCTL_TXRST_Pos              (0)                                               /*!< SC_T::ALTCTL: TXRST Position              */
#define SC_ALTCTL_TXRST_Msk              (0x1ul << SC_ALTCTL_TXRST_Pos)                    /*!< SC_T::ALTCTL: TXRST Mask                  */

#define SC_ALTCTL_RXRST_Pos              (1)                                               /*!< SC_T::ALTCTL: RXRST Position              */
#define SC_ALTCTL_RXRST_Msk              (0x1ul << SC_ALTCTL_RXRST_Pos)                    /*!< SC_T::ALTCTL: RXRST Mask                  */

#define SC_ALTCTL_DACTEN_Pos             (2)                                               /*!< SC_T::ALTCTL: DACTEN Position             */
#define SC_ALTCTL_DACTEN_Msk             (0x1ul << SC_ALTCTL_DACTEN_Pos)                   /*!< SC_T::ALTCTL: DACTEN Mask                 */

#define SC_ALTCTL_ACTEN_Pos              (3)                                               /*!< SC_T::ALTCTL: ACTEN Position              */
#define SC_ALTCTL_ACTEN_Msk              (0x1ul << SC_ALTCTL_ACTEN_Pos)                    /*!< SC_T::ALTCTL: ACTEN Mask                  */

#define SC_ALTCTL_WARSTEN_Pos            (4)                                               /*!< SC_T::ALTCTL: WARSTEN Position            */
#define SC_ALTCTL_WARSTEN_Msk            (0x1ul << SC_ALTCTL_WARSTEN_Pos)                  /*!< SC_T::ALTCTL: WARSTEN Mask                */

#define SC_ALTCTL_CNTEN0_Pos             (5)                                               /*!< SC_T::ALTCTL: CNTEN0 Position             */
#define SC_ALTCTL_CNTEN0_Msk             (0x1ul << SC_ALTCTL_CNTEN0_Pos)                   /*!< SC_T::ALTCTL: CNTEN0 Mask                 */

#define SC_ALTCTL_CNTEN1_Pos             (6)                                               /*!< SC_T::ALTCTL: CNTEN1 Position             */
#define SC_ALTCTL_CNTEN1_Msk             (0x1ul << SC_ALTCTL_CNTEN1_Pos)                   /*!< SC_T::ALTCTL: CNTEN1 Mask                 */

#define SC_ALTCTL_CNTEN2_Pos             (7)                                               /*!< SC_T::ALTCTL: CNTEN2 Position             */
#define SC_ALTCTL_CNTEN2_Msk             (0x1ul << SC_ALTCTL_CNTEN2_Pos)                   /*!< SC_T::ALTCTL: CNTEN2 Mask                 */

#define SC_ALTCTL_INITSEL_Pos            (8)                                               /*!< SC_T::ALTCTL: INITSEL Position            */
#define SC_ALTCTL_INITSEL_Msk            (0x3ul << SC_ALTCTL_INITSEL_Pos)                  /*!< SC_T::ALTCTL: INITSEL Mask                */

#define SC_ALTCTL_ADACEN_Pos             (11)                                              /*!< SC_T::ALTCTL: ADACEN Position             */
#define SC_ALTCTL_ADACEN_Msk             (0x1ul << SC_ALTCTL_ADACEN_Pos)                   /*!< SC_T::ALTCTL: ADACEN Mask                 */

#define SC_ALTCTL_RXBGTEN_Pos            (12)                                              /*!< SC_T::ALTCTL: RXBGTEN Position            */
#define SC_ALTCTL_RXBGTEN_Msk            (0x1ul << SC_ALTCTL_RXBGTEN_Pos)                  /*!< SC_T::ALTCTL: RXBGTEN Mask                */

#define SC_ALTCTL_ACTSTS0_Pos            (13)                                              /*!< SC_T::ALTCTL: ACTSTS0 Position            */
#define SC_ALTCTL_ACTSTS0_Msk            (0x1ul << SC_ALTCTL_ACTSTS0_Pos)                  /*!< SC_T::ALTCTL: ACTSTS0 Mask                */

#define SC_ALTCTL_ACTSTS1_Pos            (14)                                              /*!< SC_T::ALTCTL: ACTSTS1 Position            */
#define SC_ALTCTL_ACTSTS1_Msk            (0x1ul << SC_ALTCTL_ACTSTS1_Pos)                  /*!< SC_T::ALTCTL: ACTSTS1 Mask                */

#define SC_ALTCTL_ACTSTS2_Pos            (15)                                              /*!< SC_T::ALTCTL: ACTSTS2 Position            */
#define SC_ALTCTL_ACTSTS2_Msk            (0x1ul << SC_ALTCTL_ACTSTS2_Pos)                  /*!< SC_T::ALTCTL: ACTSTS2 Mask                */

#define SC_EGT_EGT_Pos                   (0)                                               /*!< SC_T::EGT: EGT Position                   */
#define SC_EGT_EGT_Msk                   (0xfful << SC_EGT_EGT_Pos)                        /*!< SC_T::EGT: EGT Mask                       */

#define SC_RXTOUT_RFTM_Pos               (0)                                               /*!< SC_T::RXTOUT: RFTM Position               */
#define SC_RXTOUT_RFTM_Msk               (0x1fful << SC_RXTOUT_RFTM_Pos)                   /*!< SC_T::RXTOUT: RFTM Mask                   */

#define SC_ETUCTL_ETURDIV_Pos            (0)                                               /*!< SC_T::ETUCTL: ETURDIV Position            */
#define SC_ETUCTL_ETURDIV_Msk            (0xffful << SC_ETUCTL_ETURDIV_Pos)                /*!< SC_T::ETUCTL: ETURDIV Mask                */

#define SC_ETUCTL_CMPEN_Pos              (15)                                              /*!< SC_T::ETUCTL: CMPEN Position              */
#define SC_ETUCTL_CMPEN_Msk              (0x1ul << SC_ETUCTL_CMPEN_Pos)                    /*!< SC_T::ETUCTL: CMPEN Mask                  */

#define SC_INTEN_RDAIEN_Pos              (0)                                               /*!< SC_T::INTEN: RDAIEN Position              */
#define SC_INTEN_RDAIEN_Msk              (0x1ul << SC_INTEN_RDAIEN_Pos)                    /*!< SC_T::INTEN: RDAIEN Mask                  */

#define SC_INTEN_TBEIEN_Pos              (1)                                               /*!< SC_T::INTEN: TBEIEN Position              */
#define SC_INTEN_TBEIEN_Msk              (0x1ul << SC_INTEN_TBEIEN_Pos)                    /*!< SC_T::INTEN: TBEIEN Mask                  */

#define SC_INTEN_TERRIEN_Pos             (2)                                               /*!< SC_T::INTEN: TERRIEN Position             */
#define SC_INTEN_TERRIEN_Msk             (0x1ul << SC_INTEN_TERRIEN_Pos)                   /*!< SC_T::INTEN: TERRIEN Mask                 */

#define SC_INTEN_TMR0IEN_Pos             (3)                                               /*!< SC_T::INTEN: TMR0IEN Position             */
#define SC_INTEN_TMR0IEN_Msk             (0x1ul << SC_INTEN_TMR0IEN_Pos)                   /*!< SC_T::INTEN: TMR0IEN Mask                 */

#define SC_INTEN_TMR1IEN_Pos             (4)                                               /*!< SC_T::INTEN: TMR1IEN Position             */
#define SC_INTEN_TMR1IEN_Msk             (0x1ul << SC_INTEN_TMR1IEN_Pos)                   /*!< SC_T::INTEN: TMR1IEN Mask                 */

#define SC_INTEN_TMR2IEN_Pos             (5)                                               /*!< SC_T::INTEN: TMR2IEN Position             */
#define SC_INTEN_TMR2IEN_Msk             (0x1ul << SC_INTEN_TMR2IEN_Pos)                   /*!< SC_T::INTEN: TMR2IEN Mask                 */

#define SC_INTEN_BGTIEN_Pos              (6)                                               /*!< SC_T::INTEN: BGTIEN Position              */
#define SC_INTEN_BGTIEN_Msk              (0x1ul << SC_INTEN_BGTIEN_Pos)                    /*!< SC_T::INTEN: BGTIEN Mask                  */

#define SC_INTEN_CDIEN_Pos               (7)                                               /*!< SC_T::INTEN: CDIEN Position               */
#define SC_INTEN_CDIEN_Msk               (0x1ul << SC_INTEN_CDIEN_Pos)                     /*!< SC_T::INTEN: CDIEN Mask                   */

#define SC_INTEN_INITIEN_Pos             (8)                                               /*!< SC_T::INTEN: INITIEN Position             */
#define SC_INTEN_INITIEN_Msk             (0x1ul << SC_INTEN_INITIEN_Pos)                   /*!< SC_T::INTEN: INITIEN Mask                 */

#define SC_INTEN_RXTOIF_Pos              (9)                                               /*!< SC_T::INTEN: RXTOIF Position              */
#define SC_INTEN_RXTOIF_Msk              (0x1ul << SC_INTEN_RXTOIF_Pos)                    /*!< SC_T::INTEN: RXTOIF Mask                  */

#define SC_INTEN_ACERRIEN_Pos            (10)                                              /*!< SC_T::INTEN: ACERRIEN Position            */
#define SC_INTEN_ACERRIEN_Msk            (0x1ul << SC_INTEN_ACERRIEN_Pos)                  /*!< SC_T::INTEN: ACERRIEN Mask                */

#define SC_INTSTS_RDAIF_Pos              (0)                                               /*!< SC_T::INTSTS: RDAIF Position              */
#define SC_INTSTS_RDAIF_Msk              (0x1ul << SC_INTSTS_RDAIF_Pos)                    /*!< SC_T::INTSTS: RDAIF Mask                  */

#define SC_INTSTS_TBEIF_Pos              (1)                                               /*!< SC_T::INTSTS: TBEIF Position              */
#define SC_INTSTS_TBEIF_Msk              (0x1ul << SC_INTSTS_TBEIF_Pos)                    /*!< SC_T::INTSTS: TBEIF Mask                  */

#define SC_INTSTS_TERRIF_Pos             (2)                                               /*!< SC_T::INTSTS: TERRIF Position             */
#define SC_INTSTS_TERRIF_Msk             (0x1ul << SC_INTSTS_TERRIF_Pos)                   /*!< SC_T::INTSTS: TERRIF Mask                 */

#define SC_INTSTS_TMR0IF_Pos             (3)                                               /*!< SC_T::INTSTS: TMR0IF Position             */
#define SC_INTSTS_TMR0IF_Msk             (0x1ul << SC_INTSTS_TMR0IF_Pos)                   /*!< SC_T::INTSTS: TMR0IF Mask                 */

#define SC_INTSTS_TMR1IF_Pos             (4)                                               /*!< SC_T::INTSTS: TMR1IF Position             */
#define SC_INTSTS_TMR1IF_Msk             (0x1ul << SC_INTSTS_TMR1IF_Pos)                   /*!< SC_T::INTSTS: TMR1IF Mask                 */

#define SC_INTSTS_TMR2IF_Pos             (5)                                               /*!< SC_T::INTSTS: TMR2IF Position             */
#define SC_INTSTS_TMR2IF_Msk             (0x1ul << SC_INTSTS_TMR2IF_Pos)                   /*!< SC_T::INTSTS: TMR2IF Mask                 */

#define SC_INTSTS_BGTIF_Pos              (6)                                               /*!< SC_T::INTSTS: BGTIF Position              */
#define SC_INTSTS_BGTIF_Msk              (0x1ul << SC_INTSTS_BGTIF_Pos)                    /*!< SC_T::INTSTS: BGTIF Mask                  */

#define SC_INTSTS_CDIF_Pos               (7)                                               /*!< SC_T::INTSTS: CDIF Position               */
#define SC_INTSTS_CDIF_Msk               (0x1ul << SC_INTSTS_CDIF_Pos)                     /*!< SC_T::INTSTS: CDIF Mask                   */

#define SC_INTSTS_INITIF_Pos             (8)                                               /*!< SC_T::INTSTS: INITIF Position             */
#define SC_INTSTS_INITIF_Msk             (0x1ul << SC_INTSTS_INITIF_Pos)                   /*!< SC_T::INTSTS: INITIF Mask                 */

#define SC_INTSTS_RBTOIF_Pos             (9)                                               /*!< SC_T::INTSTS: RBTOIF Position             */
#define SC_INTSTS_RBTOIF_Msk             (0x1ul << SC_INTSTS_RBTOIF_Pos)                   /*!< SC_T::INTSTS: RBTOIF Mask                 */

#define SC_INTSTS_ACERRIF_Pos            (10)                                              /*!< SC_T::INTSTS: ACERRIF Position            */
#define SC_INTSTS_ACERRIF_Msk            (0x1ul << SC_INTSTS_ACERRIF_Pos)                  /*!< SC_T::INTSTS: ACERRIF Mask                */

#define SC_STATUS_RXOV_Pos               (0)                                               /*!< SC_T::STATUS: RXOV Position               */
#define SC_STATUS_RXOV_Msk               (0x1ul << SC_STATUS_RXOV_Pos)                     /*!< SC_T::STATUS: RXOV Mask                   */

#define SC_STATUS_RXEMPTY_Pos            (1)                                               /*!< SC_T::STATUS: RXEMPTY Position            */
#define SC_STATUS_RXEMPTY_Msk            (0x1ul << SC_STATUS_RXEMPTY_Pos)                  /*!< SC_T::STATUS: RXEMPTY Mask                */

#define SC_STATUS_RXFULL_Pos             (2)                                               /*!< SC_T::STATUS: RXFULL  Position            */
#define SC_STATUS_RXFULL_Msk             (0x1ul << SC_STATUS_RXFULL_Pos)                   /*!< SC_T::STATUS: RXFULL  Mask                */

#define SC_STATUS_PEF_Pos                (4)                                               /*!< SC_T::STATUS: PEF Position                */
#define SC_STATUS_PEF_Msk                (0x1ul << SC_STATUS_PEF_Pos)                      /*!< SC_T::STATUS: PEF Mask                    */

#define SC_STATUS_FEF_Pos                (5)                                               /*!< SC_T::STATUS: FEF Position                */
#define SC_STATUS_FEF_Msk                (0x1ul << SC_STATUS_FEF_Pos)                      /*!< SC_T::STATUS: FEF Mask                    */

#define SC_STATUS_BEF_Pos                (6)                                               /*!< SC_T::STATUS: BEF Position                */
#define SC_STATUS_BEF_Msk                (0x1ul << SC_STATUS_BEF_Pos)                      /*!< SC_T::STATUS: BEF Mask                    */

#define SC_STATUS_TXOV_Pos               (8)                                               /*!< SC_T::STATUS: TXOV Position               */
#define SC_STATUS_TXOV_Msk               (0x1ul << SC_STATUS_TXOV_Pos)                     /*!< SC_T::STATUS: TXOV Mask                   */

#define SC_STATUS_TXEMPTY_Pos            (9)                                               /*!< SC_T::STATUS: TXEMPTY Position            */
#define SC_STATUS_TXEMPTY_Msk            (0x1ul << SC_STATUS_TXEMPTY_Pos)                  /*!< SC_T::STATUS: TXEMPTY Mask                */

#define SC_STATUS_TXFULL_Pos             (10)                                              /*!< SC_T::STATUS: TXFULL Position             */
#define SC_STATUS_TXFULL_Msk             (0x1ul << SC_STATUS_TXFULL_Pos)                   /*!< SC_T::STATUS: TXFULL Mask                 */

#define SC_STATUS_CREMOVE_Pos            (11)                                              /*!< SC_T::STATUS: CREMOVE Position            */
#define SC_STATUS_CREMOVE_Msk            (0x1ul << SC_STATUS_CREMOVE_Pos)                  /*!< SC_T::STATUS: CREMOVE Mask                */

#define SC_STATUS_CINSERT_Pos            (12)                                              /*!< SC_T::STATUS: CINSERT Position            */
#define SC_STATUS_CINSERT_Msk            (0x1ul << SC_STATUS_CINSERT_Pos)                  /*!< SC_T::STATUS: CINSERT Mask                */

#define SC_STATUS_CDPINSTS_Pos           (13)                                              /*!< SC_T::STATUS: CDPINSTS Position           */
#define SC_STATUS_CDPINSTS_Msk           (0x1ul << SC_STATUS_CDPINSTS_Pos)                 /*!< SC_T::STATUS: CDPINSTS Mask               */

#define SC_STATUS_RXPOINT_Pos            (16)                                              /*!< SC_T::STATUS: RXPOINT Position            */
#define SC_STATUS_RXPOINT_Msk            (0x3ul << SC_STATUS_RXPOINT_Pos)                  /*!< SC_T::STATUS: RXPOINT Mask                */

#define SC_STATUS_RXRERR_Pos             (21)                                              /*!< SC_T::STATUS: RXRERR Position             */
#define SC_STATUS_RXRERR_Msk             (0x1ul << SC_STATUS_RXRERR_Pos)                   /*!< SC_T::STATUS: RXRERR Mask                 */

#define SC_STATUS_RXOVERR_Pos            (22)                                              /*!< SC_T::STATUS: RXOVERR Position            */
#define SC_STATUS_RXOVERR_Msk            (0x1ul << SC_STATUS_RXOVERR_Pos)                  /*!< SC_T::STATUS: RXOVERR Mask                */

#define SC_STATUS_RXACT_Pos              (23)                                              /*!< SC_T::STATUS: RXACT Position              */
#define SC_STATUS_RXACT_Msk              (0x1ul << SC_STATUS_RXACT_Pos)                    /*!< SC_T::STATUS: RXACT Mask                  */

#define SC_STATUS_TXPOINT_Pos            (24)                                              /*!< SC_T::STATUS: TXPOINT Position            */
#define SC_STATUS_TXPOINT_Msk            (0x3ul << SC_STATUS_TXPOINT_Pos)                  /*!< SC_T::STATUS: TXPOINT Mask                */

#define SC_STATUS_TXRERR_Pos             (29)                                              /*!< SC_T::STATUS: TXRERR Position             */
#define SC_STATUS_TXRERR_Msk             (0x1ul << SC_STATUS_TXRERR_Pos)                   /*!< SC_T::STATUS: TXRERR Mask                 */

#define SC_STATUS_TXOVERR_Pos            (30)                                              /*!< SC_T::STATUS: TXOVERR Position            */
#define SC_STATUS_TXOVERR_Msk            (0x1ul << SC_STATUS_TXOVERR_Pos)                  /*!< SC_T::STATUS: TXOVERR Mask                */

#define SC_STATUS_TXACT_Pos              (31)                                              /*!< SC_T::STATUS: TXACT Position              */
#define SC_STATUS_TXACT_Msk              (0x1ul << SC_STATUS_TXACT_Pos)                    /*!< SC_T::STATUS: TXACT Mask                  */

#define SC_PINCTL_PWREN_Pos              (0)                                               /*!< SC_T::PINCTL: PWREN Position              */
#define SC_PINCTL_PWREN_Msk              (0x1ul << SC_PINCTL_PWREN_Pos)                    /*!< SC_T::PINCTL: PWREN Mask                  */

#define SC_PINCTL_SCRST_Pos              (1)                                               /*!< SC_T::PINCTL: SCRST Position              */
#define SC_PINCTL_SCRST_Msk              (0x1ul << SC_PINCTL_SCRST_Pos)                    /*!< SC_T::PINCTL: SCRST Mask                  */

#define SC_PINCTL_CLKKEEP_Pos            (6)                                               /*!< SC_T::PINCTL: CLKKEEP Position            */
#define SC_PINCTL_CLKKEEP_Msk            (0x1ul << SC_PINCTL_CLKKEEP_Pos)                  /*!< SC_T::PINCTL: CLKKEEP Mask                */

#define SC_PINCTL_SCDOUT_Pos             (9)                                               /*!< SC_T::PINCTL: SCDOUT Position             */
#define SC_PINCTL_SCDOUT_Msk             (0x1ul << SC_PINCTL_SCDOUT_Pos)                   /*!< SC_T::PINCTL: SCDOUT Mask                 */

#define SC_PINCTL_PWRINV_Pos             (11)                                              /*!< SC_T::PINCTL: PWRINV Position             */
#define SC_PINCTL_PWRINV_Msk             (0x1ul << SC_PINCTL_PWRINV_Pos)                   /*!< SC_T::PINCTL: PWRINV Mask                 */

#define SC_PINCTL_DATSTS_Pos             (16)                                              /*!< SC_T::PINCTL: DATSTS Position             */
#define SC_PINCTL_DATSTS_Msk             (0x1ul << SC_PINCTL_DATSTS_Pos)                   /*!< SC_T::PINCTL: DATSTS Mask                 */

#define SC_PINCTL_PWRSTS_Pos             (17)                                              /*!< SC_T::PINCTL: PWRSTS Position             */
#define SC_PINCTL_PWRSTS_Msk             (0x1ul << SC_PINCTL_PWRSTS_Pos)                   /*!< SC_T::PINCTL: PWRSTS Mask                 */

#define SC_PINCTL_RSTSTS_Pos             (18)                                              /*!< SC_T::PINCTL: RSTSTS Position             */
#define SC_PINCTL_RSTSTS_Msk             (0x1ul << SC_PINCTL_RSTSTS_Pos)                   /*!< SC_T::PINCTL: RSTSTS Mask                 */

#define SC_PINCTL_SYNC_Pos               (30)                                              /*!< SC_T::PINCTL: SYNC Position               */
#define SC_PINCTL_SYNC_Msk               (0x1ul << SC_PINCTL_SYNC_Pos)                     /*!< SC_T::PINCTL: SYNC Mask                   */

#define SC_TMRCTL0_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL0: CNT Position               */
#define SC_TMRCTL0_CNT_Msk               (0xfffffful << SC_TMRCTL0_CNT_Pos)                /*!< SC_T::TMRCTL0: CNT Mask                   */

#define SC_TMRCTL0_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL0: OPMODE Position            */
#define SC_TMRCTL0_OPMODE_Msk            (0xful << SC_TMRCTL0_OPMODE_Pos)                  /*!< SC_T::TMRCTL0: OPMODE Mask                */

#define SC_TMRCTL1_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL1: CNT Position               */
#define SC_TMRCTL1_CNT_Msk               (0xfful << SC_TMRCTL1_CNT_Pos)                    /*!< SC_T::TMRCTL1: CNT Mask                   */

#define SC_TMRCTL1_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL1: OPMODE Position            */
#define SC_TMRCTL1_OPMODE_Msk            (0xful << SC_TMRCTL1_OPMODE_Pos)                  /*!< SC_T::TMRCTL1: OPMODE Mask                */

#define SC_TMRCTL2_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL2: CNT Position               */
#define SC_TMRCTL2_CNT_Msk               (0xfful << SC_TMRCTL2_CNT_Pos)                    /*!< SC_T::TMRCTL2: CNT Mask                   */

#define SC_TMRCTL2_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL2: OPMODE Position            */
#define SC_TMRCTL2_OPMODE_Msk            (0xful << SC_TMRCTL2_OPMODE_Pos)                  /*!< SC_T::TMRCTL2: OPMODE Mask                */

#define SC_UARTCTL_UARTEN_Pos            (0)                                               /*!< SC_T::UARTCTL: UARTEN Position            */
#define SC_UARTCTL_UARTEN_Msk            (0x1ul << SC_UARTCTL_UARTEN_Pos)                  /*!< SC_T::UARTCTL: UARTEN Mask                */

#define SC_UARTCTL_WLS_Pos               (4)                                               /*!< SC_T::UARTCTL: WLS Position               */
#define SC_UARTCTL_WLS_Msk               (0x3ul << SC_UARTCTL_WLS_Pos)                     /*!< SC_T::UARTCTL: WLS Mask                   */

#define SC_UARTCTL_PBOFF_Pos             (6)                                               /*!< SC_T::UARTCTL: PBOFF Position             */
#define SC_UARTCTL_PBOFF_Msk             (0x1ul << SC_UARTCTL_PBOFF_Pos)                   /*!< SC_T::UARTCTL: PBOFF Mask                 */

#define SC_UARTCTL_OPE_Pos               (7)                                               /*!< SC_T::UARTCTL: OPE Position               */
#define SC_UARTCTL_OPE_Msk               (0x1ul << SC_UARTCTL_OPE_Pos)                     /*!< SC_T::UARTCTL: OPE Mask                   */

#define SC_TMRDAT0_TDR0_Pos              (0)                                               /*!< SC_T::TMRDAT0: TDR0 Position              */
#define SC_TMRDAT0_TDR0_Msk              (0xfffffful << SC_TMRDAT0_TDR0_Pos)               /*!< SC_T::TMRDAT0: TDR0 Mask                  */

#define SC_TMRDAT1_2_TDR1_Pos            (0)                                               /*!< SC_T::TMRDAT1_2: TDR1 Position            */
#define SC_TMRDAT1_2_TDR1_Msk            (0xfful << SC_TMRDAT1_2_TDR1_Pos)                 /*!< SC_T::TMRDAT1_2: TDR1 Mask                */

#define SC_TMRDAT1_2_TDR2_Pos            (8)                                               /*!< SC_T::TMRDAT1_2: TDR2 Position            */
#define SC_TMRDAT1_2_TDR2_Msk            (0xfful << SC_TMRDAT1_2_TDR2_Pos)                 /*!< SC_T::TMRDAT1_2: TDR2 Mask                */

/**@}*/ /* SC_CONST */
/**@}*/ /* end of SC register group */


/*---------------------- SD Card Host Interface -------------------------*/
/**
    @addtogroup SDH SD Card Host Interface(SDH)
    Memory Mapped Structure for SDH Controller
@{ */

typedef struct {

    /**
     * FBx
     * ===================================================================================================
     * Offset: 0x00 ~ 0x7C Shared Buffer (FIFO) 0 ~ 31
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |BUF       |Shared Buffer

    */
    uint32_t FB[32];
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[224];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * DMACTL
     * ===================================================================================================
     * Offset: 0x400  DMA Control and Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DMAEN     |DMA Engine Enable Control
     * |        |          |0 = DMA Disabled.
     * |        |          |1 = DMA Enabled.
     * |        |          |If this bit is cleared, DMA will ignore all requests from SD host and force bus master into IDLE state.
     * |        |          |Note: If target abort is occurred, DMAEN will be cleared.
     * |[1]     |DMARST    |Software Engine Reset
     * |        |          |0 = No effect.
     * |        |          |1 = Reset internal state machine and pointers.
     * |        |          |The contents of control register will not be cleared.
     * |        |          |This bit will auto be cleared after few clock cycles.
     * |        |          |Note: The software reset DMA related registers.
     * |[3]     |SGEN      |Scatter-Gather Function Enable Control
     * |        |          |0 = Scatter-gather function Disabled (DMA will treat the starting address in DMASAR as starting pointer of a single block memory).
     * |        |          |1 = Scatter-gather function Enabled (DMA will treat the starting address in DMASAR as a starting address of Physical Address Descriptor (PAD) table.
     * |        |          |The format of these Pads' will be described later).
     * |[9]     |DMABUSY   |DMA Transfer Is In Progress
     * |        |          |This bit indicates if SD Host is granted and doing DMA transfer or not.
     * |        |          |0 = DMA transfer is not in progress.
     * |        |          |1 = DMA transfer is in progress.
    */
    __IO uint32_t DMACTL;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * DMASA
     * ===================================================================================================
     * Offset: 0x408  DMA Transfer Starting Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ORDER     |Determined To The PAD Table Fetching Is In Order Or Out Of Order
     * |        |          |0 = PAD table is fetched in order.
     * |        |          |1 = PAD table is fetched out of order.
     * |        |          |Note: the bit0 is valid in scatter-gather mode when SGEN = 1.
     * |[1:31]  |DMASA     |DMA Transfer Starting Address
     * |        |          |This field pads 0 as least significant bit indicates a 32-bit starting address of system memory (SRAM) for DMA to retrieve or fill in data.
     * |        |          |If DMA is not in normal mode, this field will be interpreted as a starting address of Physical Address Descriptor (PAD) table.
    */
    __IO uint32_t DMASA;

    /**
     * DMABCNT
     * ===================================================================================================
     * Offset: 0x40C  DMA Transfer Byte Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:25]  |BCNT      |DMA Transfer Byte Count (Read Only)
     * |        |          |This field indicates the remained byte count of DMA transfer.
     * |        |          |The value of this field is valid only when DMA is busy; otherwise, it is 0.
    */
    __I  uint32_t DMABCNT;

    /**
     * DMAINTEN
     * ===================================================================================================
     * Offset: 0x410  DMA Interrupt Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ABORTIEN  |DMA Read/Write Target Abort Interrupt Enable Control
     * |        |          |0 = Target abort interrupt generation Disabled during DMA transfer.
     * |        |          |1 = Target abort interrupt generation Enabled during DMA transfer.
     * |[1]     |WEOTIEN   |Wrong EOT Encountered Interrupt Enable Control
     * |        |          |0 = Interrupt generation Disabled when wrong EOT is encountered.
     * |        |          |1 = Interrupt generation Enabled when wrong EOT is encountered.
    */
    __IO uint32_t DMAINTEN;

    /**
     * DMAINTSTS
     * ===================================================================================================
     * Offset: 0x414  DMA Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |ABORTIF   |DMA Read/Write Target Abort Interrupt Flag
     * |        |          |0 = No bus ERROR response received.
     * |        |          |1 = Bus ERROR response received.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
     * |[1]     |WEOTIF    |Wrong EOT Encountered Interrupt Flag
     * |        |          |When DMA Scatter-Gather function is enabled, and EOT of the descriptor is encountered before DMA transfer finished (that means the total sector count of all PAD is less than the sector count of SD host), this bit will be set.
     * |        |          |0 = No EOT encountered before DMA transfer finished.
     * |        |          |1 = EOT encountered before DMA transfer finished.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
    */
    __IO uint32_t DMAINTSTS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[250];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * GCTL
     * ===================================================================================================
     * Offset: 0x800  Global Control and Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |GCTLRST   |Software Engine Reset
     * |        |          |0 = No effect.
     * |        |          |1 = Reset SD host.
     * |        |          |The contents of control register will not be cleared.
     * |        |          |This bit will auto cleared after reset complete.
     * |[1]     |SDEN      |Secure Digital Functionality Enable Control
     * |        |          |0 = SD functionality disabled.
     * |        |          |1 = SD functionality enabled.
    */
    __IO uint32_t GCTL;

    /**
     * GINTEN
     * ===================================================================================================
     * Offset: 0x804  Global Interrupt Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DTAIEN    |DMA READ/WRITE Target Abort Interrupt Enable Control
     * |        |          |0 = DMA READ/WRITE target abort interrupt generation disabled.
     * |        |          |1 = DMA READ/WRITE target abort interrupt generation enabled.
    */
    __IO uint32_t GINTEN;

    /**
     * GINTSTS
     * ===================================================================================================
     * Offset: 0x808  Global Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DTAIF     |DMA READ/WRITE Target Abort Interrupt Flag (Read Only)
     * |        |          |This bit indicates DMA received an ERROR response from internal AHB bus during DMA read/write operation.
     * |        |          |When Target Abort is occurred, please reset all engine.
     * |        |          |0 = No bus ERROR response received.
     * |        |          |1 = Bus ERROR response received.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
    */
    __I  uint32_t GINTSTS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE3[5];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x820  SD Control and Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |COEN      |Command Output Enable Control
     * |        |          |0 = No effect. (Please use DMARST (SDH_CTL [0]) to clear this bit.)
     * |        |          |1 = Enabled, SD host will output a command to SD card.
     * |        |          |Note: When operation is finished, this bit will be cleared automatically, so don't write 0 to this bit (the controller will be abnormal).
     * |[1]     |RIEN      |Response Input Enable Control
     * |        |          |0 = No effect. (Please use DMARST (SDH_CTL [0]) to clear this bit.)
     * |        |          |1 = Enabled, SD host will wait to receive a response from SD card.
     * |        |          |Note: When operation is finished, this bit will be cleared automatically, so don't write 0 to this bit (the controller will be abnormal).
     * |[2]     |DIEN      |Data Input Enable Control
     * |        |          |0 = No effect. (Please use DMARST (SDH_CTL [0]) to clear this bit.)
     * |        |          |1 = Enabled, SD host will wait to receive block data and the CRC16 value from SD card.
     * |        |          |Note: When operation is finished, this bit will be cleared automatically, so don't write 0 to this bit (the controller will be abnormal).
     * |[3]     |DOEN      |Data Output Enable Control
     * |        |          |0 = No effect. (Please use DMARST (SDH_CTL [0]) to clear this bit.)
     * |        |          |1 = Enabled, SD host will transfer block data and the CRC16 value to SD card.
     * |        |          |Note: When operation is finished, this bit will be cleared automatically, so don't write 0 to this bit (the controller will be abnormal).
     * |[4]     |R2EN      |Response R2 Input Enable Control
     * |        |          |0 = No effect. (Please use DMARST (SDH_CTL [0]) to clear this bit.)
     * |        |          |1 = Enabled, SD host will wait to receive a response R2 from SD card and store the response data into DMC's flash buffer (exclude CRC7).
     * |        |          |Note: When operation is finished, this bit will be cleared automatically, so don't write 0 to this bit (the controller will be abnormal).
     * |[5]     |CLK74OEN  |Initial 74 Clock Cycles Output Enable Control
     * |        |          |0 = No effect. (Please use DMARST (SDH_CTL [0]) to clear this bit.)
     * |        |          |1 = Enabled, SD host will output 74 clock cycles to SD card.
     * |        |          |Note: When operation is finished, this bit will be cleared automatically, so don't write 0 to this bit (the controller will be abnormal).
     * |[6]     |CLK8OEN   |Generating 8 Clock Cycles Output Enable Control
     * |        |          |0 = No effect. (Please use DMARST (SDH_CTL [0]) to clear this bit.)
     * |        |          |1 = Enabled, SD host will output 8 clock cycles.
     * |        |          |Note: When operation is finished, this bit will be cleared automatically, so don't write 0 to this bit (the controller will be abnormal).
     * |[7]     |CLKKEEP0  |SD Clock Enable Control For Port 0
     * |        |          |0 = SD host decided when to output clock and when to disable clock output automatically.
     * |        |          |1 = SD clock always keeps free running.
     * |[8:13]  |CMDCODE   |SD Command Code
     * |        |          |This register contains the SD command code (0x00 - 0x3F).
     * |[14]    |CTLRST    |Software Engine Reset
     * |        |          |0 = No effect.
     * |        |          |1 = Reset the internal state machine and counters.
     * |        |          |The contents of control register will not be cleared (but RIEN, DIEN, DOEN and R2_EN will be cleared).
     * |        |          |This bit will be auto cleared after few clock cycles.
     * |[15]    |DBW       |SD Data Bus Width (For 1-Bit / 4-Bit Selection)
     * |        |          |0 = Data bus width is 1-bit.
     * |        |          |1 = Data bus width is 4-bit.
     * |[16:23] |BLKCNT    |Block Counts To Be Transferred Or Received
     * |        |          |This field contains the block counts for data-in and data-out transfer.
     * |        |          |For READ_MULTIPLE_BLOCK and WRITE_MULTIPLE_BLOCK command, software can use this function to accelerate data transfer and improve performance.
     * |        |          |Don't fill 0x0 to this field.
     * |        |          |Note: For READ_MULTIPLE_BLOCK and WRITE_MULTIPLE_BLOCK command, the actual total length is BLKCNT * (BLKLEN +1).
     * |[24:27] |SDNWR     |NWR Parameter For Block Write Operation
     * |        |          |This value indicates the NWR parameter for data block write operation in SD clock counts.
     * |        |          |The actual clock cycle will be SDNWR+1.
     * |[29:30] |SDPORT    |SD Port Selection
     * |        |          |00 = Port 0 selected.
     * |        |          |01 = Port 1 selected.
     * |        |          |Other = Reserved.
     * |[31]    |CLKKEEP1  |SD Clock Enable Control For Port 1
     * |        |          |0 = SD host decided when to output clock and when to disable clock output automatically.
     * |        |          |1 = SD clock always keeps free running.
    */
    __IO uint32_t CTL;

    /**
     * CMDARG
     * ===================================================================================================
     * Offset: 0x824  SD Command Argument Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |ARGUMENT  |SD Command Argument
     * |        |          |This register contains a 32-bit value specifies the argument of SD command from host controller to SD card.
     * |        |          |Before trigger COEN (SDH_CTL [0]), software should fill argument in this field.
    */
    __IO uint32_t CMDARG;

    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0x828  SD Interrupt Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BLKDIEN   |Block Transfer Done Interrupt Enable Control
     * |        |          |0 = SD host will not generate interrupt when data-in (out) transfer done.
     * |        |          |1 = SD host will generate interrupt when data-in (out) transfer done.
     * |[1]     |CRCIEN    |CRC7, CRC16 And CRC Status Error Interrupt Enable Control
     * |        |          |0 = SD host will not generate interrupt when CRC7, CRC16 and CRC status is error.
     * |        |          |1 = SD host will generate interrupt when CRC7, CRC16 and CRC status is error.
     * |[8]     |CDIEN0    |SD0 Card Detection Interrupt Enable Control
     * |        |          |Enable/Disable interrupts generation of SD controller when card 0 is inserted or removed.
     * |        |          |0 = Disable.
     * |        |          |1 = Enabled.
     * |[9]     |CDIEN1    |SD1 Card Detection Interrupt Enable Control
     * |        |          |Enable/Disable interrupts generation of SD controller when card 1 is inserted or removed.
     * |        |          |0 = Disable.
     * |        |          |1 = Enabled.
     * |[12]    |RTOIEN    |Response Time-Out Interrupt Enable Control
     * |        |          |Enable/Disable interrupts generation of SD controller when receiving response or R2 time-out.
     * |        |          |Time-out value is specified at TOUT register.
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[13]    |DITOIEN   |Data Input Time-Out Interrupt Enable Control
     * |        |          |Enable/Disable interrupts generation of SD controller when data input time-out.
     * |        |          |Time-out value is specified at TOUT register.
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[14]    |WKIEN     |Wake-Up Signal Generating Enable Control
     * |        |          |Enable/Disable wake-up signal generating of SD host when current using SD card issues an interrupt (wake-up) via DAT [1] to host.
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |[30]    |CDSRC0    |SD0 Card Detect Source Selection
     * |        |          |0 = From SD0 card's DAT3 pin.
     * |        |          |Host need clock to got data on pin DAT3.
     * |        |          |Please make sure CLKKEEP0 (SDH_CTL[7]) is 1 in order to generate free running clock for DAT3 pin.
     * |        |          |1 = From GPIO pin.
     * |[31]    |CDSRC1    |SD1 Card Detect Source Selection
     * |        |          |0 = From SD1 card's DAT3 pin.
     * |        |          |Host need clock to got data on pin DAT3.
     * |        |          |Please make sure CLKKEEP1 (SDH_CTL[31]) is 1 in order to generate free running clock for DAT3 pin.
     * |        |          |1 = From GPIO pin.
    */
    __IO uint32_t INTEN;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x82C  SD Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BLKDIF    |Block Transfer Done Interrupt Flag (Read Only)
     * |        |          |This bit indicates that SD host has finished all data-in or data-out block transfer.
     * |        |          |If there is a CRC16 error or incorrect CRC status during multiple block data transfer, the transfer will be broken and this bit will also be set.
     * |        |          |0 = Not finished yet.
     * |        |          |1 = Done.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
     * |[1]     |CRCIF     |CRC7, CRC16 And CRC Status Error Interrupt Flag (Read Only)
     * |        |          |This bit indicates that SD host has occurred CRC error during response in, data-in or data-out (CRC status error) transfer.
     * |        |          |When CRC error is occurred, software should reset SD engine.
     * |        |          |Some response (ex.
     * |        |          |R3) doesn't have CRC7 information with it; SD host will still calculate CRC7, get CRC error and set this flag.
     * |        |          |In this condition, software should ignore CRC error and clears this bit manually.
     * |        |          |0 = No CRC error is occurred.
     * |        |          |1 = CRC error is occurred.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
     * |[2]     |CRC7      |CRC7 Check Status (Read Only)
     * |        |          |SD host will check CRC7 correctness during each response in.
     * |        |          |If that response does not contain CRC7 information (ex.
     * |        |          |R3), then software should turn off CRCIEN (SDH_INTEN[1]) and ignore this bit.
     * |        |          |0 = Fault.
     * |        |          |1 = OK.
     * |[3]     |CRC16     |CRC16 Check Status Of Data-In Transfer (Read Only)
     * |        |          |SD host will check CRC16 correctness after data-in transfer.
     * |        |          |0 = Fault.
     * |        |          |1 = OK.
     * |[4:6]   |CRCSTS    |CRC Status Value Of Data-Out Transfer (Read Only)
     * |        |          |SD host will record CRC status of data-out transfer.
     * |        |          |Software could use this value to identify what type of error is during data-out transfer.
     * |        |          |010 = Positive CRC status.
     * |        |          |101 = Negative CRC status.
     * |        |          |111 = SD card programming error occurs.
     * |[7]     |DAT0STS   |DAT0 Pin Status Of Current Selected SD Port (Read Only)
     * |        |          |This bit is the DAT0 pin status of current selected SD port.
     * |[8]     |CDIF0     |SD0 Card Detection Interrupt Flag (Read Only)
     * |        |          |This bit indicates that SD card 0 is inserted or removed.
     * |        |          |Only when CDIEN0 (SDH_INTEN[8]) is set to 1, this bit is active.
     * |        |          |0 = No card is inserted or removed.
     * |        |          |1 = There is a card inserted in or removed from SD0.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
     * |[9]     |CDIF1     |SD1 Card Detection Interrupt Flag (Read Only)
     * |        |          |This bit indicates that SD card 1 is inserted or removed.
     * |        |          |Only when CDIEN1 (SDH_INTEN[9]) is set to 1, this bit is active.
     * |        |          |0 = No card is inserted or removed.
     * |        |          |1 = There is a card inserted in or removed from SD1.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
     * |[12]    |RTOIF     |Response Time-Out Interrupt Flag (Read Only)
     * |        |          |This bit indicates that SD host counts to time-out value when receiving response or R2 (waiting start bit).
     * |        |          |0 = Not time-out.
     * |        |          |1 = Response time-out.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
     * |[13]    |DITOIF    |Data Input Time-Out Interrupt Flag (Read Only)
     * |        |          |This bit indicates that SD host counts to time-out value when receiving data (waiting start bit).
     * |        |          |0 = Not time-out.
     * |        |          |1 = Data input time-out.
     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
     * |[16]    |CDSTS0    |Card Detect Status Of SD0 (Read Only)
     * |        |          |This bit indicates the card detect pin status of SD0, and is used for card detection.
     * |        |          |When there is a card inserted in or removed from SD0, software should check this bit to confirm if there is really a card insertion or removal.
     * |        |          |If CDSRC0 (SDH_INTEN[30]) = 0, to select DAT3 for card detection:.
     * |        |          |0 = Card removed.
     * |        |          |1 = Card inserted.
     * |        |          |If CDSRC0 (SDH_INTEN[30]) = 1, to select GPIO for card detection:.
     * |        |          |0 = Card inserted.
     * |        |          |1 = Card removed.
     * |[17]    |CDSTS1    |Card Detect Status Of SD1 (Read Only)
     * |        |          |This bit indicates the card detect pin status of SD1, and is used for card detection.
     * |        |          |When there is a card inserted in or removed from SD1, software should check this bit to confirm if there is really a card insertion or removal.
     * |        |          |If CDSRC1 (SDH_INTEN[31]) = 0, to select DAT3 for card detection:.
     * |        |          |0 = Card removed.
     * |        |          |1 = Card inserted.
     * |        |          |If CDSRC1 (SDH_INTEN[31]) = 1, to select GPIO for card detection:.
     * |        |          |0 = Card inserted.
     * |        |          |1 = Card removed.
     * |[18]    |DAT1STS   |DAT1 Pin Status Of SD Port (Read Only)
     * |        |          |This bit indicates the DAT1 pin status of SD port.
    */
    __IO  uint32_t INTSTS;

    /**
     * RESP0
     * ===================================================================================================
     * Offset: 0x830  SD Receiving Response Token Register 0
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |RESPTK0   |SD Receiving Response Token 0
     * |        |          |SD host controller will receive a response token for getting a reply from SD card when RIEN (SDH_CTL[1]) is set.
     * |        |          |This field contains response bit 47-16 of the response token.
    */
    __I  uint32_t RESP0;

    /**
     * RESP1
     * ===================================================================================================
     * Offset: 0x834  SD Receiving Response Token Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |RESPTK1   |SD Receiving Response Token 1
     * |        |          |SD host controller will receive a response token for getting a reply from SD card when RIEN (SDH_CTL[1]) is set.
     * |        |          |This register contains the bit 15-8 of the response token.
    */
    __I  uint32_t RESP1;

    /**
     * BLEN
     * ===================================================================================================
     * Offset: 0x838  SD Block Length Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:10]  |BLKLEN    |SD BLOCK LENGTH In Byte Unit
     * |        |          |An 11-bit value specifies the SD transfer byte count of a block.
     * |        |          |The actual byte count is equal to BLKLEN+1.
     * |        |          |Note: The default SD block length is 512 bytes
    */
    __IO uint32_t BLEN;

    /**
     * TOUT
     * ===================================================================================================
     * Offset: 0x83C  SD Response/Data-in Time-out Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |TOUT      |SD Response/Data-In Time-Out Value
     * |        |          |A 24-bit value specifies the time-out counts of response and data input.
     * |        |          |SD host controller will wait start bit of response or data-in until this value reached.
     * |        |          |The time period depends on SD engine clock frequency.
     * |        |          |Do not write a small number into this field, or you may never get response or data due to time-out.
     * |        |          |Note: Filling 0x0 into this field will disable hardware time-out function.
    */
    __IO uint32_t TOUT;

} SDH_T;

/**
    @addtogroup SDH_CONST SDH Bit Field Definition
    Constant Definitions for SDH Controller
@{ */

#define SDH_DMACTL_DMAEN_Pos             (0)                                               /*!< SDH_T::DMACTL: DMAEN Position             */
#define SDH_DMACTL_DMAEN_Msk             (0x1ul << SDH_DMACTL_DMAEN_Pos)                   /*!< SDH_T::DMACTL: DMAEN Mask                 */

#define SDH_DMACTL_DMARST_Pos            (1)                                               /*!< SDH_T::DMACTL: DMARST Position            */
#define SDH_DMACTL_DMARST_Msk            (0x1ul << SDH_DMACTL_DMARST_Pos)                  /*!< SDH_T::DMACTL: DMARST Mask                */

#define SDH_DMACTL_SGEN_Pos              (3)                                               /*!< SDH_T::DMACTL: SGEN Position              */
#define SDH_DMACTL_SGEN_Msk              (0x1ul << SDH_DMACTL_SGEN_Pos)                    /*!< SDH_T::DMACTL: SGEN Mask                  */

#define SDH_DMACTL_DMABUSY_Pos           (9)                                               /*!< SDH_T::DMACTL: DMABUSY Position           */
#define SDH_DMACTL_DMABUSY_Msk           (0x1ul << SDH_DMACTL_DMABUSY_Pos)                 /*!< SDH_T::DMACTL: DMABUSY Mask               */

#define SDH_DMASA_ORDER_Pos              (0)                                               /*!< SDH_T::DMASA: ORDER Position              */
#define SDH_DMASA_ORDER_Msk              (0x1ul << SDH_DMASA_ORDER_Pos)                    /*!< SDH_T::DMASA: ORDER Mask                  */

#define SDH_DMASA_DMASA_Pos              (1)                                               /*!< SDH_T::DMASA: DMASA Position              */
#define SDH_DMASA_DMASA_Msk              (0x7ffffffful << SDH_DMASA_DMASA_Pos)             /*!< SDH_T::DMASA: DMASA Mask                  */

#define SDH_DMABCNT_BCNT_Pos             (0)                                               /*!< SDH_T::DMABCNT: BCNT Position             */
#define SDH_DMABCNT_BCNT_Msk             (0x3fffffful << SDH_DMABCNT_BCNT_Pos)             /*!< SDH_T::DMABCNT: BCNT Mask                 */

#define SDH_DMAINTEN_ABORTIEN_Pos        (0)                                               /*!< SDH_T::DMAINTEN: ABORTIEN Position        */
#define SDH_DMAINTEN_ABORTIEN_Msk        (0x1ul << SDH_DMAINTEN_ABORTIEN_Pos)              /*!< SDH_T::DMAINTEN: ABORTIEN Mask            */

#define SDH_DMAINTEN_WEOTIEN_Pos         (1)                                               /*!< SDH_T::DMAINTEN: WEOTIEN Position         */
#define SDH_DMAINTEN_WEOTIEN_Msk         (0x1ul << SDH_DMAINTEN_WEOTIEN_Pos)               /*!< SDH_T::DMAINTEN: WEOTIEN Mask             */

#define SDH_DMAINTSTS_ABORTIF_Pos        (0)                                               /*!< SDH_T::DMAINTSTS: ABORTIF Position        */
#define SDH_DMAINTSTS_ABORTIF_Msk        (0x1ul << SDH_DMAINTSTS_ABORTIF_Pos)              /*!< SDH_T::DMAINTSTS: ABORTIF Mask            */

#define SDH_DMAINTSTS_WEOTIF_Pos         (1)                                               /*!< SDH_T::DMAINTSTS: WEOTIF Position         */
#define SDH_DMAINTSTS_WEOTIF_Msk         (0x1ul << SDH_DMAINTSTS_WEOTIF_Pos)               /*!< SDH_T::DMAINTSTS: WEOTIF Mask             */

#define SDH_GCTL_GCTLRST_Pos             (0)                                               /*!< SDH_T::GCTL: GCTLRST Position             */
#define SDH_GCTL_GCTLRST_Msk             (0x1ul << SDH_GCTL_GCTLRST_Pos)                   /*!< SDH_T::GCTL: GCTLRST Mask                 */

#define SDH_GCTL_SDEN_Pos                (1)                                               /*!< SDH_T::GCTL: SDEN Position                */
#define SDH_GCTL_SDEN_Msk                (0x1ul << SDH_GCTL_SDEN_Pos)                      /*!< SDH_T::GCTL: SDEN Mask                    */

#define SDH_GINTEN_DTAIEN_Pos            (0)                                               /*!< SDH_T::GINTEN: DTAIEN Position            */
#define SDH_GINTEN_DTAIEN_Msk            (0x1ul << SDH_GINTEN_DTAIEN_Pos)                  /*!< SDH_T::GINTEN: DTAIEN Mask                */

#define SDH_GINTSTS_DTAIF_Pos            (0)                                               /*!< SDH_T::GINTSTS: DTAIF Position            */
#define SDH_GINTSTS_DTAIF_Msk            (0x1ul << SDH_GINTSTS_DTAIF_Pos)                  /*!< SDH_T::GINTSTS: DTAIF Mask                */

#define SDH_CTL_COEN_Pos                 (0)                                               /*!< SDH_T::CTL: COEN Position                 */
#define SDH_CTL_COEN_Msk                 (0x1ul << SDH_CTL_COEN_Pos)                       /*!< SDH_T::CTL: COEN Mask                     */

#define SDH_CTL_RIEN_Pos                 (1)                                               /*!< SDH_T::CTL: RIEN Position                 */
#define SDH_CTL_RIEN_Msk                 (0x1ul << SDH_CTL_RIEN_Pos)                       /*!< SDH_T::CTL: RIEN Mask                     */

#define SDH_CTL_DIEN_Pos                 (2)                                               /*!< SDH_T::CTL: DIEN Position                 */
#define SDH_CTL_DIEN_Msk                 (0x1ul << SDH_CTL_DIEN_Pos)                       /*!< SDH_T::CTL: DIEN Mask                     */

#define SDH_CTL_DOEN_Pos                 (3)                                               /*!< SDH_T::CTL: DOEN Position                 */
#define SDH_CTL_DOEN_Msk                 (0x1ul << SDH_CTL_DOEN_Pos)                       /*!< SDH_T::CTL: DOEN Mask                     */

#define SDH_CTL_R2EN_Pos                 (4)                                               /*!< SDH_T::CTL: R2EN Position                 */
#define SDH_CTL_R2EN_Msk                 (0x1ul << SDH_CTL_R2EN_Pos)                       /*!< SDH_T::CTL: R2EN Mask                     */

#define SDH_CTL_CLK74OEN_Pos             (5)                                               /*!< SDH_T::CTL: CLK74OEN Position             */
#define SDH_CTL_CLK74OEN_Msk             (0x1ul << SDH_CTL_CLK74OEN_Pos)                   /*!< SDH_T::CTL: CLK74OEN Mask                 */

#define SDH_CTL_CLK8OEN_Pos              (6)                                               /*!< SDH_T::CTL: CLK8OEN Position              */
#define SDH_CTL_CLK8OEN_Msk              (0x1ul << SDH_CTL_CLK8OEN_Pos)                    /*!< SDH_T::CTL: CLK8OEN Mask                  */

#define SDH_CTL_CLKKEEP0_Pos             (7)                                               /*!< SDH_T::CTL: CLKKEEP0 Position             */
#define SDH_CTL_CLKKEEP0_Msk             (0x1ul << SDH_CTL_CLKKEEP0_Pos)                   /*!< SDH_T::CTL: CLKKEEP0 Mask                 */

#define SDH_CTL_CMDCODE_Pos              (8)                                               /*!< SDH_T::CTL: CMDCODE Position              */
#define SDH_CTL_CMDCODE_Msk              (0x3ful << SDH_CTL_CMDCODE_Pos)                   /*!< SDH_T::CTL: CMDCODE Mask                  */

#define SDH_CTL_CTLRST_Pos               (14)                                              /*!< SDH_T::CTL: CTLRST Position               */
#define SDH_CTL_CTLRST_Msk               (0x1ul << SDH_CTL_CTLRST_Pos)                     /*!< SDH_T::CTL: CTLRST Mask                   */

#define SDH_CTL_DBW_Pos                  (15)                                              /*!< SDH_T::CTL: DBW Position                  */
#define SDH_CTL_DBW_Msk                  (0x1ul << SDH_CTL_DBW_Pos)                        /*!< SDH_T::CTL: DBW Mask                      */

#define SDH_CTL_BLKCNT_Pos               (16)                                              /*!< SDH_T::CTL: BLKCNT Position               */
#define SDH_CTL_BLKCNT_Msk               (0xfful << SDH_CTL_BLKCNT_Pos)                    /*!< SDH_T::CTL: BLKCNT Mask                   */

#define SDH_CTL_SDNWR_Pos                (24)                                              /*!< SDH_T::CTL: SDNWR Position                */
#define SDH_CTL_SDNWR_Msk                (0xful << SDH_CTL_SDNWR_Pos)                      /*!< SDH_T::CTL: SDNWR Mask                    */

#define SDH_CTL_SDPORT_Pos               (29)                                              /*!< SDH_T::CTL: SDPORT Position               */
#define SDH_CTL_SDPORT_Msk               (0x3ul << SDH_CTL_SDPORT_Pos)                     /*!< SDH_T::CTL: SDPORT Mask                   */

#define SDH_CTL_CLKKEEP1_Pos             (31)                                              /*!< SDH_T::CTL: CLKKEEP1 Position             */
#define SDH_CTL_CLKKEEP1_Msk             (0x1ul << SDH_CTL_CLKKEEP1_Pos)                   /*!< SDH_T::CTL: CLKKEEP1 Mask                 */

#define SDH_CMDARG_ARGUMENT_Pos          (0)                                               /*!< SDH_T::CMDARG: ARGUMENT Position          */
#define SDH_CMDARG_ARGUMENT_Msk          (0xfffffffful << SDH_CMDARG_ARGUMENT_Pos)         /*!< SDH_T::CMDARG: ARGUMENT Mask              */

#define SDH_INTEN_BLKDIEN_Pos            (0)                                               /*!< SDH_T::INTEN: BLKDIEN Position            */
#define SDH_INTEN_BLKDIEN_Msk            (0x1ul << SDH_INTEN_BLKDIEN_Pos)                  /*!< SDH_T::INTEN: BLKDIEN Mask                */

#define SDH_INTEN_CRCIEN_Pos             (1)                                               /*!< SDH_T::INTEN: CRCIEN Position             */
#define SDH_INTEN_CRCIEN_Msk             (0x1ul << SDH_INTEN_CRCIEN_Pos)                   /*!< SDH_T::INTEN: CRCIEN Mask                 */

#define SDH_INTEN_CDIEN0_Pos             (8)                                               /*!< SDH_T::INTEN: CDIEN0 Position             */
#define SDH_INTEN_CDIEN0_Msk             (0x1ul << SDH_INTEN_CDIEN0_Pos)                   /*!< SDH_T::INTEN: CDIEN0 Mask                 */

#define SDH_INTEN_CDIEN1_Pos             (9)                                               /*!< SDH_T::INTEN: CDIEN1 Position             */
#define SDH_INTEN_CDIEN1_Msk             (0x1ul << SDH_INTEN_CDIEN1_Pos)                   /*!< SDH_T::INTEN: CDIEN1 Mask                 */

#define SDH_INTEN_SDHOST0IEN_Pos         (10)                                              /*!< SDH_T::INTSTS: SDHOST0IEN Position        */
#define SDH_INTEN_SDHOST0IEN_Msk         (0x1ul << SDH_INTEN_SDHOST0IEN_Pos)               /*!< SDH_T::INTSTS: SDHOST0IEN Mask            */

#define SDH_INTEN_SDHOST1IEN_Pos         (11)                                              /*!< SDH_T::INTSTS: SDHOST1IEN Position        */
#define SDH_INTEN_SDHOST1IEN_Msk         (0x1ul << SDH_INTEN_SDHOST1IEN_Pos)               /*!< SDH_T::INTSTS: SDHOST1IEN Mask            */

#define SDH_INTEN_RTOIEN_Pos             (12)                                              /*!< SDH_T::INTEN: RTOIEN Position             */
#define SDH_INTEN_RTOIEN_Msk             (0x1ul << SDH_INTEN_RTOIEN_Pos)                   /*!< SDH_T::INTEN: RTOIEN Mask                 */

#define SDH_INTEN_DITOIEN_Pos            (13)                                              /*!< SDH_T::INTEN: DITOIEN Position            */
#define SDH_INTEN_DITOIEN_Msk            (0x1ul << SDH_INTEN_DITOIEN_Pos)                  /*!< SDH_T::INTEN: DITOIEN Mask                */

#define SDH_INTEN_WKIEN_Pos              (14)                                              /*!< SDH_T::INTEN: WKIEN Position              */
#define SDH_INTEN_WKIEN_Msk              (0x1ul << SDH_INTEN_WKIEN_Pos)                    /*!< SDH_T::INTEN: WKIEN Mask                  */

#define SDH_INTEN_CDSRC0_Pos             (30)                                              /*!< SDH_T::INTEN: CDSRC0 Position             */
#define SDH_INTEN_CDSRC0_Msk             (0x1ul << SDH_INTEN_CDSRC0_Pos)                   /*!< SDH_T::INTEN: CDSRC0 Mask                 */

#define SDH_INTEN_CDSRC1_Pos             (31)                                              /*!< SDH_T::INTEN: CDSRC1 Position             */
#define SDH_INTEN_CDSRC1_Msk             (0x1ul << SDH_INTEN_CDSRC1_Pos)                   /*!< SDH_T::INTEN: CDSRC1 Mask                 */

#define SDH_INTSTS_BLKDIF_Pos            (0)                                               /*!< SDH_T::INTSTS: BLKDIF Position            */
#define SDH_INTSTS_BLKDIF_Msk            (0x1ul << SDH_INTSTS_BLKDIF_Pos)                  /*!< SDH_T::INTSTS: BLKDIF Mask                */

#define SDH_INTSTS_CRCIF_Pos             (1)                                               /*!< SDH_T::INTSTS: CRCIF Position             */
#define SDH_INTSTS_CRCIF_Msk             (0x1ul << SDH_INTSTS_CRCIF_Pos)                   /*!< SDH_T::INTSTS: CRCIF Mask                 */

#define SDH_INTSTS_CRC7_Pos              (2)                                               /*!< SDH_T::INTSTS: CRC7 Position              */
#define SDH_INTSTS_CRC7_Msk              (0x1ul << SDH_INTSTS_CRC7_Pos)                    /*!< SDH_T::INTSTS: CRC7 Mask                  */

#define SDH_INTSTS_CRC16_Pos             (3)                                               /*!< SDH_T::INTSTS: CRC16 Position             */
#define SDH_INTSTS_CRC16_Msk             (0x1ul << SDH_INTSTS_CRC16_Pos)                   /*!< SDH_T::INTSTS: CRC16 Mask                 */

#define SDH_INTSTS_CRCSTS_Pos            (4)                                               /*!< SDH_T::INTSTS: CRCSTS Position            */
#define SDH_INTSTS_CRCSTS_Msk            (0x7ul << SDH_INTSTS_CRCSTS_Pos)                  /*!< SDH_T::INTSTS: CRCSTS Mask                */

#define SDH_INTSTS_DAT0STS_Pos           (7)                                               /*!< SDH_T::INTSTS: DAT0STS Position           */
#define SDH_INTSTS_DAT0STS_Msk           (0x1ul << SDH_INTSTS_DAT0STS_Pos)                 /*!< SDH_T::INTSTS: DAT0STS Mask               */

#define SDH_INTSTS_CDIF0_Pos             (8)                                               /*!< SDH_T::INTSTS: CDIF0 Position             */
#define SDH_INTSTS_CDIF0_Msk             (0x1ul << SDH_INTSTS_CDIF0_Pos)                   /*!< SDH_T::INTSTS: CDIF0 Mask                 */

#define SDH_INTSTS_CDIF1_Pos             (9)                                               /*!< SDH_T::INTSTS: CDIF1 Position             */
#define SDH_INTSTS_CDIF1_Msk             (0x1ul << SDH_INTSTS_CDIF1_Pos)                   /*!< SDH_T::INTSTS: CDIF1 Mask                 */

#define SDH_INTSTS_SDHOST0IF_Pos         (10)                                              /*!< SDH_T::INTSTS: SDHOST0IF Position         */
#define SDH_INTSTS_SDHOST0IF_Msk         (0x1ul << SDH_INTSTS_SDHOST0IF_Pos)               /*!< SDH_T::INTSTS: SDHOST0IF Mask             */

#define SDH_INTSTS_SDHOST1IF_Pos         (11)                                              /*!< SDH_T::INTSTS: SDHOST1IF Position         */
#define SDH_INTSTS_SDHOST1IF_Msk         (0x1ul << SDH_INTSTS_SDHOST1IF_Pos)               /*!< SDH_T::INTSTS: SDHOST1IF Mask             */

#define SDH_INTSTS_RTOIF_Pos             (12)                                              /*!< SDH_T::INTSTS: RTOIF Position             */
#define SDH_INTSTS_RTOIF_Msk             (0x1ul << SDH_INTSTS_RTOIF_Pos)                   /*!< SDH_T::INTSTS: RTOIF Mask                 */

#define SDH_INTSTS_DINTOIF_Pos           (13)                                              /*!< SDH_T::INTSTS: DINTOIF Position           */
#define SDH_INTSTS_DINTOIF_Msk           (0x1ul << SDH_INTSTS_DINTOIF_Pos)                 /*!< SDH_T::INTSTS: DINTOIF Mask               */

#define SDH_INTSTS_CDSTS0_Pos            (16)                                              /*!< SDH_T::INTSTS: CDSTS0 Position            */
#define SDH_INTSTS_CDSTS0_Msk            (0x1ul << SDH_INTSTS_CDSTS0_Pos)                  /*!< SDH_T::INTSTS: CDSTS0 Mask                */

#define SDH_INTSTS_CDSTS1_Pos            (17)                                              /*!< SDH_T::INTSTS: CDSTS1 Position            */
#define SDH_INTSTS_CDSTS1_Msk            (0x1ul << SDH_INTSTS_CDSTS1_Pos)                  /*!< SDH_T::INTSTS: CDSTS1 Mask                */

#define SDH_INTSTS_DAT1STS_Pos           (18)                                              /*!< SDH_T::INTSTS: DAT1STS Position           */
#define SDH_INTSTS_DAT1STS_Msk           (0x1ul << SDH_INTSTS_DAT1STS_Pos)                 /*!< SDH_T::INTSTS: DAT1STS Mask               */

#define SDH_RESP0_RESPTK0_Pos            (0)                                               /*!< SDH_T::RESP0: RESPTK0 Position            */
#define SDH_RESP0_RESPTK0_Msk            (0xfffffffful << SDH_RESP0_RESPTK0_Pos)           /*!< SDH_T::RESP0: RESPTK0 Mask                */

#define SDH_RESP1_RESPTK1_Pos            (0)                                               /*!< SDH_T::RESP1: RESPTK1 Position            */
#define SDH_RESP1_RESPTK1_Msk            (0xfful << SDH_RESP1_RESPTK1_Pos)                 /*!< SDH_T::RESP1: RESPTK1 Mask                */

#define SDH_BLEN_BLKLEN_Pos              (0)                                               /*!< SDH_T::BLEN: BLKLEN Position              */
#define SDH_BLEN_BLKLEN_Msk              (0x7fful << SDH_BLEN_BLKLEN_Pos)                  /*!< SDH_T::BLEN: BLKLEN Mask                  */

#define SDH_TOUT_TOUT_Pos                (0)                                               /*!< SDH_T::TOUT: TOUT Position                */
#define SDH_TOUT_TOUT_Msk                (0xfffffful << SDH_TOUT_TOUT_Pos)                 /*!< SDH_T::TOUT: TOUT Mask                    */

/**@}*/ /* SDH_CONST */
/**@}*/ /* end of SDH register group */


/*---------------------- Serial Peripheral Interface Controller -------------------------*/
/**
    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
    Memory Mapped Structure for SPI Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  SPI Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SPIEN     |SPI Transfer Control Enable Control
     * |        |          |0 = Transfer control Disabled.
     * |        |          |1 = Transfer control Enabled.
     * |        |          |Note1: In Master mode, the transfer will start when there is data in the FIFO buffer after this is set to 1.
     * |        |          |In Slave mode, this device is ready to receive data when this bit is set to 1.
     * |        |          |Note2: All configurations should be set before writing 1 to this SPIEN bit.
     * |        |          |(eg: TXNEG, RXNEG, DWIDTH, LSB, CLKPOL, and so on).
     * |[1]     |RXNEG     |Receive On Negative Edge
     * |        |          |0 = Received data input signal is latched on the rising edge of SPICLK.
     * |        |          |1 = Received data input signal is latched on the falling edge of SPICLK.
     * |[2]     |TXNEG     |Transmit On Negative Edge
     * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPICLK.
     * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPICLK.
     * |[3]     |CLKPOL    |Clock Polarity
     * |        |          |0 = SPICLK is idle low.
     * |        |          |1 = SPICLK is idle high.
     * |[4:7]   |SUSPITV   |Suspend Interval (Master Only)
     * |        |          |SUSPITV = 0x0 ... 0.5 SPICLK clock cycle.
     * |        |          |SUSPITV = 0x1 ... 1.5 SPICLK clock cycle.
     * |        |          |......
     * |        |          |SUSPITV = 0xE ... 14.5 SPICLK clock cycle.
     * |        |          |SUSPITV = 0xF ... 15.5 SPICLK clock cycle.
     * |        |          |Note: The four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.
     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word.
     * |        |          |The default value is 0x3.
     * |        |          |The period of the suspend interval is obtained according to the following equation.
     * |        |          |(SUSPITV[3:0] + 0.5) * period of SPICLK clock cycle
     * |[8:12]  |DWIDTH    |Data Transmit Bit Width
     * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
     * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
     * |        |          |DWIDTH = 0x08 ... 8 bits.
     * |        |          |DWIDTH = 0x09 ... 9 bits.
     * |        |          |......
     * |        |          |DWIDTH = 0x1F ... 31 bits.
     * |        |          |DWIDTH = 0x00 ... 32 bits.
     * |[13]    |LSB       |Send LSB First
     * |        |          |0 = MSB first.
     * |        |          |1 = LSB first.
     * |        |          |Note1: The LSB, bit 0 of the SPI TX register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX).
     * |        |          |Note2: The MSB, which bit of transmit/receive register depends on the setting of DWIDTH, is transmitted/received first.
     * |[16]    |TWOBIT    |2-Bit Mode Enable Control
     * |        |          |0 = 2-bit mode Disabled.
     * |        |          |1 = 2-bit mode Enabled.
     * |        |          |Note: When 2-bit mode is enabled, the first serial transmitted bit data is from the first FIFO buffer data, and the 2nd
     * |        |          |serial transmitted bit data is from the second FIFO buffer data.
     * |        |          |As the same as transmitted function, the first received bit data is stored into the first FIFO buffer and the 2nd received bit data is stored into the second FIFO buffer at the same time.
     * |[17]    |UNITIEN   |Unit Transfer Interrupt Enable Control
     * |        |          |0 = SPI unit transfer interrupt Disabled.
     * |        |          |1 = SPI unit transfer interrupt Enabled.
     * |[18]    |SLAVE     |Slave Mode Enable Control
     * |        |          |0 = Master mode.
     * |        |          |1 = Slave mode.
     * |[19]    |REORDER   |Byte Reorder Function Enable Control
     * |        |          |0 = Byte reorder function Disabled.
     * |        |          |1 = Byte reorder function Enabled.
     * |        |          |Note1: Byte reorder function is only available if DWIDTH is defined as 16, 24, and 32 bits.
     * |        |          |Note2: The byte reorder function is not supported when the Quad or Dual I/O mode is enabled.
     * |        |          |Note3: A byte suspend interval will be inserted among each byte.
     * |        |          |The period of the byte suspend interval depends on the setting of SUSPITV.
     * |[20]    |QDIODIR   |Quad Or Dual I/O Mode Direction Control
     * |        |          |0 = Quad or Dual Input mode.
     * |        |          |1 = Quad or Dual Output mode.
     * |[21]    |DUALIOEN  |Dual I/O Mode Enable Control
     * |        |          |0 = Dual I/O mode Disabled.
     * |        |          |1 = Dual I/O mode Enabled.
     * |[22]    |QUADIOEN  |Quad I/O Mode Enable Control
     * |        |          |0 = Quad I/O mode Disabled.
     * |        |          |1 = Quad I/O mode Enabled.
    */
    __IO uint32_t CTL;

    /**
     * CLKDIV
     * ===================================================================================================
     * Offset: 0x04  SPI Clock Divider Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |DIVIDER   |Clock Divider Register
     * |        |          |The value in this field is the frequency divider for generating the peripheral clock, fspi_eclk, and the SPI bus clock of SPI master.
     * |        |          |The frequency is obtained according to the following equation.
     * |        |          |Note1: is the peripheral clock source, which is defined in the clock control, CLK_SEL1 register.
     * |        |          |Note2: is the peripheral clock which is used to drive the SPI logic unit.
    */
    __IO uint32_t CLKDIV;

    /**
     * SSCTL
     * ===================================================================================================
     * Offset: 0x08  SPI Slave Select Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |SS        |Slave Select Control (Master Only)
     * |        |          |If AUTOSS bit is cleared to 0,
     * |        |          |0 = Set the SPI_SS line to inactive state.
     * |        |          |1 = Set the proper SPI_SS line to active state.
     * |        |          |If AUTOSS bit is set to 1,
     * |        |          |0 = Keep the SPI_SS line at inactive state.
     * |        |          |1 = Select the SPI_SS line to be automatically driven to active state for the duration of transmission/reception, and will be driven to inactive state for the rest of the time.
     * |        |          |The active state of SPI_SS is specified in SSACTPOL bit.
     * |        |          |Note: SPI_SS0 is defined as the slave select input in Slave mode.
     * |[2]     |SSACTPOL  |Slave Select Active Level
     * |        |          |0 = The slave select signal SPI_SS0/1 is active on low-level.
     * |        |          |1 = The slave select signal SPI_SS0/1 is active on high-level.
     * |        |          |Note: This bit defines the active status of slave select signal (SPI_SS0/1).
     * |[3]     |AUTOSS    |Automatic Slave Select Function Enable Control (Master Only)
     * |        |          |0 = Automatic slave select function Disabled.
     * |        |          |1 = Automatic slave select function Enabled.
     * |        |          |Note1: If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing the corresponding bits of SPI_SSCTL[1:0].
     * |        |          |Note2: If this bit is set, SPI_SS0/1 signals will be generated automatically.
     * |        |          |It means that device/slave select signal, which is set in SPI_SSCTL[1:0], will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished.
     * |[4]     |SLV3WIRE  |Slave 3-Wire Mode Enable Control
     * |        |          |0 = 4-wire bi-direction interface.
     * |        |          |1 = 3-wire bi-direction interface.
     * |        |          |Note: This is used to ignore the slave select signal in Slave mode.
     * |        |          |The SPI controller can work with 3-wire interface including SPI_CLK, SPI_MISO, and SPI_MOSI.
     * |[5]     |SLVTOIEN  |Slave Mode Time-Out Interrupt Enable Control
     * |        |          |0 = Slave mode time-out interrupt Disabled.
     * |        |          |1 = Slave mode time-out interrupt Enabled.
     * |[6]     |SLVTORST  |Slave Mode Time-Out FIFO Clear
     * |        |          |0 = Time out FIFO clear Disabled.
     * |        |          |1 = Time out FIFO clear Enabled.
     * |        |          |Note: Both the FIFO clear function, TX_CLK and RXRST, active automatically when there is slave mode time-out event.
     * |[8]     |SLVBEIEN  |Slave Mode Error 0 Interrupt Enable Control
     * |        |          |0 = Slave mode error 0 interrupt Disabled.
     * |        |          |1 = Slave mode error 0 interrupt Enabled.
     * |[9]     |SLVURIEN  |Slave Mode Error 1 Interrupt Enable Control
     * |        |          |0 = Slave mode error 1 interrupt Disabled.
     * |        |          |1 = Slave mode error 1 interrupt Enabled.
     * |[12]    |SSACTIEN  |Slave Select Active Interrupt Enable Control
     * |        |          |0 = Slave select active interrupt Disabled.
     * |        |          |1 = Slave select active interrupt Enabled.
     * |[13]    |SSINAIEN  |Slave Select Inactive Interrupt Enable Control
     * |        |          |0 = Slave select inactive interrupt Disabled.
     * |        |          |1 = Slave select inactive interrupt Enabled.
     * |[16:31] |SLVTOCNT  |Slave Mode Time-Out Period
     * |        |          |0 = Slave time out function disabled.
     * |        |          |Others = Slave time out period.
     * |        |          |Note: In Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active.
     * |        |          |The clock source of the time-out counter is Slave peripheral clock.
     * |        |          |If the value is 0, it indicates the slave mode time-out function is disabled.
    */
    __IO uint32_t SSCTL;

    /**
     * PDMACTL
     * ===================================================================================================
     * Offset: 0x0C  SPI PDMA Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |TXPDMAEN  |Transmit DMA Enable Control
     * |        |          |0 = Transmit PDMA Disabled.
     * |        |          |1 = Transmit PDMA Enabled.
     * |        |          |Note: Setting this bit to 1 will start the transmit PDMA process.
     * |        |          |SPI controller will issue request to PDMA controller automatically.
     * |        |          |Hardware will clear this bit to 0 automatically after PDMA transfer done.
     * |[1]     |RXPDMAEN  |Receive PDMA Enable Control
     * |        |          |0 = Receive PDMA Disabled.
     * |        |          |1 = Receive PDMA Enabled.
     * |        |          |Note: Setting this bit to 1 will start the receive PDMA process.
     * |        |          |The SPI controller will issue request to PDMA controller automatically when the SPI receive buffer is not empty.
     * |        |          |This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.
     * |[2]     |PDMARST   |PDMA Reset
     * |        |          |0 = No effect.
     * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0 automatically.
    */
    __IO uint32_t PDMACTL;

    /**
     * FIFOCTL
     * ===================================================================================================
     * Offset: 0x10  SPI FIFO Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RXRST     |Clear Receive FIFO Buffer
     * |        |          |0 = No effect.
     * |        |          |1 = Clear receive FIFO buffer.
     * |        |          |Note1: If there is slave receive time-out event, the RXRST will be set 1 when the SLVTORST, SPI_SSCTL[6], is enabled.
     * |        |          |Note2: The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1.
     * |        |          |This bit will be cleared to 0 by hardware about 3 system clocks + 3 peripheral clock after it is set to 1.
     * |[1]     |TXRST     |Clear Transmit FIFO Buffer
     * |        |          |0 = No effect.
     * |        |          |1 = Clear transmit FIFO buffer.
     * |        |          |Note1: If there is slave receive time-out event, the TXRST will be set 1 when the SLVTORST, SPI_SSCTL[6], is enabled.
     * |        |          |Note2: The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1.
     * |        |          |This bit will be cleared to 0 by hardware about 3 system clocks + 3 peripheral clock after it is set to 1.
     * |[2]     |RXTHIEN   |Receive FIFO Threshold Interrupt Enable Control
     * |        |          |0 = RX FIFO threshold interrupt Disabled.
     * |        |          |1 = RX FIFO threshold interrupt Enabled.
     * |[3]     |TXTHIEN   |Transmit FIFO Threshold Interrupt Enable Control
     * |        |          |0 = TX FIFO threshold interrupt Disabled.
     * |        |          |1 = TX FIFO threshold interrupt Enabled.
     * |[4]     |RXTOIEN   |Slave Receive Time-Out Interrupt Enable Control (Slave Only)
     * |        |          |0 = Receive time-out interrupt Disabled.
     * |        |          |1 = Receive time-out interrupt Enabled.
     * |[5]     |RXOVIEN   |Receive FIFO Overrun Interrupt Enable Control
     * |        |          |0 = Receive FIFO overrun interrupt Disabled.
     * |        |          |1 = Receive FIFO overrun interrupt Enabled.
     * |[6]     |TXUFPOL   |Transmit Under-Run Data Out (Slave Only)
     * |        |          |0 = The SPI data bus is keep low if there is transmit under-run event.
     * |        |          |1 = The SPI data bus is keep high if there is transmit under-run event.
     * |        |          |Note1: The under run event is activated after the bus clock input and the hardware synchronous, so that the first 1~3 bit (depending on the relation between system clock and the peripheral clock) data out will be the last transaction data.
     * |        |          |Note2: If the frequency of system clock approach to peripheral clock, they may need 3-bit time to report the transmit under-run event.
     * |[7]     |TXUFIEN   |Transmit Under Run Interrupt Enable Control (Slave Only)
     * |        |          |0 = Transmit FIFO under-run interrupt Disabled.
     * |        |          |1 = Transmit FIFO under-run interrupt Enabled.
     * |[24:26] |RXTH      |Receive FIFO Threshold
     * |        |          |If the valid data count of the receive FIFO buffer is larger than the RXTH setting, the RXTHIF bit will be set to 1, else the RXTHIF bit will be cleared to 0.
     * |[28:30] |TXTH      |Transmit FIFO Threshold
     * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TXTH setting, the TXTHIF bit will be set to 1, else the TXTHIF bit will be cleared to 0.
    */
    __IO uint32_t FIFOCTL;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x14  SPI Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BUSY      |Busy Status (Read Only)
     * |        |          |0 = SPI controller is in Idle state.
     * |        |          |1 = SPI controller is in busy state.
     * |        |          |The following listing are the bus busy conditions:
     * |        |          |*. SPIEN = 1 and the TXEMPTY = 0.
     * |        |          |*. For SPI Master, the TXEMPTY = 1 but the current transaction is not finished yet.
     * |        |          |*. For SPI Slave receive mode, the SPIEN = 1 and there is serial clock input into the SPI core logic when slave select is active.
     * |        |          |*. For SPI Slave transmit mode, the SPIEN = 1 and the transmit buffer is not empty in SPI core logic even if the slave select is inactive.
     * |[1]     |UNITIF    |Unit Transfer Interrupt Status
     * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
     * |        |          |1 = SPI controller has finished one unit transfer.
     * |        |          |Note: This bit will be cleared by writing 1 to it.
     * |[2]     |SSACTIF   |Slave Select Active Interrupt Status
     * |        |          |0 = Slave select active interrupt is clear or not occur.
     * |        |          |1 = Slave select active interrupt event occurred.
     * |        |          |Note: This bit will be cleared by writing 1 to it.
     * |[3]     |SSINAIF   |Slave Select Inactive Interrupt Status
     * |        |          |0 = Slave select inactive interrupt is clear or not occur.
     * |        |          |1 = Slave select inactive interrupt event occurred.
     * |        |          |Note: This bit will be cleared by writing 1 to it.
     * |[4]     |SSLINE    |Slave Select Line Bus Status (Read Only)
     * |        |          |0 = Indicates the slave select line bus status is 0.
     * |        |          |1 = Indicates the slave select line bus status is 1.
     * |        |          |Note: If SSACTPOL, SPI_SSCTL[2], is set 0, and the SSLINE is 1, the SPI slave select is in inactive status.
     * |[5]     |SLVTOIF   |Slave Time-Out Interrupt Status
     * |        |          |0 = Slave time-out is not active.
     * |        |          |1 = Slave time-out is active.
     * |        |          |Note1: If the DWIDTH is set 16, one transaction is equal 16 bits bus clock period.
     * |        |          |This bit will be cleared by writing 1 to it.
     * |        |          |Note2: When the Slave Select is active and the value of SLVTOCNT is not 0 and the busclock input, the slave time-out counter in SPI controller logic will be start.
     * |        |          |When the value of time-out counter greater or equal than the value of SLVTOCNT, SPI_SSCTL[31:16], during before one transaction done, the slave time-out interrupt event will active.
     * |[6]     |SLVBEIF   |Slave Mode Error 0 Interrupt Status
     * |        |          |0 = No Slave mode error 0 event.
     * |        |          |1 = Slave mode error 0 occurs.
     * |        |          |Note1: If the slave select active but there is no any bus clock input, the SLVER0_INTSTS also active when the slave select goes to inactive state.
     * |        |          |This bit will be cleared by writing 1 to it.
     * |        |          |Note2: In Slave mode, there is bit counter mismatch with DWIDTH when the slave select line goes to inactive state.
     * |[7]     |SLVURIF   |Slave Mode Error 1 Interrupt Status
     * |        |          |0 = No Slave mode error 1 event.
     * |        |          |1 = Slave mode error 1 occurs.
     * |        |          |Note: In Slave mode, transmit under-run occurs when the slave select line goes to inactive state.
     * |        |          |This bit will be cleared by writing 1 to it.
     * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
     * |        |          |0 = Receive FIFO buffer is not empty.
     * |        |          |1 = Receive FIFO buffer is empty.
     * |[9]     |RXFULL    |Receive FIFO Buffer Empty Indicator (Read Only)
     * |        |          |0 = Receive FIFO buffer is not empty.
     * |        |          |1 = Receive FIFO buffer is empty.
     * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Status (Read Only)
     * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RXTH.
     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
     * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
     * |[11]    |RXOVIF    |Receive FIFO Overrun Status
     * |        |          |0 = No FIFO over-run event.
     * |        |          |1 = FIFO over-run event occurred.
     * |        |          |Note: When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
     * |        |          |This bit will be cleared by writing 1 to it.
     * |[12]    |RXTOIF    |Receive Time-Out Interrupt Status
     * |        |          |0 = No receive FIFO time-out event.
     * |        |          |1 = FIFO time-out event occurred.
     * |        |          |Note: Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 peripheral clock period in Slave mode.
     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
     * |        |          |This bit will be cleared by writing 1 to it.
     * |[15]    |SPIENSTS  |SPI Enable Bit Status (Read Only)
     * |        |          |0 = Indicates the transmit control bit is disabled.
     * |        |          |1 = Indicates the transfer control bit is active.
     * |        |          |Note: The clock source of SPI controller logic is peripheral clock, it is asynchronous with the system clock.
     * |        |          |In order to make sure the function is disabled in SPI controller logic, this bit indicates the real status of SPIEN in SPI controller logic for user.
     * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
     * |        |          |0 = Transmit FIFO buffer is not empty.
     * |        |          |1 = Transmit FIFO buffer is empty.
     * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
     * |        |          |0 = Transmit FIFO buffer is not full.
     * |        |          |1 = Transmit FIFO buffer is full.
     * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Status (Read Only)
     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
     * |        |          |Note: If TXTHIEN = 1 and TXTHIF = 1, the SPI controller will generate a SPI interrupt request.
     * |[19]    |TXUFIF    |Transmit FIFO Under-Run Interrupt Status
     * |        |          |0 =No under-run interrupt event.
     * |        |          |1 = Under-run interrupt occurred.
     * |        |          |Note: When the transmit FIFO buffer is empty and there is no datum written into the FIFO buffer, if there is more bus clock input , the output data depends on the setting of SLVUDFPOL and this bit will be set to 1 and this bit will be cleared by writing 1 to it.
     * |[23]    |TXRXRST   |FIFO CLR Status (Read Only)
     * |        |          |0 = Done the FIFO buffer clear function of TXRST or RXRST.
     * |        |          |1 = Doing the FIFO buffer clear function of TXRST or RXRST.
     * |        |          |Note: Both the TXRST, RXRST, need 3 system clock + 3 peripheral clock , the status of this bit support the user to monitor the clear function is doing or done.
     * |[24:27] |RXCNT     |Receive FIFO Data Count (Read Only)
     * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
     * |[28:31] |TXCNT     |Transmit FIFO Data Count (Read Only)
     * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
    */
    __IO  uint32_t STATUS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[2];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * TX
     * ===================================================================================================
     * Offset: 0x20  SPI Data Transmit Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |TX        |Data Transmit Bits
     * |        |          |The data transmit registers pass through the transmitted data into the 8-level transmit FIFO buffer.
     * |        |          |The number of valid bits depends on the setting of transmit bit width field of the SPI_CTL register.
     * |        |          |In Master mode, the serial data in SPI bus output need 5 module clock cycle when the data transmit registers pass through the transmitted data into the 8-level transmit FIFO buffer.
     * |        |          |For example, if DWIDTH is set to 0x08, the bits TX[7:0] will be transmitted.
     * |        |          |If DWIDTH is set to 0x00, the SPI controller will perform a 32-bit transfer.
    */
    __O  uint32_t TX;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[3];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * RX
     * ===================================================================================================
     * Offset: 0x30  SPI Data Receive Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |RX        |Data Receive Bits
     * |        |          |There is 8-level FIFO buffer in this controller.
     * |        |          |The data receive register holds the earliest datum received from SPI data input pin.
     * |        |          |If the RXEMPTY bit, SPI_STATUS[8], is not set to 1, the receive FIFO buffer can be accessed through software by reading this register.
     * |        |          |This is a read only register.
    */
    __I  uint32_t RX;

} SPI_T;

/**
    @addtogroup SPI_CONST SPI Bit Field Definition
    Constant Definitions for SPI Controller
@{ */

#define SPI_CTL_SPIEN_Pos                (0)                                               /*!< SPI_T::CTL: SPIEN Position                */
#define SPI_CTL_SPIEN_Msk                (0x1ul << SPI_CTL_SPIEN_Pos)                      /*!< SPI_T::CTL: SPIEN Mask                    */

#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI_T::CTL: RXNEG Position                */
#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI_T::CTL: RXNEG Mask                    */

#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI_T::CTL: TXNEG Position                */
#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI_T::CTL: TXNEG Mask                    */

#define SPI_CTL_CLKPOL_Pos               (3)                                               /*!< SPI_T::CTL: CLKPOL Position               */
#define SPI_CTL_CLKPOL_Msk               (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI_T::CTL: CLKPOL Mask                   */

#define SPI_CTL_SUSPITV_Pos              (4)                                               /*!< SPI_T::CTL: SUSPITV Position              */
#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI_T::CTL: SUSPITV Mask                  */

#define SPI_CTL_DWIDTH_Pos               (8)                                               /*!< SPI_T::CTL: DWIDTH Position               */
#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI_T::CTL: DWIDTH Mask                   */

#define SPI_CTL_LSB_Pos                  (13)                                              /*!< SPI_T::CTL: LSB Position                  */
#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI_T::CTL: LSB Mask                      */

#define SPI_CTL_TWOBIT_Pos               (16)                                              /*!< SPI_T::CTL: TWOBIT Position               */
#define SPI_CTL_TWOBIT_Msk               (0x1ul << SPI_CTL_TWOBIT_Pos)                     /*!< SPI_T::CTL: TWOBIT Mask                   */

#define SPI_CTL_UNITIEN_Pos              (17)                                              /*!< SPI_T::CTL: UNITIEN Position              */
#define SPI_CTL_UNITIEN_Msk              (0x1ul << SPI_CTL_UNITIEN_Pos)                    /*!< SPI_T::CTL: UNITIEN Mask                  */

#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI_T::CTL: SLAVE Position                */
#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI_T::CTL: SLAVE Mask                    */

#define SPI_CTL_REORDER_Pos              (19)                                              /*!< SPI_T::CTL: REORDER Position              */
#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI_T::CTL: REORDER Mask                  */

#define SPI_CTL_QDIODIR_Pos              (20)                                              /*!< SPI_T::CTL: QDIODIR Position              */
#define SPI_CTL_QDIODIR_Msk              (0x1ul << SPI_CTL_QDIODIR_Pos)                    /*!< SPI_T::CTL: QDIODIR Mask                  */

#define SPI_CTL_DUALIOEN_Pos             (21)                                              /*!< SPI_T::CTL: DUALIOEN Position             */
#define SPI_CTL_DUALIOEN_Msk             (0x1ul << SPI_CTL_DUALIOEN_Pos)                   /*!< SPI_T::CTL: DUALIOEN Mask                 */

#define SPI_CTL_QUADIOEN_Pos             (22)                                              /*!< SPI_T::CTL: QUADIOEN Position             */
#define SPI_CTL_QUADIOEN_Msk             (0x1ul << SPI_CTL_QUADIOEN_Pos)                   /*!< SPI_T::CTL: QUADIOEN Mask                 */

#define SPI_CLKDIV_DIVIDER_Pos           (0)                                               /*!< SPI_T::CLKDIV: DIVIDER Position           */
#define SPI_CLKDIV_DIVIDER_Msk           (0xfful << SPI_CLKDIV_DIVIDER_Pos)                /*!< SPI_T::CLKDIV: DIVIDER Mask               */

#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI_T::SSCTL: SS Position                 */
#define SPI_SSCTL_SS_Msk                 (0x3ul << SPI_SSCTL_SS_Pos)                       /*!< SPI_T::SSCTL: SS Mask                     */

#define SPI_SSCTL_SSACTPOL_Pos           (2)                                               /*!< SPI_T::SSCTL: SSACTPOL Position           */
#define SPI_SSCTL_SSACTPOL_Msk           (0x1ul << SPI_SSCTL_SSACTPOL_Pos)                 /*!< SPI_T::SSCTL: SSACTPOL Mask               */

#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI_T::SSCTL: AUTOSS Position             */
#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI_T::SSCTL: AUTOSS Mask                 */

#define SPI_SSCTL_SLV3WIRE_Pos           (4)                                               /*!< SPI_T::SSCTL: SLV3WIRE Position           */
#define SPI_SSCTL_SLV3WIRE_Msk           (0x1ul << SPI_SSCTL_SLV3WIRE_Pos)                 /*!< SPI_T::SSCTL: SLV3WIRE Mask               */

#define SPI_SSCTL_SLVTOIEN_Pos           (5)                                               /*!< SPI_T::SSCTL: SLVTOIEN Position           */
#define SPI_SSCTL_SLVTOIEN_Msk           (0x1ul << SPI_SSCTL_SLVTOIEN_Pos)                 /*!< SPI_T::SSCTL: SLVTOIEN Mask               */

#define SPI_SSCTL_SLVTORST_Pos           (6)                                               /*!< SPI_T::SSCTL: SLVTORST Position           */
#define SPI_SSCTL_SLVTORST_Msk           (0x1ul << SPI_SSCTL_SLVTORST_Pos)                 /*!< SPI_T::SSCTL: SLVTORST Mask               */

#define SPI_SSCTL_SLVBEIEN_Pos           (8)                                               /*!< SPI_T::SSCTL: SLVBEIEN Position           */
#define SPI_SSCTL_SLVBEIEN_Msk           (0x1ul << SPI_SSCTL_SLVBEIEN_Pos)                 /*!< SPI_T::SSCTL: SLVBEIEN Mask               */

#define SPI_SSCTL_SLVURIEN_Pos           (9)                                               /*!< SPI_T::SSCTL: SLVURIEN Position           */
#define SPI_SSCTL_SLVURIEN_Msk           (0x1ul << SPI_SSCTL_SLVURIEN_Pos)                 /*!< SPI_T::SSCTL: SLVURIEN Mask               */

#define SPI_SSCTL_SSACTIEN_Pos           (12)                                              /*!< SPI_T::SSCTL: SSACTIEN Position           */
#define SPI_SSCTL_SSACTIEN_Msk           (0x1ul << SPI_SSCTL_SSACTIEN_Pos)                 /*!< SPI_T::SSCTL: SSACTIEN Mask               */

#define SPI_SSCTL_SSINAIEN_Pos           (13)                                              /*!< SPI_T::SSCTL: SSINAIEN Position           */
#define SPI_SSCTL_SSINAIEN_Msk           (0x1ul << SPI_SSCTL_SSINAIEN_Pos)                 /*!< SPI_T::SSCTL: SSINAIEN Mask               */

#define SPI_SSCTL_SLVTOCNT_Pos           (16)                                              /*!< SPI_T::SSCTL: SLVTOCNT Position           */
#define SPI_SSCTL_SLVTOCNT_Msk           (0xfffful << SPI_SSCTL_SLVTOCNT_Pos)              /*!< SPI_T::SSCTL: SLVTOCNT Mask               */

#define SPI_PDMACTL_TXPDMAEN_Pos         (0)                                               /*!< SPI_T::PDMACTL: TXPDMAEN Position         */
#define SPI_PDMACTL_TXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_TXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: TXPDMAEN Mask             */

#define SPI_PDMACTL_RXPDMAEN_Pos         (1)                                               /*!< SPI_T::PDMACTL: RXPDMAEN Position         */
#define SPI_PDMACTL_RXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_RXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: RXPDMAEN Mask             */

#define SPI_PDMACTL_PDMARST_Pos          (2)                                               /*!< SPI_T::PDMACTL: PDMARST Position          */
#define SPI_PDMACTL_PDMARST_Msk          (0x1ul << SPI_PDMACTL_PDMARST_Pos)                /*!< SPI_T::PDMACTL: PDMARST Mask              */

#define SPI_FIFOCTL_RXRST_Pos            (0)                                               /*!< SPI_T::FIFOCTL: RXRST Position            */
#define SPI_FIFOCTL_RXRST_Msk            (0x1ul << SPI_FIFOCTL_RXRST_Pos)                  /*!< SPI_T::FIFOCTL: RXRST Mask                */

#define SPI_FIFOCTL_TXRST_Pos            (1)                                               /*!< SPI_T::FIFOCTL: TXRST Position            */
#define SPI_FIFOCTL_TXRST_Msk            (0x1ul << SPI_FIFOCTL_TXRST_Pos)                  /*!< SPI_T::FIFOCTL: TXRST Mask                */

#define SPI_FIFOCTL_RXTHIEN_Pos          (2)                                               /*!< SPI_T::FIFOCTL: RXTHIEN Position          */
#define SPI_FIFOCTL_RXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTHIEN Mask              */

#define SPI_FIFOCTL_TXTHIEN_Pos          (3)                                               /*!< SPI_T::FIFOCTL: TXTHIEN Position          */
#define SPI_FIFOCTL_TXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_TXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: TXTHIEN Mask              */

#define SPI_FIFOCTL_RXTOIEN_Pos          (4)                                               /*!< SPI_T::FIFOCTL: RXTOIEN Position          */
#define SPI_FIFOCTL_RXTOIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTOIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTOIEN Mask              */

#define SPI_FIFOCTL_RXOVIEN_Pos          (5)                                               /*!< SPI_T::FIFOCTL: RXOVIEN Position          */
#define SPI_FIFOCTL_RXOVIEN_Msk          (0x1ul << SPI_FIFOCTL_RXOVIEN_Pos)                /*!< SPI_T::FIFOCTL: RXOVIEN Mask              */

#define SPI_FIFOCTL_TXUFPOL_Pos          (6)                                               /*!< SPI_T::FIFOCTL: TXUFPOL Position          */
#define SPI_FIFOCTL_TXUFPOL_Msk          (0x1ul << SPI_FIFOCTL_TXUFPOL_Pos)                /*!< SPI_T::FIFOCTL: TXUFPOL Mask              */

#define SPI_FIFOCTL_TXUFIEN_Pos          (7)                                               /*!< SPI_T::FIFOCTL: TXUFIEN Position          */
#define SPI_FIFOCTL_TXUFIEN_Msk          (0x1ul << SPI_FIFOCTL_TXUFIEN_Pos)                /*!< SPI_T::FIFOCTL: TXUFIEN Mask              */

#define SPI_FIFOCTL_RXTH_Pos             (24)                                              /*!< SPI_T::FIFOCTL: RXTH Position             */
#define SPI_FIFOCTL_RXTH_Msk             (0x7ul << SPI_FIFOCTL_RXTH_Pos)                   /*!< SPI_T::FIFOCTL: RXTH Mask                 */

#define SPI_FIFOCTL_TXTH_Pos             (28)                                              /*!< SPI_T::FIFOCTL: TXTH Position             */
#define SPI_FIFOCTL_TXTH_Msk             (0x7ul << SPI_FIFOCTL_TXTH_Pos)                   /*!< SPI_T::FIFOCTL: TXTH Mask                 */

#define SPI_STATUS_BUSY_Pos              (0)                                               /*!< SPI_T::STATUS: BUSY Position              */
#define SPI_STATUS_BUSY_Msk              (0x1ul << SPI_STATUS_BUSY_Pos)                    /*!< SPI_T::STATUS: BUSY Mask                  */

#define SPI_STATUS_UNITIF_Pos            (1)                                               /*!< SPI_T::STATUS: UNITIF Position            */
#define SPI_STATUS_UNITIF_Msk            (0x1ul << SPI_STATUS_UNITIF_Pos)                  /*!< SPI_T::STATUS: UNITIF Mask                */

#define SPI_STATUS_SSACTIF_Pos           (2)                                               /*!< SPI_T::STATUS: SSACTIF Position           */
#define SPI_STATUS_SSACTIF_Msk           (0x1ul << SPI_STATUS_SSACTIF_Pos)                 /*!< SPI_T::STATUS: SSACTIF Mask               */

#define SPI_STATUS_SSINAIF_Pos           (3)                                               /*!< SPI_T::STATUS: SSINAIF Position           */
#define SPI_STATUS_SSINAIF_Msk           (0x1ul << SPI_STATUS_SSINAIF_Pos)                 /*!< SPI_T::STATUS: SSINAIF Mask               */

#define SPI_STATUS_SSLINE_Pos            (4)                                               /*!< SPI_T::STATUS: SSLINE Position            */
#define SPI_STATUS_SSLINE_Msk            (0x1ul << SPI_STATUS_SSLINE_Pos)                  /*!< SPI_T::STATUS: SSLINE Mask                */

#define SPI_STATUS_SLVTOIF_Pos           (5)                                               /*!< SPI_T::STATUS: SLVTOIF Position           */
#define SPI_STATUS_SLVTOIF_Msk           (0x1ul << SPI_STATUS_SLVTOIF_Pos)                 /*!< SPI_T::STATUS: SLVTOIF Mask               */

#define SPI_STATUS_SLVBEIF_Pos           (6)                                               /*!< SPI_T::STATUS: SLVBEIF Position           */
#define SPI_STATUS_SLVBEIF_Msk           (0x1ul << SPI_STATUS_SLVBEIF_Pos)                 /*!< SPI_T::STATUS: SLVBEIF Mask               */

#define SPI_STATUS_SLVUDRIF_Pos          (7)                                               /*!< SPI_T::STATUS: SLVUDRIF Position          */
#define SPI_STATUS_SLVUDRIF_Msk          (0x1ul << SPI_STATUS_SLVUDRIF_Pos)                /*!< SPI_T::STATUS: SLVUDRIF Mask              */

#define SPI_STATUS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::STATUS: RXEMPTY Position           */
#define SPI_STATUS_RXEMPTY_Msk           (0x1ul << SPI_STATUS_RXEMPTY_Pos)                 /*!< SPI_T::STATUS: RXEMPTY Mask               */

#define SPI_STATUS_RXFULL_Pos            (9)                                               /*!< SPI_T::STATUS: RXFULL Position            */
#define SPI_STATUS_RXFULL_Msk            (0x1ul << SPI_STATUS_RXFULL_Pos)                  /*!< SPI_T::STATUS: RXFULL Mask                */

#define SPI_STATUS_RXTHIF_Pos            (10)                                              /*!< SPI_T::STATUS: RXTHIF Position            */
#define SPI_STATUS_RXTHIF_Msk            (0x1ul << SPI_STATUS_RXTHIF_Pos)                  /*!< SPI_T::STATUS: RXTHIF Mask                */

#define SPI_STATUS_RXOVIF_Pos            (11)                                              /*!< SPI_T::STATUS: RXOVIF Position            */
#define SPI_STATUS_RXOVIF_Msk            (0x1ul << SPI_STATUS_RXOVIF_Pos)                  /*!< SPI_T::STATUS: RXOVIF Mask                */

#define SPI_STATUS_RXTOIF_Pos            (12)                                              /*!< SPI_T::STATUS: RXTOIF Position            */
#define SPI_STATUS_RXTOIF_Msk            (0x1ul << SPI_STATUS_RXTOIF_Pos)                  /*!< SPI_T::STATUS: RXTOIF Mask                */

#define SPI_STATUS_SPIENSTS_Pos          (15)                                              /*!< SPI_T::STATUS: SPIENSTS Position          */
#define SPI_STATUS_SPIENSTS_Msk          (0x1ul << SPI_STATUS_SPIENSTS_Pos)                /*!< SPI_T::STATUS: SPIENSTS Mask              */

#define SPI_STATUS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::STATUS: TXEMPTY Position           */
#define SPI_STATUS_TXEMPTY_Msk           (0x1ul << SPI_STATUS_TXEMPTY_Pos)                 /*!< SPI_T::STATUS: TXEMPTY Mask               */

#define SPI_STATUS_TXFULL_Pos            (17)                                              /*!< SPI_T::STATUS: TXFULL Position            */
#define SPI_STATUS_TXFULL_Msk            (0x1ul << SPI_STATUS_TXFULL_Pos)                  /*!< SPI_T::STATUS: TXFULL Mask                */

#define SPI_STATUS_TXTHIF_Pos            (18)                                              /*!< SPI_T::STATUS: TXTHIF Position            */
#define SPI_STATUS_TXTHIF_Msk            (0x1ul << SPI_STATUS_TXTHIF_Pos)                  /*!< SPI_T::STATUS: TXTHIF Mask                */

#define SPI_STATUS_TXUFIF_Pos            (19)                                              /*!< SPI_T::STATUS: TXUFIF Position            */
#define SPI_STATUS_TXUFIF_Msk            (0x1ul << SPI_STATUS_TXUFIF_Pos)                  /*!< SPI_T::STATUS: TXUFIF Mask                */

#define SPI_STATUS_TXRXRST_Pos           (23)                                              /*!< SPI_T::STATUS: TXRXRST Position           */
#define SPI_STATUS_TXRXRST_Msk           (0x1ul << SPI_STATUS_TXRXRST_Pos)                 /*!< SPI_T::STATUS: TXRXRST Mask               */

#define SPI_STATUS_RXCNT_Pos             (24)                                              /*!< SPI_T::STATUS: RXCNT Position             */
#define SPI_STATUS_RXCNT_Msk             (0xful << SPI_STATUS_RXCNT_Pos)                   /*!< SPI_T::STATUS: RXCNT Mask                 */

#define SPI_STATUS_TXCNT_Pos             (28)                                              /*!< SPI_T::STATUS: TXCNT Position             */
#define SPI_STATUS_TXCNT_Msk             (0xful << SPI_STATUS_TXCNT_Pos)                   /*!< SPI_T::STATUS: TXCNT Mask                 */

#define SPI_TX_TX_Pos                    (0)                                               /*!< SPI_T::TX: TX Position                    */
#define SPI_TX_TX_Msk                    (0xfffffffful << SPI_TX_TX_Pos)                   /*!< SPI_T::TX: TX Mask                        */

#define SPI_RX_RX_Pos                    (0)                                               /*!< SPI_T::RX: RX Position                    */
#define SPI_RX_RX_Msk                    (0xfffffffful << SPI_RX_RX_Pos)                   /*!< SPI_T::RX: RX Mask                        */

/**@}*/ /* SPI_CONST */
/**@}*/ /* end of SPI register group */


/*---------------------- System Manger Controller -------------------------*/
/**
    @addtogroup SYS System Manger Controller(SYS)
    Memory Mapped Structure for SYS Controller
@{ */

typedef struct {


    /**
     * PDID
     * ===================================================================================================
     * Offset: 0x00  Part Device Identification Number Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |SYS_PDID  |Part Device Identification Number
     * |        |          |This register reflects device part number code.
     * |        |          |S/W can read this register to identify which device is used.
    */
    __I  uint32_t PDID;

    /**
     * RSTSTS
     * ===================================================================================================
     * Offset: 0x04  System Reset Source Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |PORF      |The PORF Flag Is Set By The "Reset Signal" From The Power-On Reset (POR) Controller Or Bit CHIPRST (SYS_IPRST0[0]) To Indicate The Previous Reset Source
     * |        |          |0 = No reset from POR or CHIPRST.
     * |        |          |1 = Power-On Reset (POR) or CHIPRST had issued the reset signal to reset the system.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[1]     |PINRF     |The PINRF Flag Is Set By The "Reset Signal" From The /RESET Pin To Indicate The Previous Reset Source
     * |        |          |0 = No reset from /RESET pin.
     * |        |          |1 = The Pin /RESET had issued the reset signal to reset the system.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[2]     |WDTRF     |The WDTRF Flag Is Set By The "Reset Signal" From The Watchdog Timer To Indicate The Previous Reset Source
     * |        |          |0 = No reset from watchdog timer.
     * |        |          |1 = The watchdog timer had issued the reset signal to reset the system.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[3]     |LVRF      |The LVRF Flag Is Set By The "Reset Signal" From The Low-Voltage-Reset Controller To Indicate The Previous Reset Source
     * |        |          |0 = No reset from LVR.
     * |        |          |1 = The LVR controller had issued the reset signal to reset the system.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[4]     |BODRF     |The BODRF Flag Is Set By The "Reset Signal" From The Brown-Out-Detector To Indicate The Previous Reset Source
     * |        |          |0 = No reset from BOD.
     * |        |          |1 = The BOD had issued the reset signal to reset the system.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[5]     |SYSRF     |The SYSRF Flag Is Set By The "Reset Signal" From The Cortex(TM)-M4 Core To Indicate The Previous Reset Source
     * |        |          |0 = No reset from Cortex(TM)-M4.
     * |        |          |1 = The Cortex(TM)-M4 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex(TM)-M4 core.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[7]     |CPURF     |The CPURF Flag Is Set By Hardware If Software Writes CPURST (SYS_IPRST0[1]) 1 To Reset Cortex(TM)-M4 Core And Flash Memory Controller (FMC)
     * |        |          |0 = No reset from CPU.
     * |        |          |1 = The Cortex(TM)-M4 Core and FMC are reset by software setting CPURST to 1.
     * |        |          |Note: Write 1 to clear this bit to 0.
    */
    __IO uint32_t RSTSTS;

    /**
     * IPRST0
     * ===================================================================================================
     * Offset: 0x08  Peripheral Controller Reset Control Register 1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CHIPRST   |Chip One-Shot Reset (Write Protect)
     * |        |          |Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
     * |        |          |The CHIPRST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.
     * |        |          |This bit is a write protected bit, which means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = Chip normal operation.
     * |        |          |1 = Chip one shot reset.
     * |[1]     |CPURST    |Processor Core One-Shot Reset (Write Protect)
     * |        |          |Setting this bit will only reset the processor core and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles
     * |        |          |This bit is a write protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = Processor core normal operation.
     * |        |          |1 = Processor core one-shot reset.
     * |[2]     |PDMARST   |PDMA Controller Reset (Write Protect)
     * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA.
     * |        |          |User needs to set this bit to 0 to release from reset state.
     * |        |          |This bit is a write protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = PDMA controller normal operation.
     * |        |          |1 = PDMA controller reset.
     * |[3]     |EBIRST    |EBI Controller Reset (Write Protect)
     * |        |          |Setting this bit to 1 will generate a reset signal to the EBI.
     * |        |          |User needs to set this bit to 0 to release from the reset state.
     * |        |          |This bit is a write protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = EBI controller normal operation.
     * |        |          |1 = EBI controller reset.
     * |[4]     |USBHRST   |UHC Controller Reset (Write Protect)
     * |        |          |Setting this bit to 1 will generate a reset signal to the HSB HOST controller.
     * |        |          |User needs to set this bit to 0 to release from the reset state.
     * |        |          |This bit is a write protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = UHC controller normal operation.
     * |        |          |1 = UHC controller reset.
     * |[5]     |SDHRST    |EMAC Controller Reset (Write Protect)
     * |        |          |Setting this bit to 1 will generate a reset signal to the EMAC controller.
     * |        |          |User needs to set this bit to 0 to release from the reset state.
     * |        |          |This bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = EMAC controller normal operation.
     * |        |          |1 = EMAC controller reset.
     * |[6]     |SDHOST_RST|SD HOST Controller Reset (Write Protect)
     * |        |          |Setting this bit to 1 will generate a reset signal to the SD HOST controller.
     * |        |          |User needs to set this bit to 0 to release from the reset state.
     * |        |          |This bit is a write protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = SD HOST controller normal operation.
     * |        |          |1 = SD HOST controller reset.
     * |[7]     |CRCRST    |CRC Controller Reset (Write Protect)
     * |        |          |Setting this bit to 1 will generate a reset signal to the CRC controller.
     * |        |          |User needs to set this bit to 0 to release from the reset state.
     * |        |          |This bit is a write protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Reference the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = CRC controller normal operation.
     * |        |          |1 = CRC controller reset.
     * |[8]     |CAPRST    |Image Capture Controller Reset (Write Protect)
     * |        |          |Setting this bit to 1 will generate a reset signal to the CAP controller.
     * |        |          |User needs to set this bit to 0 to release from the reset state.
     * |        |          |This bit is a write protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Reference the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = CAP controller normal operation.
     * |        |          |1 = CAP controller reset.
     * |[12]    |CRPT_RST  |CRYPTO Controller Reset (Write Protect)
     * |        |          |Setting this bit to 1 will generate a reset signal to the CRYPTO controller.
     * |        |          |User needs to set this bit to 0 to release from the reset state.
     * |        |          |This bit is a write protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |        |          |0 = CRYPTO controller normal operation.
     * |        |          |1 = CRYPTO controller reset.
    */
    __IO uint32_t IPRST0;

    /**
     * IPRST1
     * ===================================================================================================
     * Offset: 0x0C  Peripheral Controller Reset Control Register 2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1]     |GPIORST   |GPIO Controller Reset
     * |        |          |0 = GPIO controller normal operation.
     * |        |          |1 = GPIO controller reset.
     * |[2]     |TMR0RST   |Timer0 Controller Reset
     * |        |          |0 = Timer0 controller normal operation.
     * |        |          |1 = Timer0 controller reset.
     * |[3]     |TMR1RST   |Timer1 Controller Reset
     * |        |          |0 = Timer1 controller normal operation.
     * |        |          |1 = Timer1 controller reset.
     * |[4]     |TMR2RST   |Timer2 Controller Reset
     * |        |          |0 = Timer2 controller normal operation.
     * |        |          |1 = Timer2 controller reset.
     * |[5]     |TMR3RST   |Timer3 Controller Reset
     * |        |          |0 = Timer3 controller normal operation.
     * |        |          |1 = Timer3 controller reset.
     * |[7]     |ACMPRST   |Analog Comparator Controller Reset
     * |        |          |0 = Analog Comparator controller normal operation.
     * |        |          |1 = Analog Comparator controller reset.
     * |[8]     |I2C0RST   |I2C0 Controller Reset
     * |        |          |0 = I2C0 controller normal operation.
     * |        |          |1 = I2C0 controller reset.
     * |[9]     |I2C1RST   |I2C1 Controller Reset
     * |        |          |0 = I2C1 controller normal operation.
     * |        |          |1 = I2C1 controller reset.
     * |[12]    |SPI0RST   |SPI0 Controller Reset
     * |        |          |0 = SPI0 controller normal operation.
     * |        |          |1 = SPI0 controller reset.
     * |[13]    |SPI1RST   |SPI1 Controller Reset
     * |        |          |0 = SPI1 controller normal operation.
     * |        |          |1 = SPI1 controller reset.
     * |[14]    |SPI2RST   |SPI2 Controller Reset
     * |        |          |0 = SPI2 controller normal operation.
     * |        |          |1 = SPI2 controller reset.
     * |[15]    |SPI3RST   |SPI3 Controller Reset
     * |        |          |0 = SPI3 controller normal operation.
     * |        |          |1 = SPI3 controller reset.
     * |[16]    |UART0RST  |UART0 Controller Reset
     * |        |          |0 = UART0 controller normal operation.
     * |        |          |1 = UART0 controller reset.
     * |[17]    |UART1RST  |UART1 Controller Reset
     * |        |          |0 = UART1 controller normal operation.
     * |        |          |1 = UART1 controller reset.
     * |[18]    |UART2RST  |UART2 Controller Reset
     * |        |          |0 = UART2 controller normal operation.
     * |        |          |1 = UART2 controller reset.
     * |[19]    |UART3RST  |UART3 Controller Reset
     * |        |          |0 = UART3 controller normal operation.
     * |        |          |1 = UART3 controller reset.
     * |[20]    |UART4RST  |UART4 Controller Reset
     * |        |          |0 = UART4 controller normal operation.
     * |        |          |1 = UART4 controller reset.
     * |[21]    |UART5RST  |UART2 Controller Reset
     * |        |          |0 = UART5 controller normal operation.
     * |        |          |1 = UART5 controller reset.
     * |[24]    |CAN0RST   |CAN0 Controller Reset
     * |        |          |0 = CAN0 controller normal operation.
     * |        |          |1 = CAN0 controller reset.
     * |[25]    |CAN1RST   |CAN1 Controller Reset
     * |        |          |0 = CAN1 controller normal operation.
     * |        |          |1 = CAN1 controller reset.
     * |[27]    |USBDRST   |USB Device Controller Reset
     * |        |          |0 = USB device controller normal operation.
     * |        |          |1 = USB device controller reset.
     * |[28]    |ADCRST    |ADC Controller Reset
     * |        |          |0 = ADC controller normal operation.
     * |        |          |1 = ADC controller reset.
     * |[29]    |I2SRST    |I2S Controller Reset
     * |        |          |0 = I2S controller normal operation.
     * |        |          |1 = I2S controller reset.
     * |[30]    |I2S1RST   |I2S1 Controller Reset
     * |        |          |0 = I2S1 controller normal operation.
     * |        |          |1 = I2S1 controller reset.
     * |[31]    |PS2RST    |PS/2 Controller Reset
     * |        |          |0 = PS/2 controller normal operation.
     * |        |          |1 = PS/2 controller reset.
    */
    __IO uint32_t IPRST1;

    /**
     * IPRST2
     * ===================================================================================================
     * Offset: 0x10  Peripheral Controller Reset Control Register 3
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SC0RST    |SC0 Controller Reset
     * |        |          |0 = SC0 controller normal operation.
     * |        |          |1 = SC0 controller reset.
     * |[1]     |SC1RST    |SC1 Controller Reset
     * |        |          |0 = SC1 controller normal operation.
     * |        |          |1 = SC1 controller reset.
     * |[2]     |SC2RST    |SC2 Controller Reset
     * |        |          |0 = SC2 controller normal operation.
     * |        |          |1 = SC2 controller reset.
     * |[3]     |SC3RST    |SC3 Controller Reset
     * |        |          |0 = SC3 controller normal operation.
     * |        |          |1 = SC3 controller reset.
     * |[4]     |SC4RST    |SC4 Controller Reset
     * |        |          |0 = SC4 controller normal operation.
     * |        |          |1 = SC4 controller reset.
     * |[5]     |SC5RST    |SC5 Controller Reset
     * |        |          |0 = SC5 controller normal operation.
     * |        |          |1 = SC5 controller reset.
     * |[8]     |I2C4RST   |I2C4 Controller Reset
     * |        |          |0 = I2C4 controller normal operation.
     * |        |          |1 = I2C4 controller reset.
     * |[16]    |PWM0RST   |PWM0 Controller Reset
     * |        |          |0 = PWM0 controller normal operation.
     * |        |          |1 = PWM0 controller reset.
     * |[17]    |PWM1RST   |PWM1 Controller Reset
     * |        |          |0 = PWM1 controller normal operation.
     * |        |          |1 = PWM1 controller reset.
     * |[22]    |QEI0RST   |QEI0 Controller Reset
     * |        |          |0 = QEI0 controller normal operation.
     * |        |          |1 = QEI0 controller reset.
     * |[23]    |QEI1RST   |QEI1 Controller Reset
     * |        |          |0 = QEI1 controller normal operation.
     * |        |          |1 = QEI1 controller reset.
    */
    __IO uint32_t IPRST2;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * BODCTL
     * ===================================================================================================
     * Offset: 0x18  Brown-out Detector Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BODEN     |Brown-Out Detector Enable Control (Write Protect)
     * |        |          |The default value is set by flash controller user configuration register config0 bit[23]
     * |        |          |0 = Brown-out Detector function Disabled.
     * |        |          |1 = Brown-out Detector function Enabled.
     * |        |          |This bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |[1:2]   |BODVL     |Brown-Out Detector Threshold Voltage Selection (Write Protect)
     * |        |          |The default value is set by flash controller user configuration register config0 bit[22:21]
     * |        |          |Relationship between BODVL and Brown-out voltage listed below:
     * |        |          |00 = 2.2V.
     * |        |          |01 = 2.7V.
     * |        |          |10 = 3.8V.
     * |        |          |11 = 4.5V.
     * |        |          |This bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |[3]     |BODRSTEN  |Brown-Out Reset Enable Control (Write Protect)
     * |        |          |While the Brown-out Detector function is enabled (BODEN high) and BOD reset function is enabled (BODRSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).
     * |        |          |While the BOD function is enabled (BODEN high) and BOD interrupt function is enabled (BODRSTEN low), BOD will assert an interrupt if BODOUT is high.
     * |        |          |BOD interrupt will keep till to the BODEN set to 0.
     * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BODEN low).
     * |        |          |The default value is set by flash controller user configuration register config0 bit[20].
     * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
     * |        |          |1 = Brown-out "RESET" function Enabled.
     * |        |          |This bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |[4]     |BODINTF   |Brown-Out Detector Interrupt Flag
     * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BODVL setting.
     * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BODVL setting or the VDD is raised up through the voltage of BODVL setting, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[5]     |BODLPM    |Brown-Out Detector Low Power Mode (Write Protect)
     * |        |          |The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
     * |        |          |0 = BOD operate in normal mode (default).
     * |        |          |1 = BOD Low Power mode Enabled.
     * |        |          |This bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
     * |[6]     |BODOUT    |Brown-Out Detector Output Status
     * |        |          |0 = Brown-out Detector output status is 0.
     * |        |          |It means the detected voltage is higher than BODVL setting or BODEN is 0.
     * |        |          |1 = Brown-out Detector output status is 1.
     * |        |          |It means the detected voltage is lower than BODVL setting.
     * |        |          |If the BODEN is 0, BOD function disabled , this bit always responds 0000.
     * |[7]     |LVREN     |Low Voltage Reset Enable Control (Write Protect)
     * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting.
     * |        |          |LVR function is enabled in default.
     * |        |          |0 = Low Voltage Reset function Disabled.
     * |        |          |1 = Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100uS delay for LVR output stable (default).
     * |        |          |This bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
    */
    __IO uint32_t BODCTL;

    /**
     * TEMPCTL
     * ===================================================================================================
     * Offset: 0x1C  Temperature Sensor Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |VTEMPEN   |Temperature Sensor Enable Control
     * |        |          |This bit is used to enable/disable temperature sensor function.
     * |        |          |0 = Temperature sensor function Disabled (default).
     * |        |          |1 = Temperature sensor function Enabled.
     * |        |          |After this bit is set to 1, the value of temperature sensor output can be obtained from ADC conversion result.
     * |        |          |Please refer to ADC function chapter for details.
    */
    __IO uint32_t TEMPCTL;

    /**
     * VCID
     * ===================================================================================================
     * Offset: 0x20  Hardware Version Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |VCID      |Hardware Version Control (Ready Only)
     * |        |          |These registers repress hardware version.
     * |        |          |These bits are the read protected bits.
     * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
    */
    __I  uint32_t VCID;

    /**
     * PORCTL
     * ===================================================================================================
     * Offset: 0x24  Power-On-Reset Controller Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |POROFF    |Power-On-Reset Enable Control (Write Protect)
     * |        |          |When power on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
     * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
     * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
     * |        |          |/RESET, Watch dog, LVR reset, BOD reset, ICE reset command and the software-chip reset function
     * |        |          |This bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x4000_0100 to disable register protection.
     * |        |          |Refer to the register SYS_REGLCTL at address GCR_BA+0x100.
    */
    __IO uint32_t PORCTL;

    /**
     * VREFCTL
     * ===================================================================================================
     * Offset: 0x28  ADC VREF Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:4]   |VREFCTL   |Vref control bits (Write Protect)
     * |        |          |00011=Vref is internal 2.65V
     * |        |          |00111=Vref is internal 2.048V
     * |        |          |01011=Vref is internal 3.072V
     * |        |          |01111=Vref is internal 4.096V
     * |        |          |10000=Vref is from AVDD
     * |        |          |Others=Reserved
     * |[8]     |ADCMODESEL|ADC IP Selection (Write Protect)
     * |        |          |0 = ADC mode.
     * |        |          |1 = E ADC mode.
     * |[9]     |PWMSYNCMODE|PWM SYNC MODE (Write Protect)
     * |        |          |0 = PWM SYNC MODE Disabled; PWM engine clock can different with HCLK.
     * |        |          |1 = PWM SYNC MODE Enabled; PWM engine clock is same as HCLK.
    */
    __IO uint32_t VREFCTL;

    /**
     * USBPHY
     * ===================================================================================================
     * Offset: 0x2C  USB PHY Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |USBROLE   |USB Role Configuration (Write Protect)
     * |        |          |USB role configuration can be from ROMMAP or software setting if software setting option, controlled by ROMMAP, is enabled.
     * |        |          |00 = Standard USB device.
     * |        |          |01 = Standard USB host.
     * |        |          |10 = ID dependent device.
     * |        |          |11 = On-The-Go device.
     * |[8]     |LDO33EN   |LDO33 Enable Control (Write Protect)
     * |        |          |0 = USB LDO33 Disabled.
     * |        |          |1 = USB LDO33 Enabled.
    */
    __IO uint32_t USBPHY;

    /**
     * GPA_MFPL
     * ===================================================================================================
     * Offset: 0x30  Port A Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PA0MFP    |PA.0 Multi-function Pin Selection
     * |[4:7]   |PA1MFP    |PA.1 Multi-function Pin Selection
     * |[8:11]  |PA2MFP    |PA.2 Multi-function Pin Selection
     * |[12:15] |PA3MFP    |PA.3 Multi-function Pin Selection
     * |[16:19] |PA4MFP    |PA.4 Multi-function Pin Selection
     * |[20:23] |PA5MFP    |PA.5 Multi-function Pin Selection
     * |[24:27] |PA6MFP    |PA.6 Multi-function Pin Selection
     * |[28:31] |PA7MFP    |PA.7 Multi-function Pin Selection
    */
    __IO uint32_t GPA_MFPL;

    /**
     * GPA_MFPH
     * ===================================================================================================
     * Offset: 0x34  Port A High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PA8MFP    |PA.8 Multi-function Pin Selection
     * |[4:7]   |PA9MFP    |PA.9 Multi-function Pin Selection
     * |[8:11]  |PA10MFP   |PA.10 Multi-function Pin Selection
     * |[12:15] |PA11MFP   |PA.11 Multi-function Pin Selection
     * |[16:19] |PA12MFP   |PA.12 Multi-function Pin Selection
     * |[20:23] |PA13MFP   |PA.13 Multi-function Pin Selection
     * |[24:27] |PA14MFP   |PA.14 Multi-function Pin Selection
     * |[28:31] |PA15MFP   |PA.15 Multi-function Pin Selection
    */
    __IO uint32_t GPA_MFPH;

    /**
     * GPB_MFPL
     * ===================================================================================================
     * Offset: 0x38  Port B Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PB0MFP    |PB.0 Multi-function Pin Selection
     * |[4:7]   |PB1MFP    |PB.1 Multi-function Pin Selection
     * |[8:11]  |PB2MFP    |PB.2 Multi-function Pin Selection
     * |[12:15] |PB3MFP    |PB.3 Multi-function Pin Selection
     * |[16:19] |PB4MFP    |PB.4 Multi-function Pin Selection
     * |[20:23] |PB5MFP    |PB.5 Multi-function Pin Selection
     * |[24:27] |PB6MFP    |PB.6 Multi-function Pin Selection
     * |[28:31] |PB7MFP    |PB.7 Multi-function Pin Selection
    */
    __IO uint32_t GPB_MFPL;

    /**
     * GPB_MFPH
     * ===================================================================================================
     * Offset: 0x3C  Port B High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PB8MFP    |PB.8 Multi-function Pin Selection
     * |[4:7]   |PB9MFP    |PB.9 Multi-function Pin Selection
     * |[8:11]  |PB10MFP   |PB.10 Multi-function Pin Selection
     * |[12:15] |PB11MFP   |PB.11 Multi-function Pin Selection
     * |[16:19] |PB12MFP   |PB.12 Multi-function Pin Selection
     * |[20:23] |PB13MFP   |PB.13 Multi-function Pin Selection
     * |[24:27] |PB14MFP   |PB.14 Multi-function Pin Selection
     * |[28:31] |PB15MFP   |PB.15 Multi-function Pin Selection
    */
    __IO uint32_t GPB_MFPH;

    /**
     * GPC_MFPL
     * ===================================================================================================
     * Offset: 0x40  Port C Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PC0MFP    |PC.0 Multi-function Pin Selection
     * |[4:7]   |PC1MFP    |PC.1 Multi-function Pin Selection
     * |[8:11]  |PC2MFP    |PC.2 Multi-function Pin Selection
     * |[12:15] |PC3MFP    |PC.3 Multi-function Pin Selection
     * |[16:19] |PC4MFP    |PC.4 Multi-function Pin Selection
     * |[20:23] |PC5MFP    |PC.5 Multi-function Pin Selection
     * |[24:27] |PC6MFP    |PC.6 Multi-function Pin Selection
     * |[28:31] |PC7MFP    |PC.7 Multi-function Pin Selection
    */
    __IO uint32_t GPC_MFPL;

    /**
     * GPC_MFPH
     * ===================================================================================================
     * Offset: 0x44  Port C High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PC8MFP    |PC.8 Multi-function Pin Selection
     * |[4:7]   |PC9MFP    |PC.9 Multi-function Pin Selection
     * |[8:11]  |PC10MFP   |PC.10 Multi-function Pin Selection
     * |[12:15] |PC11MFP   |PC.11 Multi-function Pin Selection
     * |[16:19] |PC12MFP   |PC.12 Multi-function Pin Selection
     * |[20:23] |PC13MFP   |PC.13 Multi-function Pin Selection
     * |[24:27] |PC14MFP   |PC.14 Multi-function Pin Selection
     * |[28:31] |PC15MFP   |PC.15 Multi-function Pin Selection
    */
    __IO uint32_t GPC_MFPH;

    /**
     * GPD_MFPL
     * ===================================================================================================
     * Offset: 0x48  Port D Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PD0MFP    |PD.0 Multi-function Pin Selection
     * |[4:7]   |PD1MFP    |PD.1 Multi-function Pin Selection
     * |[8:11]  |PD2MFP    |PD.2 Multi-function Pin Selection
     * |[12:15] |PD3MFP    |PD.3 Multi-function Pin Selection
     * |[16:19] |PD4MFP    |PD.4 Multi-function Pin Selection
     * |[20:23] |PD5MFP    |PD.5 Multi-function Pin Selection
     * |[24:27] |PD6MFP    |PD.6 Multi-function Pin Selection
     * |[28:31] |PD7MFP    |PD.7 Multi-function Pin Selection
    */
    __IO uint32_t GPD_MFPL;

    /**
     * GPD_MFPH
     * ===================================================================================================
     * Offset: 0x4C  Port D High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PD8MFP    |PD.8 Multi-function Pin Selection
     * |[4:7]   |PD9MFP    |PD.9 Multi-function Pin Selection
     * |[8:11]  |PD10MFP   |PD.10 Multi-function Pin Selection
     * |[12:15] |PD11MFP   |PD.11 Multi-function Pin Selection
     * |[16:19] |PD12MFP   |PD.12 Multi-function Pin Selection
     * |[20:23] |PD13MFP   |PD.13 Multi-function Pin Selection
     * |[24:27] |PD14MFP   |PD.14 Multi-function Pin Selection
     * |[28:31] |PD15MFP   |PD.15 Multi-function Pin Selection
    */
    __IO uint32_t GPD_MFPH;

    /**
     * GPE_MFPL
     * ===================================================================================================
     * Offset: 0x50  Port E Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PE0MFP    |PE.0 Multi-function Pin Selection
     * |[4:7]   |PE1MFP    |PE.1 Multi-function Pin Selection
     * |[8:11]  |PE2MFP    |PE.2 Multi-function Pin Selection
     * |[12:15] |PE3MFP    |PE.3 Multi-function Pin Selection
     * |[16:19] |PE4MFP    |PE.4 Multi-function Pin Selection
     * |[20:23] |PE5MFP    |PE.5 Multi-function Pin Selection
     * |[24:27] |PE6MFP    |PE.6 Multi-function Pin Selection
     * |[28:31] |PE7MFP    |PE.7 Multi-function Pin Selection
    */
    __IO uint32_t GPE_MFPL;

    /**
     * GPE_MFPH
     * ===================================================================================================
     * Offset: 0x54  Port E High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PE8MFP    |PE.8 Multi-function Pin Selection
     * |[4:7]   |PE9MFP    |PE.9 Multi-function Pin Selection
     * |[8:11]  |PE10MFP   |PE.10 Multi-function Pin Selection
     * |[12:15] |PE11MFP   |PE.11 Multi-function Pin Selection
     * |[16:19] |PE12MFP   |PE.12 Multi-function Pin Selection
     * |[20:23] |PE13MFP   |PE.13 Multi-function Pin Selection
     * |[24:27] |PE14MFP   |PE.14 Multi-function Pin Selection
     * |[28:31] |PE15MFP   |PE.15 Multi-function Pin Selection
    */
    __IO uint32_t GPE_MFPH;

    /**
     * GPF_MFPL
     * ===================================================================================================
     * Offset: 0x58  Port F Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PF0MFP    |PF.0 Multi-function Pin Selection
     * |[4:7]   |PF1MFP    |PF.1 Multi-function Pin Selection
     * |[8:11]  |PF2MFP    |PF.2 Multi-function Pin Selection
     * |[12:15] |PF3MFP    |PF.3 Multi-function Pin Selection
     * |[16:19] |PF4MFP    |PF.4 Multi-function Pin Selection
     * |[20:23] |PF5MFP    |PF.5 Multi-function Pin Selection
     * |[24:27] |PF6MFP    |PF.6 Multi-function Pin Selection
     * |[28:31] |PF7MFP    |PF.7 Multi-function Pin Selection
    */
    __IO uint32_t GPF_MFPL;

    /**
     * GPF_MFPH
     * ===================================================================================================
     * Offset: 0x5C  Port F High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PF8MFP    |PF.8 Multi-function Pin Selection
     * |[4:7]   |PF9MFP    |PF.9 Multi-function Pin Selection
     * |[8:11]  |PF10MFP   |PF.10 Multi-function Pin Selection
     * |[12:15] |PF11MFP   |PF.11 Multi-function Pin Selection
     * |[16:19] |PF12MFP   |PF.12 Multi-function Pin Selection
     * |[20:23] |PF13MFP   |PF.13 Multi-function Pin Selection
     * |[24:27] |PF14MFP   |PF.14 Multi-function Pin Selection
     * |[28:31] |PF15MFP   |PF.15 Multi-function Pin Selection
    */
    __IO uint32_t GPF_MFPH;

    /**
     * GPG_MFPL
     * ===================================================================================================
     * Offset: 0x60  Port G Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PG0MFP    |PG.0 Multi-function Pin Selection
     * |[4:7]   |PG1MFP    |PG.1 Multi-function Pin Selection
     * |[8:11]  |PG2MFP    |PG.2 Multi-function Pin Selection
     * |[12:15] |PG3MFP    |PG.3 Multi-function Pin Selection
     * |[16:19] |PG4MFP    |PG.4 Multi-function Pin Selection
     * |[20:23] |PG5MFP    |PG.5 Multi-function Pin Selection
     * |[24:27] |PG6MFP    |PG.6 Multi-function Pin Selection
     * |[28:31] |PG7MFP    |PG.7 Multi-function Pin Selection
    */
    __IO uint32_t GPG_MFPL;

    /**
     * GPG_MFPH
     * ===================================================================================================
     * Offset: 0x64  Port G High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PG8MFP    |PG.8 Multi-function Pin Selection
     * |[4:7]   |PG9MFP    |PG.9 Multi-function Pin Selection
     * |[8:11]  |PG10MFP   |PG.10 Multi-function Pin Selection
     * |[12:15] |PG11MFP   |PG.11 Multi-function Pin Selection
     * |[16:19] |PG12MFP   |PG.12 Multi-function Pin Selection
     * |[20:23] |PG13MFP   |PG.13 Multi-function Pin Selection
     * |[24:27] |PG14MFP   |PG.14 Multi-function Pin Selection
     * |[28:31] |PG15MFP   |PG.15 Multi-function Pin Selection
    */
    __IO uint32_t GPG_MFPH;

    /**
     * GPH_MFPL
     * ===================================================================================================
     * Offset: 0x68  Port H Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PH0MFP    |PH.0 Multi-function Pin Selection
     * |[4:7]   |PH1MFP    |PH.1 Multi-function Pin Selection
     * |[8:11]  |PH2MFP    |PH.2 Multi-function Pin Selection
     * |[12:15] |PH3MFP    |PH.3 Multi-function Pin Selection
     * |[16:19] |PH4MFP    |PH.4 Multi-function Pin Selection
     * |[20:23] |PH5MFP    |PH.5 Multi-function Pin Selection
     * |[24:27] |PH6MFP    |PH.6 Multi-function Pin Selection
     * |[28:31] |PH7MFP    |PH.7 Multi-function Pin Selection
    */
    __IO uint32_t GPH_MFPL;

    /**
     * GPH_MFPH
     * ===================================================================================================
     * Offset: 0x6C  Port H High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PH8MFP    |PH.8 Multi-function Pin Selection
     * |[4:7]   |PH9MFP    |PH.9 Multi-function Pin Selection
     * |[8:11]  |PH10MFP   |PH.10 Multi-function Pin Selection
     * |[12:15] |PH11MFP   |PH.11 Multi-function Pin Selection
     * |[16:19] |PH12MFP   |PH.12 Multi-function Pin Selection
     * |[20:23] |PH13MFP   |PH.13 Multi-function Pin Selection
     * |[24:27] |PH14MFP   |PH.14 Multi-function Pin Selection
     * |[28:31] |PH15MFP   |PH.15 Multi-function Pin Selection
    */
    __IO uint32_t GPH_MFPH;

    /**
     * GPI_MFPL
     * ===================================================================================================
     * Offset: 0x70  Port I Low Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PI0MFP    |PI.0 Multi-function Pin Selection
     * |[4:7]   |PI1MFP    |PI.1 Multi-function Pin Selection
     * |[8:11]  |PI2MFP    |PI.2 Multi-function Pin Selection
     * |[12:15] |PI3MFP    |PI.3 Multi-function Pin Selection
     * |[16:19] |PI4MFP    |PI.4 Multi-function Pin Selection
     * |[20:23] |PI5MFP    |PI.5 Multi-function Pin Selection
     * |[24:27] |PI6MFP    |PI.6 Multi-function Pin Selection
     * |[28:31] |PI7MFP    |PI.7 Multi-function Pin Selection
    */
    __IO uint32_t GPI_MFPL;

    /**
     * GPI_MFPH
     * ===================================================================================================
     * Offset: 0x74  Port I High Byte Multi-function Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |PI8MFP    |PI.8 Multi-function Pin Selection
     * |[4:7]   |PI9MFP    |PI.9 Multi-function Pin Selection
     * |[8:11]  |PI10MFP   |PI.10 Multi-function Pin Selection
     * |[12:15] |PI11MFP   |PI.11 Multi-function Pin Selection
     * |[16:19] |PI12MFP   |PI.12 Multi-function Pin Selection
     * |[20:23] |PI13MFP   |PI.13 Multi-function Pin Selection
     * |[24:27] |PI14MFP   |PI.14 Multi-function Pin Selection
     * |[28:31] |PI15MFP   |PI.15 Multi-function Pin Selection
    */
    __IO uint32_t GPI_MFPH;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[18];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * SRAM_INTCTL
     * ===================================================================================================
     * Offset: 0xC0  SRAM Failed Interrupt Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |PERRIEN   |SRAM Parity Check Fail Interrupt Enable Control
     * |        |          |0 = SRAMF INT Disabled.
     * |        |          |1 = SRAMF INT Enabled when SRAM fail flag.
    */
    __IO uint32_t SRAM_INTCTL;

    /**
     * SRAM_STATUS
     * ===================================================================================================
     * Offset: 0xC4  SRAM Parity Check Error Flag
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |PERRIF0   |SRAM Parity Check Fail Flag
     * |        |          |0 = No first 1 SRAM fail.
     * |        |          |1 = First SRAM Fail.
     * |[1]     |PERRIF1   |SRAM Parity Check Fail Flag
     * |        |          |0 = 2nd SRAM fail.
     * |        |          |1 = 2nd SRAM Fail.
    */
    __IO uint32_t SRAM_STATUS;

    /**
     * SRAM0_ERRADDR
     * ===================================================================================================
     * Offset: 0xC8  SRAM Parity Check Error First Address1
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |PERRADDR  |First SRAM parity check fail address
    */
    __I  uint32_t SRAM0_ERRADDR;

    /**
     * SRAM1_ERRADDR
     * ===================================================================================================
     * Offset: 0xCC  SRAM Parity Check Error First Address2
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |PERRADDR  |2nd
     * |        |          |SRAM parity check fail address
    */
    __I  uint32_t SRAM1_ERRADDR;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[8];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * IRCTCTL
     * ===================================================================================================
     * Offset: 0xF0  IRC Trim Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |FREQSEL   |Trim Frequency Selection
     * |        |          |This field indicates the target frequency of HIRC auto trim.
     * |        |          |If no any target frequency is selected (FREQSEL is 00), the HIRC auto trim function is disabled.
     * |        |          |During auto trim operation, if clock error detected with CESTOPEN is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
     * |        |          |00 = Disable HIRC auto trim function.
     * |        |          |01 = Enable HIRC auto trim function and trim HIRC to 22.1184 MHz.
     * |        |          |10 = Enable HIRC auto trim function and trim HIRC to 24 MHz.
     * |        |          |11 = Reserved.
     * |[4:5]   |LOOPSEL   |Trim Calculation Loop
     * |        |          |This field defines that trim value calculation is based on how many 32.768 kHz clock.
     * |        |          |For example, if CALCLOOP is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.
     * |        |          |00 = Trim value calculation is based on average difference in 4 32.768 kHz clock.
     * |        |          |01 = Trim value calculation is based on average difference in 8 32.768 kHz clock.
     * |        |          |10 = Trim value calculation is based on average difference in 16 32.768 kHz clock.
     * |        |          |11 = Trim value calculation is based on average difference in 32 32.768 kHz clock.
     * |[6:7]   |RETRYCNT  |Trim Value Update Limitation Count
     * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC locked.
     * |        |          |Once the HIRC locked, the internal trim value update counter will be reset.
     * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and FREQSEL will be cleared to 00.
     * |        |          |00 = Trim retry count limitation is 64.
     * |        |          |01 = Trim retry count limitation is 128.
     * |        |          |10 = Trim retry count limitation is 256.
     * |        |          |11 = Trim retry count limitation is 512.
     * |[8]     |CESTOPEN  |Clock Error Stop Enable Control
     * |        |          |0 = The trim operation is keep going if clock is inaccuracy.
     * |        |          |1 = The trim operation is stopped if clock is inaccuracy.
    */
    __IO uint32_t IRCTCTL;

    /**
     * IRCTIEN
     * ===================================================================================================
     * Offset: 0xF4  IRC Trim Interrupt Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1]     |TFAILIEN  |Trim Failure Interrupt Enable
     * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by FREQSEL.
     * |        |          |If this bit is high and TFAILIF is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
     * |        |          |0 = Disable TFAILIF status to trigger an interrupt to CPU.
     * |        |          |1 = Enable TFAILIF status to trigger an interrupt to CPU.
     * |[2]     |CLKEIEN   |Clock Error Interrupt Enable Control
     * |        |          |This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.
     * |        |          |If this bit is set to1, and CLKERRIF is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
     * |        |          |0 = Disable CLKERRIF status to trigger an interrupt to CPU.
     * |        |          |1 = Enable CLKERRIF status to trigger an interrupt to CPU.
    */
    __IO uint32_t IRCTIEN;

    /**
     * IRCTISTS
     * ===================================================================================================
     * Offset: 0xF8  IRC Trim Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |FREQLOCK  |HIRC Frequency Lock Status
     * |        |          |This bit indicates the HIRC frequency is locked.
     * |        |          |This is a status bit and doesn't trigger any interrupt.
     * |[1]     |TFAILIF   |Trim Failure Interrupt Status
     * |        |          |This bit indicates that HIRC trim value update limitation count reached and the HIRC clock frequency still doesn't be locked.
     * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL will be cleared to 00 by hardware automatically.
     * |        |          |If this bit is set and TFAILIEN is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
     * |        |          |Write 1 to clear this to 0.
     * |        |          |0 = Trim value update limitation count does not reach.
     * |        |          |1 = Trim value update limitation count reached and HIRC frequency still not locked.
     * |[2]     |CLKERRIF  |Clock Error Interrupt Status
     * |        |          |When the frequency of external 32.768 kHz low-speed crystal or HIRC is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy
     * |        |          |Once this bit is set to 1, the auto trim operation stopped and FREQSEL will be cleared to 00 by hardware automatically if CESTOPEN is set to 1.
     * |        |          |If this bit is set and CLKEIEN is high, an interrupt will be triggered to notify the clock frequency is inaccuracy.
     * |        |          |Write 1 to clear this to 0.
     * |        |          |0 = Clock frequency is accuracy.
     * |        |          |1 = Clock frequency is inaccuracy.
    */
    __IO uint32_t IRCTISTS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE3[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * REGLCTL
     * ===================================================================================================
     * Offset: 0x100  Register Write-Protection Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |REGLCTL   |Register Write-Protection Disable Index (Read Only)
     * |        |          |0 = Write-protection Enabled for writing protected registers.
     * |        |          |Any write to the protected register is ignored.
     * |        |          |1 = Write-protection Disabled for writing protected registers.
     * |        |          |The Protected registers are:
     * |        |          |SYS_IPRST0: address 0x4000_0008
     * |        |          |SYS_BODCTL: address 0x4000_0018
     * |        |          |SYS_PORCTL: address 0x4000_0024
     * |        |          |PWRCON: address 0x4000_0200 (bit[6] is not protected for power wake-up interrupt clear)
     * |        |          |APBCLK bit[0]: address 0x4000_0208 (bit[0] is watchdog clock enable)
     * |        |          |CLKSEL0: address 0x4000_0210 (for HCLK and CPU STCLK clock source select)
     * |        |          |CLKSEL1 bit[1:0]: address 0x4000_0214 (for watchdog clock source select)
     * |        |          |NMI_SEL]: address 0x4000_0300 (for NMI source select)
     * |        |          |ISPCON: address 0x4000_5000 (Flash ISP Control register)
     * |        |          |ISPTRG: address 0x4000_5010 (ISP Trigger Control register)
     * |        |          |WTCR: address 0x4004_0000
     * |        |          |FATCON: address 0x4000_5018
     * |        |          |TAMPER: address 0x400E_1000
     * |[0:7]   |SYS_REGLCTL|Register Write-Protection Code (Write Only)
     * |        |          |Some registers have write-protection function.
     * |        |          |Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field.
     * |        |          |After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal write.
    */
    __IO  uint32_t REGLCTL;

} SYS_T;

/**
    @addtogroup SYS_CONST SYS Bit Field Definition
    Constant Definitions for SYS Controller
@{ */

#define SYS_PDID_SYS_PDID_Pos            (0)                                               /*!< SYS_T::PDID: SYS_PDID Position            */
#define SYS_PDID_SYS_PDID_Msk            (0xfffffffful << SYS_PDID_SYS_PDID_Pos)           /*!< SYS_T::PDID: SYS_PDID Mask                */

#define SYS_RSTSTS_PORF_Pos              (0)                                               /*!< SYS_T::RSTSTS: PORF Position              */
#define SYS_RSTSTS_PORF_Msk              (0x1ul << SYS_RSTSTS_PORF_Pos)                    /*!< SYS_T::RSTSTS: PORF Mask                  */

#define SYS_RSTSTS_PINRF_Pos             (1)                                               /*!< SYS_T::RSTSTS: PINRF Position             */
#define SYS_RSTSTS_PINRF_Msk             (0x1ul << SYS_RSTSTS_PINRF_Pos)                   /*!< SYS_T::RSTSTS: PINRF Mask                 */

#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS_T::RSTSTS: WDTRF Position             */
#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS_T::RSTSTS: WDTRF Mask                 */

#define SYS_RSTSTS_LVRF_Pos              (3)                                               /*!< SYS_T::RSTSTS: LVRF Position              */
#define SYS_RSTSTS_LVRF_Msk              (0x1ul << SYS_RSTSTS_LVRF_Pos)                    /*!< SYS_T::RSTSTS: LVRF Mask                  */

#define SYS_RSTSTS_BODRF_Pos             (4)                                               /*!< SYS_T::RSTSTS: BODRF Position             */
#define SYS_RSTSTS_BODRF_Msk             (0x1ul << SYS_RSTSTS_BODRF_Pos)                   /*!< SYS_T::RSTSTS: BODRF Mask                 */

#define SYS_RSTSTS_SYSRF_Pos             (5)                                               /*!< SYS_T::RSTSTS: SYSRF Position             */
#define SYS_RSTSTS_SYSRF_Msk             (0x1ul << SYS_RSTSTS_SYSRF_Pos)                   /*!< SYS_T::RSTSTS: SYSRF Mask                 */

#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS_T::RSTSTS: CPURF Position             */
#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS_T::RSTSTS: CPURF Mask                 */

#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS_T::IPRST0: CHIPRST Position           */
#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS_T::IPRST0: CHIPRST Mask               */

#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS_T::IPRST0: CPURST Position            */
#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS_T::IPRST0: CPURST Mask                */

#define SYS_IPRST0_PDMARST_Pos           (2)                                               /*!< SYS_T::IPRST0: PDMARST Position           */
#define SYS_IPRST0_PDMARST_Msk           (0x1ul << SYS_IPRST0_PDMARST_Pos)                 /*!< SYS_T::IPRST0: PDMARST Mask               */

#define SYS_IPRST0_EBIRST_Pos            (3)                                               /*!< SYS_T::IPRST0: EBIRST Position            */
#define SYS_IPRST0_EBIRST_Msk            (0x1ul << SYS_IPRST0_EBIRST_Pos)                  /*!< SYS_T::IPRST0: EBIRST Mask                */

#define SYS_IPRST0_USBHRST_Pos           (4)                                               /*!< SYS_T::IPRST0: USBHRST Position           */
#define SYS_IPRST0_USBHRST_Msk           (0x1ul << SYS_IPRST0_USBHRST_Pos)                 /*!< SYS_T::IPRST0: USBHRST Mask               */

#define SYS_IPRST0_EMACRST_Pos           (5)                                               /*!< SYS_T::IPRST0: EMACRST Position            */
#define SYS_IPRST0_EMACRST_Msk           (0x1ul << SYS_IPRST0_EMACRST_Pos)                 /*!< SYS_T::IPRST0: EMACRST Mask                */

#define SYS_IPRST0_SDHRST_Pos            (6)                                               /*!< SYS_T::IPRST0: SDHRST Position        */
#define SYS_IPRST0_SDHRST_Msk            (0x1ul << SYS_IPRST0_SDHRST_Pos)                  /*!< SYS_T::IPRST0: SDHRST Mask            */

#define SYS_IPRST0_CRCRST_Pos            (7)                                               /*!< SYS_T::IPRST0: CRCRST Position            */
#define SYS_IPRST0_CRCRST_Msk            (0x1ul << SYS_IPRST0_CRCRST_Pos)                  /*!< SYS_T::IPRST0: CRCRST Mask                */

#define SYS_IPRST0_CAPRST_Pos            (8)                                               /*!< SYS_T::IPRST0: CAPRST Position            */
#define SYS_IPRST0_CAPRST_Msk            (0x1ul << SYS_IPRST0_CAPRST_Pos)                  /*!< SYS_T::IPRST0: CAPRST Mask                */

#define SYS_IPRST0_CRPTRST_Pos           (12)                                              /*!< SYS_T::IPRST0: CRPTRST Position           */
#define SYS_IPRST0_CRPTRST_Msk           (0x1ul << SYS_IPRST0_CRPTRST_Pos)                 /*!< SYS_T::IPRST0: CRPTRST Mask               */

#define SYS_IPRST1_GPIORST_Pos           (1)                                               /*!< SYS_T::IPRST1: GPIORST Position           */
#define SYS_IPRST1_GPIORST_Msk           (0x1ul << SYS_IPRST1_GPIORST_Pos)                 /*!< SYS_T::IPRST1: GPIORST Mask               */

#define SYS_IPRST1_TMR0RST_Pos           (2)                                               /*!< SYS_T::IPRST1: TMR0RST Position           */
#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS_T::IPRST1: TMR0RST Mask               */

#define SYS_IPRST1_TMR1RST_Pos           (3)                                               /*!< SYS_T::IPRST1: TMR1RST Position           */
#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS_T::IPRST1: TMR1RST Mask               */

#define SYS_IPRST1_TMR2RST_Pos           (4)                                               /*!< SYS_T::IPRST1: TMR2RST Position           */
#define SYS_IPRST1_TMR2RST_Msk           (0x1ul << SYS_IPRST1_TMR2RST_Pos)                 /*!< SYS_T::IPRST1: TMR2RST Mask               */

#define SYS_IPRST1_TMR3RST_Pos           (5)                                               /*!< SYS_T::IPRST1: TMR3RST Position           */
#define SYS_IPRST1_TMR3RST_Msk           (0x1ul << SYS_IPRST1_TMR3RST_Pos)                 /*!< SYS_T::IPRST1: TMR3RST Mask               */

#define SYS_IPRST1_ACMPRST_Pos           (7)                                               /*!< SYS_T::IPRST1: ACMPRST Position           */
#define SYS_IPRST1_ACMPRST_Msk           (0x1ul << SYS_IPRST1_ACMPRST_Pos)                 /*!< SYS_T::IPRST1: ACMPRST Mask               */

#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS_T::IPRST1: I2C0RST Position           */
#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS_T::IPRST1: I2C0RST Mask               */

#define SYS_IPRST1_I2C1RST_Pos           (9)                                               /*!< SYS_T::IPRST1: I2C1RST Position           */
#define SYS_IPRST1_I2C1RST_Msk           (0x1ul << SYS_IPRST1_I2C1RST_Pos)                 /*!< SYS_T::IPRST1: I2C1RST Mask               */

#define SYS_IPRST1_I2C2RST_Pos           (10)                                              /*!< SYS_T::IPRST1: I2C2RST Position           */
#define SYS_IPRST1_I2C2RST_Msk           (0x1ul << SYS_IPRST1_I2C2RST_Pos)                 /*!< SYS_T::IPRST1: I2C2RST Mask               */

#define SYS_IPRST1_I2C3RST_Pos           (11)                                              /*!< SYS_T::IPRST1: I2C3RST Position           */
#define SYS_IPRST1_I2C3RST_Msk           (0x1ul << SYS_IPRST1_I2C3RST_Pos)                 /*!< SYS_T::IPRST1: I2C3RST Mask               */

#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS_T::IPRST1: SPI0RST Position           */
#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS_T::IPRST1: SPI0RST Mask               */

#define SYS_IPRST1_SPI1RST_Pos           (13)                                              /*!< SYS_T::IPRST1: SPI1RST Position           */
#define SYS_IPRST1_SPI1RST_Msk           (0x1ul << SYS_IPRST1_SPI1RST_Pos)                 /*!< SYS_T::IPRST1: SPI1RST Mask               */

#define SYS_IPRST1_SPI2RST_Pos           (14)                                              /*!< SYS_T::IPRST1: SPI2RST Position           */
#define SYS_IPRST1_SPI2RST_Msk           (0x1ul << SYS_IPRST1_SPI2RST_Pos)                 /*!< SYS_T::IPRST1: SPI2RST Mask               */

#define SYS_IPRST1_SPI3RST_Pos           (15)                                              /*!< SYS_T::IPRST1: SPI3RST Position           */
#define SYS_IPRST1_SPI3RST_Msk           (0x1ul << SYS_IPRST1_SPI3RST_Pos)                 /*!< SYS_T::IPRST1: SPI3RST Mask               */

#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS_T::IPRST1: UART0RST Position          */
#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS_T::IPRST1: UART0RST Mask              */

#define SYS_IPRST1_UART1RST_Pos          (17)                                              /*!< SYS_T::IPRST1: UART1RST Position          */
#define SYS_IPRST1_UART1RST_Msk          (0x1ul << SYS_IPRST1_UART1RST_Pos)                /*!< SYS_T::IPRST1: UART1RST Mask              */

#define SYS_IPRST1_UART2RST_Pos          (18)                                              /*!< SYS_T::IPRST1: UART2RST Position          */
#define SYS_IPRST1_UART2RST_Msk          (0x1ul << SYS_IPRST1_UART2RST_Pos)                /*!< SYS_T::IPRST1: UART2RST Mask              */

#define SYS_IPRST1_UART3RST_Pos          (19)                                              /*!< SYS_T::IPRST1: UART3RST Position          */
#define SYS_IPRST1_UART3RST_Msk          (0x1ul << SYS_IPRST1_UART3RST_Pos)                /*!< SYS_T::IPRST1: UART3RST Mask              */

#define SYS_IPRST1_UART4RST_Pos          (20)                                              /*!< SYS_T::IPRST1: UART4RST Position          */
#define SYS_IPRST1_UART4RST_Msk          (0x1ul << SYS_IPRST1_UART4RST_Pos)                /*!< SYS_T::IPRST1: UART4RST Mask              */

#define SYS_IPRST1_UART5RST_Pos          (21)                                              /*!< SYS_T::IPRST1: UART5RST Position          */
#define SYS_IPRST1_UART5RST_Msk          (0x1ul << SYS_IPRST1_UART5RST_Pos)                /*!< SYS_T::IPRST1: UART5RST Mask              */

#define SYS_IPRST1_CAN0RST_Pos           (24)                                              /*!< SYS_T::IPRST1: CAN0RST Position           */
#define SYS_IPRST1_CAN0RST_Msk           (0x1ul << SYS_IPRST1_CAN0RST_Pos)                 /*!< SYS_T::IPRST1: CAN0RST Mask               */

#define SYS_IPRST1_CAN1RST_Pos           (25)                                              /*!< SYS_T::IPRST1: CAN1RST Position           */
#define SYS_IPRST1_CAN1RST_Msk           (0x1ul << SYS_IPRST1_CAN1RST_Pos)                 /*!< SYS_T::IPRST1: CAN1RST Mask               */

#define SYS_IPRST1_USBDRST_Pos           (27)                                              /*!< SYS_T::IPRST1: USBDRST Position           */
#define SYS_IPRST1_USBDRST_Msk           (0x1ul << SYS_IPRST1_USBDRST_Pos)                 /*!< SYS_T::IPRST1: USBDRST Mask               */

#define SYS_IPRST1_ADCRST_Pos            (28)                                              /*!< SYS_T::IPRST1: ADCRST Position           */
#define SYS_IPRST1_ADCRST_Msk            (0x1ul << SYS_IPRST1_ADCRST_Pos)                 /*!< SYS_T::IPRST1: ADCRST Mask               */

#define SYS_IPRST1_I2S0RST_Pos           (29)                                              /*!< SYS_T::IPRST1: I2SRST Position            */
#define SYS_IPRST1_I2S0RST_Msk           (0x1ul << SYS_IPRST1_I2S0RST_Pos)                 /*!< SYS_T::IPRST1: I2SRST Mask                */

#define SYS_IPRST1_I2S1RST_Pos           (30)                                              /*!< SYS_T::IPRST1: I2S1RST Position           */
#define SYS_IPRST1_I2S1RST_Msk           (0x1ul << SYS_IPRST1_I2S1RST_Pos)                 /*!< SYS_T::IPRST1: I2S1RST Mask               */

#define SYS_IPRST1_PS2RST_Pos            (31)                                              /*!< SYS_T::IPRST1: PS2RST Position            */
#define SYS_IPRST1_PS2RST_Msk            (0x1ul << SYS_IPRST1_PS2RST_Pos)                  /*!< SYS_T::IPRST1: PS2RST Mask                */

#define SYS_IPRST2_SC0RST_Pos            (0)                                               /*!< SYS_T::IPRST2: SC0RST Position            */
#define SYS_IPRST2_SC0RST_Msk            (0x1ul << SYS_IPRST2_SC0RST_Pos)                  /*!< SYS_T::IPRST2: SC0RST Mask                */

#define SYS_IPRST2_SC1RST_Pos            (1)                                               /*!< SYS_T::IPRST2: SC1RST Position            */
#define SYS_IPRST2_SC1RST_Msk            (0x1ul << SYS_IPRST2_SC1RST_Pos)                  /*!< SYS_T::IPRST2: SC1RST Mask                */

#define SYS_IPRST2_SC2RST_Pos            (2)                                               /*!< SYS_T::IPRST2: SC2RST Position            */
#define SYS_IPRST2_SC2RST_Msk            (0x1ul << SYS_IPRST2_SC2RST_Pos)                  /*!< SYS_T::IPRST2: SC2RST Mask                */

#define SYS_IPRST2_SC3RST_Pos            (3)                                               /*!< SYS_T::IPRST2: SC3RST Position            */
#define SYS_IPRST2_SC3RST_Msk            (0x1ul << SYS_IPRST2_SC3RST_Pos)                  /*!< SYS_T::IPRST2: SC3RST Mask                */

#define SYS_IPRST2_SC4RST_Pos            (4)                                               /*!< SYS_T::IPRST2: SC4RST Position            */
#define SYS_IPRST2_SC4RST_Msk            (0x1ul << SYS_IPRST2_SC4RST_Pos)                  /*!< SYS_T::IPRST2: SC4RST Mask                */

#define SYS_IPRST2_SC5RST_Pos            (5)                                               /*!< SYS_T::IPRST2: SC5RST Position            */
#define SYS_IPRST2_SC5RST_Msk            (0x1ul << SYS_IPRST2_SC5RST_Pos)                  /*!< SYS_T::IPRST2: SC5RST Mask                */

#define SYS_IPRST2_I2C4RST_Pos           (8)                                               /*!< SYS_T::IPRST2: I2C4RST Position           */
#define SYS_IPRST2_I2C4RST_Msk           (0x1ul << SYS_IPRST2_I2C4RST_Pos)                 /*!< SYS_T::IPRST2: I2C4RST Mask               */

#define SYS_IPRST2_PWM0RST_Pos           (16)                                              /*!< SYS_T::IPRST2: PWM0RST Position           */
#define SYS_IPRST2_PWM0RST_Msk           (0x1ul << SYS_IPRST2_PWM0RST_Pos)                 /*!< SYS_T::IPRST2: PWM0RST Mask               */

#define SYS_IPRST2_PWM1RST_Pos           (17)                                              /*!< SYS_T::IPRST2: PWM1RST Position           */
#define SYS_IPRST2_PWM1RST_Msk           (0x1ul << SYS_IPRST2_PWM1RST_Pos)                 /*!< SYS_T::IPRST2: PWM1RST Mask               */

#define SYS_IPRST2_QEI0RST_Pos           (22)                                              /*!< SYS_T::IPRST2: QEI0RST Position           */
#define SYS_IPRST2_QEI0RST_Msk           (0x1ul << SYS_IPRST2_QEI0RST_Pos)                 /*!< SYS_T::IPRST2: QEI0RST Mask               */

#define SYS_IPRST2_QEI1RST_Pos           (23)                                              /*!< SYS_T::IPRST2: QEI1RST Position           */
#define SYS_IPRST2_QEI1RST_Msk           (0x1ul << SYS_IPRST2_QEI1RST_Pos)                 /*!< SYS_T::IPRST2: QEI1RST Mask               */

#define SYS_BODCTL_BODEN_Pos             (0)                                               /*!< SYS_T::BODCTL: BODEN Position             */
#define SYS_BODCTL_BODEN_Msk             (0x1ul << SYS_BODCTL_BODEN_Pos)                   /*!< SYS_T::BODCTL: BODEN Mask                 */

#define SYS_BODCTL_BODVL_Pos             (1)                                               /*!< SYS_T::BODCTL: BODVL Position             */
#define SYS_BODCTL_BODVL_Msk             (0x3ul << SYS_BODCTL_BODVL_Pos)                   /*!< SYS_T::BODCTL: BODVL Mask                 */

#define SYS_BODCTL_BODRSTEN_Pos          (3)                                               /*!< SYS_T::BODCTL: BODRSTEN Position          */
#define SYS_BODCTL_BODRSTEN_Msk          (0x1ul << SYS_BODCTL_BODRSTEN_Pos)                /*!< SYS_T::BODCTL: BODRSTEN Mask              */

#define SYS_BODCTL_BODINTF_Pos           (4)                                               /*!< SYS_T::BODCTL: BODINTF Position           */
#define SYS_BODCTL_BODINTF_Msk           (0x1ul << SYS_BODCTL_BODINTF_Pos)                 /*!< SYS_T::BODCTL: BODINTF Mask               */

#define SYS_BODCTL_BODLPM_Pos            (5)                                               /*!< SYS_T::BODCTL: BODLPM Position            */
#define SYS_BODCTL_BODLPM_Msk            (0x1ul << SYS_BODCTL_BODLPM_Pos)                  /*!< SYS_T::BODCTL: BODLPM Mask                */

#define SYS_BODCTL_BODOUT_Pos            (6)                                               /*!< SYS_T::BODCTL: BODOUT Position            */
#define SYS_BODCTL_BODOUT_Msk            (0x1ul << SYS_BODCTL_BODOUT_Pos)                  /*!< SYS_T::BODCTL: BODOUT Mask                */

#define SYS_BODCTL_LVREN_Pos             (7)                                               /*!< SYS_T::BODCTL: LVREN Position             */
#define SYS_BODCTL_LVREN_Msk             (0x1ul << SYS_BODCTL_LVREN_Pos)                   /*!< SYS_T::BODCTL: LVREN Mask                 */

#define SYS_TEMPCTL_VTEMPEN_Pos          (0)                                               /*!< SYS_T::TEMPCTL: VTEMPEN Position          */
#define SYS_TEMPCTL_VTEMPEN_Msk          (0x1ul << SYS_TEMPCTL_VTEMPEN_Pos)                /*!< SYS_T::TEMPCTL: VTEMPEN Mask              */

#define SYS_VCID_VCID_Pos                (0)                                               /*!< SYS_T::VCID: VCID Position                */
#define SYS_VCID_VCID_Msk                (0xfffful << SYS_VCID_VCID_Pos)                   /*!< SYS_T::VCID: VCID Mask                    */

#define SYS_PORCTL_POROFF_Pos            (0)                                               /*!< SYS_T::PORCTL: POROFF Position            */
#define SYS_PORCTL_POROFF_Msk            (0xfffful << SYS_PORCTL_POROFF_Pos)               /*!< SYS_T::PORCTL: POROFF Mask                */

#define SYS_VREFCTL_VREFCTL_Pos          (0)                                               /*!< SYS_T::VREFCTL: VREFCTL Position          */
#define SYS_VREFCTL_VREFCTL_Msk          (0x1ful << SYS_VREFCTL_VREFCTL_Pos)               /*!< SYS_T::VREFCTL: VREFCTL Mask              */

#define SYS_VREFCTL_ADCMODESEL_Pos       (8)                                               /*!< SYS_T::VREFCTL: ADCMODESEL Position       */
#define SYS_VREFCTL_ADCMODESEL_Msk       (0x1ul << SYS_VREFCTL_ADCMODESEL_Pos)             /*!< SYS_T::VREFCTL: ADCMODESEL Mask           */

#define SYS_VREFCTL_PWMSYNCMODE_Pos      (9)                                               /*!< SYS_T::VREFCTL: PWMSYNCMODE Position      */
#define SYS_VREFCTL_PWMSYNCMODE_Msk      (0x1ul << SYS_VREFCTL_PWMSYNCMODE_Pos)            /*!< SYS_T::VREFCTL: PWMSYNCMODE Mask          */

#define SYS_USBPHY_USBROLE_Pos           (0)                                               /*!< SYS_T::USBPHY: USBROLE Position           */
#define SYS_USBPHY_USBROLE_Msk           (0x3ul << SYS_USBPHY_USBROLE_Pos)                 /*!< SYS_T::USBPHY: USBROLE Mask               */

#define SYS_USBPHY_LDO33EN_Pos           (8)                                               /*!< SYS_T::USBPHY: LDO33EN Position           */
#define SYS_USBPHY_LDO33EN_Msk           (0x1ul << SYS_USBPHY_LDO33EN_Pos)                 /*!< SYS_T::USBPHY: LDO33EN Mask               */

#define SYS_GPA_MFPL_PA0MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPL: PA0MFP Position          */
#define SYS_GPA_MFPL_PA0MFP_Msk          (0xful << SYS_GPA_MFPL_PA0MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA0MFP Mask              */

#define SYS_GPA_MFPL_PA1MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPL: PA1MFP Position          */
#define SYS_GPA_MFPL_PA1MFP_Msk          (0xful << SYS_GPA_MFPL_PA1MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA1MFP Mask              */

#define SYS_GPA_MFPL_PA2MFP_Pos          (8)                                               /*!< SYS_T::GPA_MFPL: PA2MFP Position          */
#define SYS_GPA_MFPL_PA2MFP_Msk          (0xful << SYS_GPA_MFPL_PA2MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA2MFP Mask              */

#define SYS_GPA_MFPL_PA3MFP_Pos          (12)                                              /*!< SYS_T::GPA_MFPL: PA3MFP Position          */
#define SYS_GPA_MFPL_PA3MFP_Msk          (0xful << SYS_GPA_MFPL_PA3MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA3MFP Mask              */

#define SYS_GPA_MFPL_PA4MFP_Pos          (16)                                              /*!< SYS_T::GPA_MFPL: PA4MFP Position          */
#define SYS_GPA_MFPL_PA4MFP_Msk          (0xful << SYS_GPA_MFPL_PA4MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA4MFP Mask              */

#define SYS_GPA_MFPL_PA5MFP_Pos          (20)                                              /*!< SYS_T::GPA_MFPL: PA5MFP Position          */
#define SYS_GPA_MFPL_PA5MFP_Msk          (0xful << SYS_GPA_MFPL_PA5MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA5MFP Mask              */

#define SYS_GPA_MFPL_PA6MFP_Pos          (24)                                              /*!< SYS_T::GPA_MFPL: PA6MFP Position          */
#define SYS_GPA_MFPL_PA6MFP_Msk          (0xful << SYS_GPA_MFPL_PA6MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA6MFP Mask              */

#define SYS_GPA_MFPL_PA7MFP_Pos          (28)                                              /*!< SYS_T::GPA_MFPL: PA7MFP Position          */
#define SYS_GPA_MFPL_PA7MFP_Msk          (0xful << SYS_GPA_MFPL_PA7MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA7MFP Mask              */

#define SYS_GPA_MFPH_PA8MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPH: PA8MFP Position          */
#define SYS_GPA_MFPH_PA8MFP_Msk          (0xful << SYS_GPA_MFPH_PA8MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA8MFP Mask              */

#define SYS_GPA_MFPH_PA9MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPH: PA9MFP Position          */
#define SYS_GPA_MFPH_PA9MFP_Msk          (0xful << SYS_GPA_MFPH_PA9MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA9MFP Mask              */

#define SYS_GPA_MFPH_PA10MFP_Pos         (8)                                               /*!< SYS_T::GPA_MFPH: PA10MFP Position         */
#define SYS_GPA_MFPH_PA10MFP_Msk         (0xful << SYS_GPA_MFPH_PA10MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA10MFP Mask             */

#define SYS_GPA_MFPH_PA11MFP_Pos         (12)                                              /*!< SYS_T::GPA_MFPH: PA11MFP Position         */
#define SYS_GPA_MFPH_PA11MFP_Msk         (0xful << SYS_GPA_MFPH_PA11MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA11MFP Mask             */

#define SYS_GPA_MFPH_PA12MFP_Pos         (16)                                              /*!< SYS_T::GPA_MFPH: PA12MFP Position         */
#define SYS_GPA_MFPH_PA12MFP_Msk         (0xful << SYS_GPA_MFPH_PA12MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA12MFP Mask             */

#define SYS_GPA_MFPH_PA13MFP_Pos         (20)                                              /*!< SYS_T::GPA_MFPH: PA13MFP Position         */
#define SYS_GPA_MFPH_PA13MFP_Msk         (0xful << SYS_GPA_MFPH_PA13MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA13MFP Mask             */

#define SYS_GPA_MFPH_PA14MFP_Pos         (24)                                              /*!< SYS_T::GPA_MFPH: PA14MFP Position         */
#define SYS_GPA_MFPH_PA14MFP_Msk         (0xful << SYS_GPA_MFPH_PA14MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA14MFP Mask             */

#define SYS_GPA_MFPH_PA15MFP_Pos         (28)                                              /*!< SYS_T::GPA_MFPH: PA15MFP Position         */
#define SYS_GPA_MFPH_PA15MFP_Msk         (0xful << SYS_GPA_MFPH_PA15MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA15MFP Mask             */

#define SYS_GPB_MFPL_PB0MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPL: PB0MFP Position          */
#define SYS_GPB_MFPL_PB0MFP_Msk          (0xful << SYS_GPB_MFPL_PB0MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB0MFP Mask              */

#define SYS_GPB_MFPL_PB1MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPL: PB1MFP Position          */
#define SYS_GPB_MFPL_PB1MFP_Msk          (0xful << SYS_GPB_MFPL_PB1MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB1MFP Mask              */

#define SYS_GPB_MFPL_PB2MFP_Pos          (8)                                               /*!< SYS_T::GPB_MFPL: PB2MFP Position          */
#define SYS_GPB_MFPL_PB2MFP_Msk          (0xful << SYS_GPB_MFPL_PB2MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB2MFP Mask              */

#define SYS_GPB_MFPL_PB3MFP_Pos          (12)                                              /*!< SYS_T::GPB_MFPL: PB3MFP Position          */
#define SYS_GPB_MFPL_PB3MFP_Msk          (0xful << SYS_GPB_MFPL_PB3MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB3MFP Mask              */

#define SYS_GPB_MFPL_PB4MFP_Pos          (16)                                              /*!< SYS_T::GPB_MFPL: PB4MFP Position          */
#define SYS_GPB_MFPL_PB4MFP_Msk          (0xful << SYS_GPB_MFPL_PB4MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB4MFP Mask              */

#define SYS_GPB_MFPL_PB5MFP_Pos          (20)                                              /*!< SYS_T::GPB_MFPL: PB5MFP Position          */
#define SYS_GPB_MFPL_PB5MFP_Msk          (0xful << SYS_GPB_MFPL_PB5MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB5MFP Mask              */

#define SYS_GPB_MFPL_PB6MFP_Pos          (24)                                              /*!< SYS_T::GPB_MFPL: PB6MFP Position          */
#define SYS_GPB_MFPL_PB6MFP_Msk          (0xful << SYS_GPB_MFPL_PB6MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB6MFP Mask              */

#define SYS_GPB_MFPL_PB7MFP_Pos          (28)                                              /*!< SYS_T::GPB_MFPL: PB7MFP Position          */
#define SYS_GPB_MFPL_PB7MFP_Msk          (0xful << SYS_GPB_MFPL_PB7MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB7MFP Mask              */

#define SYS_GPB_MFPH_PB8MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPH: PB8MFP Position          */
#define SYS_GPB_MFPH_PB8MFP_Msk          (0xful << SYS_GPB_MFPH_PB8MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB8MFP Mask              */

#define SYS_GPB_MFPH_PB9MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPH: PB9MFP Position          */
#define SYS_GPB_MFPH_PB9MFP_Msk          (0xful << SYS_GPB_MFPH_PB9MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB9MFP Mask              */

#define SYS_GPB_MFPH_PB10MFP_Pos         (8)                                               /*!< SYS_T::GPB_MFPH: PB10MFP Position         */
#define SYS_GPB_MFPH_PB10MFP_Msk         (0xful << SYS_GPB_MFPH_PB10MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB10MFP Mask             */

#define SYS_GPB_MFPH_PB11MFP_Pos         (12)                                              /*!< SYS_T::GPB_MFPH: PB11MFP Position         */
#define SYS_GPB_MFPH_PB11MFP_Msk         (0xful << SYS_GPB_MFPH_PB11MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB11MFP Mask             */

#define SYS_GPB_MFPH_PB12MFP_Pos         (16)                                              /*!< SYS_T::GPB_MFPH: PB12MFP Position         */
#define SYS_GPB_MFPH_PB12MFP_Msk         (0xful << SYS_GPB_MFPH_PB12MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB12MFP Mask             */

#define SYS_GPB_MFPH_PB13MFP_Pos         (20)                                              /*!< SYS_T::GPB_MFPH: PB13MFP Position         */
#define SYS_GPB_MFPH_PB13MFP_Msk         (0xful << SYS_GPB_MFPH_PB13MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB13MFP Mask             */

#define SYS_GPB_MFPH_PB14MFP_Pos         (24)                                              /*!< SYS_T::GPB_MFPH: PB14MFP Position         */
#define SYS_GPB_MFPH_PB14MFP_Msk         (0xful << SYS_GPB_MFPH_PB14MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB14MFP Mask             */

#define SYS_GPB_MFPH_PB15MFP_Pos         (28)                                              /*!< SYS_T::GPB_MFPH: PB15MFP Position         */
#define SYS_GPB_MFPH_PB15MFP_Msk         (0xful << SYS_GPB_MFPH_PB15MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB15MFP Mask             */

#define SYS_GPC_MFPL_PC0MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPL: PC0MFP Position          */
#define SYS_GPC_MFPL_PC0MFP_Msk          (0xful << SYS_GPC_MFPL_PC0MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC0MFP Mask              */

#define SYS_GPC_MFPL_PC1MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPL: PC1MFP Position          */
#define SYS_GPC_MFPL_PC1MFP_Msk          (0xful << SYS_GPC_MFPL_PC1MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC1MFP Mask              */

#define SYS_GPC_MFPL_PC2MFP_Pos          (8)                                               /*!< SYS_T::GPC_MFPL: PC2MFP Position          */
#define SYS_GPC_MFPL_PC2MFP_Msk          (0xful << SYS_GPC_MFPL_PC2MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC2MFP Mask              */

#define SYS_GPC_MFPL_PC3MFP_Pos          (12)                                              /*!< SYS_T::GPC_MFPL: PC3MFP Position          */
#define SYS_GPC_MFPL_PC3MFP_Msk          (0xful << SYS_GPC_MFPL_PC3MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC3MFP Mask              */

#define SYS_GPC_MFPL_PC4MFP_Pos          (16)                                              /*!< SYS_T::GPC_MFPL: PC4MFP Position          */
#define SYS_GPC_MFPL_PC4MFP_Msk          (0xful << SYS_GPC_MFPL_PC4MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC4MFP Mask              */

#define SYS_GPC_MFPL_PC5MFP_Pos          (20)                                              /*!< SYS_T::GPC_MFPL: PC5MFP Position          */
#define SYS_GPC_MFPL_PC5MFP_Msk          (0xful << SYS_GPC_MFPL_PC5MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC5MFP Mask              */

#define SYS_GPC_MFPL_PC6MFP_Pos          (24)                                              /*!< SYS_T::GPC_MFPL: PC6MFP Position          */
#define SYS_GPC_MFPL_PC6MFP_Msk          (0xful << SYS_GPC_MFPL_PC6MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC6MFP Mask              */

#define SYS_GPC_MFPL_PC7MFP_Pos          (28)                                              /*!< SYS_T::GPC_MFPL: PC7MFP Position          */
#define SYS_GPC_MFPL_PC7MFP_Msk          (0xful << SYS_GPC_MFPL_PC7MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC7MFP Mask              */

#define SYS_GPC_MFPH_PC8MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPH: PC8MFP Position          */
#define SYS_GPC_MFPH_PC8MFP_Msk          (0xful << SYS_GPC_MFPH_PC8MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC8MFP Mask              */

#define SYS_GPC_MFPH_PC9MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPH: PC9MFP Position          */
#define SYS_GPC_MFPH_PC9MFP_Msk          (0xful << SYS_GPC_MFPH_PC9MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC9MFP Mask              */

#define SYS_GPC_MFPH_PC10MFP_Pos         (8)                                               /*!< SYS_T::GPC_MFPH: PC10MFP Position         */
#define SYS_GPC_MFPH_PC10MFP_Msk         (0xful << SYS_GPC_MFPH_PC10MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC10MFP Mask             */

#define SYS_GPC_MFPH_PC11MFP_Pos         (12)                                              /*!< SYS_T::GPC_MFPH: PC11MFP Position         */
#define SYS_GPC_MFPH_PC11MFP_Msk         (0xful << SYS_GPC_MFPH_PC11MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC11MFP Mask             */

#define SYS_GPC_MFPH_PC12MFP_Pos         (16)                                              /*!< SYS_T::GPC_MFPH: PC12MFP Position         */
#define SYS_GPC_MFPH_PC12MFP_Msk         (0xful << SYS_GPC_MFPH_PC12MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC12MFP Mask             */

#define SYS_GPC_MFPH_PC13MFP_Pos         (20)                                              /*!< SYS_T::GPC_MFPH: PC13MFP Position         */
#define SYS_GPC_MFPH_PC13MFP_Msk         (0xful << SYS_GPC_MFPH_PC13MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC13MFP Mask             */

#define SYS_GPC_MFPH_PC14MFP_Pos         (24)                                              /*!< SYS_T::GPC_MFPH: PC14MFP Position         */
#define SYS_GPC_MFPH_PC14MFP_Msk         (0xful << SYS_GPC_MFPH_PC14MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC14MFP Mask             */

#define SYS_GPC_MFPH_PC15MFP_Pos         (28)                                              /*!< SYS_T::GPC_MFPH: PC15MFP Position         */
#define SYS_GPC_MFPH_PC15MFP_Msk         (0xful << SYS_GPC_MFPH_PC15MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC15MFP Mask             */

#define SYS_GPD_MFPL_PD0MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPL: PD0MFP Position          */
#define SYS_GPD_MFPL_PD0MFP_Msk          (0xful << SYS_GPD_MFPL_PD0MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD0MFP Mask              */

#define SYS_GPD_MFPL_PD1MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPL: PD1MFP Position          */
#define SYS_GPD_MFPL_PD1MFP_Msk          (0xful << SYS_GPD_MFPL_PD1MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD1MFP Mask              */

#define SYS_GPD_MFPL_PD2MFP_Pos          (8)                                               /*!< SYS_T::GPD_MFPL: PD2MFP Position          */
#define SYS_GPD_MFPL_PD2MFP_Msk          (0xful << SYS_GPD_MFPL_PD2MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD2MFP Mask              */

#define SYS_GPD_MFPL_PD3MFP_Pos          (12)                                              /*!< SYS_T::GPD_MFPL: PD3MFP Position          */
#define SYS_GPD_MFPL_PD3MFP_Msk          (0xful << SYS_GPD_MFPL_PD3MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD3MFP Mask              */

#define SYS_GPD_MFPL_PD4MFP_Pos          (16)                                              /*!< SYS_T::GPD_MFPL: PD4MFP Position          */
#define SYS_GPD_MFPL_PD4MFP_Msk          (0xful << SYS_GPD_MFPL_PD4MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD4MFP Mask              */

#define SYS_GPD_MFPL_PD5MFP_Pos          (20)                                              /*!< SYS_T::GPD_MFPL: PD5MFP Position          */
#define SYS_GPD_MFPL_PD5MFP_Msk          (0xful << SYS_GPD_MFPL_PD5MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD5MFP Mask              */

#define SYS_GPD_MFPL_PD6MFP_Pos          (24)                                              /*!< SYS_T::GPD_MFPL: PD6MFP Position          */
#define SYS_GPD_MFPL_PD6MFP_Msk          (0xful << SYS_GPD_MFPL_PD6MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD6MFP Mask              */

#define SYS_GPD_MFPL_PD7MFP_Pos          (28)                                              /*!< SYS_T::GPD_MFPL: PD7MFP Position          */
#define SYS_GPD_MFPL_PD7MFP_Msk          (0xful << SYS_GPD_MFPL_PD7MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD7MFP Mask              */

#define SYS_GPD_MFPH_PD8MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPH: PD8MFP Position          */
#define SYS_GPD_MFPH_PD8MFP_Msk          (0xful << SYS_GPD_MFPH_PD8MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD8MFP Mask              */

#define SYS_GPD_MFPH_PD9MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPH: PD9MFP Position          */
#define SYS_GPD_MFPH_PD9MFP_Msk          (0xful << SYS_GPD_MFPH_PD9MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD9MFP Mask              */

#define SYS_GPD_MFPH_PD10MFP_Pos         (8)                                               /*!< SYS_T::GPD_MFPH: PD10MFP Position         */
#define SYS_GPD_MFPH_PD10MFP_Msk         (0xful << SYS_GPD_MFPH_PD10MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD10MFP Mask             */

#define SYS_GPD_MFPH_PD11MFP_Pos         (12)                                              /*!< SYS_T::GPD_MFPH: PD11MFP Position         */
#define SYS_GPD_MFPH_PD11MFP_Msk         (0xful << SYS_GPD_MFPH_PD11MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD11MFP Mask             */

#define SYS_GPD_MFPH_PD12MFP_Pos         (16)                                              /*!< SYS_T::GPD_MFPH: PD12MFP Position         */
#define SYS_GPD_MFPH_PD12MFP_Msk         (0xful << SYS_GPD_MFPH_PD12MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD12MFP Mask             */

#define SYS_GPD_MFPH_PD13MFP_Pos         (20)                                              /*!< SYS_T::GPD_MFPH: PD13MFP Position         */
#define SYS_GPD_MFPH_PD13MFP_Msk         (0xful << SYS_GPD_MFPH_PD13MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD13MFP Mask             */

#define SYS_GPD_MFPH_PD14MFP_Pos         (24)                                              /*!< SYS_T::GPD_MFPH: PD14MFP Position         */
#define SYS_GPD_MFPH_PD14MFP_Msk         (0xful << SYS_GPD_MFPH_PD14MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD14MFP Mask             */

#define SYS_GPD_MFPH_PD15MFP_Pos         (28)                                              /*!< SYS_T::GPD_MFPH: PD15MFP Position         */
#define SYS_GPD_MFPH_PD15MFP_Msk         (0xful << SYS_GPD_MFPH_PD15MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD15MFP Mask             */

#define SYS_GPE_MFPL_PE0MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPL: PE0MFP Position          */
#define SYS_GPE_MFPL_PE0MFP_Msk          (0xful << SYS_GPE_MFPL_PE0MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE0MFP Mask              */

#define SYS_GPE_MFPL_PE1MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPL: PE1MFP Position          */
#define SYS_GPE_MFPL_PE1MFP_Msk          (0xful << SYS_GPE_MFPL_PE1MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE1MFP Mask              */

#define SYS_GPE_MFPL_PE2MFP_Pos          (8)                                               /*!< SYS_T::GPE_MFPL: PE2MFP Position          */
#define SYS_GPE_MFPL_PE2MFP_Msk          (0xful << SYS_GPE_MFPL_PE2MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE2MFP Mask              */

#define SYS_GPE_MFPL_PE3MFP_Pos          (12)                                              /*!< SYS_T::GPE_MFPL: PE3MFP Position          */
#define SYS_GPE_MFPL_PE3MFP_Msk          (0xful << SYS_GPE_MFPL_PE3MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE3MFP Mask              */

#define SYS_GPE_MFPL_PE4MFP_Pos          (16)                                              /*!< SYS_T::GPE_MFPL: PE4MFP Position          */
#define SYS_GPE_MFPL_PE4MFP_Msk          (0xful << SYS_GPE_MFPL_PE4MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE4MFP Mask              */

#define SYS_GPE_MFPL_PE5MFP_Pos          (20)                                              /*!< SYS_T::GPE_MFPL: PE5MFP Position          */
#define SYS_GPE_MFPL_PE5MFP_Msk          (0xful << SYS_GPE_MFPL_PE5MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE5MFP Mask              */

#define SYS_GPE_MFPL_PE6MFP_Pos          (24)                                              /*!< SYS_T::GPE_MFPL: PE6MFP Position          */
#define SYS_GPE_MFPL_PE6MFP_Msk          (0xful << SYS_GPE_MFPL_PE6MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE6MFP Mask              */

#define SYS_GPE_MFPL_PE7MFP_Pos          (28)                                              /*!< SYS_T::GPE_MFPL: PE7MFP Position          */
#define SYS_GPE_MFPL_PE7MFP_Msk          (0xful << SYS_GPE_MFPL_PE7MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE7MFP Mask              */

#define SYS_GPE_MFPH_PE8MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPH: PE8MFP Position          */
#define SYS_GPE_MFPH_PE8MFP_Msk          (0xful << SYS_GPE_MFPH_PE8MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE8MFP Mask              */

#define SYS_GPE_MFPH_PE9MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPH: PE9MFP Position          */
#define SYS_GPE_MFPH_PE9MFP_Msk          (0xful << SYS_GPE_MFPH_PE9MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE9MFP Mask              */

#define SYS_GPE_MFPH_PE10MFP_Pos         (8)                                               /*!< SYS_T::GPE_MFPH: PE10MFP Position         */
#define SYS_GPE_MFPH_PE10MFP_Msk         (0xful << SYS_GPE_MFPH_PE10MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE10MFP Mask             */

#define SYS_GPE_MFPH_PE11MFP_Pos         (12)                                              /*!< SYS_T::GPE_MFPH: PE11MFP Position         */
#define SYS_GPE_MFPH_PE11MFP_Msk         (0xful << SYS_GPE_MFPH_PE11MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE11MFP Mask             */

#define SYS_GPE_MFPH_PE12MFP_Pos         (16)                                              /*!< SYS_T::GPE_MFPH: PE12MFP Position         */
#define SYS_GPE_MFPH_PE12MFP_Msk         (0xful << SYS_GPE_MFPH_PE12MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE12MFP Mask             */

#define SYS_GPE_MFPH_PE13MFP_Pos         (20)                                              /*!< SYS_T::GPE_MFPH: PE13MFP Position         */
#define SYS_GPE_MFPH_PE13MFP_Msk         (0xful << SYS_GPE_MFPH_PE13MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE13MFP Mask             */

#define SYS_GPE_MFPH_PE14MFP_Pos         (24)                                              /*!< SYS_T::GPE_MFPH: PE14MFP Position         */
#define SYS_GPE_MFPH_PE14MFP_Msk         (0xful << SYS_GPE_MFPH_PE14MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE14MFP Mask             */

#define SYS_GPE_MFPH_PE15MFP_Pos         (28)                                              /*!< SYS_T::GPE_MFPH: PE15MFP Position         */
#define SYS_GPE_MFPH_PE15MFP_Msk         (0xful << SYS_GPE_MFPH_PE15MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE15MFP Mask             */

#define SYS_GPF_MFPL_PF0MFP_Pos          (0)                                               /*!< SYS_T::GPF_MFPL: PF0MFP Position          */
#define SYS_GPF_MFPL_PF0MFP_Msk          (0xful << SYS_GPF_MFPL_PF0MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF0MFP Mask              */

#define SYS_GPF_MFPL_PF1MFP_Pos          (4)                                               /*!< SYS_T::GPF_MFPL: PF1MFP Position          */
#define SYS_GPF_MFPL_PF1MFP_Msk          (0xful << SYS_GPF_MFPL_PF1MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF1MFP Mask              */

#define SYS_GPF_MFPL_PF2MFP_Pos          (8)                                               /*!< SYS_T::GPF_MFPL: PF2MFP Position          */
#define SYS_GPF_MFPL_PF2MFP_Msk          (0xful << SYS_GPF_MFPL_PF2MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF2MFP Mask              */

#define SYS_GPF_MFPL_PF3MFP_Pos          (12)                                              /*!< SYS_T::GPF_MFPL: PF3MFP Position          */
#define SYS_GPF_MFPL_PF3MFP_Msk          (0xful << SYS_GPF_MFPL_PF3MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF3MFP Mask              */

#define SYS_GPF_MFPL_PF4MFP_Pos          (16)                                              /*!< SYS_T::GPF_MFPL: PF4MFP Position          */
#define SYS_GPF_MFPL_PF4MFP_Msk          (0xful << SYS_GPF_MFPL_PF4MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF4MFP Mask              */

#define SYS_GPF_MFPL_PF5MFP_Pos          (20)                                              /*!< SYS_T::GPF_MFPL: PF5MFP Position          */
#define SYS_GPF_MFPL_PF5MFP_Msk          (0xful << SYS_GPF_MFPL_PF5MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF5MFP Mask              */

#define SYS_GPF_MFPL_PF6MFP_Pos          (24)                                              /*!< SYS_T::GPF_MFPL: PF6MFP Position          */
#define SYS_GPF_MFPL_PF6MFP_Msk          (0xful << SYS_GPF_MFPL_PF6MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF6MFP Mask              */

#define SYS_GPF_MFPL_PF7MFP_Pos          (28)                                              /*!< SYS_T::GPF_MFPL: PF7MFP Position          */
#define SYS_GPF_MFPL_PF7MFP_Msk          (0xful << SYS_GPF_MFPL_PF7MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF7MFP Mask              */

#define SYS_GPF_MFPH_PF8MFP_Pos          (0)                                               /*!< SYS_T::GPF_MFPH: PF8MFP Position          */
#define SYS_GPF_MFPH_PF8MFP_Msk          (0xful << SYS_GPF_MFPH_PF8MFP_Pos)                /*!< SYS_T::GPF_MFPH: PF8MFP Mask              */

#define SYS_GPF_MFPH_PF9MFP_Pos          (4)                                               /*!< SYS_T::GPF_MFPH: PF9MFP Position          */
#define SYS_GPF_MFPH_PF9MFP_Msk          (0xful << SYS_GPF_MFPH_PF9MFP_Pos)                /*!< SYS_T::GPF_MFPH: PF9MFP Mask              */

#define SYS_GPF_MFPH_PF10MFP_Pos         (8)                                               /*!< SYS_T::GPF_MFPH: PF10MFP Position         */
#define SYS_GPF_MFPH_PF10MFP_Msk         (0xful << SYS_GPF_MFPH_PF10MFP_Pos)               /*!< SYS_T::GPF_MFPH: PF10MFP Mask             */

#define SYS_GPF_MFPH_PF11MFP_Pos         (12)                                              /*!< SYS_T::GPF_MFPH: PF11MFP Position         */
#define SYS_GPF_MFPH_PF11MFP_Msk         (0xful << SYS_GPF_MFPH_PF11MFP_Pos)               /*!< SYS_T::GPF_MFPH: PF11MFP Mask             */

#define SYS_GPF_MFPH_PF12MFP_Pos         (16)                                              /*!< SYS_T::GPF_MFPH: PF12MFP Position         */
#define SYS_GPF_MFPH_PF12MFP_Msk         (0xful << SYS_GPF_MFPH_PF12MFP_Pos)               /*!< SYS_T::GPF_MFPH: PF12MFP Mask             */

#define SYS_GPF_MFPH_PF13MFP_Pos         (20)                                              /*!< SYS_T::GPF_MFPH: PF13MFP Position         */
#define SYS_GPF_MFPH_PF13MFP_Msk         (0xful << SYS_GPF_MFPH_PF13MFP_Pos)               /*!< SYS_T::GPF_MFPH: PF13MFP Mask             */

#define SYS_GPF_MFPH_PF14MFP_Pos         (24)                                              /*!< SYS_T::GPF_MFPH: PF14MFP Position         */
#define SYS_GPF_MFPH_PF14MFP_Msk         (0xful << SYS_GPF_MFPH_PF14MFP_Pos)               /*!< SYS_T::GPF_MFPH: PF14MFP Mask             */

#define SYS_GPF_MFPH_PF15MFP_Pos         (28)                                              /*!< SYS_T::GPF_MFPH: PF15MFP Position         */
#define SYS_GPF_MFPH_PF15MFP_Msk         (0xful << SYS_GPF_MFPH_PF15MFP_Pos)               /*!< SYS_T::GPF_MFPH: PF15MFP Mask             */

#define SYS_GPG_MFPL_PG0MFP_Pos          (0)                                               /*!< SYS_T::GPG_MFPL: PG0MFP Position          */
#define SYS_GPG_MFPL_PG0MFP_Msk          (0xful << SYS_GPG_MFPL_PG0MFP_Pos)                /*!< SYS_T::GPG_MFPL: PG0MFP Mask              */

#define SYS_GPG_MFPL_PG1MFP_Pos          (4)                                               /*!< SYS_T::GPG_MFPL: PG1MFP Position          */
#define SYS_GPG_MFPL_PG1MFP_Msk          (0xful << SYS_GPG_MFPL_PG1MFP_Pos)                /*!< SYS_T::GPG_MFPL: PG1MFP Mask              */

#define SYS_GPG_MFPL_PG2MFP_Pos          (8)                                               /*!< SYS_T::GPG_MFPL: PG2MFP Position          */
#define SYS_GPG_MFPL_PG2MFP_Msk          (0xful << SYS_GPG_MFPL_PG2MFP_Pos)                /*!< SYS_T::GPG_MFPL: PG2MFP Mask              */

#define SYS_GPG_MFPL_PG3MFP_Pos          (12)                                              /*!< SYS_T::GPG_MFPL: PG3MFP Position          */
#define SYS_GPG_MFPL_PG3MFP_Msk          (0xful << SYS_GPG_MFPL_PG3MFP_Pos)                /*!< SYS_T::GPG_MFPL: PG3MFP Mask              */

#define SYS_GPG_MFPL_PG4MFP_Pos          (16)                                              /*!< SYS_T::GPG_MFPL: PG4MFP Position          */
#define SYS_GPG_MFPL_PG4MFP_Msk          (0xful << SYS_GPG_MFPL_PG4MFP_Pos)                /*!< SYS_T::GPG_MFPL: PG4MFP Mask              */

#define SYS_GPG_MFPL_PG5MFP_Pos          (20)                                              /*!< SYS_T::GPG_MFPL: PG5MFP Position          */
#define SYS_GPG_MFPL_PG5MFP_Msk          (0xful << SYS_GPG_MFPL_PG5MFP_Pos)                /*!< SYS_T::GPG_MFPL: PG5MFP Mask              */

#define SYS_GPG_MFPL_PG6MFP_Pos          (24)                                              /*!< SYS_T::GPG_MFPL: PG6MFP Position          */
#define SYS_GPG_MFPL_PG6MFP_Msk          (0xful << SYS_GPG_MFPL_PG6MFP_Pos)                /*!< SYS_T::GPG_MFPL: PG6MFP Mask              */

#define SYS_GPG_MFPL_PG7MFP_Pos          (28)                                              /*!< SYS_T::GPG_MFPL: PG7MFP Position          */
#define SYS_GPG_MFPL_PG7MFP_Msk          (0xful << SYS_GPG_MFPL_PG7MFP_Pos)                /*!< SYS_T::GPG_MFPL: PG7MFP Mask              */

#define SYS_GPG_MFPH_PG8MFP_Pos          (0)                                               /*!< SYS_T::GPG_MFPH: PG8MFP Position          */
#define SYS_GPG_MFPH_PG8MFP_Msk          (0xful << SYS_GPG_MFPH_PG8MFP_Pos)                /*!< SYS_T::GPG_MFPH: PG8MFP Mask              */

#define SYS_GPG_MFPH_PG9MFP_Pos          (4)                                               /*!< SYS_T::GPG_MFPH: PG9MFP Position          */
#define SYS_GPG_MFPH_PG9MFP_Msk          (0xful << SYS_GPG_MFPH_PG9MFP_Pos)                /*!< SYS_T::GPG_MFPH: PG9MFP Mask              */

#define SYS_GPG_MFPH_PG10MFP_Pos         (8)                                               /*!< SYS_T::GPG_MFPH: PG10MFP Position         */
#define SYS_GPG_MFPH_PG10MFP_Msk         (0xful << SYS_GPG_MFPH_PG10MFP_Pos)               /*!< SYS_T::GPG_MFPH: PG10MFP Mask             */

#define SYS_GPG_MFPH_PG11MFP_Pos         (12)                                              /*!< SYS_T::GPG_MFPH: PG11MFP Position         */
#define SYS_GPG_MFPH_PG11MFP_Msk         (0xful << SYS_GPG_MFPH_PG11MFP_Pos)               /*!< SYS_T::GPG_MFPH: PG11MFP Mask             */

#define SYS_GPG_MFPH_PG12MFP_Pos         (16)                                              /*!< SYS_T::GPG_MFPH: PG12MFP Position         */
#define SYS_GPG_MFPH_PG12MFP_Msk         (0xful << SYS_GPG_MFPH_PG12MFP_Pos)               /*!< SYS_T::GPG_MFPH: PG12MFP Mask             */

#define SYS_GPG_MFPH_PG13MFP_Pos         (20)                                              /*!< SYS_T::GPG_MFPH: PG13MFP Position         */
#define SYS_GPG_MFPH_PG13MFP_Msk         (0xful << SYS_GPG_MFPH_PG13MFP_Pos)               /*!< SYS_T::GPG_MFPH: PG13MFP Mask             */

#define SYS_GPG_MFPH_PG14MFP_Pos         (24)                                              /*!< SYS_T::GPG_MFPH: PG14MFP Position         */
#define SYS_GPG_MFPH_PG14MFP_Msk         (0xful << SYS_GPG_MFPH_PG14MFP_Pos)               /*!< SYS_T::GPG_MFPH: PG14MFP Mask             */

#define SYS_GPG_MFPH_PG15MFP_Pos         (28)                                              /*!< SYS_T::GPG_MFPH: PG15MFP Position         */
#define SYS_GPG_MFPH_PG15MFP_Msk         (0xful << SYS_GPG_MFPH_PG15MFP_Pos)               /*!< SYS_T::GPG_MFPH: PG15MFP Mask             */

#define SYS_GPH_MFPL_PH0MFP_Pos          (0)                                               /*!< SYS_T::GPH_MFPL: PH0MFP Position          */
#define SYS_GPH_MFPL_PH0MFP_Msk          (0xful << SYS_GPH_MFPL_PH0MFP_Pos)                /*!< SYS_T::GPH_MFPL: PH0MFP Mask              */

#define SYS_GPH_MFPL_PH1MFP_Pos          (4)                                               /*!< SYS_T::GPH_MFPL: PH1MFP Position          */
#define SYS_GPH_MFPL_PH1MFP_Msk          (0xful << SYS_GPH_MFPL_PH1MFP_Pos)                /*!< SYS_T::GPH_MFPL: PH1MFP Mask              */

#define SYS_GPH_MFPL_PH2MFP_Pos          (8)                                               /*!< SYS_T::GPH_MFPL: PH2MFP Position          */
#define SYS_GPH_MFPL_PH2MFP_Msk          (0xful << SYS_GPH_MFPL_PH2MFP_Pos)                /*!< SYS_T::GPH_MFPL: PH2MFP Mask              */

#define SYS_GPH_MFPL_PH3MFP_Pos          (12)                                              /*!< SYS_T::GPH_MFPL: PH3MFP Position          */
#define SYS_GPH_MFPL_PH3MFP_Msk          (0xful << SYS_GPH_MFPL_PH3MFP_Pos)                /*!< SYS_T::GPH_MFPL: PH3MFP Mask              */

#define SYS_GPH_MFPL_PH4MFP_Pos          (16)                                              /*!< SYS_T::GPH_MFPL: PH4MFP Position          */
#define SYS_GPH_MFPL_PH4MFP_Msk          (0xful << SYS_GPH_MFPL_PH4MFP_Pos)                /*!< SYS_T::GPH_MFPL: PH4MFP Mask              */

#define SYS_GPH_MFPL_PH5MFP_Pos          (20)                                              /*!< SYS_T::GPH_MFPL: PH5MFP Position          */
#define SYS_GPH_MFPL_PH5MFP_Msk          (0xful << SYS_GPH_MFPL_PH5MFP_Pos)                /*!< SYS_T::GPH_MFPL: PH5MFP Mask              */

#define SYS_GPH_MFPL_PH6MFP_Pos          (24)                                              /*!< SYS_T::GPH_MFPL: PH6MFP Position          */
#define SYS_GPH_MFPL_PH6MFP_Msk          (0xful << SYS_GPH_MFPL_PH6MFP_Pos)                /*!< SYS_T::GPH_MFPL: PH6MFP Mask              */

#define SYS_GPH_MFPL_PH7MFP_Pos          (28)                                              /*!< SYS_T::GPH_MFPL: PH7MFP Position          */
#define SYS_GPH_MFPL_PH7MFP_Msk          (0xful << SYS_GPH_MFPL_PH7MFP_Pos)                /*!< SYS_T::GPH_MFPL: PH7MFP Mask              */

#define SYS_GPH_MFPH_PH8MFP_Pos          (0)                                               /*!< SYS_T::GPH_MFPH: PH8MFP Position          */
#define SYS_GPH_MFPH_PH8MFP_Msk          (0xful << SYS_GPH_MFPH_PH8MFP_Pos)                /*!< SYS_T::GPH_MFPH: PH8MFP Mask              */

#define SYS_GPH_MFPH_PH9MFP_Pos          (4)                                               /*!< SYS_T::GPH_MFPH: PH9MFP Position          */
#define SYS_GPH_MFPH_PH9MFP_Msk          (0xful << SYS_GPH_MFPH_PH9MFP_Pos)                /*!< SYS_T::GPH_MFPH: PH9MFP Mask              */

#define SYS_GPH_MFPH_PH10MFP_Pos         (8)                                               /*!< SYS_T::GPH_MFPH: PH10MFP Position         */
#define SYS_GPH_MFPH_PH10MFP_Msk         (0xful << SYS_GPH_MFPH_PH10MFP_Pos)               /*!< SYS_T::GPH_MFPH: PH10MFP Mask             */

#define SYS_GPH_MFPH_PH11MFP_Pos         (12)                                              /*!< SYS_T::GPH_MFPH: PH11MFP Position         */
#define SYS_GPH_MFPH_PH11MFP_Msk         (0xful << SYS_GPH_MFPH_PH11MFP_Pos)               /*!< SYS_T::GPH_MFPH: PH11MFP Mask             */

#define SYS_GPH_MFPH_PH12MFP_Pos         (16)                                              /*!< SYS_T::GPH_MFPH: PH12MFP Position         */
#define SYS_GPH_MFPH_PH12MFP_Msk         (0xful << SYS_GPH_MFPH_PH12MFP_Pos)               /*!< SYS_T::GPH_MFPH: PH12MFP Mask             */

#define SYS_GPH_MFPH_PH13MFP_Pos         (20)                                              /*!< SYS_T::GPH_MFPH: PH13MFP Position         */
#define SYS_GPH_MFPH_PH13MFP_Msk         (0xful << SYS_GPH_MFPH_PH13MFP_Pos)               /*!< SYS_T::GPH_MFPH: PH13MFP Mask             */

#define SYS_GPH_MFPH_PH14MFP_Pos         (24)                                              /*!< SYS_T::GPH_MFPH: PH14MFP Position         */
#define SYS_GPH_MFPH_PH14MFP_Msk         (0xful << SYS_GPH_MFPH_PH14MFP_Pos)               /*!< SYS_T::GPH_MFPH: PH14MFP Mask             */

#define SYS_GPH_MFPH_PH15MFP_Pos         (28)                                              /*!< SYS_T::GPH_MFPH: PH15MFP Position         */
#define SYS_GPH_MFPH_PH15MFP_Msk         (0xful << SYS_GPH_MFPH_PH15MFP_Pos)               /*!< SYS_T::GPH_MFPH: PH15MFP Mask             */

#define SYS_GPI_MFPL_PI0MFP_Pos          (0)                                               /*!< SYS_T::GPI_MFPL: PI0MFP Position          */
#define SYS_GPI_MFPL_PI0MFP_Msk          (0xful << SYS_GPI_MFPL_PI0MFP_Pos)                /*!< SYS_T::GPI_MFPL: PI0MFP Mask              */

#define SYS_GPI_MFPL_PI1MFP_Pos          (4)                                               /*!< SYS_T::GPI_MFPL: PI1MFP Position          */
#define SYS_GPI_MFPL_PI1MFP_Msk          (0xful << SYS_GPI_MFPL_PI1MFP_Pos)                /*!< SYS_T::GPI_MFPL: PI1MFP Mask              */

#define SYS_GPI_MFPL_PI2MFP_Pos          (8)                                               /*!< SYS_T::GPI_MFPL: PI2MFP Position          */
#define SYS_GPI_MFPL_PI2MFP_Msk          (0xful << SYS_GPI_MFPL_PI2MFP_Pos)                /*!< SYS_T::GPI_MFPL: PI2MFP Mask              */

#define SYS_GPI_MFPL_PI3MFP_Pos          (12)                                              /*!< SYS_T::GPI_MFPL: PI3MFP Position          */
#define SYS_GPI_MFPL_PI3MFP_Msk          (0xful << SYS_GPI_MFPL_PI3MFP_Pos)                /*!< SYS_T::GPI_MFPL: PI3MFP Mask              */

#define SYS_GPI_MFPL_PI4MFP_Pos          (16)                                              /*!< SYS_T::GPI_MFPL: PI4MFP Position          */
#define SYS_GPI_MFPL_PI4MFP_Msk          (0xful << SYS_GPI_MFPL_PI4MFP_Pos)                /*!< SYS_T::GPI_MFPL: PI4MFP Mask              */

#define SYS_GPI_MFPL_PI5MFP_Pos          (20)                                              /*!< SYS_T::GPI_MFPL: PI5MFP Position          */
#define SYS_GPI_MFPL_PI5MFP_Msk          (0xful << SYS_GPI_MFPL_PI5MFP_Pos)                /*!< SYS_T::GPI_MFPL: PI5MFP Mask              */

#define SYS_GPI_MFPL_PI6MFP_Pos          (24)                                              /*!< SYS_T::GPI_MFPL: PI6MFP Position          */
#define SYS_GPI_MFPL_PI6MFP_Msk          (0xful << SYS_GPI_MFPL_PI6MFP_Pos)                /*!< SYS_T::GPI_MFPL: PI6MFP Mask              */

#define SYS_GPI_MFPL_PI7MFP_Pos          (28)                                              /*!< SYS_T::GPI_MFPL: PI7MFP Position          */
#define SYS_GPI_MFPL_PI7MFP_Msk          (0xful << SYS_GPI_MFPL_PI7MFP_Pos)                /*!< SYS_T::GPI_MFPL: PI7MFP Mask              */

#define SYS_GPI_MFPH_PI8MFP_Pos          (0)                                               /*!< SYS_T::GPI_MFPH: PI8MFP Position          */
#define SYS_GPI_MFPH_PI8MFP_Msk          (0xful << SYS_GPI_MFPH_PI8MFP_Pos)                /*!< SYS_T::GPI_MFPH: PI8MFP Mask              */

#define SYS_GPI_MFPH_PI9MFP_Pos          (4)                                               /*!< SYS_T::GPI_MFPH: PI9MFP Position          */
#define SYS_GPI_MFPH_PI9MFP_Msk          (0xful << SYS_GPI_MFPH_PI9MFP_Pos)                /*!< SYS_T::GPI_MFPH: PI9MFP Mask              */

#define SYS_GPI_MFPH_PI10MFP_Pos         (8)                                               /*!< SYS_T::GPI_MFPH: PI10MFP Position         */
#define SYS_GPI_MFPH_PI10MFP_Msk         (0xful << SYS_GPI_MFPH_PI10MFP_Pos)               /*!< SYS_T::GPI_MFPH: PI10MFP Mask             */

#define SYS_GPI_MFPH_PI11MFP_Pos         (12)                                              /*!< SYS_T::GPI_MFPH: PI11MFP Position         */
#define SYS_GPI_MFPH_PI11MFP_Msk         (0xful << SYS_GPI_MFPH_PI11MFP_Pos)               /*!< SYS_T::GPI_MFPH: PI11MFP Mask             */

#define SYS_GPI_MFPH_PI12MFP_Pos         (16)                                              /*!< SYS_T::GPI_MFPH: PI12MFP Position         */
#define SYS_GPI_MFPH_PI12MFP_Msk         (0xful << SYS_GPI_MFPH_PI12MFP_Pos)               /*!< SYS_T::GPI_MFPH: PI12MFP Mask             */

#define SYS_GPI_MFPH_PI13MFP_Pos         (20)                                              /*!< SYS_T::GPI_MFPH: PI13MFP Position         */
#define SYS_GPI_MFPH_PI13MFP_Msk         (0xful << SYS_GPI_MFPH_PI13MFP_Pos)               /*!< SYS_T::GPI_MFPH: PI13MFP Mask             */

#define SYS_GPI_MFPH_PI14MFP_Pos         (24)                                              /*!< SYS_T::GPI_MFPH: PI14MFP Position         */
#define SYS_GPI_MFPH_PI14MFP_Msk         (0xful << SYS_GPI_MFPH_PI14MFP_Pos)               /*!< SYS_T::GPI_MFPH: PI14MFP Mask             */

#define SYS_GPI_MFPH_PI15MFP_Pos         (28)                                              /*!< SYS_T::GPI_MFPH: PI15MFP Position         */
#define SYS_GPI_MFPH_PI15MFP_Msk         (0xful << SYS_GPI_MFPH_PI15MFP_Pos)               /*!< SYS_T::GPI_MFPH: PI15MFP Mask             */

#define SYS_SRAM_INTCTL_PERRIEN_Pos      (0)                                               /*!< SYS_T::SRAM_INTCTL: PERRIEN Position      */
#define SYS_SRAM_INTCTL_PERRIEN_Msk      (0x1ul << SYS_SRAM_INTCTL_PERRIEN_Pos)            /*!< SYS_T::SRAM_INTCTL: PERRIEN Mask          */

#define SYS_SRAM_STATUS_PERRIF0_Pos      (0)                                               /*!< SYS_T::SRAM_STATUS: PERRIF0 Position      */
#define SYS_SRAM_STATUS_PERRIF0_Msk      (0x1ul << SYS_SRAM_STATUS_PERRIF0_Pos)            /*!< SYS_T::SRAM_STATUS: PERRIF0 Mask          */

#define SYS_SRAM_STATUS_PERRIF1_Pos      (1)                                               /*!< SYS_T::SRAM_STATUS: PERRIF1 Position      */
#define SYS_SRAM_STATUS_PERRIF1_Msk      (0x1ul << SYS_SRAM_STATUS_PERRIF1_Pos)            /*!< SYS_T::SRAM_STATUS: PERRIF1 Mask          */

#define SYS_SRAM0_ERRADDR_PERRADDR_Pos   (0)                                               /*!< SYS_T::SRAM0_ERRADDR: PERRADDR Position   */
#define SYS_SRAM0_ERRADDR_PERRADDR_Msk   (0xfffffffful << SYS_SRAM0_ERRADDR_PERRADDR_Pos)  /*!< SYS_T::SRAM0_ERRADDR: PERRADDR Mask       */

#define SYS_SRAM1_ERRADDR_PERRADDR_Pos   (0)                                               /*!< SYS_T::SRAM1_ERRADDR: PERRADDR Position   */
#define SYS_SRAM1_ERRADDR_PERRADDR_Msk   (0xfffffffful << SYS_SRAM1_ERRADDR_PERRADDR_Pos)  /*!< SYS_T::SRAM1_ERRADDR: PERRADDR Mask       */

#define SYS_IRCTCTL_FREQSEL_Pos          (0)                                               /*!< SYS_T::IRCTCTL: FREQSEL Position          */
#define SYS_IRCTCTL_FREQSEL_Msk          (0x3ul << SYS_IRCTCTL_FREQSEL_Pos)                /*!< SYS_T::IRCTCTL: FREQSEL Mask              */

#define SYS_IRCTCTL_CALCLOOP_Pos         (4)                                               /*!< SYS_T::IRCTCTL: CALCLOOP Position         */
#define SYS_IRCTCTL_CALCLOOP_Msk         (0x3ul << SYS_IRCTCTL_CALCLOOP_Pos)               /*!< SYS_T::IRCTCTL: CALCLOOP Mask             */

#define SYS_IRCTCTL_RETRYCNT_Pos         (6)                                               /*!< SYS_T::IRCTCTL: RETRYCNT Position         */
#define SYS_IRCTCTL_RETRYCNT_Msk         (0x3ul << SYS_IRCTCTL_RETRYCNT_Pos)               /*!< SYS_T::IRCTCTL: RETRYCNT Mask             */

#define SYS_IRCTCTL_CESTOPEN_Pos         (8)                                               /*!< SYS_T::IRCTCTL: CESTOPEN Position         */
#define SYS_IRCTCTL_CESTOPEN_Msk         (0x1ul << SYS_IRCTCTL_CESTOPEN_Pos)               /*!< SYS_T::IRCTCTL: CESTOPEN Mask             */

#define SYS_IRCTIEN_TFAILIEN_Pos         (1)                                               /*!< SYS_T::IRCTIEN: TFAILIEN Position         */
#define SYS_IRCTIEN_TFAILIEN_Msk         (0x1ul << SYS_IRCTIEN_TFAILIEN_Pos)               /*!< SYS_T::IRCTIEN: TFAILIEN Mask             */

#define SYS_IRCTIEN_CLKEIEN_Pos          (2)                                               /*!< SYS_T::IRCTIEN: CLKEIEN Position          */
#define SYS_IRCTIEN_CLKEIEN_Msk          (0x1ul << SYS_IRCTIEN_CLKEIEN_Pos)                /*!< SYS_T::IRCTIEN: CLKEIEN Mask              */

#define SYS_IRCTISTS_FREQLOCK_Pos        (0)                                               /*!< SYS_T::IRCTISTS: FREQLOCK Position        */
#define SYS_IRCTISTS_FREQLOCK_Msk        (0x1ul << SYS_IRCTISTS_FREQLOCK_Pos)              /*!< SYS_T::IRCTISTS: FREQLOCK Mask            */

#define SYS_IRCTISTS_TFAILIF_Pos         (1)                                               /*!< SYS_T::IRCTISTS: TFAILIF Position         */
#define SYS_IRCTISTS_TFAILIF_Msk         (0x1ul << SYS_IRCTISTS_TFAILIF_Pos)               /*!< SYS_T::IRCTISTS: TFAILIF Mask             */

#define SYS_IRCTISTS_CLKERRIF_Pos        (2)                                               /*!< SYS_T::IRCTISTS: CLKERRIF Position        */
#define SYS_IRCTISTS_CLKERRIF_Msk        (0x1ul << SYS_IRCTISTS_CLKERRIF_Pos)              /*!< SYS_T::IRCTISTS: CLKERRIF Mask            */

#define SYS_REGLCTL_REGLCTL_Pos          (0)                                               /*!< SYS_T::REGLCTL: REGLCTL Position          */
#define SYS_REGLCTL_REGLCTL_Msk          (0x1ul << SYS_REGLCTL_REGLCTL_Pos)                /*!< SYS_T::REGLCTL: REGLCTL Mask              */

#define SYS_REGLCTL_SYS_REGLCTL_Pos      (0)                                               /*!< SYS_T::REGLCTL: SYS_REGLCTL Position      */
#define SYS_REGLCTL_SYS_REGLCTL_Msk      (0xfful << SYS_REGLCTL_SYS_REGLCTL_Pos)           /*!< SYS_T::REGLCTL: SYS_REGLCTL Mask          */

/**@}*/ /* SYS_CONST */
/**@}*/ /* end of SYS register group */


/*---------------------- Timer Controller -------------------------*/
/**
    @addtogroup TIMER Timer Controller(TIMER)
    Memory Mapped Structure for TIMER Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  Timer Control and Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |PSC       |PSC Counter
     * |        |          |Timer input clock source is divided by (PSC+1) before it is fed to the timer up counter.
     * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
     * |[16]    |CNTDATEN  |Data Load Enable
     * |        |          |When this bit is set, timer counter value (TIMER_CNT) will be updated continuously to monitor internal 24-bit up counter value as the counter is counting.
     * |        |          |0 = Timer Data Register update Disabled.
     * |        |          |1 = Timer Data Register update Enabled while timer counter is active.
     * |[21]    |TOGDIS1   |Toggle Output 1 Disable
     * |        |          |Setting this bit will disable the Toggle output pins group 1.
     * |        |          |0 = Toggle output pins group 1 Enabled.
     * |        |          |1 = Toggle output pins group 1 Disabled.
     * |        |          |Note: The group1 pins are PB4, PB1, PC6, and PC1.
     * |[22]    |TOGDIS2   |Toggle Output 2 Disable
     * |        |          |Setting this bit will disable the Toggle output pins group 2.
     * |        |          |0 = Toggle output pins group 2 Enabled.
     * |        |          |1 = Toggle output pins group 2 Disabled.
     * |        |          |Note1: If both TOUT1 (group 1 pins) and TOUT2 (group 2 pins) function are enabled, toggle output signal is generated only from TOUT1 pins.
     * |        |          |Note2: The group2 pins are PD1, PE8, PE1, and PD11.
     * |[23]    |WKEN      |Wake-Up Enable
     * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMER_INTSTS[0]) is 1 and INTEN (TIMERX_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
     * |        |          |0 = Wake-up trigger event Disabled if timer interrupt signal generated.
     * |        |          |1 = Wake-up trigger event Enabled if timer interrupt signal generated.
     * |[24]    |EXTCNTEN  |Counter Mode Enable Bit
     * |        |          |This bit is for external counting pin function enabled.
     * |        |          |When timer is used as an event counter, this bit should be set to 1 and select PCLK as timer clock source.
     * |        |          |0 = External counter mode Disabled.
     * |        |          |1 = External counter mode Enabled.
     * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
     * |        |          |This bit indicates the 24-bit up counter status.
     * |        |          |0 = 24-bit up counter is not active.
     * |        |          |1 = 24-bit up counter is active.
     * |[26]    |RSTCNT    |Timer Reset Bit
     * |        |          |Setting this bit will reset the 24-bit up counter value (TIMER_CNT) and also force CNTEN (TIMERX_CTL[30]) to 0 if ACTSTS (TIMERX_CTL[25]) is 1.
     * |        |          |0 = No effect.
     * |        |          |1 = Reset 8-bit PSC counter, 24-bit up counter value and CNTEN bit.
     * |[27:28] |OPMODE    |Timer Operation Mode
     * |        |          |00 = The Timer controller is operated in One-shot mode.
     * |        |          |01 = The Timer controller is operated in Periodic mode.
     * |        |          |10 = The Timer controller is operated in Toggle-output mode.
     * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
     * |[29]    |INTEN     |Interrupt Enable Bit
     * |        |          |0 = Timer Interrupt Disabled.
     * |        |          |1 = Timer Interrupt Enabled.
     * |        |          |If this bit is enabled, when the timer interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.
     * |[30]    |CNTEN     |Timer Enable
     * |        |          |0 = Stops/Suspends counting.
     * |        |          |1 = Starts counting.
     * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TIMERX_CTL[28:27] = 00) when the timer interrupt flag TIF (TIMER_INTSTS[0]) is generated.
     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable (Write Protect)
     * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
     * |        |          |TIMER counter will be held while CPU is held by ICE.
     * |        |          |1 = ICE debug mode acknowledgement Disabled.
     * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
    */
    __IO uint32_t CTL;

    /**
     * CMP
     * ===================================================================================================
     * Offset: 0x04  Timer Compare Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |CMPDAT    |Timer Compared Value
     * |        |          |CMPDAT is a 24-bit compared value register.
     * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMER_INTSTS[0] timer interrupt flag) will set to 1.
     * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
     * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the timer will run into unknown state.
     * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if software writes a new value into CMPDAT field.
     * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest CMPDAT value to be the timer compared value if software writes a new value into CMPDAT field.
    */
    __IO uint32_t CMP;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x08  Timer Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |TIF       |Timer Interrupt Flag
     * |        |          |This bit indicates the interrupt flag status of Timer while TIMER_CNT value reaches to CMPDAT value.
     * |        |          |0 = No effect.
     * |        |          |1 = TIMER_CNT value matches the CMPDAT value.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |[1]     |TWKF      |Timer Wake-Up Flag
     * |        |          |This bit indicates the interrupt wake-up flag status of timer.
     * |        |          |0 = Timer does not cause CPU wake-up.
     * |        |          |1 = CPU wake-up from Idle or power-down mode if timer time-out interrupt signal generated.
     * |        |          |Note: This bit is cleared by writing 1 to it.
    */
    __IO uint32_t INTSTS;

    /**
     * CNT
     * ===================================================================================================
     * Offset: 0x0C  Timer Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |TIMER_CNT |Timer Data Register
     * |        |          |1. EXTCNTEN (TIMERX_CTL[24] ) = 0 : TIMER_CNT is 24- bit counter value.
     * |        |          |User can read TIMER_CNT for getting current 24- bit counter value if TIMERX_CTL[24] is set to 0
     * |        |          |2. EXTCNTEN (TIMERX_CTL[24] ) = 1 : TIMER_CNT is 24- bit event counter value.
     * |        |          |User can read TIMER_CNT for getting current 24- bit event counter value if TIMERX_CTL[24] is 1
    */
    __I  uint32_t CNT;

    /**
     * CAP
     * ===================================================================================================
     * Offset: 0x10  Timer Capture Data Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:23]  |CAPDAT    |Timer Capture Data Register
     * |        |          |When CAPEN (TIMER_EXTCTL[3]) bit is set, CAPFUNCS (TIMER_EXTCTL[4]) bit is 0, and a transition on TMx_EXT pin matched the CAPEDGE (TIMER_EXTCTL[2:1]) setting, CAPIF (TIMER_EINTSTS[0]) will set to 1 and the current timer counter value (TIMER_CNT value) will be auto-loaded into this CAPDAT field.
    */
    __I  uint32_t CAP;

    /**
     * EXTCTL
     * ===================================================================================================
     * Offset: 0x14  Timer External Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CNTPHASE  |Timer External Count Phase
     * |        |          |This bit indicates the detection phase of external counting pin.
     * |        |          |0 = A falling edge of external counting pin will be counted.
     * |        |          |1 = A rising edge of external counting pin will be counted.
     * |[1:2]   |CAPEDGE   |Timer External Pin Edge Detect
     * |        |          |00 = A 1 to 0 transition on TMx_EXT (x= 0~3) pin will be detected.
     * |        |          |01 = A 0 to 1 transition on TMx_EXT (x= 0~3) pin will be detected.
     * |        |          |10 = Either 1 to 0 or 0 to 1 transition on TMx_EXT (x= 0~3) pin will be detected.
     * |        |          |11 = Reserved.
     * |[3]     |CAPEN     |Timer External Pin Enable
     * |        |          |This bit enables the CAPFUNCS (TIMER_EXTCTL[4]) function on the TMx_EXT pin.
     * |        |          |0 = CAPFUNCS function of TMx_EXT (x= 0~3) pin will be ignored.
     * |        |          |1 = CAPFUNCS function of TMx_EXT (x= 0~3) pin is active.
     * |[4]     |CAPFUNCS  |Timer External Reset Counter / Capture Mode Select
     * |        |          |0 = Transition on TMx_EXT (x= 0~3) pin is using to save the 24-bit timer counter value.
     * |        |          |(TIMER_CNT value) to timer capture value (TIMER_CAP value) if CAPIF (TIMER_EINTSTS[0]) is set to 1
     * |        |          |1 = Transition on TMx_EXT (x= 0~3) pin is using to reset the 24-bit timer counter value.
     * |[5]     |CAPIEN    |Timer External Interrupt Enable
     * |        |          |0 = TMx_EXT (x= 0~3) pin detection Interrupt Disabled.
     * |        |          |1 = TMx_EXT (x= 0~3) pin detection Interrupt Enabled.
     * |        |          |CAPIEN is used to enable timer external interrupt.
     * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF = 1.
     * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the TEX pin will cause the CAPIF(TIMER_EINTSTS[0]) interrupt flag to be set then the interrupt signal is generated and sent to NVIC to inform CPU.
     * |[6]     |CAPDBEN   |Timer External Capture Pin De-Bounce Enable
     * |        |          |0 = TMx_EXT (x= 0~3) pin de-bounce Disabled.
     * |        |          |1 = TMx_EXT (x= 0~3) pin de-bounce Enabled.
     * |        |          |If this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.
     * |[7]     |ECNTDBEN  |Timer Counter Pin De-Bounce Enable
     * |        |          |0 = TMx (x= 0~3) pin de-bounce Disabled.
     * |        |          |1 = TMx (x= 0~3) pin de-bounce Enabled.
     * |        |          |If this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.
    */
    __IO uint32_t EXTCTL;

    /**
     * EINTSTS
     * ===================================================================================================
     * Offset: 0x18  Timer External Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CAPIF     |Timer External Interrupt Flag
     * |        |          |This bit indicates the timer external interrupt flag status.
     * |        |          |When CAPEN (TIMER_EXTCTL[3]) bit is set, CAPFUNCS (TIMER_EXTCTL[4]) bit is 0, and a transition on TMx_EXT (x= 0~3) pin matched the CAPEDGE (TIMER_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
     * |        |          |0 = TMx_EXT (x= 0~3) pin interrupt did not occur.
     * |        |          |1 = TMx_EXT (x= 0~3) pin interrupt occurred.
     * |        |          |Note: This bit is cleared by writing 1 to it.
    */
    __IO uint32_t EINTSTS;

} TIMER_T;

/**
    @addtogroup TIMER_CONST TIMER Bit Field Definition
    Constant Definitions for TIMER Controller
@{ */

#define TIMER_CTL_PSC_Pos                  (0)                                             /*!< TIMER_T::CTL: PSC Position                  */
#define TIMER_CTL_PSC_Msk                  (0xfful << TIMER_CTL_PSC_Pos)                   /*!< TIMER_T::CTL: PSC Mask                      */

#define TIMER_CTL_CNTDATEN_Pos             (16)                                            /*!< TIMER_T::CTL: CNTDATEN Position             */
#define TIMER_CTL_CNTDATEN_Msk             (0x1ul << TIMER_CTL_CNTDATEN_Pos)               /*!< TIMER_T::CTL: CNTDATEN Mask                 */

#define TIMER_CTL_TOGDIS1_Pos              (21)                                            /*!< TIMER_T::CTL: TOGDIS1 Position              */
#define TIMER_CTL_TOGDIS1_Msk              (0x1ul << TIMER_CTL_TOGDIS1_Pos)                /*!< TIMER_T::CTL: TOGDIS1 Mask                  */

#define TIMER_CTL_TOGDIS2_Pos              (22)                                            /*!< TIMER_T::CTL: TOGDIS2 Position              */
#define TIMER_CTL_TOGDIS2_Msk              (0x1ul << TIMER_CTL_TOGDIS2_Pos)                /*!< TIMER_T::CTL: TOGDIS2 Mask                  */

#define TIMER_CTL_WKEN_Pos                 (23)                                            /*!< TIMER_T::CTL: WKEN Position                 */
#define TIMER_CTL_WKEN_Msk                 (0x1ul << TIMER_CTL_WKEN_Pos)                   /*!< TIMER_T::CTL: WKEN Mask                     */

#define TIMER_CTL_EXTCNTEN_Pos             (24)                                            /*!< TIMER_T::CTL: EXTCNTEN Position             */
#define TIMER_CTL_EXTCNTEN_Msk             (0x1ul << TIMER_CTL_EXTCNTEN_Pos)               /*!< TIMER_T::CTL: EXTCNTEN Mask                 */

#define TIMER_CTL_ACTSTS_Pos               (25)                                            /*!< TIMER_T::CTL: ACTSTS Position               */
#define TIMER_CTL_ACTSTS_Msk               (0x1ul << TIMER_CTL_ACTSTS_Pos)                 /*!< TIMER_T::CTL: ACTSTS Mask                   */

#define TIMER_CTL_RSTCNT_Pos               (26)                                            /*!< TIMER_T::CTL: RSTCNT Position               */
#define TIMER_CTL_RSTCNT_Msk               (0x1ul << TIMER_CTL_RSTCNT_Pos)                 /*!< TIMER_T::CTL: RSTCNT Mask                   */

#define TIMER_CTL_OPMODE_Pos               (27)                                            /*!< TIMER_T::CTL: OPMODE Position               */
#define TIMER_CTL_OPMODE_Msk               (0x3ul << TIMER_CTL_OPMODE_Pos)                 /*!< TIMER_T::CTL: OPMODE Mask                   */

#define TIMER_CTL_INTEN_Pos                (29)                                            /*!< TIMER_T::CTL: INTEN Position                */
#define TIMER_CTL_INTEN_Msk                (0x1ul << TIMER_CTL_INTEN_Pos)                  /*!< TIMER_T::CTL: INTEN Mask                    */

#define TIMER_CTL_CNTEN_Pos                (30)                                            /*!< TIMER_T::CTL: CNTEN Position                */
#define TIMER_CTL_CNTEN_Msk                (0x1ul << TIMER_CTL_CNTEN_Pos)                  /*!< TIMER_T::CTL: CNTEN Mask                    */

#define TIMER_CTL_ICEDEBUG_Pos             (31)                                            /*!< TIMER_T::CTL: ICEDEBUG Position             */
#define TIMER_CTL_ICEDEBUG_Msk             (0x1ul << TIMER_CTL_ICEDEBUG_Pos)               /*!< TIMER_T::CTL: ICEDEBUG Mask                 */

#define TIMER_CMP_CMPDAT_Pos               (0)                                             /*!< TIMER_T::CMP: CMPDAT Position               */
#define TIMER_CMP_CMPDAT_Msk               (0xfffffful << TIMER_CMP_CMPDAT_Pos)            /*!< TIMER_T::CMP: CMPDAT Mask                   */

#define TIMER_INTSTS_TIF_Pos               (0)                                             /*!< TIMER_T::INTSTS: TIF Position               */
#define TIMER_INTSTS_TIF_Msk               (0x1ul << TIMER_INTSTS_TIF_Pos)                 /*!< TIMER_T::INTSTS: TIF Mask                   */

#define TIMER_INTSTS_TWKF_Pos              (1)                                             /*!< TIMER_T::INTSTS: TWKF Position              */
#define TIMER_INTSTS_TWKF_Msk              (0x1ul << TIMER_INTSTS_TWKF_Pos)                /*!< TIMER_T::INTSTS: TWKF Mask                  */

#define TIMER_CNT_TIMER_CNT_Pos            (0)                                             /*!< TIMER_T::CNT: TIMER_CNT Position            */
#define TIMER_CNT_TIMER_CNT_Msk            (0xfffffful << TIMER_CNT_TIMER_CNT_Pos)         /*!< TIMER_T::CNT: TIMER_CNT Mask                */

#define TIMER_CAP_CAPDAT_Pos               (0)                                             /*!< TIMER_T::CAP: CAPDAT Position               */
#define TIMER_CAP_CAPDAT_Msk               (0xfffffful << TIMER_CAP_CAPDAT_Pos)            /*!< TIMER_T::CAP: CAPDAT Mask                   */

#define TIMER_EXTCTL_CNTPHASE_Pos          (0)                                             /*!< TIMER_T::EXTCTL: CNTPHASE Position          */
#define TIMER_EXTCTL_CNTPHASE_Msk          (0x1ul << TIMER_EXTCTL_CNTPHASE_Pos)            /*!< TIMER_T::EXTCTL: CNTPHASE Mask              */

#define TIMER_EXTCTL_CAPEDGE_Pos           (1)                                             /*!< TIMER_T::EXTCTL: CAPEDGE Position           */
#define TIMER_EXTCTL_CAPEDGE_Msk           (0x3ul << TIMER_EXTCTL_CAPEDGE_Pos)             /*!< TIMER_T::EXTCTL: CAPEDGE Mask               */

#define TIMER_EXTCTL_CAPEN_Pos             (3)                                             /*!< TIMER_T::EXTCTL: CAPEN Position             */
#define TIMER_EXTCTL_CAPEN_Msk             (0x1ul << TIMER_EXTCTL_CAPEN_Pos)               /*!< TIMER_T::EXTCTL: CAPEN Mask                 */

#define TIMER_EXTCTL_CAPFUNCS_Pos          (4)                                             /*!< TIMER_T::EXTCTL: CAPFUNCS Position          */
#define TIMER_EXTCTL_CAPFUNCS_Msk          (0x1ul << TIMER_EXTCTL_CAPFUNCS_Pos)            /*!< TIMER_T::EXTCTL: CAPFUNCS Mask              */

#define TIMER_EXTCTL_CAPIEN_Pos            (5)                                             /*!< TIMER_T::EXTCTL: CAPIEN Position            */
#define TIMER_EXTCTL_CAPIEN_Msk            (0x1ul << TIMER_EXTCTL_CAPIEN_Pos)              /*!< TIMER_T::EXTCTL: CAPIEN Mask                */

#define TIMER_EXTCTL_CAPDBEN_Pos           (6)                                             /*!< TIMER_T::EXTCTL: CAPDBEN Position           */
#define TIMER_EXTCTL_CAPDBEN_Msk           (0x1ul << TIMER_EXTCTL_CAPDBEN_Pos)             /*!< TIMER_T::EXTCTL: CAPDBEN Mask               */

#define TIMER_EXTCTL_ECNTDBEN_Pos          (7)                                             /*!< TIMER_T::EXTCTL: ECNTDBEN Position          */
#define TIMER_EXTCTL_ECNTDBEN_Msk          (0x1ul << TIMER_EXTCTL_ECNTDBEN_Pos)            /*!< TIMER_T::EXTCTL: ECNTDBEN Mask              */

#define TIMER_EINTSTS_CAPIF_Pos            (0)                                             /*!< TIMER_T::EINTSTS: CAPIF Position            */
#define TIMER_EINTSTS_CAPIF_Msk            (0x1ul << TIMER_EINTSTS_CAPIF_Pos)              /*!< TIMER_T::EINTSTS: CAPIF Mask                */


/**@}*/ /* TIMER_CONST */
/**@}*/ /* end of TMR register group */


/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
/**
    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
    Memory Mapped Structure for UART Controller
@{ */

typedef struct {


    /**
     * DAT
     * ===================================================================================================
     * Offset: 0x00  UARTx Receive / Transmit Buffer Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |DAT       |Receiving/Transmit Buffer
     * |        |          |Write Operation:
     * |        |          |By writing one byte to this register, the data byte will be stored in transmitter FIFO. The
     * |        |          |UART Controller will send out the data stored in transmitter FIFO top location through the
     * |        |          |UART_TXD.
     * |        |          |Read Operation:
     * |        |          |By reading this register, the UART will return an 8-bit data received from receiving FIFO
    */
    __IO uint32_t DAT;

    /**
     * INTEN
     * ===================================================================================================
     * Offset: 0x04  UARTx Interrupt Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable Control
     * |        |          |0 = INT_RDA Disabled.
     * |        |          |1 = INT_RDA Enabled.
     * |[1]     |THREIEN   |Transmit Holding Register Empty Interrupt Enable Control
     * |        |          |0 = INT_THRE Disabled.
     * |        |          |1 = INT_THRE Enabled.
     * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Control
     * |        |          |0 = INT_RLS Disabled.
     * |        |          |1 = INT_RLS Enabled.
     * |[3]     |MODEMIEN  |Modem Status Interrupt Enable Control
     * |        |          |0 = INT_MODEM Disabled.
     * |        |          |1 = INT_MODEM Enabled.
     * |[4]     |RXTOIEN   |RX Time-Out Interrupt Enable Control
     * |        |          |0 = NT_TOUT Disabled.
     * |        |          |1 = INT_TOUT Enabled.
     * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable Control
     * |        |          |0 = INT_BUF_ERR Disabled.
     * |        |          |1 = INT_BUF_ERR Enabled.
     * |[6]     |WKCTSIEN  |UART Wake-Up Function Enable Control
     * |        |          |0 = UART wake-up function Disabled.
     * |        |          |1 = UART wake-up function Enabled when the chip is in Power-down mode, an external CTS change will wake up chip from Power-down mode.
     * |[8]     |LINIEN    |LIN RX Break Field Detected Interrupt Enable Control
     * |        |          |0 = Lin bus RX break filed interrupt Disabled.
     * |        |          |1 = Lin bus RX break filed interrupt Enabled.
     * |        |          |Note: This field is used for LIN function mode.
     * |[11]    |TOCNTEN   |Time-Out Counter Enable Control
     * |        |          |0 = Time-out counter Disabled.
     * |        |          |1 = Time-out counter Enabled.
     * |[12]    |ATORTSEN  |RTS Auto Flow Control Enable Control
     * |        |          |0 = RTS auto flow control Disabled.
     * |        |          |1 = RTS auto flow control Enabled.
     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO[19:16]), the UART will de-assert RTS signal.
     * |[13]    |ATOCTSEN  |CTS Auto Flow Control Enable Control
     * |        |          |0 = CTS auto flow control Disabled.
     * |        |          |1 = CTS auto flow control Enabled.
     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
     * |[14]    |TXPDMAEN  |TX DMA Enable Control
     * |        |          |This bit can enable or disable TX DMA service.
     * |        |          |0 = TX DMA Disabled.
     * |        |          |1 = TX DMA Enabled.
     * |[15]    |RXPDMAEN  |RX DMA Enable Control
     * |        |          |This bit can enable or disable RX DMA service.
     * |        |          |0 = RX DMA Disabled.
     * |        |          |1 = RX DMA Enabled.
    */
    __IO uint32_t INTEN;

    /**
     * FIFO
     * ===================================================================================================
     * Offset: 0x08  UARTx FIFO Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1]     |RXRST     |RX Field Software Reset
     * |        |          |When RX_RST is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
     * |        |          |0 = No effect.
     * |        |          |1 = Reset the RX internal state machine and pointers.
     * |        |          |Note: This bit will be automatically cleared for at least 3 UART engine clock cycles.
     * |[2]     |TXRST     |TX Field Software Reset
     * |        |          |When TX_RST is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
     * |        |          |0 = No effect.
     * |        |          |1 = Reset the TX internal state machine and pointers.
     * |        |          |Note: This bit will auto clear needs at least 3 UART engine clock cycles.
     * |[4:7]   |RFITL     |RX FIFO Interrupt (INT_RDA) Trigger Level
     * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDAIF will be set (if RDAIEN (UART_INTEN [0]) is enabled, an interrupt will generated).
     * |        |          |0000 = 1 byte
     * |        |          |0001 = 4 bytes
     * |        |          |0010 = 8 bytes
     * |        |          |0011 = 14 bytes
     * |        |          |0100 = 30/14 bytes  (High-speed/Normal Speed)
     * |        |          |0101 = 46/14 bytes  (High-speed/Normal Speed)
     * |        |          |0110 = 62/14 bytes  (High-speed/Normal Speed)
     * |        |          |others = 62/14 bytes  (High-speed/Normal Speed)
     * |[8]     |RXOFF     |Receiver Disable
     * |        |          |The receiver is disabled or not.
     * |        |          |0 = Receiver Enabled.
     * |        |          |1 = Receiver Disabled.
     * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode.
     * |        |          |It should be programmed before RS-485_NMM (UART_ALTCTL [8]) is programmed.
     * |[16:19] |RTSTRGLV  |RTS Trigger Level For Auto-Flow Control Use
     * |        |          |0000 = 01 byte
     * |        |          |0001 = 04 bytes
     * |        |          |0010 = 08 bytes
     * |        |          |0011 = 14 bytes
     * |        |          |0100 = 30/14 bytes  (High-speed/Normal Speed)
     * |        |          |0101 = 46/14 bytes  (High-speed/Normal Speed)
     * |        |          |0110 = 62/14 bytes  (High-speed/Normal Speed)
     * |        |          |others = 62/14 bytes  (High-speed/Normal Speed)
     * |        |          |Note: This field is used for auto RTS flow control.
    */
    __IO uint32_t FIFO;

    /**
     * LINE
     * ===================================================================================================
     * Offset: 0x0C  UARTx Line Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |WLS       |Word Length Selection
     * |        |          |00 = 5-bit
     * |        |          |01 = 6-bit
     * |        |          |10 = 7-bit
     * |        |          |11 = 8-bit
     * |[2]     |NSB       |Number Of "STOP Bit"
     * |        |          |0= One " STOP bit" is generated in the transmitted data.
     * |        |          |1= One and a half " STOP bit" is generated in the transmitted data when 5-bit word length is selected.
     * |        |          |Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.
     * |[3]     |PBE       |Parity Bit Enable Control
     * |        |          |0 = No parity bit.
     * |        |          |1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
     * |[4]     |EPE       |Even Parity Enable Control
     * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
     * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
     * |        |          |This bit is effective only when bit 3 (parity bit enable) is set.
     * |[5]     |SPE       |Stick Parity Enable Control
     * |        |          |0 = Stick parity Disabled.
     * |        |          |1 = If bit 3 and 4 are logic 1, the parity bit is transmitted and checked as logic 0.
     * |        |          |If bit 3 is 1 and bit 4 is 0 then the parity bit is transmitted and checked as 1.
     * |[6]     |BCB       |Break Control
     * |        |          |When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
     * |        |          |This bit acts only on TX and has no effect on the transmitter logic.
    */
    __IO uint32_t LINE;

    /**
     * MODEM
     * ===================================================================================================
     * Offset: 0x10  UARTx Modem Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1]     |RTS       |RTS (Request-To-Send) Signal
     * |        |          |0 = Drive RTS pin to logic 1 (If the RTSACTLV
     * |        |          |set to low level triggered).
     * |        |          |1 = Drive RTS pin to logic 0 (If the RTSACTLV set to low level triggered).
     * |        |          |0 = Drive RTS pin to logic 0 (If the RTSACTLV
     * |        |          |set to high level triggered).
     * |        |          |1 = Drive RTS pin to logic 1 (If the RTSACTLV set to high level triggered).
     * |[9]     |RTSACTLV  |RTS Trigger Level
     * |        |          |This bit can change the RTS trigger level.
     * |        |          |0= Low level triggered.
     * |        |          |1= High level triggered.
     * |[13]    |RTSSTS    |RTS Pin State (Read Only)
     * |        |          |This bit is the output pin status of RTS.
    */
    __IO uint32_t MODEM;

    /**
     * MODEMSTS
     * ===================================================================================================
     * Offset: 0x14  UARTx Modem Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CTSDETF   |Detect CTS State Change Flag (Read Only)
     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN[3]) is set to 1.
     * |        |          |Software can write 1 to clear this bit to 0
     * |[4]     |CTSSTS    |CTS Pin Status (Read Only)
     * |        |          |This bit is the pin status of CTS.
     * |[8]     |CTSACTLV  |CTS Trigger Level
     * |        |          |This bit can change the CTS trigger level.
     * |        |          |0= Low level triggered.
     * |        |          |1= High level triggered.
    */
    __IO uint32_t MODEMSTS;

    /**
     * FIFOSTS
     * ===================================================================================================
     * Offset: 0x18  UARTx FIFO Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RXOVIF    |RX Overflow Error IF (Read Only)
     * |        |          |This bit is set when RX FIFO overflow.
     * |        |          |If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, 64/16 bytes of UART0/UART1, this bit will be set.
     * |        |          |Note: This bit is read only, but it can be cleared by writing '1' to it.
     * |[2]     |SCERR     |Smart Card Over Error Retry Flag
     * |        |          |It is set to 1 when transmitter re-transmits over the retry number (TXRTY (UART_SCCTL[6:4])) or the receiver transfer error retry over retry number (RXRTY (UART_SCCTL[2:0]))
     * |        |          |0 = No any transmitter re-transmits over or receiver transfer error retry over.
     * |        |          |1 = one of the transmitter re-transmits over active or receiver transfer error retry over active.
     * |        |          |Note1: This field is used for SC function mode.
     * |        |          |Note2: This bit is read only, but it can be cleared by writing '1' to it.
     * |[3]     |ADDRDETF  |RS-485 Address Byte Detection Flag (Read Only)
     * |        |          |This bit is set to logic 1 and set RS-485_ADD_EN (UART_ALTCTL[15]) whenever in RS-485 mode the receiver detect any address byte received address byte character (bit9 = '1') bit, and it is reset whenever the CPU writes 1 to this bit.
     * |        |          |Note1: This field is used for RS-485 function mode.
     * |        |          |Note2: This bit is read only, but it can be cleared by writing '1' to it.
     * |[4]     |PEF       |Parity Error Flag (Read Only)
     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
     * |        |          |Note: This bit is read only, but it can be cleared by writing '1' to it.
     * |[5]     |FEF       |Framing Error Flag (Read Only)
     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.
     * |        |          |Note: This bit is read only, but it can be cleared by writing '1' to it.
     * |[6]     |BIF       |Break Interrupt Flag (Read Only)
     * |        |          |This bit is set to a logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
     * |        |          |Note: This bit is read only, but it can be cleared by writing '1' to it.
     * |[8:13]  |RXPTR     |RX FIFO Pointer (Read Only)
     * |        |          |This field indicates the RX FIFO Buffer Pointer.
     * |        |          |When UART receives one byte from external device, RXPTR increases one.
     * |        |          |When one byte of RX FIFO is read by CPU, RXPTR decreases one.
     * |[14]    |RXEMPTY   |Receiver FIFO Empty (Read Only)
     * |        |          |This bit initiate RX FIFO empty or not.
     * |        |          |When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
     * |        |          |It will be cleared when UART receives any new data.
     * |[15]    |RXFULL    |Receiver FIFO Full (Read Only)
     * |        |          |This bit initiates RX FIFO full or not.
     * |        |          |This bit is set when RXPTR is equal to 64/16(UART0/UART1~5), otherwise is cleared by hardware.
     * |[16:21] |TXPTR     |TX FIFO Pointer (Read Only)
     * |        |          |This field indicates the TX FIFO Buffer Pointer.
     * |        |          |When CPU writes one byte into UART_DAT, TXPTR increases one.
     * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.
     * |[22]    |TXEMPTY   |Transmitter FIFO Empty (Read Only)
     * |        |          |This bit indicates TX FIFO empty or not.
     * |        |          |When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
     * |        |          |It will be cleared when writing data into DAT (TX FIFO not empty).
     * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
     * |        |          |This bit indicates TX FIFO full or not.
     * |        |          |This bit is set when TXPTR is equal to 64/16(UART0/UART1~5), otherwise is cleared by hardware.
     * |[24]    |TXOVIF    |TX Overflow Error Interrupt Flag (Read Only)
     * |        |          |If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to
     * |        |          |logic 1.
     * |        |          |Note: This bit is read only, but it can be cleared by writing '1' to it.
     * |[28]    |TXEMPTYF  |Transmitter Empty Flag (Read Only)
     * |        |          |Bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
     * |        |          |Bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
    */
    __IO uint32_t FIFOSTS;

    /**
     * INTSTS
     * ===================================================================================================
     * Offset: 0x1C  UARTx Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RDAIF     |Receive Data Available Interrupt Flag (Read Only)
     * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDAIF will be set.
     * |        |          |If RDAIEN bit (UART_INTEN[0]) is enabled, the RDA interrupt will be generated.
     * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL).
     * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag (Read Only)
     * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
     * |        |          |If THREIEN bit (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.
     * |        |          |Note: This bit is read only and it will be cleared when writing data into DAT (TX FIFO not empty).
     * |[2]     |RLSIF     |Receive Line Interrupt Flag (Read Only)
     * |        |          |This bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set).
     * |        |          |If RLSIEN bit (UART_INTEN[2]) is enabled, the RLS interrupt will be generated.
     * |        |          |Note1: In RS-485 function mode, this field include receiver detect any address byte received address byte character (bit9 = '1') bit.
     * |        |          |Note2: In SC function mode, this field includes error retry over flag .
     * |        |          |Note3: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
     * |[3]     |MODENIF   |MODEM Interrupt Flag (Read Only)
     * |        |          |This bit is set when the CTS pin has state change (CTSDETF=1).
     * |        |          |If MODEMIEN bit (UART_INTEN[3]) is enabled, the Modem interrupt will be generated.
     * |        |          |Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF.
     * |[4]     |RXTOIF    |Time-Out Interrupt Flag (Read Only)
     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
     * |        |          |If TIME_OUT_IEN bit (UART_INTEN[11]) is enabled, the Time-out interrupt will be generated.
     * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
     * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
     * |        |          |This bit is set when the TX or RX FIFO overflows (TXOVIF or RXOVIF is set).
     * |        |          |When BERRIF is set, the transfer maybe is not correct.
     * |        |          |If BUFERRIEN bit (UART_INTEN[5]) is enabled, the buffer error interrupt will be generated.
     * |        |          |Note: This bit is cleared when both TXOVIF and RXOVIF are cleared.
     * |[7]     |LIN_IF    |LIN Bus Flag (Read Only)
     * |        |          |This bit is set when LIN slave header detect (SLVHDETF=1), LIN break detect (BRKDETF=1), bit error detect (BITEF=1), LIN slave ID parity error (SLVIDPEF) or LIN slave header error detect (SLVHEF) If LIN_RX_BRK_ IEN bit (UART_INTEN[8]) is enabled the LIN interrupt will be generated.
     * |        |          |Note: This bit is cleared when both SLVHDETF and LIN_BRDER_F and BITEF and LINS_IDPENR_F and SLVHEF are cleared
     * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator (Read Only)
     * |        |          |This bit is set if RDAIEN and RDAIF are both set to 1.
     * |        |          |0 = No RDA interrupt is generated.
     * |        |          |1 = RDA interrupt is generated.
     * |[9]     |THREINT   |Transmit Holding Register Empty Interrupt
     * |        |          |Indicator (Read Only)
     * |        |          |This bit is set if THREIEN and THREIF are both set to 1.
     * |        |          |0 = No THRE interrupt is generated.
     * |        |          |1 = THRE interrupt is generated.
     * |[10]    |RLSINT    |Receive Line Status Interrupt Indicator (Read Only)
     * |        |          |This bit is set if RLSIEN and RLSIF are both set to 1.
     * |        |          |0 = No RLS interrupt is generated.
     * |        |          |1 = RLS interrupt is generated.
     * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator (Read Only)
     * |        |          |This bit is set if MODEMIEN and MODENIF are both set to 1.
     * |        |          |0 = No Modem interrupt is generated.
     * |        |          |1 = Modem interrupt is generated.
     * |[12]    |RXTOINT   |Time-Out Interrupt Indicator (Read Only)
     * |        |          |This bit is set if TOUT_IEN and RXTOIF are both set to 1.
     * |        |          |0 = No Tout interrupt is generated.
     * |        |          |1 = Tout interrupt is generated.
     * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator (Read Only)
     * |        |          |This bit is set if BUFERRIEN and BERRIF are both set to 1.
     * |        |          |0 = No buffer error interrupt is generated.
     * |        |          |1 = The buffer error interrupt is generated.
     * |[15]    |LININT    |LIN Bus Interrupt Indicator (Read Only)
     * |        |          |This bit is set if LIN_IEN and LIN_RX_BREAK_IF are both set to 1.
     * |        |          |0 = No LIN RX Break interrupt is generated.
     * |        |          |1 = LIN RX Break interrupt is generated.
     * |[18]    |HWRLSIF   |In DMA Mode, Receive Line Status Flag (Read Only)
     * |        |          |This bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set).
     * |        |          |If RLSIEN bit (UART_INTEN[2]) is enabled, the RLS interrupt will be generated.
     * |        |          |Note1: In RS-485 function mode, this field includes receiver detect any address byte received address byte character (bit9 = '1') bit.
     * |        |          |Note2: In SC function mode, this field includes error retry over flag.
     * |        |          |Note3: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
     * |[19]    |HWMODIF   |In DMA Mode, MODEM Interrupt Flag (Read Only)
     * |        |          |This bit is set when the CTS pin has state change (CTSDETF = 1).
     * |        |          |If MODEMIEN (UART_INTEN[3]) is enabled, the Modem interrupt will be generated.
     * |        |          |Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF.
     * |[20]    |HWTOIF    |In DMA Mode, Time-Out Interrupt Flag (Read Only)
     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
     * |        |          |If TIME_OUT_IEN (UART_INTEN[11]) is enabled, the Time-out interrupt will be generated.
     * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
     * |[21]    |HWBUFEIF  |In DMA Mode, Buffer Error Interrupt Flag (Read Only)
     * |        |          |This bit is set when the TX or RX FIFO overflows (TXOVIF or RXOVIF is set).
     * |        |          |When BERRIF is set, the transfer maybe is not correct.
     * |        |          |If BUFERRIEN bit (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
     * |        |          |Note: This bit is cleared when both TXOVIF and RXOVIF are cleared.
     * |[26]    |HWRLSINT  |In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)
     * |        |          |This bit is set if RLSIEN and HWRLSIF are both set to 1.
     * |        |          |0 = No RLS interrupt is generated in DMA mode.
     * |        |          |1 = RLS interrupt is generated in DMA mode.
     * |[27]    |HWMODINT  |In DMA Mode, MODEM Status Interrupt Indicator (Read Only)
     * |        |          |This bit is set if MODEMIEN and HWMODIF are both set to 1.
     * |        |          |0 = No Modem interrupt is generated in DMA mode.
     * |        |          |1 = Modem interrupt is generated in DMA mode.
     * |[28]    |HWTOINT   |In DMA Mode, Time-Out Interrupt Indicator (Read Only)
     * |        |          |This bit is set if TOUT_IEN and HWTOIF are both set to 1.
     * |        |          |0 = No Tout interrupt is generated in DMA mode.
     * |        |          |1 = Tout interrupt is generated in DMA mode.
     * |[29]    |HWBUFEINT |In DMA Mode, Buffer Error Interrupt Indicator (Read Only)
     * |        |          |This bit is set if BUFERRIEN and HWBFERIF are both set to 1.
     * |        |          |0 = No buffer error interrupt is generated in DMA mode.
     * |        |          |1 = The buffer error interrupt is generated in DMA mode.
    */
    __IO uint32_t INTSTS;

    /**
     * TOUT
     * ===================================================================================================
     * Offset: 0x20  UARTx Time-out Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |TOIC      |Time-Out Interrupt Comparator
     * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate clock) whenever the RX FIFO receives a new data word.
     * |        |          |Once the content of time-out counter (TOUT_CNT) is equal to that of time-out interrupt comparator (TOIC), a receiver time-out interrupt (INT_TOUT) is generated if RXTOIEN (UART_INTEN[4]).
     * |        |          |A new incoming data word or RX FIFO empty clears INT_TOUT.
     * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
     * |        |          |So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
     * |[8:15]  |DLY       |TX Delay Time Value
     * |        |          |This field is use to programming the transfer delay time between the last stop bit and next start bit.
     * |        |          |Note: The counter clock is baud rate clock
    */
    __IO uint32_t TOUT;

    /**
     * BAUD
     * ===================================================================================================
     * Offset: 0x24  UARTx Baud Rate Divisor Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |BRD       |Baud Rate Divider
     * |        |          |The field indicated the baud rate divider
     * |[24:27] |EDIVM1    |Divider X
     * |        |          |The baud rate divider M = X+1.
     * |[28]    |BAUDM0    |Divider X Equal To 1
     * |        |          |0 = Divider M = X (the equation of M = X+1, but EDIVM1 (UART_BAUD[27:24]) must >= 8).
     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD (UART_BAUD[15:0]) must >= 3).
     * |        |          |Refer to the table below for more information.
     * |[29]    |BAUDM1    |Divider X Enable Control
     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is
     * |        |          |Baud Rate = Clock / [M * (BRD + 2)]; The default value of M is 16.
     * |        |          |0 = Divider X Disabled (the equation of M = 16).
     * |        |          |1 = Divider X Enabled (the equation of M = X+1, but EDIVM1 (UART_BAUD[27:24]) must >= 8).
     * |        |          |Refer to the table below for more information.
     * |        |          |Note: In IrDA mode, this bit must disable.
    */
    __IO uint32_t BAUD;

    /**
     * IRDA
     * ===================================================================================================
     * Offset: 0x28  UARTx IrDA Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[1]     |TXEN      |IrDA Receiver/Transmitter Selection Enable Bit
     * |        |          |0 = IrDA receiver Enabled.
     * |        |          |1 = IrDA transmitter Enabled.
     * |[5]     |TXINV     |IrDA Inverse Transmitting Output Signal
     * |        |          |0 = No inversion.
     * |        |          |1 = Inverse TX output signal.
     * |[6]     |RXINV     |IrDA Inverse Receive Input Signal
     * |        |          |0 = No inversion.
     * |        |          |1 = Inverse RX input signal.
     * |[7]     |FIXPULSE  |Pulse width of TX is fixed 1.6us.
    */
    __IO uint32_t IRDA;

    /**
     * ALTCTL
     * ===================================================================================================
     * Offset: 0x2C  UARTx Alternate Control/Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |BKFL      |LIN Break Field Length
     * |        |          |This field indicates a 4-bit LIN TX break field count.
     * |        |          |Note1: This break field length is BRKFL + 1.
     * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
     * |[6]     |LINRXEN   |LIN RX Enable Control
     * |        |          |0 = LIN RX mode Disabled.
     * |        |          |1 = LIN RX mode Enabled.
     * |[7]     |LINTXEN   |LIN TX Break Mode Enable Control
     * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field" depending on the setting HSEL register.
     * |        |          |0 = Send LIN TX header Disabled.
     * |        |          |1 = Send LIN TX header Enabled.
     * |        |          |Note: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by HSEL field) transfer operation finished, this bit will be cleared automatically.
     * |[8]     |RS485NMM  |RS-485 Normal Multi-Drop Operation Mode (NMM)
     * |        |          |0 = RS-485 Normal Multi-drop Operation Mode (NMM) Disabled.
     * |        |          |1 = RS-485 Normal Multi-drop Operation Mode (NMM) Enabled.
     * |        |          |Note: It can't be active with RS-485_AAD operation mode.
     * |[9]     |RS485AAD  |RS-485 Auto Address Detection Operation Mode (AAD)
     * |        |          |0 = RS-485 Auto Address Detection (AAD) Operation mode Disabled.
     * |        |          |1 = RS-485 Auto Address Detection (AAD) Operation mode Enabled.
     * |        |          |Note: It can't be active with RS-485_NMM operation mode.
     * |[10]    |RS485AUD  |RS-485 Auto Direction Mode (AUD)
     * |        |          |0 = RS-485 Auto Direction Operation (AUO) mode Disabled.
     * |        |          |1 = RS-485 Auto Direction Operation (AUO) mode Enabled.
     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
     * |[15]    |ADDRDEN   |RS-485 Address Detection Enable Control
     * |        |          |This bit is use to enable RS-485 address detection mode.
     * |        |          |0 = address detection mode Disabled.
     * |        |          |1 = Address detection mode Enabled.
     * |        |          |Note: This field is used for RS-485 any operation mode.
     * |[24:31] |ADDRMV    |Address Match Value
     * |        |          |This field contains the RS-485 address match values.
     * |        |          |Note: This field is used for RS-485 auto address detection mode.
    */
    __IO uint32_t ALTCTL;

    /**
     * FUNCSEL
     * ===================================================================================================
     * Offset: 0x30  UARTx Function Select Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |FUNCSEL   |Function Select Enable Control
     * |        |          |000 = UART function.
     * |        |          |001 = LIN function Enabled.
     * |        |          |010 = IrDA function Enabled.
     * |        |          |011 = RS-485 function Enabled.
     * |        |          |100 = Smart-Card function Enabled.
    */
    __IO uint32_t FUNCSEL;

    /**
     * LINCTL
     * ===================================================================================================
     * Offset: 0x34  UARTx LIN Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SLVEN     |LIN Slave Mode Enable Control
     * |        |          |0 = LIN slave mode Disabled.
     * |        |          |1 = LIN slave mode Enabled.
     * |[1]     |SLVHDEN   |LIN Slave Header Detection Enable Control
     * |        |          |0 = LIN slave header detection Disabled.
     * |        |          |1 = LIN slave header detection Enabled.
     * |        |          |Note1: This bit only valid in LIN slave mode (SLVEN = 1).
     * |        |          |Note2: In LIN function mode, when header field (break + sync + frame ID) is detected, hardware will generate an interrupt to CPU (INT_LIN) and the SLVHDETF flag (UART_LINSTS[0]) will be asserted.
     * |[2]     |SLVAREN   |LIN Slave Automatic Resynchronization Mode Enable Control
     * |        |          |0 = LIN automatic resynchronization Disabled.
     * |        |          |1 = LIN automatic resynchronization Enabled.
     * |        |          |Note1: This bit only valid in LIN slave mode (SLVEN = 1).
     * |        |          |Note2: When operating in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUDM1 (UART_BAUD[29]) and BAUDM0 (UART_BAUD[28]) must be 1).
     * |        |          |Note3: The control and interactions of this field are explained in 6.31.5.3.
     * |[3]     |SLVDUEN   |LIN Slave Divider Update Method Enable Control
     * |        |          |0 = UART_BAUD is updated as soon as UART_BAUD is writing by software (if no automatic resynchronization update occurs at the same time).
     * |        |          |1 = UART_BAUD is updated at the next received character.
     * |        |          |User must set the bit before checksum reception.
     * |        |          |Note1: This bit only valid in LIN slave mode (SLVEN = 1).
     * |        |          |Note2: This bit is used for LIN slave automatic resynchronization mode (for non-automatic resynchronization mode, this bit should be kept cleared).
     * |        |          |Note3: The control and interactions of this field are explained in 6.31.5.3.
     * |[4]     |MUTE      |LIN Mute Mode Enable Control
     * |        |          |0 = LIN mute mode. Disabled
     * |        |          |1 = LIN mute mode Enabled.
     * |        |          |Note: The wake-up condition from mute mode and each control and interactions of this field are explained in 6.31.5.3.
     * |[8]     |SENDH     |LIN TX Send Header Enable Control
     * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field" depending on the setting HSEL register.
     * |        |          |0 = Send LIN TX header Disabled.
     * |        |          |1 = Send LIN TX header Enabled.
     * |        |          |Note: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by HSEL field) transfer operation finished, this bit will be cleared automatically.
     * |[9]     |IDPEN     |LIN ID Parity Enable Control
     * |        |          |0 = LIN frame ID parity Disabled.
     * |        |          |1 = LIN frame ID parity Enabled.
     * |        |          |Note1: This bit can be used for LIN master to sending header field (SENDH = 1 and HSEL = 2'b10) or be used for enable LIN slave received frame ID parity checked.
     * |        |          |Note2: This bit is only used when operation header transmitter is in HSEL = 2'b10.
     * |[10]    |BRKDETEN  |LIN Break Detection Enable Control
     * |        |          |When detect great than 11/10 bits are detected as 0, and are followed by a delimiter character, the BRKDETF flag (UART_LINSTS[8]) at the end of break field.
     * |        |          |If the LINIEN bit (UART_INTEN[8]) = 1, an interrupt will be generated.
     * |        |          |0 = LIN break detection Disabled.
     * |        |          |1 = LIN break detection Enabled.
     * |[11]    |RXOFF     |If the receiver is be enabled (RXOFF = 0), all received byte data will be accepted and stored in the RX-FIFO, and if the receiver is disabled (RXOFF = 1), all received byte data will be ignore.
     * |        |          |0 = Bit error detection function Disabled.
     * |        |          |1 = Bit error detection Enabled.
     * |        |          |Note: This bit is only valid when operating in LIN function mode (UART_FUNCSEL = 2'b01).
     * |[12]    |BITERREN  |Bit Error Detect Enable Control
     * |        |          |0 = Bit error detection function Disabled.
     * |        |          |1 = Bit error detection Enabled.
     * |        |          |Note: In LIN function mode, when occur bit error, hardware will generate an interrupt to CPU (INT_LIN) and the BITEF (UART_LINSTS[9]) flag will be asserted.
     * |[16:19] |BRKFL     |LIN Break Field Length
     * |        |          |This field indicates a 4-bit LIN TX break field count.
     * |        |          |Note1: These registers are shadow registers of LIN_BKFL (UART_ALTCTL[3:0]), User can read/write it by setting LIN_BKFL (UART_ALTCTL[3:0]) or LIN_BKFL (UART_LINCTL[19:16]).
     * |        |          |Note2: This break field length is BRKFL + 1.
     * |        |          |Note3: According to LIN spec, the reset value is 0XC (break field length = 13).
     * |[20:21] |BSL       |LIN Break/Sync Delimiter Length
     * |        |          |00 = LIN break/sync delimiter length is 1 bit time.
     * |        |          |10 = The LIN break/sync delimiter length is 2 bit time.
     * |        |          |10 = The LIN break/sync delimiter length is 3 bit time.
     * |        |          |11 = The LIN break/sync delimiter length is 4 bit time.
     * |        |          |Note: This bit used for LIN master to send header field.
     * |[22:23] |HSEL      |LIN Header Selection
     * |        |          |00 = LIN header includes "break field".
     * |        |          |01 = LIN header includes "break field" and "sync field".
     * |        |          |10 = LIN header includes "break field", "sync field" and "frame ID field".
     * |        |          |11 = LIN header includes "break field", "sync field" and "frame ID field", but this mode only supports Receiver mode, not support transmitter mode.
     * |        |          |This mode difference with mode "10"; in this mode, the receiver will receive ID field (not check the PID (UART_LINCTL[31:24]) register) and when received ID field the SLVHDETF will be asserted (if SLVHDEN (UART_LINCTL[1]) be set).
     * |        |          |Note: This bit is used to master mode for LIN to sending header field (SENDH = 1) or used to slave to indicates wake-up condition from mute mode (MUTE).
     * |[24:31] |PID       |This Field Contains The LIN Frame ID Value In LIN Function Mode, The Frame ID Parity Can Be Generated By Software Or Hardware Depending On UART_LINCTL [IDPEN]
     * |        |          |If the parity generated by hardware (IDPEN (UART_LINCTL[9]) = 1), user fill ID0~ID5, hardware will calculi P0 and P1, otherwise user must filled frame ID and parity in this field.
     * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first)
     * |        |          |Note2: This field can be used for LIN Master mode or Slave mode.
    */
    __IO uint32_t LINCTL;

    /**
     * LINSTS
     * ===================================================================================================
     * Offset: 0x38  UARTx LIN Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SLVHDETF  |LIN Slave Header Detection Flag (Read Only)
     * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.
     * |        |          |0 = LIN header not detected.
     * |        |          |1 = LIN header detected (break + sync + frame ID).
     * |        |          |Note1: This bit is read only, but can be cleared by writing 1 to it.
     * |        |          |Note2: This bit is only valid in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1) and LIN slave header detection function (SLVHDEN (UART_LINCTL[1])) is enabled.
     * |        |          |Note3: When the ID parity check (IDPEN (UART_LINCTL[9]) = 1) is enabled, if hardware detect complete harder ("break + sync + frame ID"), the LINS_HEDT_F (UART_LINCTL[1]) will be set no matter the frame ID is corrected or not.
     * |[1]     |SLVHEF    |LIN Slave Header Error Flag (Read Only)
     * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it.
     * |        |          |The header include "break delimiter is too short", "frame error in sync field or Identifier field", "sync field data is not 0x55 without automatic resynchronization mode", "sync field deviation error with automatic resynchronization mode", "sync field measure time-out with automatic resynchronization mode" and "LIN header reception time-out".
     * |        |          |0 = LIN header error not detected.
     * |        |          |1 = LIN header error detected.
     * |        |          |Note1: This bit is read only, but can be cleared by writing 1 to it.
     * |        |          |Note2: This bit is only valid in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1) and LIN slave header detection function (SLVHDEN (UART_LINCTL[1])) is enabled.
     * |[2]     |SLVIDPEF  |LIN Slave ID Parity Error Flag (Read Only)
     * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
     * |        |          |0 = no active.
     * |        |          |1 = Receipted frame ID parity is not correct.
     * |        |          |Note1: This bit is read only, but can be cleared by writing 1 to it.
     * |        |          |Note2: This bit is only valid in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1) and LIN frame ID parity check function (IDPEN (UART_LINCTL[9])) is enabled.
     * |[3]     |SLVSYNCF  |LIN Slave Sync Field
     * |        |          |This bit indicates that the LIN sync field is being analyzed.
     * |        |          |When the receiver header have some error been detect, user must to reset the internal circuit to re-search new frame header by writing 1 to this bit.
     * |        |          |0 = The current character is not at LIN sync state.
     * |        |          |1 = The current character is at LIN sync state.
     * |        |          |Note1: This bit only valid in LIN Slave mode (SLVEN = 1).
     * |        |          |Note2: This bit is read only, but can be cleared by writing 1 to it.
     * |        |          |Note3: When user writing 1 to it, hardware will reload the initial baud-rate and re-search new frame header, the control and interactions of this field are explained in 6.31.5.3.
     * |[8]     |BRKDETF   |LIN Break Detection Flag (Read Only)
     * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it.
     * |        |          |0 = LIN break not detected.
     * |        |          |1 = LIN break detected.
     * |        |          |Note1: This bit is read only, but can be cleared by writing 1 to it.
     * |        |          |Note2: This bit is only valid when enable LIN break detection function (BRKDETEN (UART_LINCTL[10]))
     * |[9]     |BITEF     |Bit Error Detect Status Flag (Read Only)
     * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BITEF will be set.
     * |        |          |When occur bit error, hardware will generate an interrupt to CPU (INT_LIN).
     * |        |          |Note1: This bit is read only, but can be cleared by writing 1 to it.
     * |        |          |Note2: This bit is only valid when enable bit error detection function (BRKL (UART_LINCTL[12]) == 1).
    */
    __IO uint32_t LINSTS;

    /**
     * LINDEBUG
     * ===================================================================================================
     * Offset: 0x3C  UARTx LIN Debug Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DEVERRF   |LIN Header Deviation Error (Read Only)
     * |        |          |This bit indicates the header error cause by the sync field deviation error or sync field measure time-out with automatic resynchronization mode.
     * |[1]     |TOF       |LIN Header Time-Out (Read Only)
     * |        |          |This bit indicates the header error cause by the LIN header reception time-out.
     * |[2]     |FRAMEERRF |LIN Header Frame Error Flag (Read Only)
     * |        |          |This bit indicates the header error cause by break delimiter is too short or frame error in sync field or Identifier field.
     * |[3]     |SYNCERRF  |LIN Header Sync Data Error (Read Only)
     * |        |          |This bit indicates the header error cause by the LIN received sync data is not 0x55.
    */
    __IO uint32_t LINDEBUG;


} UART_T;

/**
    @addtogroup UART_CONST UART Bit Field Definition
    Constant Definitions for UART Controller
@{ */

#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART_T::DAT: DAT Position                 */
#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART_T::DAT: DAT Mask                     */

#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART_T::INTEN: RDAIEN Position            */
#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART_T::INTEN: RDAIEN Mask                */

#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART_T::INTEN: THREIEN Position           */
#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART_T::INTEN: THREIEN Mask               */

#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART_T::INTEN: RLSIEN Position            */
#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART_T::INTEN: RLSIEN Mask                */

#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART_T::INTEN: MODEMIEN Position          */
#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART_T::INTEN: MODEMIEN Mask              */

#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART_T::INTEN: RXTOIEN Position           */
#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART_T::INTEN: RXTOIEN Mask               */

#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART_T::INTEN: BUFERRIEN Position         */
#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART_T::INTEN: BUFERRIEN Mask             */

#define UART_INTEN_WKCTSIEN_Pos          (6)                                               /*!< UART_T::INTEN: WKCTSIEN Position          */
#define UART_INTEN_WKCTSIEN_Msk          (0x1ul << UART_INTEN_WKCTSIEN_Pos)                /*!< UART_T::INTEN: WKCTSIEN Mask              */

#define UART_INTEN_LINIEN_Pos            (8)                                               /*!< UART_T::INTEN: LINIEN Position            */
#define UART_INTEN_LINIEN_Msk            (0x1ul << UART_INTEN_LINIEN_Pos)                  /*!< UART_T::INTEN: LINIEN Mask                */

#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART_T::INTEN: TOCNTEN Position           */
#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART_T::INTEN: TOCNTEN Mask               */

#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART_T::INTEN: ATORTSEN Position          */
#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART_T::INTEN: ATORTSEN Mask              */

#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART_T::INTEN: ATOCTSEN Position          */
#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART_T::INTEN: ATOCTSEN Mask              */

#define UART_INTEN_TXPDMAEN_Pos          (14)                                              /*!< UART_T::INTEN: TXPDMAEN Position          */
#define UART_INTEN_TXPDMAEN_Msk          (0x1ul << UART_INTEN_TXPDMAEN_Pos)                /*!< UART_T::INTEN: TXPDMAEN Mask              */

#define UART_INTEN_RXPDMAEN_Pos          (15)                                              /*!< UART_T::INTEN: RXPDMAEN Position          */
#define UART_INTEN_RXPDMAEN_Msk          (0x1ul << UART_INTEN_RXPDMAEN_Pos)                /*!< UART_T::INTEN: RXPDMAEN Mask              */

#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART_T::FIFO: RXRST Position              */
#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART_T::FIFO: RXRST Mask                  */

#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART_T::FIFO: TXRST Position              */
#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART_T::FIFO: TXRST Mask                  */

#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART_T::FIFO: RFITL Position              */
#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART_T::FIFO: RFITL Mask                  */

#define UART_FIFO_RXOFF_Pos              (8)                                               /*!< UART_T::FIFO: RXOFF Position              */
#define UART_FIFO_RXOFF_Msk              (0x1ul << UART_FIFO_RXOFF_Pos)                    /*!< UART_T::FIFO: RXOFF Mask                  */

#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART_T::FIFO: RTSTRGLV Position           */
#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART_T::FIFO: RTSTRGLV Mask               */

#define UART_LINE_WLS_Pos                (0)                                               /*!< UART_T::LINE: WLS Position                */
#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART_T::LINE: WLS Mask                    */

#define UART_LINE_NSB_Pos                (2)                                               /*!< UART_T::LINE: NSB Position                */
#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART_T::LINE: NSB Mask                    */

#define UART_LINE_PBE_Pos                (3)                                               /*!< UART_T::LINE: PBE Position                */
#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART_T::LINE: PBE Mask                    */

#define UART_LINE_EPE_Pos                (4)                                               /*!< UART_T::LINE: EPE Position                */
#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART_T::LINE: EPE Mask                    */

#define UART_LINE_SPE_Pos                (5)                                               /*!< UART_T::LINE: SPE Position                */
#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART_T::LINE: SPE Mask                    */

#define UART_LINE_BCB_Pos                (6)                                               /*!< UART_T::LINE: BCB Position                */
#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART_T::LINE: BCB Mask                    */

#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART_T::MODEM: RTS Position               */
#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART_T::MODEM: RTS Mask                   */

#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART_T::MODEM: RTSACTLV Position          */
#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART_T::MODEM: RTSACTLV Mask              */

#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART_T::MODEM: RTSSTS Position            */
#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART_T::MODEM: RTSSTS Mask                */

#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART_T::MODEMSTS: CTSDETF Position        */
#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART_T::MODEMSTS: CTSDETF Mask            */

#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART_T::MODEMSTS: CTSSTS Position         */
#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART_T::MODEMSTS: CTSSTS Mask             */

#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART_T::MODEMSTS: CTSACTLV Position       */
#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART_T::MODEMSTS: CTSACTLV Mask           */

#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART_T::FIFOSTS: RXOVIF Position          */
#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART_T::FIFOSTS: RXOVIF Mask              */

#define UART_FIFOSTS_SCERR_Pos           (2)                                               /*!< UART_T::FIFOSTS: SCERR Position           */
#define UART_FIFOSTS_SCERR_Msk           (0x1ul << UART_FIFOSTS_SCERR_Pos)                 /*!< UART_T::FIFOSTS: SCERR Mask               */

#define UART_FIFOSTS_ADDRDETF_Pos        (3)                                               /*!< UART_T::FIFOSTS: ADDRDETF Position        */
#define UART_FIFOSTS_ADDRDETF_Msk        (0x1ul << UART_FIFOSTS_ADDRDETF_Pos)              /*!< UART_T::FIFOSTS: ADDRDETF Mask            */

#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART_T::FIFOSTS: PEF Position             */
#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART_T::FIFOSTS: PEF Mask                 */

#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART_T::FIFOSTS: FEF Position             */
#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART_T::FIFOSTS: FEF Mask                 */

#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART_T::FIFOSTS: BIF Position             */
#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART_T::FIFOSTS: BIF Mask                 */

#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART_T::FIFOSTS: RXPTR Position           */
#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART_T::FIFOSTS: RXPTR Mask               */

#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART_T::FIFOSTS: RXEMPTY Position         */
#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART_T::FIFOSTS: RXEMPTY Mask             */

#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART_T::FIFOSTS: RXFULL Position          */
#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART_T::FIFOSTS: RXFULL Mask              */

#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART_T::FIFOSTS: TXPTR Position           */
#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART_T::FIFOSTS: TXPTR Mask               */

#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART_T::FIFOSTS: TXEMPTY Position         */
#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART_T::FIFOSTS: TXEMPTY Mask             */

#define UART_FIFOSTS_TXFULL_Pos         (23)                                               /*!< UART_T::FIFOSTS: TXFULL Position         */
#define UART_FIFOSTS_TXFULL_Msk         (0x1ul << UART_FIFOSTS_TXFULL_Pos)                 /*!< UART_T::FIFOSTS: TXFULL Mask             */

#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART_T::FIFOSTS: TXOVIF Position          */
#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART_T::FIFOSTS: TXOVIF Mask              */

#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART_T::FIFOSTS: TXEMPTYF Position        */
#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART_T::FIFOSTS: TXEMPTYF Mask            */

#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART_T::INTSTS: RDAIF Position            */
#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART_T::INTSTS: RDAIF Mask                */

#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART_T::INTSTS: THREIF Position           */
#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART_T::INTSTS: THREIF Mask               */

#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART_T::INTSTS: RLSIF Position            */
#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART_T::INTSTS: RLSIF Mask                */

#define UART_INTSTS_MODEMIF_Pos          (3)                                               /*!< UART_T::INTSTS: MODENIF Position          */
#define UART_INTSTS_MODEMIF_Msk          (0x1ul << UART_INTSTS_MODEMIF_Pos)                /*!< UART_T::INTSTS: MODENIF Mask              */

#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART_T::INTSTS: RXTOIF Position           */
#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART_T::INTSTS: RXTOIF Mask               */

#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART_T::INTSTS: BUFERRIF Position           */
#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART_T::INTSTS: BUFERRIF Mask               */

#define UART_INTSTS_LINIF_Pos            (7)                                               /*!< UART_T::INTSTS: LINIF Position           */
#define UART_INTSTS_LINIF_Msk            (0x1ul << UART_INTSTS_LINIF_Pos)                  /*!< UART_T::INTSTS: LINIF Mask               */

#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART_T::INTSTS: RDAINT Position           */
#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART_T::INTSTS: RDAINT Mask               */

#define UART_INTSTS_THREINT_Pos          (9)                                               /*!< UART_T::INTSTS: THERINT Position          */
#define UART_INTSTS_THREINT_Msk          (0x1ul << UART_INTSTS_THREINT_Pos)                /*!< UART_T::INTSTS: THERINT Mask              */

#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART_T::INTSTS: RLSINT Position           */
#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART_T::INTSTS: RLSINT Mask               */

#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART_T::INTSTS: MODEMINT Position         */
#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART_T::INTSTS: MODEMINT Mask             */

#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART_T::INTSTS: RXTOINT Position          */
#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART_T::INTSTS: RXTOINT Mask              */

#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART_T::INTSTS: BUFERRINT Position          */
#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART_T::INTSTS: BUFERRINT Mask              */

#define UART_INTSTS_LININT_Pos            (15)                                              /*!< UART_T::INTSTS: LININT Position            */
#define UART_INTSTS_LININT_Msk            (0x1ul << UART_INTSTS_LININT_Pos)                 /*!< UART_T::INTSTS: LININT Mask                */

#define UART_INTSTS_HWRLSIF_Pos          (18)                                              /*!< UART_T::INTSTS: HWRLSIF Position          */
#define UART_INTSTS_HWRLSIF_Msk          (0x1ul << UART_INTSTS_HWRLSIF_Pos)                /*!< UART_T::INTSTS: HWRLSIF Mask              */

#define UART_INTSTS_HWMODIF_Pos          (19)                                              /*!< UART_T::INTSTS: HWMODIF Position          */
#define UART_INTSTS_HWMODIF_Msk          (0x1ul << UART_INTSTS_HWMODIF_Pos)                /*!< UART_T::INTSTS: HWMODIF Mask              */

#define UART_INTSTS_HWTOIF_Pos           (20)                                              /*!< UART_T::INTSTS: HWTOIF Position           */
#define UART_INTSTS_HWTOIF_Msk           (0x1ul << UART_INTSTS_HWTOIF_Pos)                 /*!< UART_T::INTSTS: HWTOIF Mask               */

#define UART_INTSTS_HWBUFEIF_Pos         (21)                                              /*!< UART_T::INTSTS: HWBUFEIF Position         */
#define UART_INTSTS_HWBUFEIF_Msk         (0x1ul << UART_INTSTS_HWBUFEIF_Pos)               /*!< UART_T::INTSTS: HWBUFEIF Mask             */

#define UART_INTSTS_HWRLSINT_Pos         (26)                                              /*!< UART_T::INTSTS: HWRLSINT Position         */
#define UART_INTSTS_HWRLSINT_Msk         (0x1ul << UART_INTSTS_HWRLSINT_Pos)               /*!< UART_T::INTSTS: HWRLSINT Mask             */

#define UART_INTSTS_HWMODINT_Pos         (27)                                              /*!< UART_T::INTSTS: HWMODINT Position         */
#define UART_INTSTS_HWMODINT_Msk         (0x1ul << UART_INTSTS_HWMODINT_Pos)               /*!< UART_T::INTSTS: HWMODINT Mask             */

#define UART_INTSTS_HWTOINT_Pos          (28)                                              /*!< UART_T::INTSTS: HWTOINT Position          */
#define UART_INTSTS_HWTOINT_Msk          (0x1ul << UART_INTSTS_HWTOINT_Pos)                /*!< UART_T::INTSTS: HWTOINT Mask              */

#define UART_INTSTS_HWBUFEINT_Pos        (29)                                              /*!< UART_T::INTSTS: HWBUFEINT Position          */
#define UART_INTSTS_HWBUFEINT_Msk        (0x1ul << UART_INTSTS_HWBUFEINT_Pos)              /*!< UART_T::INTSTS: HWBUFEINT Mask              */

#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART_T::TOUT: TOIC Position               */
#define UART_TOUT_TOIC_Msk               (0xfful << UART_TOUT_TOIC_Pos)                    /*!< UART_T::TOUT: TOIC Mask                   */

#define UART_TOUT_DLY_Pos                (8)                                               /*!< UART_T::TOUT: DLY Position                */
#define UART_TOUT_DLY_Msk                (0xfful << UART_TOUT_DLY_Pos)                     /*!< UART_T::TOUT: DLY Mask                    */

#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position                */
#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                    */

#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART_T::BAUD: EDIVM1 Position             */
#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART_T::BAUD: EDIVM1 Mask                 */

#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART_T::BAUD: BAUDM0 Position             */
#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART_T::BAUD: BAUDM0 Mask                 */

#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART_T::BAUD: BAUDM1 Position             */
#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART_T::BAUD: BAUDM1 Mask                 */

#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART_T::IRDA: TXEN Position               */
#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART_T::IRDA: TXEN Mask                   */

#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART_T::IRDA: TXINV Position              */
#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART_T::IRDA: TXINV Mask                  */

#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART_T::IRDA: RXINV Position              */
#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART_T::IRDA: RXINV Mask                  */

#define UART_IRDA_FIXPULSE_Pos           (7)                                               /*!< UART_T::IRDA: FIXPULSE Position           */
#define UART_IRDA_FIXPULSE_Msk           (0x1ul << UART_IRDA_FIXPULSE_Pos)                 /*!< UART_T::IRDA: FIXPULSE Mask               */

#define UART_ALTCTL_BKFL_Pos             (0)                                               /*!< UART_T::ALTCTL: BKFL Position             */
#define UART_ALTCTL_BKFL_Msk             (0xful << UART_ALTCTL_BKFL_Pos)                   /*!< UART_T::ALTCTL: BKFL Mask                 */

#define UART_ALTCTL_LINRXEN_Pos          (6)                                               /*!< UART_T::ALTCTL: LINRXEN Position          */
#define UART_ALTCTL_LINRXEN_Msk          (0x1ul << UART_ALTCTL_LINRXEN_Pos)                /*!< UART_T::ALTCTL: LINRXEN Mask              */

#define UART_ALTCTL_LINTXEN_Pos          (7)                                               /*!< UART_T::ALTCTL: LINTXEN Position          */
#define UART_ALTCTL_LINTXEN_Msk          (0x1ul << UART_ALTCTL_LINTXEN_Pos)                /*!< UART_T::ALTCTL: LINTXEN Mask              */

#define UART_ALTCTL_RS485NMM_Pos         (8)                                               /*!< UART_T::ALTCTL: RS485NMM Position         */
#define UART_ALTCTL_RS485NMM_Msk         (0x1ul << UART_ALTCTL_RS485NMM_Pos)               /*!< UART_T::ALTCTL: RS485NMM Mask             */

#define UART_ALTCTL_RS485AAD_Pos         (9)                                               /*!< UART_T::ALTCTL: RS485AAD Position         */
#define UART_ALTCTL_RS485AAD_Msk         (0x1ul << UART_ALTCTL_RS485AAD_Pos)               /*!< UART_T::ALTCTL: RS485AAD Mask             */

#define UART_ALTCTL_RS485AUD_Pos         (10)                                              /*!< UART_T::ALTCTL: RS485AUD Position         */
#define UART_ALTCTL_RS485AUD_Msk         (0x1ul << UART_ALTCTL_RS485AUD_Pos)               /*!< UART_T::ALTCTL: RS485AUD Mask             */

#define UART_ALTCTL_ADDRDEN_Pos          (15)                                              /*!< UART_T::ALTCTL: ADDRDEN Position          */
#define UART_ALTCTL_ADDRDEN_Msk          (0x1ul << UART_ALTCTL_ADDRDEN_Pos)                /*!< UART_T::ALTCTL: ADDRDEN Mask              */

#define UART_ALTCTL_ADDRMV_Pos           (24)                                              /*!< UART_T::ALTCTL: ADDRMV Position           */
#define UART_ALTCTL_ADDRMV_Msk           (0xfful << UART_ALTCTL_ADDRMV_Pos)                /*!< UART_T::ALTCTL: ADDRMV Mask               */

#define UART_FUNCSEL_FUNCSEL_Pos         (0)                                               /*!< UART_T::FUNCSEL: FUNCSEL Position         */
#define UART_FUNCSEL_FUNCSEL_Msk         (0x7ul << UART_FUNCSEL_FUNCSEL_Pos)               /*!< UART_T::FUNCSEL: FUNCSEL Mask             */

#define UART_LINCTL_SLVEN_Pos            (0)                                               /*!< UART_T::LINCTL: SLVEN Position            */
#define UART_LINCTL_SLVEN_Msk            (0x1ul << UART_LINCTL_SLVEN_Pos)                  /*!< UART_T::LINCTL: SLVEN Mask                */

#define UART_LINCTL_SLVHDEN_Pos          (1)                                               /*!< UART_T::LINCTL: SLVHDEN Position          */
#define UART_LINCTL_SLVHDEN_Msk          (0x1ul << UART_LINCTL_SLVHDEN_Pos)                /*!< UART_T::LINCTL: SLVHDEN Mask              */

#define UART_LINCTL_SLVAREN_Pos          (2)                                               /*!< UART_T::LINCTL: SLVAREN Position          */
#define UART_LINCTL_SLVAREN_Msk          (0x1ul << UART_LINCTL_SLVAREN_Pos)                /*!< UART_T::LINCTL: SLVAREN Mask              */

#define UART_LINCTL_SLVDUEN_Pos          (3)                                               /*!< UART_T::LINCTL: SLVDUEN Position          */
#define UART_LINCTL_SLVDUEN_Msk          (0x1ul << UART_LINCTL_SLVDUEN_Pos)                /*!< UART_T::LINCTL: SLVDUEN Mask              */

#define UART_LINCTL_MUTE_Pos             (4)                                               /*!< UART_T::LINCTL: MUTE Position             */
#define UART_LINCTL_MUTE_Msk             (0x1ul << UART_LINCTL_MUTE_Pos)                   /*!< UART_T::LINCTL: MUTE Mask                 */

#define UART_LINCTL_SENDH_Pos            (8)                                               /*!< UART_T::LINCTL: SENDH Position            */
#define UART_LINCTL_SENDH_Msk            (0x1ul << UART_LINCTL_SENDH_Pos)                  /*!< UART_T::LINCTL: SENDH Mask                */

#define UART_LINCTL_IDPEN_Pos            (9)                                               /*!< UART_T::LINCTL: IDPEN Position            */
#define UART_LINCTL_IDPEN_Msk            (0x1ul << UART_LINCTL_IDPEN_Pos)                  /*!< UART_T::LINCTL: IDPEN Mask                */

#define UART_LINCTL_BRKDETEN_Pos         (10)                                              /*!< UART_T::LINCTL: BRKDETEN Position         */
#define UART_LINCTL_BRKDETEN_Msk         (0x1ul << UART_LINCTL_BRKDETEN_Pos)               /*!< UART_T::LINCTL: BRKDETEN Mask             */

#define UART_LINCTL_RXOFF_Pos            (11)                                              /*!< UART_T::LINCTL: RXOFF Position            */
#define UART_LINCTL_RXOFF_Msk            (0x1ul << UART_LINCTL_RXOFF_Pos)                  /*!< UART_T::LINCTL: RXOFF Mask                */

#define UART_LINCTL_BITERREN_Pos         (12)                                              /*!< UART_T::LINCTL: BITERREN Position             */
#define UART_LINCTL_BITERREN_Msk         (0x1ul << UART_LINCTL_BITERREN_Pos)               /*!< UART_T::LINCTL: BITERREN Mask                 */

#define UART_LINCTL_BRKFL_Pos            (16)                                              /*!< UART_T::LINCTL: BRKFL Position         */
#define UART_LINCTL_BRKFL_Msk            (0xful << UART_LINCTL_BRKFL_Pos)                  /*!< UART_T::LINCTL: BRKFL Mask             */

#define UART_LINCTL_BSL_Pos              (20)                                              /*!< UART_T::LINCTL: BSL Position              */
#define UART_LINCTL_BSL_Msk              (0x3ul << UART_LINCTL_BSL_Pos)                    /*!< UART_T::LINCTL: BSL Mask                  */

#define UART_LINCTL_HSEL_Pos             (22)                                              /*!< UART_T::LINCTL: HSEL Position             */
#define UART_LINCTL_HSEL_Msk             (0x3ul << UART_LINCTL_HSEL_Pos)                   /*!< UART_T::LINCTL: HSEL Mask                 */

#define UART_LINCTL_PID_Pos              (24)                                              /*!< UART_T::LINCTL: PID Position              */
#define UART_LINCTL_PID_Msk              (0xfful << UART_LINCTL_PID_Pos)                   /*!< UART_T::LINCTL: PID Mask                  */

#define UART_LINSTS_SLVHDETF_Pos         (0)                                               /*!< UART_T::LINSTS: SLVHDETF Position         */
#define UART_LINSTS_SLVHDETF_Msk         (0x1ul << UART_LINSTS_SLVHDETF_Pos)               /*!< UART_T::LINSTS: SLVHDETF Mask             */

#define UART_LINSTS_SLVHEF_Pos           (1)                                               /*!< UART_T::LINSTS: SLVHEF Position           */
#define UART_LINSTS_SLVHEF_Msk           (0x1ul << UART_LINSTS_SLVHEF_Pos)                 /*!< UART_T::LINSTS: SLVHEF Mask               */

#define UART_LINSTS_SLVIDPEF_Pos         (2)                                               /*!< UART_T::LINSTS: SLVIDPEF Position         */
#define UART_LINSTS_SLVIDPEF_Msk         (0x1ul << UART_LINSTS_SLVIDPEF_Pos)               /*!< UART_T::LINSTS: SLVIDPEF Mask             */

#define UART_LINSTS_SLVSYNCF_Pos         (3)                                               /*!< UART_T::LINSTS: SLVSYNCF Position         */
#define UART_LINSTS_SLVSYNCF_Msk         (0x1ul << UART_LINSTS_SLVSYNCF_Pos)               /*!< UART_T::LINSTS: SLVSYNCF Mask             */

#define UART_LINSTS_BRKDETF_Pos          (8)                                               /*!< UART_T::LINSTS: BRKDETF Position          */
#define UART_LINSTS_BRKDETF_Msk          (0x1ul << UART_LINSTS_BRKDETF_Pos)                /*!< UART_T::LINSTS: BRKDETF Mask              */

#define UART_LINSTS_BITEF_Pos            (9)                                               /*!< UART_T::LINSTS: BITEF Position            */
#define UART_LINSTS_BITEF_Msk            (0x1ul << UART_LINSTS_BITEF_Pos)                  /*!< UART_T::LINSTS: BITEF Mask                */

#define UART_LINDEBUG_DEVERRF_Pos        (0)                                               /*!< UART_T::LINDEBUG: DEVERRF Position        */
#define UART_LINDEBUG_DEVERRF_Msk        (0x1ul << UART_LINDEBUG_DEVERRF_Pos)              /*!< UART_T::LINDEBUG: DEVERRF Mask            */

#define UART_LINDEBUG_TOF_Pos            (1)                                               /*!< UART_T::LINDEBUG: TOF Position            */
#define UART_LINDEBUG_TOF_Msk            (0x1ul << UART_LINDEBUG_TOF_Pos)                  /*!< UART_T::LINDEBUG: TOF Mask                */

#define UART_LINDEBUG_FRAMEERRF_Pos      (2)                                               /*!< UART_T::LINDEBUG: FRAMEERRF Position      */
#define UART_LINDEBUG_FRAMEERRF_Msk      (0x1ul << UART_LINDEBUG_FRAMEERRF_Pos)            /*!< UART_T::LINDEBUG: FRAMEERRF Mask          */

#define UART_LINDEBUG_SYNCERRF_Pos       (3)                                               /*!< UART_T::LINDEBUG: SYNCERRF Position       */
#define UART_LINDEBUG_SYNCERRF_Msk       (0x1ul << UART_LINDEBUG_SYNCERRF_Pos)             /*!< UART_T::LINDEBUG: SYNCERRF Mask           */

/**@}*/ /* UART_CONST */
/**@}*/ /* end of UART register group */


/*---------------------- USB Host Controller -------------------------*/
/**
    @addtogroup USBH USB Host Controller(USBH)
    Memory Mapped Structure for USBH Controller
@{ */

typedef struct {
    /**
     * HcRevision
     * ===================================================================================================
     * Offset: 0x00  Host Controller Revision Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |REV       |Revision
     * |        |          |Indicates the Open HCI Specification revision number implemented by the Hardware.
     * |        |          |Host Controller supports 1.1 specification.
     * |        |          |(X.Y = XYh).
    */
    __I  uint32_t HcRevision;

    /**
     * HcControl
     * ===================================================================================================
     * Offset: 0x04  Host Controller Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |CBSR      |Control Bulk Service Ratio
     * |        |          |Specifies the number of Control Endpoints serviced for every Bulk Endpoint.
     * |        |          |Encoding is N-1 where N is the number of Control Endpoints (i.e.
     * |        |          |'00' = 1 Control Endpoint; '11' = 3 Control Endpoints).
     * |[2]     |PLE       |Periodic List Enable Control
     * |        |          |When set, this bit enables processing of the Periodic (interrupt and isochronous) list.
     * |        |          |The Host Controller checks this bit prior to attempting any periodic transfers in a frame.
     * |[3]     |IE        |Isochronous List Enable Control
     * |        |          |When cleared, this bit disables the Isochronous List when the Periodic List is enabled (so Interrupt EDs may be serviced).
     * |        |          |While processing the Periodic List, the Host Controller will check this bit when it finds an isochronous ED.
     * |[4]     |CLE       |Control List Enable Control
     * |        |          |When set, this bit enables processing of the Control list.
     * |[5]     |BLE       |Bulk List Enable Control
     * |        |          |When set, this bit enables processing of the Bulk list.
     * |[6:7]   |HCFS      |Host Controller Functional State
     * |        |          |This field sets the Host Controller state.
     * |        |          |The Controller may force a state change from USBSUSPEND to USBRESUME after detecting resume signaling from a downstream port.
     * |        |          |States are:.
     * |        |          |00 = USBSUSPEND.
     * |        |          |01 = USBRESUME.
     * |        |          |10 = USBOPERATIONAL.
     * |        |          |11 = USBRESET.
     * |[9]     |RWC       |Remote Wake-Up Connected
     * |        |          |This bit indicated whether the HC supports a remote wake-up signal.
     * |        |          |This implementation does not support any such signal.
     * |        |          |The bit is hard-coded to '0.'.
     * |[10]    |RWE       |Remote Wake-Up Connected Enable Control
     * |        |          |If a remote wake-up signal is supported, this bit enables that operation.
     * |        |          |Since there is no remote wake-up signal supported, this bit is ignored.
    */
    __IO uint32_t HcControl;

    /**
     * HcCommandStatus
     * ===================================================================================================
     * Offset: 0x08  Host Controller Command Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |HCR       |Host Controller Reset
     * |        |          |This bit is set to initiate the software reset.
     * |        |          |This bit is cleared by the Host Controller, upon completed of the reset operation.
     * |[1]     |CLF       |Control List Filled
     * |        |          |Set to indicate there is an active ED on the Control List.
     * |        |          |It may be set by either software or the Host Controller and cleared by the Host Controller each time it begins processing the head of the Control List.
     * |[2]     |BLF       |Bulk List Filled
     * |        |          |Set to indicate there is an active ED on the Bulk List.
     * |        |          |The bit may be set by either software or the Host Controller and cleared by the Host Controller each time it begins processing the head of the Bulk List.
     * |[16:17] |SOC       |Schedule Overrun Count
     * |        |          |This field is incremented every time the SchedulingOverrun bit in HcInterruptStatus is set.
     * |        |          |The count wraps from '11' to '00'.
    */
    __IO uint32_t HcCommandStatus;

    /**
     * HcInterruptStatus
     * ===================================================================================================
     * Offset: 0x0C  Host Controller Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SO        |Scheduling Overrun
     * |        |          |Set when the List Processor determines a Schedule Overrun has occurred.
     * |[1]     |WDH       |Write Back Done Head
     * |        |          |Set after the Host Controller has written HcDoneHead to HccaDoneHead.
     * |[2]     |SF        |Start Of Frame
     * |        |          |Set when the Frame Management block signals a 'Start of Frame' event.
     * |[3]     |RD        |Resume Detected
     * |        |          |Set when Host Controller detects resume signaling on a downstream port.
     * |[4]     |UE        |Unrecoverable Error
     * |        |          |This event is not implemented and is hard-coded to '0.' Writes are ignored.
     * |[5]     |FNOF      |Frame Number Overflow
     * |        |          |Set when bit 15 of Frame Number changes value.
     * |[6]     |RHSC      |Root Hub Status Change
     * |        |          |This bit is set when the content of HcRhStatus or the content of any HcRhPortStatus register has changed.
    */
    __IO uint32_t HcInterruptStatus;

    /**
     * HcInterruptEnable
     * ===================================================================================================
     * Offset: 0x10  Host Controller Interrupt Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SO        |Scheduling Overrun Enable Control
     * |        |          |0 = The interrupt function Disabled.
     * |        |          |1 = Interrupt generation Enabled due to Scheduling Overrun.
     * |[1]     |WDH       |Write Back Done Head Enable Control
     * |        |          |0 = The interrupt function Disabled.
     * |        |          |1 = Interrupt generation Enabled due to Write-back Done Head.
     * |[2]     |SF        |Start Of Frame Enable Control
     * |        |          |0 = The interrupt function Disabled.
     * |        |          |1 = interrupt generation Enabled due to Start of Frame.
     * |[3]     |RD        |Resume Detected Enable Control
     * |        |          |0 = The interrupt function Disabled.
     * |        |          |1 = interrupt generation Enabled due to Resume Detected.
     * |[4]     |UE        |Unrecoverable Error Enable Control
     * |        |          |This event is not implemented. All writes to this bit are ignored.
     * |[5]     |FNO       |Frame Number Overflow Enable Control
     * |        |          |0 = The interrupt function Disabled.
     * |        |          |1 = Interrupt generation Enabled due to Frame Number Overflow.
     * |[6]     |RHSC      |Root Hub Status Change Enable Control
     * |        |          |0 = The interrupt function Disabled.
     * |        |          |1 = interrupt generation Enabled due to Root Hub Status Change.
     * |[31]    |MIE       |Master Interrupt Enable Control
     * |        |          |This bit is a global interrupt enable.
     * |        |          |A write of '1' allows interrupts to be enabled via the specific enable bits listed above.
    */
    __IO uint32_t HcInterruptEnable;

    /**
     * HcInterruptDisable
     * ===================================================================================================
     * Offset: 0x14  Host Controller Interrupt Disable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SO        |Scheduling Overrun Disable Control
     * |        |          |0 = No effect.
     * |        |          |1 = Interrupt generation Disabled due to Scheduling Overrun.
     * |[1]     |WDH       |Write Back Done Head Disable Control
     * |        |          |0 = No effect.
     * |        |          |1 = Interrupt generation Disabled due to Write-back Done Head.
     * |[2]     |SF        |Start Of Frame Disable Control
     * |        |          |0 = No effect.
     * |        |          |1 = Interrupt generation Disabled due to Start of Frame.
     * |[3]     |RD        |Resume Detected Disable Control
     * |        |          |0 = No effect.
     * |        |          |1 = Interrupt generation Disabled due to Resume Detected.
     * |[4]     |UE        |Unrecoverable Error Disable Control
     * |        |          |This event is not implemented. All writes to this bit are ignored.
     * |[5]     |FNO       |Frame Number Overflow Disable Control
     * |        |          |0 = No effect.
     * |        |          |1 = Interrupt generation Disabled due to Frame Number Overflow.
     * |[6]     |RHSC      |Root Hub Status Change Disable Control
     * |        |          |0 = No effect.
     * |        |          |1 = Interrupt generation Disabled due to Root Hub Status Change.
     * |[31]    |MIE       |Master Interrupt Disable Control
     * |        |          |Global interrupt disable. Writing '1' to disable all interrupts.
    */
    __IO uint32_t HcInterruptDisable;

    /**
     * HcHCCA
     * ===================================================================================================
     * Offset: 0x18  Host Controller Communication Area Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[8:31]  |HCCA      |Host Controller Communication Area
     * |        |          |Pointer to HCCA base address.
    */
    __IO uint32_t HcHCCA;

    /**
     * HcPeriodCurrentED
     * ===================================================================================================
     * Offset: 0x1C  Host Controller Period Current ED Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[4:31]  |PCED      |Periodic Current ED
     * |        |          |Pointer to the current Periodic List ED.
    */
    __IO uint32_t HcPeriodCurrentED;

    /**
     * HcControlHeadED
     * ===================================================================================================
     * Offset: 0x20  Host Controller Control Head ED Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[4:31]  |CHED      |Control Head ED
     * |        |          |Pointer to the Control List Head ED.
    */
    __IO uint32_t HcControlHeadED;

    /**
     * HcControlCurrentED
     * ===================================================================================================
     * Offset: 0x24  Host Controller Control Current ED Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[4:31]  |CCED      |Control Current Head ED
     * |        |          |Pointer to the current Control List Head ED.
    */
    __IO uint32_t HcControlCurrentED;

    /**
     * HcBulkHeadED
     * ===================================================================================================
     * Offset: 0x28  Host Controller Bulk Head ED Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[4:31]  |BHED      |Bulk Head ED
     * |        |          |Pointer to the Bulk List Head ED.
    */
    __IO uint32_t HcBulkHeadED;

    /**
     * HcBulkCurrentED
     * ===================================================================================================
     * Offset: 0x2C  Host Controller Bulk Current ED Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[4:31]  |BCED      |Bulk Current Head ED
     * |        |          |Pointer to the current Bulk List Head ED.
    */
    __IO uint32_t HcBulkCurrentED;

    /**
     * HcDoneHead
     * ===================================================================================================
     * Offset: 0x30  Host Controller Done Head Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[4:31]  |DH        |Done Head
     * |        |          |Pointer to the current Done List Head ED.
    */
    __IO uint32_t HcDoneHead;

    /**
     * HcFmInterval
     * ===================================================================================================
     * Offset: 0x34  Host Controller Frame Interval Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:13]  |FI        |Frame Interval
     * |        |          |This field specifies the length of a frame as (bit times - 1).
     * |        |          |For 12,000 bit times in a frame, a value of 11,999 is stored here.
     * |[16:30] |FSMPS     |FS Largest Data Packet
     * |        |          |This field specifies a value that is loaded into the Largest Data Packet Counter at the beginning of each frame.
     * |[31]    |FIT       |Frame Interval Toggle
     * |        |          |This bit is toggled by HCD when it loads a new value into Frame Interval.
    */
    __IO uint32_t HcFmInterval;

    /**
     * HcFmRemaining
     * ===================================================================================================
     * Offset: 0x38  Host Controller Frame Remaining Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:13]  |FR        |Frame Remaining
     * |        |          |When the Host Controller is in the USBOPERATIONAL state, this 14-bit field decrements each 12 MHz clock period.
     * |        |          |When the count reaches 0, (end of frame) the counter reloads with Frame Interval.
     * |        |          |In addition, the counter loads when the Host Controller transitions into USBOPERATIONAL.
     * |[31]    |FRT       |Frame Remaining Toggle
     * |        |          |Loaded with Frame Interval Toggle when FrameRemaining is loaded.
    */
    __I  uint32_t HcFmRemaining;

    /**
     * HcFmNumber
     * ===================================================================================================
     * Offset: 0x3C  Host Controller Frame Number Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |FN        |Frame Number
     * |        |          |This 16-bit incrementing counter field is incremented coincident with the loading of FrameRemaining.
     * |        |          |The count rolls over from 'FFFFh' to '0h.'.
    */
    __I  uint32_t HcFmNumber;

    /**
     * HcPeriodicStart
     * ===================================================================================================
     * Offset: 0x40  Host Controller Periodic Start Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:13]  |PS        |Periodic Start
     * |        |          |This field contains a value used by the List Processor to determine where in a frame the Periodic List processing must begin.
    */
    __IO uint32_t HcPeriodicStart;

    /**
     * HcLSThreshold
     * ===================================================================================================
     * Offset: 0x44  Host Controller Low-speed Threshold Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |LST       |Low-Speed Threshold
     * |        |          |This field contains a value which is compared to the FrameRemaining field prior to initiating a Low-speed transaction.
     * |        |          |The transaction is started only if FrameRemaining >= this field.
     * |        |          |The value is calculated by HCD with the consideration of transmission and setup overhead.
    */
    __IO uint32_t HcLSThreshold;

    /**
     * HcRhDescriptorA
     * ===================================================================================================
     * Offset: 0x48  Host Controller Root Hub Descriptor A Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |NDP       |Number Downstream Ports
     * |        |          |Root Hub supports two downstream ports. It's 2 in this Root Hub.
     * |[8]     |PSM       |Power Switching Mode
     * |        |          |Global power switching mode implemented in Root Hub.
     * |        |          |This bit is only valid when NPS bit is cleared.
     * |        |          |This bit should be written '0'.
     * |        |          |0 = Global Switching.
     * |        |          |1 = Individual Switching.
     * |[9]     |NPS       |No Power Switching
     * |        |          |Global power switching implemented in Root Hub.
     * |        |          |This bit should be written to support the external system port power switching implementation.
     * |        |          |0 = Ports are power switched.
     * |        |          |1 = Ports are always powered on.
     * |[10]    |DT        |Device Type
     * |        |          |The OHCI Root Hub is not a compound device.
     * |[11]    |OCPM      |Overcurrent Protection Mode
     * |        |          |Global overcurrent reporting implemented in Root Hub.
     * |        |          |This bit should be written 0 and is only valid when NOCP bit is cleared.
     * |        |          |0 = Global Overcurrent.
     * |        |          |1 = Individual Overcurrent.
     * |[12]    |NOCP      |No Overcurrent Protection
     * |        |          |Global overcurrent reporting implemented in Root Hub.
     * |        |          |This bit should be written to support the external system port overcurrent implementation.
     * |        |          |0 = Overcurrent status is reported.
     * |        |          |1 = Overcurrent status is not reported.
     * |[24:31] |POTGT     |Power On To Power Good Time
     * |        |          |This field value is represented as the number of 2 ms intervals, which ensuring that the power switching is effective within 2 ms.
     * |        |          |Only bits [25:24] are implemented as R/W.
     * |        |          |The remaining bits are read only as '0'.
     * |        |          |It is not expected that these bits be written to anything other than 1h, but limited adjustment is provided.
     * |        |          |This field should be written to support system implementation.
     * |        |          |This field should always be written to a non-zero value.
    */
    __IO uint32_t HcRhDescriptorA;

    /**
     * HcRhDescriptorB
     * ===================================================================================================
     * Offset: 0x4C  Host Controller Root Hub Descriptor B Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |DR        |Device Removable
     * |        |          |Root Hub ports default to removable devices.
     * |        |          |0 = Device not removable.
     * |        |          |1 = Device removable.
     * |        |          |Port Bit relationship:
     * |        |          |DevRemove[0] = Reserved.
     * |        |          |DevRemove[1] = Port 1.
     * |        |          |DevRemove[2] = Port 2.
    */
    __IO uint32_t HcRhDescriptorB;

    /**
     * HcRhStatus
     * ===================================================================================================
     * Offset: 0x50  Host Controller Root Hub Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |LPS       |LocalPowerStatus (Read)
     * |        |          |Not Supported. Always read '0'.
     * |        |          |ClearGlobalPower (Write)
     * |        |          |Writing '1' issues a ClearGlobalPower command to the ports. Writing '0' has no effect.
     * |[1]     |OCI       |Overcurrent Indicator
     * |        |          |This bit reflects the state of the OVRCUR pin.
     * |        |          |This field is only valid if NOCP (RHDESA[12]) and OCPM (RHDESA[11]) are cleared.
     * |        |          |0 = No overcurrent condition.
     * |        |          |1 = Overcurrent condition.
     * |[15]    |DRWE      |Device Remote Wake-Up Enable Control (Read)
     * |        |          |This bit enables ports' CC (HcRhPtr[0]) as a remote wake-up event.
     * |        |          |0 = Disabled.
     * |        |          |1 = Enabled.
     * |        |          |Set Remote Wake-up Enable Control (Write)
     * |        |          |Writing 1' sets DRWEn. Writing '0' has no effect.
     * |[16]    |LPSC      |Local Power Status Change (Read)
     * |        |          |Not supported. Always read '0'.
     * |        |          |SetGlobalPower (Write)
     * |        |          |Writing '1' issues a SetGlobalPower command to the ports. Writing '0' has no effect.
     * |[17]    |OCIC      |Overcurrent Indicator Change
     * |        |          |This bit is set when OC bit changes.
     * |        |          |Writing '1' clears this bit. Writing '0' has no effect.
     * |[31]    |CRWE      |Clear Remote Wake-Up Enable Control
     * |        |          |Writing '1' to this bit clears DRWEn (HcRhStatus[15]). Writing '0' has no effect.
    */
    __IO uint32_t HcRhStatus;

    /**
     * HcRhPortStatus1/HcRhPortStatus2
     * ===================================================================================================
     * Offset: 0x54,0x58  Host Controller Root Hub Port Status [1/2]
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |CCS       |Current Connect Status (Read)
     * |        |          |0 = No device connected.
     * |        |          |1 = Device connected.
     * |        |          |Clear Port Enable Control (Write)
     * |        |          |Writing '1' a clears PE. Writing '0' has no effect.
     * |[1]     |PES       |Port Enable Status (Read)
     * |        |          |0 = Port Disabled.
     * |        |          |1 = Port Enabled.
     * |        |          |SetPortEnable (Write)
     * |        |          |Writing '1' sets PE. Writing '0' has no effect.
     * |[2]     |PSS       |PortSuspendStatus (Read)
     * |        |          |0 = Port is not suspended.
     * |        |          |1 = Port is selectively suspended.
     * |        |          |SetPortSuspend (Write)
     * |        |          |Writing '1' sets PortSuspendStatus. Writing '0' has no effect.
     * |[3]     |POCI      |PortOverCurrentIndicator (Read)
     * |        |          |Root Hub supports global overcurrent reporting.
     * |        |          |This bit reflects the state of the OVRCUR pin dedicated to this port.
     * |        |          |This field is only valid if NOCP (RHDESA[12]) is cleared and OCPM (RHDESA[11]) is set.
     * |        |          |0 = No overcurrent condition.
     * |        |          |1 = Overcurrent condition.
     * |        |          |ClearPortSuspend (Write)
     * |        |          |Writing '1' initiates the selective resume sequence for the port. Writing '0' has no effect.
     * |[4]     |PRS       |PortResetStatus (Read)
     * |        |          |This bit reflects the power state of the port regardless of the power switching mode.
     * |        |          |0 = Port reset signal is not active.
     * |        |          |1 = Port reset signal is active.
     * |        |          |SetPortReset (Write)
     * |        |          |Writing '1' sets PR. Writing '0' has no effect.
     * |[8]     |PPS       |PortPowerStatus (Read)
     * |        |          |This bit reflects the power state of the port regardless of the power switching mode.
     * |        |          |0 = Port power is off.
     * |        |          |1 = Port power is on.
     * |        |          |Note: If NPS (RHDESA[9]) is set, this bit is always read as '1'.
     * |        |          |SetPortPower (Write)
     * |        |          |Writing '1' sets PPS. Writing '0' has no effect.
     * |[9]     |LSDA      |LowSpeedDeviceAttached (Read)
     * |        |          |This bit defines the speed (and bud idle) of the attached device. It is only valid when CC bit is set.
     * |        |          |0 = Full Speed device.
     * |        |          |1 = Low-speed device.
     * |        |          |ClearPortPower (Write)
     * |        |          |Writing '1' clears PPS bit. Writing '0' has no effect.
     * |[16]    |CSC       |Connect Status Change
     * |        |          |This bit indicates connect or disconnect event has been detected.
     * |        |          |Writing '1' clears this bit.
     * |        |          |Writing '0' has no effect.
     * |        |          |0 = No connect/disconnect event.
     * |        |          |1 = Hardware detection of connect/disconnect event.
     * |        |          |Note: If DevRemove (HcRhDescriptorB[2:0]) is set, this bit resets to '1'.
     * |[17]    |PESC      |Port Enable Status Change
     * |        |          |This bit indicates that the port has been disabled due to a hardware event (cleared PE bit).
     * |        |          |0 = No port enable change event.
     * |        |          |1 = Port enable state has been changed.
     * |[18]    |PSSC      |Port Reset Status Change
     * |        |          |This bit indicates the completion of the selective resume sequence for the port.
     * |        |          |0 = Port is not resumed.
     * |        |          |1 = Port resume is complete.
     * |[19]    |OCIC      |Port Overcurrent Indicator Change
     * |        |          |This bit is set when OC (HcRhStatus[1]) changes. Writing '1' clears this bit. Writing '0' has no effect.
     * |[20]    |PRSC      |Port Reset Status Change
     * |        |          |This bit indicates that the port reset signal has completed.
     * |        |          |0 = Port reset is not complete.
     * |        |          |1 = Port reset is complete.
    */
    __IO uint32_t HcRhPortStatus[2];
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[105];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * HcPhyControl
     * ===================================================================================================
     * Offset: 0x200  USB PHY Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[27]    |STBYEN    |USB Transceiver Standby Enable Control
     * |        |          |This bit controls if USB 1.1 transceiver could enter the standby mode to reduce power consumption.
     * |        |          |If this bit is low, the USB 1.1 transceiver would never enter the standby mode.
     * |        |          |If this bit is high, the USB 1.1 transceiver will enter standby mode while port is in power off state (port power is inactive).
    */
    __IO uint32_t HcPhyControl;

    /**
     * HcMiscControl
     * ===================================================================================================
     * Offset: 0x204  USB Operational Mode Enable Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |DBR16     |Data Buffer Region 16
     * |        |          |When set, the size of the data buffer region is 16 bytes. Otherwise, the size is 32 bytes.
     * |[1]     |ABORT     |AHB Bus ERROR Response
     * |        |          |This bit indicates there is an ERROR response received in AHB bus.
     * |        |          |0 = No ERROR response received.
     * |        |          |1 = ERROR response received.
     * |[3]     |OCA       |Overcurrent Active Low
     * |        |          |This bit controls the polarity of overcurrent flag from external power IC.
     * |        |          |0 = Overcurrent flag is high active.
     * |        |          |1 = Overcurrent flag is low active.
     * |[4]     |PCAL      |Port Power Control Active Low
     * |        |          |This bit controls the polarity of port power control to external power IC.
     * |        |          |0 = Port power control is high active.
     * |        |          |1 = Port power control is low active.
     * |[8]     |SIEPD     |SIE Pipeline Disable Control
     * |        |          |When set, waits for all USB bus activity to complete prior to returning completion status to the List Processor.
     * |        |          |This is a fail safe mechanism to avoid potential problems with the clk_dr transition between 1.5 MHz and 12 MHz.
     * |[16]    |DPRT1     |Port 1 Disable Control
     * |        |          |This bit controls if the connection between USB host controller and transceiver of port 1 is disabled.
     * |        |          |If the connection is disabled, the USB host controller will not recognize any event of USB bus.
     * |        |          |Set this bit high, the transceiver of port 1 will also be forced into the standby mode no matter what USB host controller operation is.
     * |        |          |0 = The connection between USB host controller and transceiver of port 1 is enabled.
     * |        |          |1 = The connection between USB host controller and transceiver of port 1 is disabled and the transceiver of port 1 will also be forced into the standby mode.
     * |[17]    |DPRT2     |Port 2 Disable Control
     * |        |          |This bit controls if the connection between USB host controller and transceiver of port 2 is disabled.
     * |        |          |If the connection is disabled, the USB host controller will not recognize any event of USB bus.
     * |        |          |Set this bit high, the transceiver of port 2 will also be forced into the standby mode no matter what USB host controller operation is.
     * |        |          |0 = The connection between USB host controller and transceiver of port 2 is enabled.
     * |        |          |1 = The connection between USB host controller and transceiver of port 2 is disabled and the transceiver of port 2 will also be forced into the standby mode.
    */
    __IO uint32_t HcMiscControl;

} USBH_T;

/**
    @addtogroup USBH_CONST USBH Bit Field Definition
    Constant Definitions for USBH Controller
@{ */

#define USBH_HcRevision_REV_Pos          (0)                                               /*!< USBH_T::HcRevision: REV Position          */
#define USBH_HcRevision_REV_Msk          (0xfful << USBH_HcRevision_REV_Pos)               /*!< USBH_T::HcRevision: REV Mask              */

#define USBH_HcControl_CBSR_Pos          (0)                                               /*!< USBH_T::HcControl: CBSR Position          */
#define USBH_HcControl_CBSR_Msk          (0x3ul << USBH_HcControl_CBSR_Pos)                /*!< USBH_T::HcControl: CBSR Mask              */

#define USBH_HcControl_PLE_Pos           (2)                                               /*!< USBH_T::HcControl: CBSR Position          */
#define USBH_HcControl_PLE_Msk           (0x1ul << USBH_HcControl_PLE_Pos)                 /*!< USBH_T::HcControl: CBSR Mask              */

#define USBH_HcControl_IE_Pos            (3)                                               /*!< USBH_T::HcControl: IE Position            */
#define USBH_HcControl_IE_Msk            (0x1ul << USBH_HcControl_IE_Pos)                  /*!< USBH_T::HcControl: IE Mask                */

#define USBH_HcControl_CLE_Pos           (4)                                               /*!< USBH_T::HcControl: CLE Position           */
#define USBH_HcControl_CLE_Msk           (0x1ul << USBH_HcControl_CLE_Pos)                 /*!< USBH_T::HcControl: CLE Mask               */

#define USBH_HcControl_BLE_Pos           (5)                                               /*!< USBH_T::HcControl: BLE Position           */
#define USBH_HcControl_BLE_Msk           (0x1ul << USBH_HcControl_BLE_Pos)                 /*!< USBH_T::HcControl: BLE Mask               */

#define USBH_HcControl_HCFS_Pos          (6)                                               /*!< USBH_T::HcControl: HCFS Position          */
#define USBH_HcControl_HCFS_Msk          (0x3ul << USBH_HcControl_HCFS_Pos)                /*!< USBH_T::HcControl: HCFS Mask              */

#define USBH_HcCommandStatus_HCR_Pos     (0)                                               /*!< USBH_T::HcCommandStatus: HCR Position     */
#define USBH_HcCommandStatus_HCR_Msk     (0x1ul << USBH_HcCommandStatus_HCR_Pos)           /*!< USBH_T::HcCommandStatus: HCR Mask         */

#define USBH_HcCommandStatus_CLF_Pos     (1)                                               /*!< USBH_T::HcCommandStatus: CLF Position     */
#define USBH_HcCommandStatus_CLF_Msk     (0x1ul << USBH_HcCommandStatus_CLF_Pos)           /*!< USBH_T::HcCommandStatus: CLF Mask         */

#define USBH_HcCommandStatus_BLF_Pos     (2)                                               /*!< USBH_T::HcCommandStatus: BLF Position     */
#define USBH_HcCommandStatus_BLF_Msk     (0x1ul << USBH_HcCommandStatus_BLF_Pos)           /*!< USBH_T::HcCommandStatus: BLF Mask         */

#define USBH_HcCommandStatus_SOC_Pos     (16)                                              /*!< USBH_T::HcCommandStatus: SOC Position     */
#define USBH_HcCommandStatus_SOC_Msk     (0x3ul << USBH_HcCommandStatus_SOC_Pos)           /*!< USBH_T::HcCommandStatus: SOC Mask         */

#define USBH_HcInterruptStatus_SO_Pos    (0)                                               /*!< USBH_T::HcInterruptStatus: SO Position    */
#define USBH_HcInterruptStatus_SO_Msk    (0x1ul << USBH_HcInterruptStatus_SO_Pos)          /*!< USBH_T::HcInterruptStatus: SO Mask        */

#define USBH_HcInterruptStatus_WDH_Pos   (1)                                               /*!< USBH_T::HcInterruptStatus: WDH Position   */
#define USBH_HcInterruptStatus_WDH_Msk   (0x1ul << USBH_HcInterruptStatus_WDH_Pos)         /*!< USBH_T::HcInterruptStatus: WDH Mask       */

#define USBH_HcInterruptStatus_SF_Pos    (2)                                               /*!< USBH_T::HcInterruptStatus: SF Position    */
#define USBH_HcInterruptStatus_SF_Msk    (0x1ul << USBH_HcInterruptStatus_SF_Pos)          /*!< USBH_T::HcInterruptStatus: SF Mask        */

#define USBH_HcInterruptStatus_RD_Pos    (3)                                               /*!< USBH_T::HcInterruptStatus: RD Position    */
#define USBH_HcInterruptStatus_RD_Msk    (0x1ul << USBH_HcInterruptStatus_RD_Pos)          /*!< USBH_T::HcInterruptStatus: RD Mask        */

#define USBH_HcInterruptStatus_FNO_Pos   (5)                                               /*!< USBH_T::HcInterruptStatus: FNO Position   */
#define USBH_HcInterruptStatus_FNO_Msk   (0x1ul << USBH_HcInterruptStatus_FNO_Pos)         /*!< USBH_T::HcInterruptStatus: FNO Mask       */

#define USBH_HcInterruptStatus_RHSC_Pos  (6)                                               /*!< USBH_T::HcInterruptStatus: RHSC Position  */
#define USBH_HcInterruptStatus_RHSC_Msk  (0x1ul << USBH_HcInterruptStatus_RHSC_Pos)        /*!< USBH_T::HcInterruptStatus: RHSC Mask      */

#define USBH_HcInterruptEnable_SO_Pos    (0)                                               /*!< USBH_T::HcInterruptEnable: SO Position    */
#define USBH_HcInterruptEnable_SO_Msk    (0x1ul << USBH_HcInterruptEnable_SO_Pos)          /*!< USBH_T::HcInterruptEnable: SO Mask        */

#define USBH_HcInterruptEnable_WDH_Pos   (1)                                               /*!< USBH_T::HcInterruptEnable: WDH Position   */
#define USBH_HcInterruptEnable_WDH_Msk   (0x1ul << USBH_HcInterruptEnable_WDH_Pos)         /*!< USBH_T::HcInterruptEnable: WDH Mask       */

#define USBH_HcInterruptEnable_SF_Pos    (2)                                               /*!< USBH_T::HcInterruptEnable: SF Position    */
#define USBH_HcInterruptEnable_SF_Msk    (0x1ul << USBH_HcInterruptEnable_SF_Pos)          /*!< USBH_T::HcInterruptEnable: SF Mask        */

#define USBH_HcInterruptEnable_RD_Pos    (3)                                               /*!< USBH_T::HcInterruptEnable: RD Position    */
#define USBH_HcInterruptEnable_RD_Msk    (0x1ul << USBH_HcInterruptEnable_RD_Pos)          /*!< USBH_T::HcInterruptEnable: RD Mask        */

#define USBH_HcInterruptEnable_FNO_Pos   (5)                                               /*!< USBH_T::HcInterruptEnable: FNO Position   */
#define USBH_HcInterruptEnable_FNO_Msk   (0x1ul << USBH_HcInterruptEnable_FNO_Pos)         /*!< USBH_T::HcInterruptEnable: FNO Mask       */

#define USBH_HcInterruptEnable_RHSC_Pos  (6)                                               /*!< USBH_T::HcInterruptEnable: RHSC Position  */
#define USBH_HcInterruptEnable_RHSC_Msk  (0x1ul << USBH_HcInterruptEnable_RHSC_Pos)        /*!< USBH_T::HcInterruptEnable: RHSC Mask      */

#define USBH_HcInterruptEnable_MIE_Pos   (31)                                              /*!< USBH_T::HcInterruptEnable: MIE Position   */
#define USBH_HcInterruptEnable_MIE_Msk   (0x1ul << USBH_HcInterruptEnable_MIE_Pos)         /*!< USBH_T::HcInterruptEnable: MIE Mask       */

#define USBH_HcInterruptDisable_SO_Pos   (0)                                               /*!< USBH_T::HcInterruptDisable: SO Position   */
#define USBH_HcInterruptDisable_SO_Msk   (0x1ul << USBH_HcInterruptDisable_SO_Pos)         /*!< USBH_T::HcInterruptDisable: SO Mask       */

#define USBH_HcInterruptDisable_WDH_Pos  (1)                                               /*!< USBH_T::HcInterruptDisable: WDH Position  */
#define USBH_HcInterruptDisable_WDH_Msk  (0x1ul << USBH_HcInterruptDisable_WDH_Pos)        /*!< USBH_T::HcInterruptDisable: WDH Mask      */

#define USBH_HcInterruptDisable_SF_Pos   (2)                                               /*!< USBH_T::HcInterruptDisable: SF Position   */
#define USBH_HcInterruptDisable_SF_Msk   (0x1ul << USBH_HcInterruptDisable_SF_Pos)         /*!< USBH_T::HcInterruptDisable: SF Mask       */

#define USBH_HcInterruptDisable_RD_Pos   (3)                                               /*!< USBH_T::HcInterruptDisable: RD Position   */
#define USBH_HcInterruptDisable_RD_Msk   (0x1ul << USBH_HcInterruptDisable_RD_Pos)         /*!< USBH_T::HcInterruptDisable: RD Mask       */

#define USBH_HcInterruptDisable_FNO_Pos  (5)                                               /*!< USBH_T::HcInterruptDisable: FNO Position  */
#define USBH_HcInterruptDisable_FNO_Msk  (0x1ul << USBH_HcInterruptDisable_FNO_Pos)        /*!< USBH_T::HcInterruptDisable: FNO Mask      */

#define USBH_HcInterruptDisable_RHSC_Pos (6)                                               /*!< USBH_T::HcInterruptDisable: RHSC Position */
#define USBH_HcInterruptDisable_RHSC_Msk (0x1ul << USBH_HcInterruptDisable_RHSC_Pos)       /*!< USBH_T::HcInterruptDisable: RHSC Mask     */

#define USBH_HcInterruptDisable_MIE_Pos  (31)                                              /*!< USBH_T::HcInterruptDisable: MIE Position  */
#define USBH_HcInterruptDisable_MIE_Msk  (0x1ul << USBH_HcInterruptDisable_MIE_Pos)        /*!< USBH_T::HcInterruptDisable: MIE Mask      */

#define USBH_HcHCCA_HCCA_Pos             (8)                                               /*!< USBH_T::HcHCCA: HCCA Position             */
#define USBH_HcHCCA_HCCA_Msk             (0xfffffful << USBH_HcHCCA_HCCA_Pos)              /*!< USBH_T::HcHCCA: HCCA Mask                 */

#define USBH_HcPeriodCurrentED_PCED_Pos  (4)                                               /*!< USBH_T::HcPeriodCurrentED: PCED Position  */
#define USBH_HcPeriodCurrentED_PCED_Msk  (0xffffffful << USBH_HcPeriodCurrentED_PCED_Pos)  /*!< USBH_T::HcPeriodCurrentED: PCED Mask      */

#define USBH_HcControlHeadED_CHED_Pos    (4)                                               /*!< USBH_T::HcControlHeadED: CHED Position    */
#define USBH_HcControlHeadED_CHED_Msk    (0xffffffful << USBH_HcControlHeadED_CHED_Pos)    /*!< USBH_T::HcControlHeadED: CHED Mask        */

#define USBH_HcControlCurrentED_CCED_Pos (4)                                               /*!< USBH_T::HcControlCurrentED: CCED Position */
#define USBH_HcControlCurrentED_CCED_Msk (0xffffffful << USBH_HcControlCurrentED_CCED_Pos) /*!< USBH_T::HcControlCurrentED: CCED Mask     */

#define USBH_HcBulkHeadED_BHED_Pos       (4)                                               /*!< USBH_T::HcBulkHeadED: BHED Position       */
#define USBH_HcBulkHeadED_BHED_Msk       (0xffffffful << USBH_HcBulkHeadED_BHED_Pos)       /*!< USBH_T::HcBulkHeadED: BHED Mask           */

#define USBH_HcBulkCurrentED_BCED_Pos    (4)                                               /*!< USBH_T::HcBulkCurrentED: BCED Position    */
#define USBH_HcBulkCurrentED_BCED_Msk    (0xffffffful << USBH_HcBulkCurrentED_BCED_Pos)    /*!< USBH_T::HcBulkCurrentED: BCED Mask        */

#define USBH_HcDoneHead_DH_Pos           (4)                                               /*!< USBH_T::HcDoneHead: DH Position           */
#define USBH_HcDoneHead_DH_Msk           (0xffffffful << USBH_HcDoneHead_DH_Pos)           /*!< USBH_T::HcDoneHead: DH Mask               */

#define USBH_HcFmInterval_FI_Pos         (0)                                               /*!< USBH_T::HcFmInterval: FI Position         */
#define USBH_HcFmInterval_FI_Msk         (0x3ffful << USBH_HcFmInterval_FI_Pos)            /*!< USBH_T::HcFmInterval: FI Mask             */

#define USBH_HcFmInterval_FSMPS_Pos      (16)                                              /*!< USBH_T::HcFmInterval: FSMPS Position      */
#define USBH_HcFmInterval_FSMPS_Msk      (0x7ffful << USBH_HcFmInterval_FSMPS_Pos)         /*!< USBH_T::HcFmInterval: FSMPS Mask          */

#define USBH_HcFmInterval_FIT_Pos        (31)                                              /*!< USBH_T::HcFmInterval: FIT Position        */
#define USBH_HcFmInterval_FIT_Msk        (0x1ul << USBH_HcFmInterval_FIT_Pos)              /*!< USBH_T::HcFmInterval: FIT Mask            */

#define USBH_HcFmRemaining_FR_Pos        (0)                                               /*!< USBH_T::HcFmRemaining: FR Position        */
#define USBH_HcFmRemaining_FR_Msk        (0x3ffful << USBH_HcFmRemaining_FR_Pos)           /*!< USBH_T::HcFmRemaining: FR Mask            */

#define USBH_HcFmRemaining_FRT_Pos       (31)                                              /*!< USBH_T::HcFmRemaining: FRT Position       */
#define USBH_HcFmRemaining_FRT_Msk       (0x1ul << USBH_HcFmRemaining_FRT_Pos)             /*!< USBH_T::HcFmRemaining: FRT Mask           */

#define USBH_HcFmNumber_FN_Pos           (0)                                               /*!< USBH_T::HcFmNumber: FN Position           */
#define USBH_HcFmNumber_FN_Msk           (0xfffful << USBH_HcFmNumber_FN_Pos)              /*!< USBH_T::HcFmNumber: FN Mask               */

#define USBH_HcPeriodicStart_PS_Pos      (0)                                               /*!< USBH_T::HcPeriodicStart: PS Position      */
#define USBH_HcPeriodicStart_PS_Msk      (0x3ffful << USBH_HcPeriodicStart_PS_Pos)         /*!< USBH_T::HcPeriodicStart: PS Mask          */

#define USBH_HcLSThreshold_LST_Pos       (0)                                               /*!< USBH_T::HcLSThreshold: LST Position       */
#define USBH_HcLSThreshold_LST_Msk       (0xffful << USBH_HcLSThreshold_LST_Pos)           /*!< USBH_T::HcLSThreshold: LST Mask           */

#define USBH_HcRhDescriptorA_NDP_Pos     (0)                                               /*!< USBH_T::HcRhDescriptorA: NDP Position     */
#define USBH_HcRhDescriptorA_NDP_Msk     (0xfful << USBH_HcRhDescriptorA_NDP_Pos)          /*!< USBH_T::HcRhDescriptorA: NDP Mask         */
 
#define USBH_HcRhDescriptorA_PSM_Pos     (8)                                               /*!< USBH_T::HcRhDescriptorA: PSM Position     */
#define USBH_HcRhDescriptorA_PSM_Msk     (0x1ul << USBH_HcRhDescriptorA_PSM_Pos)           /*!< USBH_T::HcRhDescriptorA: PSM Mask         */

#define USBH_HcRhDescriptorA_NPS_Pos     (9)                                               /*!< USBH_T::HcRhDescriptorA: NPS Position     */
#define USBH_HcRhDescriptorA_NPS_Msk     (0x1ul << USBH_HcRhDescriptorA_NPS_Pos)           /*!< USBH_T::HcRhDescriptorA: NPS Mask         */

#define USBH_HcRhDescriptorA_DT_Pos      (10)                                              /*!< USBH_T::HcRhDescriptorA: DT Position      */
#define USBH_HcRhDescriptorA_DT_Msk      (0x1ul << USBH_HcRhDescriptorA_DT_Pos)            /*!< USBH_T::HcRhDescriptorA: DT Mask          */

#define USBH_HcRhDescriptorA_OCPM_Pos    (11)                                              /*!< USBH_T::HcRhDescriptorA: OCPM Position    */
#define USBH_HcRhDescriptorA_OCPM_Msk    (0x1ul << USBH_HcRhDescriptorA_OCPM_Pos)          /*!< USBH_T::HcRhDescriptorA: OCPM Mask        */

#define USBH_HcRhDescriptorA_NOCP_Pos    (12)                                              /*!< USBH_T::HcRhDescriptorA: NOCP Position    */
#define USBH_HcRhDescriptorA_NOCP_Msk    (0x1ul << USBH_HcRhDescriptorA_NOCP_Pos)          /*!< USBH_T::HcRhDescriptorA: NOCP Mask        */

#define USBH_HcRhDescriptorA_POTPGT_Pos  (24)                                              /*!< USBH_T::HcRhDescriptorA: POTPGT Position  */
#define USBH_HcRhDescriptorA_POTPGT_Msk  (0xfful << USBH_HcRhDescriptorA_POTPGT_Pos)       /*!< USBH_T::HcRhDescriptorA: POTPGT Mask      */

#define USBH_HcRhDescriptorB_PPCM_Pos    (16)                                              /*!< USBH_T::HcRhDescriptorB: PPCM Position    */
#define USBH_HcRhDescriptorB_PPCM_Msk    (0xfffful << USBH_HcRhDescriptorB_PPCM_Pos)       /*!< USBH_T::HcRhDescriptorB: PPCM Mask        */

#define USBH_HcRhStatus_LPS_Pos          (0)                                               /*!< USBH_T::HcRhStatus: LPS Position          */
#define USBH_HcRhStatus_LPS_Msk          (0x1ul << USBH_HcRhStatus_LPS_Pos)                /*!< USBH_T::HcRhStatus: LPS Mask              */

#define USBH_HcRhStatus_OCI_Pos          (1)                                               /*!< USBH_T::HcRhStatus: OCI Position          */
#define USBH_HcRhStatus_OCI_Msk          (0x1ul << USBH_HcRhStatus_OCI_Pos)                /*!< USBH_T::HcRhStatus: OCI Mask              */

#define USBH_HcRhStatus_DRWE_Pos         (15)                                              /*!< USBH_T::HcRhStatus: DRWE Position         */
#define USBH_HcRhStatus_DRWE_Msk         (0x1ul << USBH_HcRhStatus_DRWE_Pos)               /*!< USBH_T::HcRhStatus: DRWE Mask             */

#define USBH_HcRhStatus_LPSC_Pos         (16)                                              /*!< USBH_T::HcRhStatus: LPSC Position         */
#define USBH_HcRhStatus_LPSC_Msk         (0x1ul << USBH_HcRhStatus_LPSC_Pos)               /*!< USBH_T::HcRhStatus: LPSC Mask             */

#define USBH_HcRhStatus_OCIC_Pos         (17)                                              /*!< USBH_T::HcRhStatus: OCIC Position         */
#define USBH_HcRhStatus_OCIC_Msk         (0x1ul << USBH_HcRhStatus_OCIC_Pos)               /*!< USBH_T::HcRhStatus: OCIC Mask             */

#define USBH_HcRhStatus_CRWE_Pos         (31)                                              /*!< USBH_T::HcRhStatus: CRWE Position         */
#define USBH_HcRhStatus_CRWE_Msk         (0x1ul << USBH_HcRhStatus_CRWE_Pos)               /*!< USBH_T::HcRhStatus: CRWE Mask             */

#define USBH_HcRhPortStatus_CCS_Pos      (0)                                               /*!< USBH_T::HcRhPortStatus: CCS Position      */
#define USBH_HcRhPortStatus_CCS_Msk      (0x1ul << USBH_HcRhPortStatus_CCS_Pos)             /*!< USBH_T::HcRhPortStatus: CCS Mask         */

#define USBH_HcRhPortStatus_PES_Pos      (1)                                               /*!< USBH_T::HcRhPortStatus: PES Position      */
#define USBH_HcRhPortStatus_PES_Msk      (0x1ul << USBH_HcRhPortStatus_PES_Pos)            /*!< USBH_T::HcRhPortStatus: PES Mask          */

#define USBH_HcRhPortStatus_PSS_Pos      (2)                                               /*!< USBH_T::HcRhPortStatus: PSS Position      */
#define USBH_HcRhPortStatus_PSS_Msk      (0x1ul << USBH_HcRhPortStatus_PSS_Pos)            /*!< USBH_T::HcRhPortStatus: PSS Mask          */

#define USBH_HcRhPortStatus_POCI_Pos     (3)                                               /*!< USBH_T::HcRhPortStatus: POCI Position     */
#define USBH_HcRhPortStatus_POCI_Msk     (0x1ul << USBH_HcRhPortStatus_POCI_Pos)           /*!< USBH_T::HcRhPortStatus: POCI Mask         */

#define USBH_HcRhPortStatus_PRS_Pos      (4)                                               /*!< USBH_T::HcRhPortStatus: PRS Position      */
#define USBH_HcRhPortStatus_PRS_Msk      (0x1ul << USBH_HcRhPortStatus_PRS_Pos)            /*!< USBH_T::HcRhPortStatus: PRS Mask          */

#define USBH_HcRhPortStatus_PPS_Pos      (8)                                               /*!< USBH_T::HcRhPortStatus: PPS Position      */
#define USBH_HcRhPortStatus_PPS_Msk      (0x1ul << USBH_HcRhPortStatus_PPS_Pos)            /*!< USBH_T::HcRhPortStatus: PPS Mask          */

#define USBH_HcRhPortStatus_LSDA_Pos     (9)                                               /*!< USBH_T::HcRhPortStatus: LSDA Position     */
#define USBH_HcRhPortStatus_LSDA_Msk     (0x1ul << USBH_HcRhPortStatus_LSDA_Pos)           /*!< USBH_T::HcRhPortStatus: LSDA Mask         */

#define USBH_HcRhPortStatus_CSC_Pos      (16)                                              /*!< USBH_T::HcRhPortStatus: CSC Position      */
#define USBH_HcRhPortStatus_CSC_Msk      (0x1ul << USBH_HcRhPortStatus_CSC_Pos)            /*!< USBH_T::HcRhPortStatus: CSC Mask          */

#define USBH_HcRhPortStatus_PESC_Pos     (17)                                              /*!< USBH_T::HcRhPortStatus: PESC Position     */
#define USBH_HcRhPortStatus_PESC_Msk     (0x1ul << USBH_HcRhPortStatus_PESC_Pos)           /*!< USBH_T::HcRhPortStatus: PESC Mask         */

#define USBH_HcRhPortStatus_PSSC_Pos     (18)                                              /*!< USBH_T::HcRhPortStatus: PSSC Position     */
#define USBH_HcRhPortStatus_PSSC_Msk     (0x1ul << USBH_HcRhPortStatus_PSSC_Pos)           /*!< USBH_T::HcRhPortStatus: PSSC Mask         */

#define USBH_HcRhPortStatus_OCIC_Pos     (19)                                              /*!< USBH_T::HcRhPortStatus: OCIC Position     */
#define USBH_HcRhPortStatus_OCIC_Msk     (0x1ul << USBH_HcRhPortStatus_OCIC_Pos)           /*!< USBH_T::HcRhPortStatus: OCIC Mask         */

#define USBH_HcRhPortStatus_PRSC_Pos     (20)                                              /*!< USBH_T::HcRhPortStatus: PRSC Position     */
#define USBH_HcRhPortStatus_PRSC_Msk     (0x1ul << USBH_HcRhPortStatus_PRSC_Pos)           /*!< USBH_T::HcRhPortStatus: PRSC Mask         */

#define USBH_HcPhyControl_STBYEN_Pos     (27)                                              /*!< USBH_T::HcPhyControl: STBYEN Position     */
#define USBH_HcPhyControl_STBYEN_Msk     (0x1ul << USBH_HcPhyControl_STBYEN_Pos)           /*!< USBH_T::HcPhyControl: STBYEN Mask         */

#define USBH_HcMiscControl_DBR16_Pos     (0)                                               /*!< USBH_T::HcMiscControl: DBR16 Position     */
#define USBH_HcMiscControl_DBR16_Msk     (0x1ul << USBH_HcMiscControl_DBR16_Pos)           /*!< USBH_T::HcMiscControl: DBR16 Mask         */

#define USBH_HcMiscControl_ABORT_Pos     (1)                                               /*!< USBH_T::HcMiscControl: ABORT Position     */
#define USBH_HcMiscControl_ABORT_Msk     (0x1ul << USBH_HcMiscControl_ABORT_Pos)           /*!< USBH_T::HcMiscControl: ABORT Mask         */

#define USBH_HcMiscControl_OCAL_Pos      (3)                                               /*!< USBH_T::HcMiscControl: OCAL Position      */
#define USBH_HcMiscControl_OCAL_Msk      (0x1ul << USBH_HcMiscControl_OCAL_Pos)            /*!< USBH_T::HcMiscControl: OCAL Mask          */

#define USBH_HcMiscControl_PCAL_Pos      (4)                                               /*!< USBH_T::HcMiscControl: PCAL Position      */
#define USBH_HcMiscControl_PCAL_Msk      (0x1ul << USBH_HcMiscControl_PCAL_Pos)            /*!< USBH_T::HcMiscControl: PCAL Mask          */

#define USBH_HcMiscControl_SIEPD_Pos     (8)                                               /*!< USBH_T::HcMiscControl: SIEPD Position     */
#define USBH_HcMiscControl_SIEPD_Msk     (0x1ul << USBH_HcMiscControl_SIEPD_Pos)           /*!< USBH_T::HcMiscControl: SIEPD Mask         */

#define USBH_HcMiscControl_DPRT1_Pos     (16)                                              /*!< USBH_T::HcMiscControl: DPRT1 Position     */
#define USBH_HcMiscControl_DPRT1_Msk     (0x1ul << USBH_HcMiscControl_DPRT1_Pos)           /*!< USBH_T::HcMiscControl: DPRT1 Mask         */

#define USBH_HcMiscControl_DPRT2_Pos     (17)                                              /*!< USBH_T::HcMiscControl: DPRT2 Position     */
#define USBH_HcMiscControl_DPRT2_Msk     (0x1ul << USBH_HcMiscControl_DPRT2_Pos)           /*!< USBH_T::HcMiscControl: DPRT2 Mask         */

/**@}*/ /* USBH_CONST */
/**@}*/ /* end of USBH register group */


/*---------------------- USB Device Controller -------------------------*/
/**
    @addtogroup USBD USB Device Controller(USBD)
    Memory Mapped Structure for USBD Controller
@{ */
/**
  * @brief USBD endpoints register
  */
typedef struct {

    union {

        /**
         * EPxDAT
         * ===================================================================================================
         * Offset: 0x64+x*0x28  Endpoint x Data Register
         * ---------------------------------------------------------------------------------------------------
         * |Bits    |Field     |Descriptions
         * | :----: | :----:   | :---- |
         * |[0:31]  |EPDAT     |Endpoint A~L Data Register
         * |        |          |Endpoint A~L data buffer for the buffer transaction (read or write).
         * |        |          |Note: Only word or byte access are supported.
        */
        __IO uint32_t EPDAT;
        /**
         * EPxDAT_BYTE
         * ===================================================================================================
         * Offset: 0x64+x*0x28  Endpoint x Data Register for Byte Access
         * ---------------------------------------------------------------------------------------------------
         * |Bits    |Field     |Descriptions
         * | :----: | :----:   | :---- |
         * |[0:7]   |EPDAT     |Endpoint A~L Data Register
         * |        |          |Endpoint A~L data buffer for the buffer transaction (read or write).
         * |        |          |Note: Only word or byte access are supported.
        */
        __IO uint8_t  EPDAT_BYTE;

    }; ///< Define EPA Data Register 32-bit or 8-bit access

    /**
     * EPxINTSTS
     * ===================================================================================================
     * Offset: 0x68+x*0x28  Endpoint x Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BUFFULLIF |Buffer Full
     * |        |          |For an IN endpoint, the currently selected buffer is full, or no buffer is available to the local side for writing (no space to write).
     * |        |          |For an OUT endpoint, there is a buffer available on the local side, and there are FIFO full of bytes available to be read (entire packet is available for reading).
     * |        |          |0 = The endpoint packet buffer is not full.
     * |        |          |1 = The endpoint packet buffer is full.
     * |        |          |Note: This bit is read-only.
     * |[1]     |BUFEMPTYIF|Buffer Empty
     * |        |          |For an IN endpoint, a buffer is available to the local side for writing up to FIFO full of bytes.
     * |        |          |0 = The endpoint buffer is not empty.
     * |        |          |1 = The endpoint buffer is empty.
     * |        |          |For an OUT endpoint:
     * |        |          |0 = The currently selected buffer has not a count of 0.
     * |        |          |1 = The currently selected buffer has a count of 0, or no buffer is available on the local side (nothing to read).
     * |        |          |Note: This bit is read-only.
     * |[2]     |SHORTTXIF |Short Packet Transferred Interrupt
     * |        |          |0 = The length of the last packet was not less than the Maximum Packet Size (EPMPS).
     * |        |          |1 = The length of the last packet was less than the Maximum Packet Size (EPMPS).
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[3]     |TXPKIF    |Data Packet Transmitted Interrupt
     * |        |          |0 = Not a data packet is transmitted from the endpoint to the host.
     * |        |          |1 = A data packet is transmitted from the endpoint to the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[4]     |RXPKIF    |Data Packet Received Interrupt
     * |        |          |0 = No data packet is received from the host by the endpoint.
     * |        |          |1 = A data packet is received from the host by the endpoint.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[5]     |OUTTKIF   |Data OUT Token Interrupt
     * |        |          |0 = A Data OUT token has not been received from the host.
     * |        |          |1 = A Data OUT token has been received from the host.
     * |        |          |This bit also set by PING tokens(in high-speed only).
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[6]     |INTKIF    |Data IN Token Interrupt
     * |        |          |0 = Not Data IN token has been received from the host.
     * |        |          |1 = A Data IN token has been received from the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[7]     |PINGIF    |PING Token Interrupt
     * |        |          |0 = A Data PING token has not been received from the host.
     * |        |          |1 = A Data PING token has been received from the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[8]     |NAKIF     |USB NAK Sent
     * |        |          |0 = The last USB IN packet could be provided, and was acknowledged with a ACK.
     * |        |          |1 = The last USB IN packet could not be provided, and was acknowledged with a NAK.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[9]     |STALLIF   |USB STALL Sent
     * |        |          |0 = The last USB packet could be accepted or provided because the endpoint was stalled, and was acknowledged with a STALL.
     * |        |          |1 = The last USB packet could not be accepted or provided because the endpoint was stalled, and was acknowledged with a STALL.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[10]    |NYETIF    |NYET Sent
     * |        |          |0 = The space available in the RAM is sufficient to accommodate the next on coming data packet.
     * |        |          |1 = The space available in the RAM is not sufficient to accommodate the next on coming data packet.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[11]    |ERRIF     |ERR Sent
     * |        |          |0 = No any error in the transaction.
     * |        |          |1 = There occurs any error in the transaction.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[12]    |SHORTRXIF |Bulk Out Short Packet Received
     * |        |          |0 = No bulk out short packet is received.
     * |        |          |1 = Received bulk out short packet (including zero length packet ).
     * |        |          |Note: Write 1 to clear this bit to 0.
    */
    __IO uint32_t EPINTSTS;

    /**
     * EPxINTEN
     * ===================================================================================================
     * Offset: 0x6C+x*0x28  Endpoint x Interrupt Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |BUFFULLIEN|Buffer Full Interrupt
     * |        |          |When set, this bit enables a local interrupt to be set when a buffer full condition is detected on the bus.
     * |        |          |0 = Buffer full interrupt Disabled.
     * |        |          |1 = Buffer full interrupt Enabled.
     * |[1]     |BUFEMPTYIEN|Buffer Empty Interrupt
     * |        |          |When set, this bit enables a local interrupt to be set when a buffer empty condition is detected on the bus.
     * |        |          |0 = Buffer empty interrupt Disabled.
     * |        |          |1 = Buffer empty interrupt Enabled.
     * |[2]     |SHORTTXIEN|Short Packet Transferred Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set when a short data packet has been transferred to/from the host.
     * |        |          |0 = Short data packet interrupt Disabled.
     * |        |          |1 = Short data packet interrupt Enabled.
     * |[3]     |TXPKIEN   |Data Packet Transmitted Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set when a data packet has been received from the host.
     * |        |          |0 = Data packet has been received from the host interrupt Disabled.
     * |        |          |1 = Data packet has been received from the host interrupt Enabled.
     * |[4]     |RXPKIEN   |Data Packet Received Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set when a data packet has been transmitted to the host.
     * |        |          |0 = Data packet has been transmitted to the host interrupt Disabled.
     * |        |          |1 = Data packet has been transmitted to the host interrupt Enabled.
     * |[5]     |OUTTKIEN  |Data OUT Token Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set when a Data OUT token has been received from the host.
     * |        |          |0 = Data OUT token interrupt Disabled.
     * |        |          |1 = Data OUT token interrupt Enabled.
     * |[6]     |INTKIEN   |Data IN Token Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set when a Data IN token has been received from the host.
     * |        |          |0 = Data IN token interrupt Disabled.
     * |        |          |1 = Data IN token interrupt Enabled.
     * |[7]     |PINGIEN   |PING Token Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set when a PING token has been received from the host.
     * |        |          |0 = PING token interrupt Disabled.
     * |        |          |1 = PING token interrupt Enabled.
     * |[8]     |NAKIEN    |USB NAK Sent Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set when a NAK token is sent to the host.
     * |        |          |0 = NAK token interrupt Disabled.
     * |        |          |1 = NAK token interrupt Enabled.
     * |[9]     |STALLIEN  |USB STALL Sent Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set when a stall token is sent to the host.
     * |        |          |0 = STALL token interrupt Disabled.
     * |        |          |1 = STALL token interrupt Enabled.
     * |[10]    |NYETIEN   |NYET Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set whenever NYET condition occurs on the bus for this endpoint.
     * |        |          |0 = NYET condition interrupt Disabled.
     * |        |          |1 = NYET condition interrupt Enabled.
     * |[11]    |ERRIEN    |ERR Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set whenever ERR condition occurs on the bus for this endpoint.
     * |        |          |0 = Error event interrupt Disabled.
     * |        |          |1 = Error event interrupt Enabled.
     * |[12]    |SHORTRXIEN|Bulk Out Short Packet Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be set whenever bulk out short packet occurs on the bus for this endpoint.
     * |        |          |0 = Bulk out interrupt Disabled.
     * |        |          |1 = Bulk out interrupt Enabled.
    */
    __IO uint32_t EPINTEN;

    /**
     * EPxDATCNT
     * ===================================================================================================
     * Offset: 0x70+x*0x28  Endpoint x Data Available Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |DATCNT    |Data Count
     * |        |          |For an OUT/IN endpoint, this register returns the number of valid bytes in the endpoint packet buffer.
     * |[16:30] |DMALOOP   |DMA Loop
     * |        |          |This register is the remaining DMA loop to complete. Each loop means 32-byte transfer.
    */
    __I  uint32_t EPDATCNT;

    /**
     * EPxRSPCTL
     * ===================================================================================================
     * Offset: 0x74+x*0x28  Endpoint x Response Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |FLUSH     |Buffer Flush
     * |        |          |Writing 1 to this bit causes the packet buffer to be flushed and the corresponding EP_AVAIL register to be cleared.
     * |        |          |This bit is self-clearing.
     * |        |          |This bit should always be written after an configuration event.
     * |        |          |0 = The packet buffer is not flushed.
     * |        |          |1 = The packet buffer is flushed by user.
     * |[1:2]   |MODE      |Mode Control
     * |        |          |The two bits decide the operation mode of the in-endpoint.
     * |        |          |00: Auto-Validate Mode
     * |        |          |01: Manual-Validate Mode
     * |        |          |10: Fly Mode
     * |        |          |11: Reserved
     * |        |          |These bits are not valid for an out-endpoint.
     * |        |          |The auto validate mode will be activated when the reserved mode is selected.
     * |[3]     |TOGGLE    |Endpoint Toggle
     * |        |          |This bit is used to clear the endpoint data toggle bit.
     * |        |          |Reading this bit returns the current state of the endpoint data toggle bit.
     * |        |          |The local CPU may use this bit to initialize the end-point's toggle in case of reception of a Set Interface request or a Clear Feature (ep_halt) request from the host.
     * |        |          |Only when toggle bit is "1", this bit can be written into the inversed write data bit[3].
     * |        |          |0 = Not clear the endpoint data toggle bit.
     * |        |          |1 = Clear the endpoint data toggle bit.
     * |[4]     |HALT      |Endpoint Halt
     * |        |          |This bit is used to send a STALL handshake as response to the token from the host.
     * |        |          |When an Endpoint Set Feature (Endpoin_halt) is detected by the local CPU, it must write a '1' to this bit.
     * |        |          |0 = Not send a STALL handshake as response to the token from the host.
     * |        |          |1 = Send a STALL handshake as response to the token from the host.
     * |[5]     |ZEROLEN   |Zero Length
     * |        |          |This bit is used to send a zero-length packet n response to an IN-token.
     * |        |          |When this bit is set, a zero packet is sent to the host on reception of an IN-token.
     * |        |          |0 = A zero packet is not sent to the host on reception of an IN-token.
     * |        |          |1 = A zero packet is sent to the host on reception of an IN-token.
     * |[6]     |SHORTTXEN |Short Packet Transfer Enable
     * |        |          |This bit is applicable only in case of Auto-Validate Method.
     * |        |          |This bit is set to validate any remaining data in the buffer which is not equal to the MPS of the endpoint, and happens to be the last transfer.
     * |        |          |0 = Not validate any remaining data in the buffer which is not equal to the MPS of the endpoint.
     * |        |          |1 = Validate any remaining data in the buffer which is not equal to the MPS of the endpoint.
     * |[7]     |DISBUF    |Buffer Disable Control
     * |        |          |This bit is used to disable buffer (set buffer size to 1) when a Bulk-OUT short packet is received.
     * |        |          |0 = Buffer Not Disabled when Bulk-OUT short packet is received.
     * |        |          |1 = Buffer Disabled when Bulk-OUT short packet is received.
    */
    __IO uint32_t EPRSPCTL;

    /**
     * EPxMPS
     * ===================================================================================================
     * Offset: 0x78+x*0x28  Endpoint x Maximum Packet Size Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:10]  |EPMPS     |Endpoint Maximum Packet Size
     * |        |          |This field determines the Maximum Packet Size of the Endpoint.
    */
    __IO uint32_t EPMPS;

    /**
     * EPxTXCNT
     * ===================================================================================================
     * Offset: 0x7C+x*0x28  Endpoint x Transfer Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:10]  |TXCNT     |Endpoint Transfer Count
     * |        |          |For IN endpoints, this field determines the total number of bytes to be sent to the host in case of manual validation method.
     * |        |          |For OUT endpoints, this field has no effect.
    */
    __IO uint32_t EPTXCNT;

    /**
     * EPxCFG
     * ===================================================================================================
     * Offset: 0x80+x*0x28  Endpoint x Configuration Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |EPEN      |Endpoint Valid
     * |        |          |When set, this bit enables this endpoint.
     * |        |          |This bit has no effect on Endpoint 0, which is always enabled.
     * |        |          |0 = The endpoint Disabled.
     * |        |          |1 = The endpoint Enabled.
     * |[1:2]   |EPTYPE    |Endpoint Type
     * |        |          |This field selects the type of this endpoint. Endpoint 0 is forced to a Control type.
     * |        |          |00 = Reserved.
     * |        |          |01 = Bulk.
     * |        |          |10 = Interrupt.
     * |        |          |11 = Isochronous.
     * |[3]     |EPDIR     |Endpoint Direction
     * |        |          |0 = out-endpoint (Host OUT to Device).
     * |        |          |1 = in-endpoint (Host IN to Device).
     * |        |          |Note: A maximum of one OUT and IN endpoint is allowed for each endpoint number.
     * |[4:7]   |EPNUM     |Endpoint Number
     * |        |          |This field selects the number of the endpoint. Valid numbers 1 to 15.
    */
    __IO uint32_t EPCFG;

    /**
     * EPxBUFSTART
     * ===================================================================================================
     * Offset: 0x84+x*0x28  Endpoint x RAM Start Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |SADDR     |Endpoint Start Address
     * |        |          |This is the start-address of the RAM space allocated for the endpoint A~L.
    */
    __IO uint32_t EPBUFSTART;

    /**
     * EPxBUFEND
     * ===================================================================================================
     * Offset: 0x88+x*0x28  Endpoint x RAM End Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |EADDR     |Endpoint End Address
     * |        |          |This is the end-address of the RAM space allocated for the endpoint A~L.
    */
    __IO uint32_t EPBUFEND;


} USBD_EP_T;


typedef struct {


    /**
     * GINTSTS
     * ===================================================================================================
     * Offset: 0x00  Interrupt Status Low Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |USBIF     |USB Interrupt
     * |        |          |This bit conveys the interrupt status for USB specific events endpoint.
     * |        |          |When set, USB interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[1]     |CEPIF     |Control Endpoint Interrupt
     * |        |          |This bit conveys the interrupt status for control endpoint.
     * |        |          |When set, Control-ep's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[2]     |EPAIF     |Endpoints A Interrupt
     * |        |          |When set, the corresponding Endpoint A's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[3]     |EPBIF     |Endpoints B Interrupt
     * |        |          |When set, the corresponding Endpoint B's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[4]     |EPCIF     |Endpoints C Interrupt
     * |        |          |When set, the corresponding Endpoint C's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[5]     |EPDIF     |Endpoints D Interrupt
     * |        |          |When set, the corresponding Endpoint D's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[6]     |EPEIF     |Endpoints E Interrupt
     * |        |          |When set, the corresponding Endpoint E's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[7]     |EPFIF     |Endpoints F Interrupt
     * |        |          |When set, the corresponding Endpoint F's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[8]     |EPGIF     |Endpoints G Interrupt
     * |        |          |When set, the corresponding Endpoint G's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[9]     |EPHIF     |Endpoints H Interrupt
     * |        |          |When set, the corresponding Endpoint H's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[10]    |EPIIF     |Endpoints I Interrupt
     * |        |          |When set, the corresponding Endpoint I's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[11]    |EPJIF     |Endpoints J Interrupt
     * |        |          |When set, the corresponding Endpoint J's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[12]    |EPKIF     |Endpoints K Interrupt
     * |        |          |When set, the corresponding Endpoint K's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
     * |[13]    |EPLIF     |Endpoints L Interrupt
     * |        |          |When set, the corresponding Endpoint L's interrupt status register should be read to determine the cause of the interrupt.
     * |        |          |0 = No interrupt event occurred.
     * |        |          |1 = The related interrupt event is occurred.
    */
    __I  uint32_t GINTSTS;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE0[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * GINTEN
     * ===================================================================================================
     * Offset: 0x08  Interrupt Enable Low Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |USBIE     |USB Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be generated when a USB event occurs on the bus.
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[1]     |CEPIE     |Control Endpoint Interrupt Enable Control
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the control endpoint.
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[2]     |EPAIE     |Interrupt Enable Control For Endpoint A
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint A.
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[3]     |EPBIE     |Interrupt Enable Control For Endpoint B
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint B
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[4]     |EPCIE     |Interrupt Enable Control For Endpoint C
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint C
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[5]     |EPDIE     |Interrupt Enable Control For Endpoint D
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint D
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[6]     |EPEIE     |Interrupt Enable Control For Endpoint E
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint E
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[7]     |EPFIE     |Interrupt Enable Control For Endpoint F
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint F
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[8]     |EPGIE     |Interrupt Enable Control For Endpoint G
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint G
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[9]     |EPHIE     |Interrupt Enable Control For Endpoint H
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint H
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[10]    |EPIIE     |Interrupt Enable Control For Endpoint I
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint I
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[11]    |EPJIE     |Interrupt Enable Control For Endpoint J
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint J
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[12]    |EPKIE     |Interrupt Enable Control For Endpoint K
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint K
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
     * |[13]    |EPLIE     |Interrupt Enable Control For Endpoint L
     * |        |          |When set, this bit enables a local interrupt to be generated when an interrupt is pending for the endpoint L
     * |        |          |0 = The related interrupt Disabled.
     * |        |          |1 = The related interrupt Enabled.
    */
    __IO uint32_t GINTEN;
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE1[1];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * BUSINTSTS
     * ===================================================================================================
     * Offset: 0x10  USB Bus Interrupt Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SOFIF     |SOF Receive Control
     * |        |          |This bit indicates when a start-of-frame packet has been received.
     * |        |          |0 = No start-of-frame packet has been received.
     * |        |          |1 = Start-of-frame packet has been received.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[1]     |RSTIF     |Reset Status
     * |        |          |When set, this bit indicates that either the USB root port reset is end.
     * |        |          |0 = No USB root port reset is end.
     * |        |          |1 = USB root port reset is end.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[2]     |RESUMEIF  |Resume
     * |        |          |When set, this bit indicates that a device resume has occurred.
     * |        |          |0 = No device resume has occurred.
     * |        |          |1 = Device resume has occurred.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[3]     |SUSPENDIF |Suspend Request
     * |        |          |This bit is set as default and it has to be cleared by writing '1' before the USB reset.
     * |        |          |This bit is also set when a USB Suspend request is detected from the host.
     * |        |          |0 = No USB Suspend request is detected from the host.
     * |        |          |1= USB Suspend request is detected from the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[4]     |HISPDIF   |High-Speed Settle
     * |        |          |0 = No valid high-speed reset protocol is detected.
     * |        |          |1 = Valid high-speed reset protocol is over and the device has settled in high-speed.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[5]     |DMADONEIF |DMA Completion Interrupt
     * |        |          |0 = No DMA transfer over.
     * |        |          |1 = DMA transfer is over.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[6]     |PHYCLKVLDIF|Usable Clock Interrupt
     * |        |          |0 = Usable clock is not available.
     * |        |          |1 = Usable clock is available from the transceiver.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[8]     |VBUSDETIF |VBUS Detection Interrupt Status
     * |        |          |0 = No VBUS is plug-in.
     * |        |          |1 = VBUS is plug-in.
     * |        |          |Note: Write 1 to clear this bit to 0.
    */
    __IO uint32_t BUSINTSTS;

    /**
     * BUSINTEN
     * ===================================================================================================
     * Offset: 0x14  USB Bus Interrupt Enable Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SOFIEN    |SOF Interrupt
     * |        |          |This bit enables the SOF interrupt.
     * |        |          |0 = SOF interrupt Disabled.
     * |        |          |1 = SOF interrupt Enabled.
     * |[1]     |RSTIEN    |Reset Status
     * |        |          |This bit enables the USB-Reset interrupt.
     * |        |          |0 = USB-Reset interrupt Disabled.
     * |        |          |1 = USB-Reset interrupt Enabled.
     * |[2]     |RESUMEIEN |Resume
     * |        |          |This bit enables the Resume interrupt.
     * |        |          |0 = Resume interrupt Disabled.
     * |        |          |1 = Resume interrupt Enabled.
     * |[3]     |SUSPENDIEN|Suspend Request
     * |        |          |This bit enables the Suspend interrupt.
     * |        |          |0 = Suspend interrupt Disabled.
     * |        |          |1 = Suspend interrupt Enabled.
     * |[4]     |HISPDIEN  |High-Speed Settle
     * |        |          |This bit enables the high-speed settle interrupt.
     * |        |          |0 = High-speed settle interrupt Disabled.
     * |        |          |1 = High-speed settle interrupt Enabled.
     * |[5]     |DMADONEIEN|DMA Completion Interrupt
     * |        |          |This bit enables the DMA completion interrupt
     * |        |          |0 = DMA completion interrupt Disabled.
     * |        |          |1 = DMA completion interrupt Enabled.
     * |[6]     |PHYCLKVLDIEN|Usable Clock Interrupt
     * |        |          |This bit enables the usable clock interrupt.
     * |        |          |0 = Usable clock interrupt Disabled.
     * |        |          |1 = Usable clock interrupt Enabled.
     * |[8]     |VBUSDETIEN|VBUS Detection Interrupt Enable Control
     * |        |          |This bit enables the VBUS floating detection interrupt.
     * |        |          |0 = VBUS floating detection interrupt Disabled.
     * |        |          |1 = VBUS floating detection interrupt Enabled.
    */
    __IO uint32_t BUSINTEN;

    /**
     * OPER
     * ===================================================================================================
     * Offset: 0x18  USB Operational Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RESUMEEN  |Generate Resume
     * |        |          |0 = No Resume sequence to be initiated to the host.
     * |        |          |1 = A Resume sequence to be initiated to the host if device remote wakeup is enabled.
     * |        |          |This bit is self-clearing.
     * |[1]     |HISPDEN   |USB High-Speed
     * |        |          |0 = The USB device controller to suppress the chirp-sequence during reset protocol, thereby allowing the USB device controller to settle in full-speed, even though it is connected to a USB2.0 Host.
     * |        |          |1 = The USB device controller to initiate a chirp-sequence during reset protocol.
     * |[2]     |CURSPD    |USB Current Speed
     * |        |          |0 = The device has settled in Full Speed.
     * |        |          |1 = The USB device controller has settled in High-speed.
    */
    __IO uint32_t OPER;

    /**
     * FRAMECNT
     * ===================================================================================================
     * Offset: 0x1C  USB Frame Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |MFRAMECNT |Micro-Frame Counter
     * |        |          |This field contains the micro-frame number for the frame number in the frame counter field.
     * |[3:13]  |FRAMECNT  |Frame Counter
     * |        |          |This field contains the frame count from the most recent start-of-frame packet.
    */
    __I  uint32_t FRAMECNT;

    /**
     * FADDR
     * ===================================================================================================
     * Offset: 0x20  USB Function Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:6]   |FADDR     |USB Function Address
     * |        |          |This field contains the current USB address of the device.
     * |        |          |This field is cleared when a root port reset is detected.
    */
    __IO uint32_t FADDR;

    /**
     * TEST
     * ===================================================================================================
     * Offset: 0x24  USB Test Mode Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:2]   |TESTMODE  |Test Mode Selection
     * |        |          |000 = Normal Operation.
     * |        |          |001 = Test_J.
     * |        |          |010 = Test_K.
     * |        |          |011 = Test_SE0_NAK.
     * |        |          |100 = Test_Packet.
     * |        |          |101 = Test_Force_Enable.
     * |        |          |110 = Reserved.
     * |        |          |111 = Reserved.
     * |        |          |Note: This field is cleared when root port reset is detected.
    */
    __IO uint32_t TEST;

    union {

        /**
         * CEPDAT
         * ===================================================================================================
         * Offset: 0x28  Control-Endpoint Data Buffer
         * ---------------------------------------------------------------------------------------------------
         * |Bits    |Field     |Descriptions
         * | :----: | :----:   | :---- |
         * |[0:31]  |DAT       |Control-Endpoint Data Buffer
         * |        |          |Control endpoint data buffer for the buffer transaction (read or write).
         * |        |          |Note: Only word or byte access are supported.
        */
        __IO uint32_t CEPDAT;
        /**
         * CEPDAT_BYTE
         * ===================================================================================================
         * Offset: 0x28  Control-Endpoint Data Buffer for Byte Access
         * ---------------------------------------------------------------------------------------------------
         * |Bits    |Field     |Descriptions
         * | :----: | :----:   | :---- |
         * |[0:7]   |DAT       |Control-Endpoint Data Buffer
         * |        |          |Control endpoint data buffer for the buffer transaction (read or write).
         * |        |          |Note: Only word or byte access are supported.
        */
        __IO uint8_t  CEPDAT_BYTE;

    };///< Define Control-Endpoint Data Register 32-bit or 8-bit access

    /**
     * CEPCTL
     * ===================================================================================================
     * Offset: 0x2C  Control-Endpoint Control and Status
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |NAKCLR    |No Acknowledge Control
     * |        |          |This bit plays a crucial role in any control transfer.
     * |        |          |0 = The bit is being cleared by the local CPU by writing zero, the USB device controller will be responding with NAKs for the subsequent status phase.
     * |        |          |This mechanism holds the host from moving to the next request, until the local CPU is also ready to process the next request.
     * |        |          |1 = This bit is set to one by the USB device controller, whenever a setup token is received.
     * |        |          |The local CPU can take its own time to finish off any house-keeping work based on the request and then clear this bit.
     * |        |          |Note: Only when CPU writes data[1:0] is 2'b10 or 2'b00, this bit can be updated.
     * |[1]     |STALLEN   |Stall Enable Control
     * |        |          |When this stall bit is set, the control endpoint sends a stall handshake in response to any in or out token thereafter.
     * |        |          |This is typically used for response to invalid/unsupported requests.
     * |        |          |When this bit is being set the NAK clear bit has to be cleared at the same time since the NAK clear bit has highest priority than STALL.
     * |        |          |It is automatically cleared on receipt of a next setup-token.
     * |        |          |So, the local CPU need not write again to clear this bit.
     * |        |          |0 = No sends a stall handshake in response to any in or out token thereafter.
     * |        |          |1 = The control endpoint sends a stall handshake in response to any in or out token thereafter.
     * |        |          |Note: Only when CPU writes data[1:0] is 2'b10 or 2'b00, this bit can be updated.
     * |[2]     |ZEROLEN   |Zero Packet Length
     * |        |          |This bit is valid for Auto Validation mode only.
     * |        |          |0 = No zero length packet to the host during Data stage to an IN token.
     * |        |          |1 = USB device controller can send a zero length packet to the host during Data stage to an IN token.
     * |        |          |This bit gets cleared once the zero length data packet is sent.
     * |        |          |So, the local CPU need not write again to clear this bit.
     * |[3]     |FLUSH     |CEP-FLUSH Bit
     * |        |          |0 = No the packet buffer and its corresponding USBD_CEPDATCNT register to be cleared.
     * |        |          |1 = The packet buffer and its corresponding USBD_CEPDATCNT register to be cleared.
     * |        |          |This bit is self-cleaning.
    */
    __IO uint32_t CEPCTL;

    /**
     * CEPINTEN
     * ===================================================================================================
     * Offset: 0x30  Control-Endpoint Interrupt Enable
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SETUPTKIEN|Setup Token Interrupt Enable Control
     * |        |          |0 = The SETUP token interrupt in Control Endpoint Disabled.
     * |        |          |1 = The SETUP token interrupt in Control Endpoint Enabled.
     * |[1]     |SETUPPKIEN|Setup Packet Interrupt
     * |        |          |0 = The SETUP packet interrupt in Control Endpoint Disabled.
     * |        |          |1 = The SETUP packet interrupt in Control Endpoint Enabled.
     * |[2]     |OUTTKIEN  |Out Token Interrupt
     * |        |          |0 = The OUT token interrupt in Control Endpoint Disabled.
     * |        |          |1 = The OUT token interrupt in Control Endpoint Enabled.
     * |[3]     |INTKIEN   |In Token Interrupt
     * |        |          |0 = The IN token interrupt in Control Endpoint Disabled.
     * |        |          |1 = The IN token interrupt in Control Endpoint Enabled.
     * |[4]     |PINGIEN   |Ping Token Interrupt
     * |        |          |0 = The ping token interrupt in Control Endpoint Disabled.
     * |        |          |1 = The ping token interrupt Control Endpoint Enabled.
     * |[5]     |TXPKIEN   |Data Packet Transmitted Interrupt
     * |        |          |0 = The data packet transmitted interrupt in Control Endpoint Disabled.
     * |        |          |1 = The data packet transmitted interrupt in Control Endpoint Enabled.
     * |[6]     |RXPKIEN   |Data Packet Received Interrupt
     * |        |          |0 = The data received interrupt in Control Endpoint Disabled.
     * |        |          |1 = The data received interrupt in Control Endpoint Enabled.
     * |[7]     |NAKIEN    |NAK Sent Interrupt
     * |        |          |0 = The NAK sent interrupt in Control Endpoint Disabled.
     * |        |          |1 = The NAK sent interrupt in Control Endpoint Enabled.
     * |[8]     |STALLIEN  |STALL Sent Interrupt
     * |        |          |0 = The STALL sent interrupt in Control Endpoint Disabled.
     * |        |          |1 = The STALL sent interrupt in Control Endpoint Enabled.
     * |[9]     |ERRIEN    |USB Error Interrupt
     * |        |          |0 = The USB Error interrupt in Control Endpoint Disabled.
     * |        |          |1 = The USB Error interrupt in Control Endpoint Enabled.
     * |[10]    |STSDONEIEN|Status Completion Interrupt
     * |        |          |0 = The Status Completion interrupt in Control Endpoint Disabled.
     * |        |          |1 = The Status Completion interrupt in Control Endpoint Enabled.
     * |[11]    |BUFFULLIEN|Buffer Full Interrupt
     * |        |          |0 = The buffer full interrupt in Control Endpoint Disabled.
     * |        |          |1 = The buffer full interrupt in Control Endpoint Enabled.
     * |[12]    |BUFEMPTYIEN|Buffer Empty Interrupt
     * |        |          |0 = The buffer empty interrupt in Control Endpoint Disabled.
     * |        |          |1= The buffer empty interrupt in Control Endpoint Enabled.
    */
    __IO uint32_t CEPINTEN;

    /**
     * CEPINTSTS
     * ===================================================================================================
     * Offset: 0x34  Control-Endpoint Interrupt Status
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |SETUPTKIF |Setup Token Interrupt
     * |        |          |0 = Not a Setup token is received.
     * |        |          |1 = A Setup token is received. Writing 1 clears this status bit
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[1]     |SETUPPKIF |Setup Packet Interrupt
     * |        |          |This bit must be cleared (by writing 1) before the next setup packet can be received.
     * |        |          |If the bit is not cleared, then the successive setup packets will be overwritten in the setup packet buffer.
     * |        |          |0 = Not a Setup packet has been received from the host.
     * |        |          |1 = A Setup packet has been received from the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[2]     |OUTTKIF   |Out Token Interrupt
     * |        |          |0 = The control-endpoint does not received an OUT token from the host.
     * |        |          |1 = The control-endpoint receives an OUT token from the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[3]     |INTKIF    |In Token Interrupt
     * |        |          |0 = The control-endpoint does not received an IN token from the host.
     * |        |          |1 = The control-endpoint receives an IN token from the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[4]     |PINGIF    |Ping Token Interrupt
     * |        |          |0 = The control-endpoint does not received a ping token from the host.
     * |        |          |1 = The control-endpoint receives a ping token from the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[5]     |TXPKIF    |Data Packet Transmitted Interrupt
     * |        |          |0 = Not a data packet is successfully transmitted to the host in response to an IN-token and an ACK-token is received for the same.
     * |        |          |1 = A data packet is successfully transmitted to the host in response to an IN-token and an ACK-token is received for the same.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[6]     |RXPKIF    |Data Packet Received Interrupt
     * |        |          |0 = Not a data packet is successfully received from the host for an OUT-token and an ACK is sent to the host.
     * |        |          |1 = A data packet is successfully received from the host for an OUT-token and an ACK is sent to the host.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[7]     |NAKIF     |NAK Sent Interrupt
     * |        |          |0 = Not a NAK-token is sent in response to an IN/OUT token.
     * |        |          |1 = A NAK-token is sent in response to an IN/OUT token.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[8]     |STALLIF   |STALL Sent Interrupt
     * |        |          |0 = Not a stall-token is sent in response to an IN/OUT token.
     * |        |          |1 = A stall-token is sent in response to an IN/OUT token.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[9]     |ERRIF     |USB Error Interrupt
     * |        |          |0 = No error had occurred during the transaction.
     * |        |          |1 = An error had occurred during the transaction.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[10]    |STSDONEIF |Status Completion Interrupt
     * |        |          |0 = Not a USB transaction has completed successfully.
     * |        |          |1 = The status stage of a USB transaction has completed successfully.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[11]    |BUFFULLIF |Buffer Full Interrupt
     * |        |          |0 = The control-endpoint buffer is not full.
     * |        |          |1 = The control-endpoint buffer is full.
     * |        |          |Note: Write 1 to clear this bit to 0.
     * |[12]    |BUFEMPTYIF|Buffer Empty Interrupt
     * |        |          |0 = The control-endpoint buffer is not empty.
     * |        |          |1 = The control-endpoint buffer is empty.
     * |        |          |Note: Write 1 to clear this bit to 0.
    */
    __IO uint32_t CEPINTSTS;

    /**
     * CEPTXCNT
     * ===================================================================================================
     * Offset: 0x38  Control-Endpoint In-transfer Data Count
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |TXCNT     |In-Transfer Data Count
     * |        |          |There is no mode selection for the control endpoint (but it operates like manual mode).The local-CPU has to fill the control-endpoint buffer with the data to be sent for an in-token and to write the count of bytes in this register.
     * |        |          |When zero is written into this field, a zero length packet is sent to the host.
     * |        |          |When the count written in the register is more than the MPS, the data sent will be of only MPS.
    */
    __IO uint32_t CEPTXCNT;

    /**
     * CEPRXCNT
     * ===================================================================================================
     * Offset: 0x3C  Control-Endpoint Out-transfer Data Count
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |RXCNT     |Out-Transfer Data Count
     * |        |          |The USB device controller maintains the count of the data received in case of an out transfer, during the control transfer.
    */
    __I  uint32_t CEPRXCNT;

    /**
     * CEPDATCNT
     * ===================================================================================================
     * Offset: 0x40  Control-Endpoint data count
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:15]  |DATCNT    |Control-Endpoint Data Count
     * |        |          |The USB device controller maintains the count of the data of control-endpoint.
    */
    __I  uint32_t CEPDATCNT;

    /**
     * SETUP1_0
     * ===================================================================================================
     * Offset: 0x44  Setup1 & Setup0 bytes
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |SETUP0    |Setup Byte 0[7:0]
     * |        |          |This register provides byte 0 of the last setup packet received.
     * |        |          |For a Standard Device Request, the following bmRequestType information is returned.
     * |        |          |Bit 7(Direction):
     * |        |          | 0: Host to device
     * |        |          | 1: Device to host
     * |        |          |Bit 6-5 (Type):
     * |        |          | 00: Standard
     * |        |          | 01: Class
     * |        |          | 10: Vendor
     * |        |          | 11: Reserved
     * |        |          |Bit 4-0 (Recipient)
     * |        |          | 00000: Device
     * |        |          | 00001: Interface
     * |        |          | 00010: Endpoint
     * |        |          | 00011: Other
     * |        |          | Others: Reserved
     * |[8:15]  |SETUP1    |Setup Byte 1[15:8]
     * |        |          |This register provides byte 1 of the last setup packet received.
     * |        |          |For a Standard Device Request, the following bRequest Code information is returned.
     * |        |          |00000000 = Get Status.
     * |        |          |00000001 = Clear Feature.
     * |        |          |00000010 = Reserved.
     * |        |          |00000011 = Set Feature.
     * |        |          |00000100 = Reserved.
     * |        |          |00000101 = Set Address.
     * |        |          |00000110 = Get Descriptor.
     * |        |          |00000111 = Set Descriptor.
     * |        |          |00001000 = Get Configuration.
     * |        |          |00001001 = Set Configuration.
     * |        |          |00001010 = Get Interface.
     * |        |          |00001011 = Set Interface.
     * |        |          |00001100 = Synch Frame.
    */
    __I  uint32_t SETUP1_0;

    /**
     * SETUP3_2
     * ===================================================================================================
     * Offset: 0x48  Setup3 & Setup2 Bytes
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |SETUP2    |Setup Byte 2 [7:0]
     * |        |          |This register provides byte 2 of the last setup packet received.
     * |        |          |For a Standard Device Request, the least significant byte of the wValue field is returned.
     * |[8:15]  |SETUP3    |Setup Byte 3 [15:8]
     * |        |          |This register provides byte 3 of the last setup packet received.
     * |        |          |For a Standard Device Request, the most significant byte of the wValue field is returned.
    */
    __I  uint32_t SETUP3_2;

    /**
     * SETUP5_4
     * ===================================================================================================
     * Offset: 0x4C  Setup5 & Setup4 Bytes
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |SETUP4    |Setup Byte 4[7:0]
     * |        |          |This register provides byte 4 of the last setup packet received.
     * |        |          |For a Standard Device Request, the least significant byte of the wIndex is returned.
     * |[8:15]  |SETUP5    |Setup Byte 5[15:8]
     * |        |          |This register provides byte 5 of the last setup packet received.
     * |        |          |For a Standard Device Request, the most significant byte of the wIndex field is returned.
    */
    __I  uint32_t SETUP5_4;

    /**
     * SETUP7_6
     * ===================================================================================================
     * Offset: 0x50  Setup7 & Setup6 Bytes
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:7]   |SETUP6    |Setup Byte 6[7:0]
     * |        |          |This register provides byte 6 of the last setup packet received.
     * |        |          |For a Standard Device Request, the least significant byte of the wLength field is returned.
     * |[8:15]  |SETUP7    |Setup Byte 7[15:8]
     * |        |          |This register provides byte 7 of the last setup packet received.
     * |        |          |For a Standard Device Request, the most significant byte of the wLength field is returned.
    */
    __I  uint32_t SETUP7_6;

    /**
     * CEPBUFSTART
     * ===================================================================================================
     * Offset: 0x54  Control Endpoint RAM Start Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |SADDR     |Control-Endpoint Start Address
     * |        |          |This is the start-address of the RAM space allocated for the control-endpoint.
    */
    __IO uint32_t CEPBUFSTART;

    /**
     * CEPBUFEND
     * ===================================================================================================
     * Offset: 0x58  Control Endpoint RAM End Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:11]  |EADDR     |Control-Endpoint End Address
     * |        |          |This is the end-address of the RAM space allocated for the control-endpoint.
    */
    __IO uint32_t CEPBUFEND;

    /**
     * DMACTL
     * ===================================================================================================
     * Offset: 0x5C  DMA Control Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:3]   |EPNUM     |DMA Endpoint Address Bits
     * |        |          |Used to define the Endpoint Address
     * |[4]     |DMARD     |DMA Operation
     * |        |          |0 = the operation is a DMA write.
     * |        |          |1 = the operation is a DMA read.
     * |[5]     |DMAEN     |DMA Enable Control
     * |        |          |0 = DMA function Disabled.
     * |        |          |1 = DMA function Enabled.
     * |[6]     |SGEN      |Scatter Gather Function Enable Control
     * |        |          |0 = Scatter gather function Disabled.
     * |        |          |1 = Scatter gather function Enabled.
     * |[7]     |DMARST    |Reset DMA State Machine
     * |        |          |0 = No reset the DMA state machine.
     * |        |          |1 = Reset the DMA state machine.
    */
    __IO uint32_t DMACTL;

    /**
     * DMACNT
     * ===================================================================================================
     * Offset: 0x60  DMA Count Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:19]  |DMACNT    |DMA Transfer Count
     * |        |          |The transfer count of the DMA operation to be performed is written to this register.
    */
    __IO uint32_t DMACNT;

    USBD_EP_T EP[12];
    /// @cond HIDDEN_SYMBOLS
    uint32_t RESERVE2[303];
    /// @endcond //HIDDEN_SYMBOLS


    /**
     * DMAADDR
     * ===================================================================================================
     * Offset: 0x700  AHB DMA Address Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |DMAADDR   |DMAADDR
     * |        |          |The register specifies the address from which the DMA has to read / write.
     * |        |          |The address must WORD (32-bit) aligned.
    */
    __IO uint32_t DMAADDR;

    /**
     * PHYCTL
     * ===================================================================================================
     * Offset: 0x704  USB PHY Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[8]     |DPPUEN    |DP Pull-Up
     * |        |          |0 = Pull-up resistor on D+ Disabled.
     * |        |          |1 = Pull-up resistor on D+ Enabled.
     * |[9]     |PHYEN     |PHY Suspend Enable Control
     * |        |          |0 = The USB PHY is suspend.
     * |        |          |1 = The USB PHY is not suspend.
     * |[24]    |WKEN      |Wake-Up Enable Control
     * |        |          |0 = The wake-up function Disabled.
     * |        |          |1 = The wake-up function Enabled.
     * |[31]    |VBUSDET   |VBUS Status
     * |        |          |0 = The VBUS is not detected yet.
     * |        |          |1 = The VBUS is detected.
    */
    __IO uint32_t PHYCTL;

} USBD_T;

/**
    @addtogroup USBD_CONST USBD Bit Field Definition
    Constant Definitions for USBD Controller
@{ */

#define USBD_GINTSTS_USBIF_Pos           (0)                                               /*!< USBD_T::GINTSTS: USBIF Position           */
#define USBD_GINTSTS_USBIF_Msk           (0x1ul << USBD_GINTSTS_USBIF_Pos)                 /*!< USBD_T::GINTSTS: USBIF Mask               */

#define USBD_GINTSTS_CEPIF_Pos           (1)                                               /*!< USBD_T::GINTSTS: CEPIF Position           */
#define USBD_GINTSTS_CEPIF_Msk           (0x1ul << USBD_GINTSTS_CEPIF_Pos)                 /*!< USBD_T::GINTSTS: CEPIF Mask               */

#define USBD_GINTSTS_EPAIF_Pos           (2)                                               /*!< USBD_T::GINTSTS: EPAIF Position           */
#define USBD_GINTSTS_EPAIF_Msk           (0x1ul << USBD_GINTSTS_EPAIF_Pos)                 /*!< USBD_T::GINTSTS: EPAIF Mask               */

#define USBD_GINTSTS_EPBIF_Pos           (3)                                               /*!< USBD_T::GINTSTS: EPBIF Position           */
#define USBD_GINTSTS_EPBIF_Msk           (0x1ul << USBD_GINTSTS_EPBIF_Pos)                 /*!< USBD_T::GINTSTS: EPBIF Mask               */

#define USBD_GINTSTS_EPCIF_Pos           (4)                                               /*!< USBD_T::GINTSTS: EPCIF Position           */
#define USBD_GINTSTS_EPCIF_Msk           (0x1ul << USBD_GINTSTS_EPCIF_Pos)                 /*!< USBD_T::GINTSTS: EPCIF Mask               */

#define USBD_GINTSTS_EPDIF_Pos           (5)                                               /*!< USBD_T::GINTSTS: EPDIF Position           */
#define USBD_GINTSTS_EPDIF_Msk           (0x1ul << USBD_GINTSTS_EPDIF_Pos)                 /*!< USBD_T::GINTSTS: EPDIF Mask               */

#define USBD_GINTSTS_EPEIF_Pos           (6)                                               /*!< USBD_T::GINTSTS: EPEIF Position           */
#define USBD_GINTSTS_EPEIF_Msk           (0x1ul << USBD_GINTSTS_EPEIF_Pos)                 /*!< USBD_T::GINTSTS: EPEIF Mask               */

#define USBD_GINTSTS_EPFIF_Pos           (7)                                               /*!< USBD_T::GINTSTS: EPFIF Position           */
#define USBD_GINTSTS_EPFIF_Msk           (0x1ul << USBD_GINTSTS_EPFIF_Pos)                 /*!< USBD_T::GINTSTS: EPFIF Mask               */

#define USBD_GINTSTS_EPGIF_Pos           (8)                                               /*!< USBD_T::GINTSTS: EPGIF Position           */
#define USBD_GINTSTS_EPGIF_Msk           (0x1ul << USBD_GINTSTS_EPGIF_Pos)                 /*!< USBD_T::GINTSTS: EPGIF Mask               */

#define USBD_GINTSTS_EPHIF_Pos           (9)                                               /*!< USBD_T::GINTSTS: EPHIF Position           */
#define USBD_GINTSTS_EPHIF_Msk           (0x1ul << USBD_GINTSTS_EPHIF_Pos)                 /*!< USBD_T::GINTSTS: EPHIF Mask               */

#define USBD_GINTSTS_EPIIF_Pos           (10)                                              /*!< USBD_T::GINTSTS: EPIIF Position           */
#define USBD_GINTSTS_EPIIF_Msk           (0x1ul << USBD_GINTSTS_EPIIF_Pos)                 /*!< USBD_T::GINTSTS: EPIIF Mask               */

#define USBD_GINTSTS_EPJIF_Pos           (11)                                              /*!< USBD_T::GINTSTS: EPJIF Position           */
#define USBD_GINTSTS_EPJIF_Msk           (0x1ul << USBD_GINTSTS_EPJIF_Pos)                 /*!< USBD_T::GINTSTS: EPJIF Mask               */

#define USBD_GINTSTS_EPKIF_Pos           (12)                                              /*!< USBD_T::GINTSTS: EPKIF Position           */
#define USBD_GINTSTS_EPKIF_Msk           (0x1ul << USBD_GINTSTS_EPKIF_Pos)                 /*!< USBD_T::GINTSTS: EPKIF Mask               */

#define USBD_GINTSTS_EPLIF_Pos           (13)                                              /*!< USBD_T::GINTSTS: EPLIF Position           */
#define USBD_GINTSTS_EPLIF_Msk           (0x1ul << USBD_GINTSTS_EPLIF_Pos)                 /*!< USBD_T::GINTSTS: EPLIF Mask               */

#define USBD_GINTEN_USBIE_Pos            (0)                                               /*!< USBD_T::GINTEN: USBIE Position            */
#define USBD_GINTEN_USBIE_Msk            (0x1ul << USBD_GINTEN_USBIE_Pos)                  /*!< USBD_T::GINTEN: USBIE Mask                */

#define USBD_GINTEN_CEPIE_Pos            (1)                                               /*!< USBD_T::GINTEN: CEPIE Position            */
#define USBD_GINTEN_CEPIE_Msk            (0x1ul << USBD_GINTEN_CEPIE_Pos)                  /*!< USBD_T::GINTEN: CEPIE Mask                */

#define USBD_GINTEN_EPAIE_Pos            (2)                                               /*!< USBD_T::GINTEN: EPAIE Position            */
#define USBD_GINTEN_EPAIE_Msk            (0x1ul << USBD_GINTEN_EPAIE_Pos)                  /*!< USBD_T::GINTEN: EPAIE Mask                */

#define USBD_GINTEN_EPBIE_Pos            (3)                                               /*!< USBD_T::GINTEN: EPBIE Position            */
#define USBD_GINTEN_EPBIE_Msk            (0x1ul << USBD_GINTEN_EPBIE_Pos)                  /*!< USBD_T::GINTEN: EPBIE Mask                */

#define USBD_GINTEN_EPCIE_Pos            (4)                                               /*!< USBD_T::GINTEN: EPCIE Position            */
#define USBD_GINTEN_EPCIE_Msk            (0x1ul << USBD_GINTEN_EPCIE_Pos)                  /*!< USBD_T::GINTEN: EPCIE Mask                */

#define USBD_GINTEN_EPDIE_Pos            (5)                                               /*!< USBD_T::GINTEN: EPDIE Position            */
#define USBD_GINTEN_EPDIE_Msk            (0x1ul << USBD_GINTEN_EPDIE_Pos)                  /*!< USBD_T::GINTEN: EPDIE Mask                */

#define USBD_GINTEN_EPEIE_Pos            (6)                                               /*!< USBD_T::GINTEN: EPEIE Position            */
#define USBD_GINTEN_EPEIE_Msk            (0x1ul << USBD_GINTEN_EPEIE_Pos)                  /*!< USBD_T::GINTEN: EPEIE Mask                */

#define USBD_GINTEN_EPFIE_Pos            (7)                                               /*!< USBD_T::GINTEN: EPFIE Position            */
#define USBD_GINTEN_EPFIE_Msk            (0x1ul << USBD_GINTEN_EPFIE_Pos)                  /*!< USBD_T::GINTEN: EPFIE Mask                */

#define USBD_GINTEN_EPGIE_Pos            (8)                                               /*!< USBD_T::GINTEN: EPGIE Position            */
#define USBD_GINTEN_EPGIE_Msk            (0x1ul << USBD_GINTEN_EPGIE_Pos)                  /*!< USBD_T::GINTEN: EPGIE Mask                */

#define USBD_GINTEN_EPHIE_Pos            (9)                                               /*!< USBD_T::GINTEN: EPHIE Position            */
#define USBD_GINTEN_EPHIE_Msk            (0x1ul << USBD_GINTEN_EPHIE_Pos)                  /*!< USBD_T::GINTEN: EPHIE Mask                */

#define USBD_GINTEN_EPIIE_Pos            (10)                                              /*!< USBD_T::GINTEN: EPIIE Position            */
#define USBD_GINTEN_EPIIE_Msk            (0x1ul << USBD_GINTEN_EPIIE_Pos)                  /*!< USBD_T::GINTEN: EPIIE Mask                */

#define USBD_GINTEN_EPJIE_Pos            (11)                                              /*!< USBD_T::GINTEN: EPJIE Position            */
#define USBD_GINTEN_EPJIE_Msk            (0x1ul << USBD_GINTEN_EPJIE_Pos)                  /*!< USBD_T::GINTEN: EPJIE Mask                */

#define USBD_GINTEN_EPKIE_Pos            (12)                                              /*!< USBD_T::GINTEN: EPKIE Position            */
#define USBD_GINTEN_EPKIE_Msk            (0x1ul << USBD_GINTEN_EPKIE_Pos)                  /*!< USBD_T::GINTEN: EPKIE Mask                */

#define USBD_GINTEN_EPLIE_Pos            (13)                                              /*!< USBD_T::GINTEN: EPLIE Position            */
#define USBD_GINTEN_EPLIE_Msk            (0x1ul << USBD_GINTEN_EPLIE_Pos)                  /*!< USBD_T::GINTEN: EPLIE Mask                */

#define USBD_BUSINTSTS_SOFIF_Pos         (0)                                               /*!< USBD_T::BUSINTSTS: SOFIF Position         */
#define USBD_BUSINTSTS_SOFIF_Msk         (0x1ul << USBD_BUSINTSTS_SOFIF_Pos)               /*!< USBD_T::BUSINTSTS: SOFIF Mask             */

#define USBD_BUSINTSTS_RSTIF_Pos         (1)                                               /*!< USBD_T::BUSINTSTS: RSTIF Position         */
#define USBD_BUSINTSTS_RSTIF_Msk         (0x1ul << USBD_BUSINTSTS_RSTIF_Pos)               /*!< USBD_T::BUSINTSTS: RSTIF Mask             */

#define USBD_BUSINTSTS_RESUMEIF_Pos      (2)                                               /*!< USBD_T::BUSINTSTS: RESUMEIF Position      */
#define USBD_BUSINTSTS_RESUMEIF_Msk      (0x1ul << USBD_BUSINTSTS_RESUMEIF_Pos)            /*!< USBD_T::BUSINTSTS: RESUMEIF Mask          */

#define USBD_BUSINTSTS_SUSPENDIF_Pos     (3)                                               /*!< USBD_T::BUSINTSTS: SUSPENDIF Position     */
#define USBD_BUSINTSTS_SUSPENDIF_Msk     (0x1ul << USBD_BUSINTSTS_SUSPENDIF_Pos)           /*!< USBD_T::BUSINTSTS: SUSPENDIF Mask         */

#define USBD_BUSINTSTS_HISPDIF_Pos       (4)                                               /*!< USBD_T::BUSINTSTS: HISPDIF Position       */
#define USBD_BUSINTSTS_HISPDIF_Msk       (0x1ul << USBD_BUSINTSTS_HISPDIF_Pos)             /*!< USBD_T::BUSINTSTS: HISPDIF Mask           */

#define USBD_BUSINTSTS_DMADONEIF_Pos     (5)                                               /*!< USBD_T::BUSINTSTS: DMADONEIF Position     */
#define USBD_BUSINTSTS_DMADONEIF_Msk     (0x1ul << USBD_BUSINTSTS_DMADONEIF_Pos)           /*!< USBD_T::BUSINTSTS: DMADONEIF Mask         */

#define USBD_BUSINTSTS_PHYCLKVLDIF_Pos   (6)                                               /*!< USBD_T::BUSINTSTS: PHYCLKVLDIF Position   */
#define USBD_BUSINTSTS_PHYCLKVLDIF_Msk   (0x1ul << USBD_BUSINTSTS_PHYCLKVLDIF_Pos)         /*!< USBD_T::BUSINTSTS: PHYCLKVLDIF Mask       */

#define USBD_BUSINTSTS_VBUSDETIF_Pos     (8)                                               /*!< USBD_T::BUSINTSTS: VBUSDETIF Position     */
#define USBD_BUSINTSTS_VBUSDETIF_Msk     (0x1ul << USBD_BUSINTSTS_VBUSDETIF_Pos)           /*!< USBD_T::BUSINTSTS: VBUSDETIF Mask         */

#define USBD_BUSINTEN_SOFIEN_Pos         (0)                                               /*!< USBD_T::BUSINTEN: SOFIEN Position         */
#define USBD_BUSINTEN_SOFIEN_Msk         (0x1ul << USBD_BUSINTEN_SOFIEN_Pos)               /*!< USBD_T::BUSINTEN: SOFIEN Mask             */

#define USBD_BUSINTEN_RSTIEN_Pos         (1)                                               /*!< USBD_T::BUSINTEN: RSTIEN Position         */
#define USBD_BUSINTEN_RSTIEN_Msk         (0x1ul << USBD_BUSINTEN_RSTIEN_Pos)               /*!< USBD_T::BUSINTEN: RSTIEN Mask             */

#define USBD_BUSINTEN_RESUMEIEN_Pos      (2)                                               /*!< USBD_T::BUSINTEN: RESUMEIEN Position      */
#define USBD_BUSINTEN_RESUMEIEN_Msk      (0x1ul << USBD_BUSINTEN_RESUMEIEN_Pos)            /*!< USBD_T::BUSINTEN: RESUMEIEN Mask          */

#define USBD_BUSINTEN_SUSPENDIEN_Pos     (3)                                               /*!< USBD_T::BUSINTEN: SUSPENDIEN Position     */
#define USBD_BUSINTEN_SUSPENDIEN_Msk     (0x1ul << USBD_BUSINTEN_SUSPENDIEN_Pos)           /*!< USBD_T::BUSINTEN: SUSPENDIEN Mask         */

#define USBD_BUSINTEN_HISPDIEN_Pos       (4)                                               /*!< USBD_T::BUSINTEN: HISPDIEN Position       */
#define USBD_BUSINTEN_HISPDIEN_Msk       (0x1ul << USBD_BUSINTEN_HISPDIEN_Pos)             /*!< USBD_T::BUSINTEN: HISPDIEN Mask           */

#define USBD_BUSINTEN_DMADONEIEN_Pos     (5)                                               /*!< USBD_T::BUSINTEN: DMADONEIEN Position     */
#define USBD_BUSINTEN_DMADONEIEN_Msk     (0x1ul << USBD_BUSINTEN_DMADONEIEN_Pos)           /*!< USBD_T::BUSINTEN: DMADONEIEN Mask         */

#define USBD_BUSINTEN_PHYCLKVLDIEN_Pos   (6)                                               /*!< USBD_T::BUSINTEN: PHYCLKVLDIEN Position   */
#define USBD_BUSINTEN_PHYCLKVLDIEN_Msk   (0x1ul << USBD_BUSINTEN_PHYCLKVLDIEN_Pos)         /*!< USBD_T::BUSINTEN: PHYCLKVLDIEN Mask       */

#define USBD_BUSINTEN_VBUSDETIEN_Pos     (8)                                               /*!< USBD_T::BUSINTEN: VBUSDETIEN Position     */
#define USBD_BUSINTEN_VBUSDETIEN_Msk     (0x1ul << USBD_BUSINTEN_VBUSDETIEN_Pos)           /*!< USBD_T::BUSINTEN: VBUSDETIEN Mask         */

#define USBD_OPER_RESUMEEN_Pos           (0)                                               /*!< USBD_T::OPER: RESUMEEN Position           */
#define USBD_OPER_RESUMEEN_Msk           (0x1ul << USBD_OPER_RESUMEEN_Pos)                 /*!< USBD_T::OPER: RESUMEEN Mask               */

#define USBD_OPER_HISPDEN_Pos            (1)                                               /*!< USBD_T::OPER: HISPDEN Position            */
#define USBD_OPER_HISPDEN_Msk            (0x1ul << USBD_OPER_HISPDEN_Pos)                  /*!< USBD_T::OPER: HISPDEN Mask                */

#define USBD_OPER_CURSPD_Pos             (2)                                               /*!< USBD_T::OPER: CURSPD Position             */
#define USBD_OPER_CURSPD_Msk             (0x1ul << USBD_OPER_CURSPD_Pos)                   /*!< USBD_T::OPER: CURSPD Mask                 */

#define USBD_FRAMECNT_MFRAMECNT_Pos      (0)                                               /*!< USBD_T::FRAMECNT: MFRAMECNT Position      */
#define USBD_FRAMECNT_MFRAMECNT_Msk      (0x7ul << USBD_FRAMECNT_MFRAMECNT_Pos)            /*!< USBD_T::FRAMECNT: MFRAMECNT Mask          */

#define USBD_FRAMECNT_FRAMECNT_Pos       (3)                                               /*!< USBD_T::FRAMECNT: FRAMECNT Position       */
#define USBD_FRAMECNT_FRAMECNT_Msk       (0x7fful << USBD_FRAMECNT_FRAMECNT_Pos)           /*!< USBD_T::FRAMECNT: FRAMECNT Mask           */

#define USBD_FADDR_FADDR_Pos             (0)                                               /*!< USBD_T::FADDR: FADDR Position             */
#define USBD_FADDR_FADDR_Msk             (0x7ful << USBD_FADDR_FADDR_Pos)                  /*!< USBD_T::FADDR: FADDR Mask                 */

#define USBD_TEST_TESTMODE_Pos           (0)                                               /*!< USBD_T::TEST: TESTMODE Position           */
#define USBD_TEST_TESTMODE_Msk           (0x7ul << USBD_TEST_TESTMODE_Pos)                 /*!< USBD_T::TEST: TESTMODE Mask               */

#define USBD_CEPDAT_DAT_Pos              (0)                                               /*!< USBD_T::CEPDAT: DAT Position              */
#define USBD_CEPDAT_DAT_Msk              (0xfffffffful << USBD_CEPDAT_DAT_Pos)             /*!< USBD_T::CEPDAT: DAT Mask                  */

#define USBD_CEPCTL_NAKCLR_Pos           (0)                                               /*!< USBD_T::CEPCTL: NAKCLR Position           */
#define USBD_CEPCTL_NAKCLR_Msk           (0x1ul << USBD_CEPCTL_NAKCLR_Pos)                 /*!< USBD_T::CEPCTL: NAKCLR Mask               */

#define USBD_CEPCTL_STALLEN_Pos          (1)                                               /*!< USBD_T::CEPCTL: STALLEN Position          */
#define USBD_CEPCTL_STALLEN_Msk          (0x1ul << USBD_CEPCTL_STALLEN_Pos)                /*!< USBD_T::CEPCTL: STALLEN Mask              */

#define USBD_CEPCTL_ZEROLEN_Pos          (2)                                               /*!< USBD_T::CEPCTL: ZEROLEN Position          */
#define USBD_CEPCTL_ZEROLEN_Msk          (0x1ul << USBD_CEPCTL_ZEROLEN_Pos)                /*!< USBD_T::CEPCTL: ZEROLEN Mask              */

#define USBD_CEPCTL_FLUSH_Pos            (3)                                               /*!< USBD_T::CEPCTL: FLUSH Position            */
#define USBD_CEPCTL_FLUSH_Msk            (0x1ul << USBD_CEPCTL_FLUSH_Pos)                  /*!< USBD_T::CEPCTL: FLUSH Mask                */

#define USBD_CEPINTEN_SETUPTKIEN_Pos     (0)                                               /*!< USBD_T::CEPINTEN: SETUPTKIEN Position     */
#define USBD_CEPINTEN_SETUPTKIEN_Msk     (0x1ul << USBD_CEPINTEN_SETUPTKIEN_Pos)           /*!< USBD_T::CEPINTEN: SETUPTKIEN Mask         */

#define USBD_CEPINTEN_SETUPPKIEN_Pos     (1)                                               /*!< USBD_T::CEPINTEN: SETUPPKIEN Position     */
#define USBD_CEPINTEN_SETUPPKIEN_Msk     (0x1ul << USBD_CEPINTEN_SETUPPKIEN_Pos)           /*!< USBD_T::CEPINTEN: SETUPPKIEN Mask         */

#define USBD_CEPINTEN_OUTTKIEN_Pos       (2)                                               /*!< USBD_T::CEPINTEN: OUTTKIEN Position       */
#define USBD_CEPINTEN_OUTTKIEN_Msk       (0x1ul << USBD_CEPINTEN_OUTTKIEN_Pos)             /*!< USBD_T::CEPINTEN: OUTTKIEN Mask           */

#define USBD_CEPINTEN_INTKIEN_Pos        (3)                                               /*!< USBD_T::CEPINTEN: INTKIEN Position        */
#define USBD_CEPINTEN_INTKIEN_Msk        (0x1ul << USBD_CEPINTEN_INTKIEN_Pos)              /*!< USBD_T::CEPINTEN: INTKIEN Mask            */

#define USBD_CEPINTEN_PINGIEN_Pos        (4)                                               /*!< USBD_T::CEPINTEN: PINGIEN Position        */
#define USBD_CEPINTEN_PINGIEN_Msk        (0x1ul << USBD_CEPINTEN_PINGIEN_Pos)              /*!< USBD_T::CEPINTEN: PINGIEN Mask            */

#define USBD_CEPINTEN_TXPKIEN_Pos        (5)                                               /*!< USBD_T::CEPINTEN: TXPKIEN Position        */
#define USBD_CEPINTEN_TXPKIEN_Msk        (0x1ul << USBD_CEPINTEN_TXPKIEN_Pos)              /*!< USBD_T::CEPINTEN: TXPKIEN Mask            */

#define USBD_CEPINTEN_RXPKIEN_Pos        (6)                                               /*!< USBD_T::CEPINTEN: RXPKIEN Position        */
#define USBD_CEPINTEN_RXPKIEN_Msk        (0x1ul << USBD_CEPINTEN_RXPKIEN_Pos)              /*!< USBD_T::CEPINTEN: RXPKIEN Mask            */

#define USBD_CEPINTEN_NAKIEN_Pos         (7)                                               /*!< USBD_T::CEPINTEN: NAKIEN Position         */
#define USBD_CEPINTEN_NAKIEN_Msk         (0x1ul << USBD_CEPINTEN_NAKIEN_Pos)               /*!< USBD_T::CEPINTEN: NAKIEN Mask             */

#define USBD_CEPINTEN_STALLIEN_Pos       (8)                                               /*!< USBD_T::CEPINTEN: STALLIEN Position       */
#define USBD_CEPINTEN_STALLIEN_Msk       (0x1ul << USBD_CEPINTEN_STALLIEN_Pos)             /*!< USBD_T::CEPINTEN: STALLIEN Mask           */

#define USBD_CEPINTEN_ERRIEN_Pos         (9)                                               /*!< USBD_T::CEPINTEN: ERRIEN Position         */
#define USBD_CEPINTEN_ERRIEN_Msk         (0x1ul << USBD_CEPINTEN_ERRIEN_Pos)               /*!< USBD_T::CEPINTEN: ERRIEN Mask             */

#define USBD_CEPINTEN_STSDONEIEN_Pos     (10)                                              /*!< USBD_T::CEPINTEN: STSDONEIEN Position     */
#define USBD_CEPINTEN_STSDONEIEN_Msk     (0x1ul << USBD_CEPINTEN_STSDONEIEN_Pos)           /*!< USBD_T::CEPINTEN: STSDONEIEN Mask         */

#define USBD_CEPINTEN_BUFFULLIEN_Pos     (11)                                              /*!< USBD_T::CEPINTEN: BUFFULLIEN Position     */
#define USBD_CEPINTEN_BUFFULLIEN_Msk     (0x1ul << USBD_CEPINTEN_BUFFULLIEN_Pos)           /*!< USBD_T::CEPINTEN: BUFFULLIEN Mask         */

#define USBD_CEPINTEN_BUFEMPTYIEN_Pos    (12)                                              /*!< USBD_T::CEPINTEN: BUFEMPTYIEN Position    */
#define USBD_CEPINTEN_BUFEMPTYIEN_Msk    (0x1ul << USBD_CEPINTEN_BUFEMPTYIEN_Pos)          /*!< USBD_T::CEPINTEN: BUFEMPTYIEN Mask        */

#define USBD_CEPINTSTS_SETUPTKIF_Pos     (0)                                               /*!< USBD_T::CEPINTSTS: SETUPTKIF Position     */
#define USBD_CEPINTSTS_SETUPTKIF_Msk     (0x1ul << USBD_CEPINTSTS_SETUPTKIF_Pos)           /*!< USBD_T::CEPINTSTS: SETUPTKIF Mask         */

#define USBD_CEPINTSTS_SETUPPKIF_Pos     (1)                                               /*!< USBD_T::CEPINTSTS: SETUPPKIF Position     */
#define USBD_CEPINTSTS_SETUPPKIF_Msk     (0x1ul << USBD_CEPINTSTS_SETUPPKIF_Pos)           /*!< USBD_T::CEPINTSTS: SETUPPKIF Mask         */

#define USBD_CEPINTSTS_OUTTKIF_Pos       (2)                                               /*!< USBD_T::CEPINTSTS: OUTTKIF Position       */
#define USBD_CEPINTSTS_OUTTKIF_Msk       (0x1ul << USBD_CEPINTSTS_OUTTKIF_Pos)             /*!< USBD_T::CEPINTSTS: OUTTKIF Mask           */

#define USBD_CEPINTSTS_INTKIF_Pos        (3)                                               /*!< USBD_T::CEPINTSTS: INTKIF Position        */
#define USBD_CEPINTSTS_INTKIF_Msk        (0x1ul << USBD_CEPINTSTS_INTKIF_Pos)              /*!< USBD_T::CEPINTSTS: INTKIF Mask            */

#define USBD_CEPINTSTS_PINGIF_Pos        (4)                                               /*!< USBD_T::CEPINTSTS: PINGIF Position        */
#define USBD_CEPINTSTS_PINGIF_Msk        (0x1ul << USBD_CEPINTSTS_PINGIF_Pos)              /*!< USBD_T::CEPINTSTS: PINGIF Mask            */

#define USBD_CEPINTSTS_TXPKIF_Pos        (5)                                               /*!< USBD_T::CEPINTSTS: TXPKIF Position        */
#define USBD_CEPINTSTS_TXPKIF_Msk        (0x1ul << USBD_CEPINTSTS_TXPKIF_Pos)              /*!< USBD_T::CEPINTSTS: TXPKIF Mask            */

#define USBD_CEPINTSTS_RXPKIF_Pos        (6)                                               /*!< USBD_T::CEPINTSTS: RXPKIF Position        */
#define USBD_CEPINTSTS_RXPKIF_Msk        (0x1ul << USBD_CEPINTSTS_RXPKIF_Pos)              /*!< USBD_T::CEPINTSTS: RXPKIF Mask            */

#define USBD_CEPINTSTS_NAKIF_Pos         (7)                                               /*!< USBD_T::CEPINTSTS: NAKIF Position         */
#define USBD_CEPINTSTS_NAKIF_Msk         (0x1ul << USBD_CEPINTSTS_NAKIF_Pos)               /*!< USBD_T::CEPINTSTS: NAKIF Mask             */

#define USBD_CEPINTSTS_STALLIF_Pos       (8)                                               /*!< USBD_T::CEPINTSTS: STALLIF Position       */
#define USBD_CEPINTSTS_STALLIF_Msk       (0x1ul << USBD_CEPINTSTS_STALLIF_Pos)             /*!< USBD_T::CEPINTSTS: STALLIF Mask           */

#define USBD_CEPINTSTS_ERRIF_Pos         (9)                                               /*!< USBD_T::CEPINTSTS: ERRIF Position         */
#define USBD_CEPINTSTS_ERRIF_Msk         (0x1ul << USBD_CEPINTSTS_ERRIF_Pos)               /*!< USBD_T::CEPINTSTS: ERRIF Mask             */

#define USBD_CEPINTSTS_STSDONEIF_Pos     (10)                                              /*!< USBD_T::CEPINTSTS: STSDONEIF Position     */
#define USBD_CEPINTSTS_STSDONEIF_Msk     (0x1ul << USBD_CEPINTSTS_STSDONEIF_Pos)           /*!< USBD_T::CEPINTSTS: STSDONEIF Mask         */

#define USBD_CEPINTSTS_BUFFULLIF_Pos     (11)                                              /*!< USBD_T::CEPINTSTS: BUFFULLIF Position     */
#define USBD_CEPINTSTS_BUFFULLIF_Msk     (0x1ul << USBD_CEPINTSTS_BUFFULLIF_Pos)           /*!< USBD_T::CEPINTSTS: BUFFULLIF Mask         */

#define USBD_CEPINTSTS_BUFEMPTYIF_Pos    (12)                                              /*!< USBD_T::CEPINTSTS: BUFEMPTYIF Position    */
#define USBD_CEPINTSTS_BUFEMPTYIF_Msk    (0x1ul << USBD_CEPINTSTS_BUFEMPTYIF_Pos)          /*!< USBD_T::CEPINTSTS: BUFEMPTYIF Mask        */

#define USBD_CEPTXCNT_TXCNT_Pos          (0)                                               /*!< USBD_T::CEPTXCNT: TXCNT Position          */
#define USBD_CEPTXCNT_TXCNT_Msk          (0xfful << USBD_CEPTXCNT_TXCNT_Pos)               /*!< USBD_T::CEPTXCNT: TXCNT Mask              */

#define USBD_CEPRXCNT_RXCNT_Pos          (0)                                               /*!< USBD_T::CEPRXCNT: RXCNT Position          */
#define USBD_CEPRXCNT_RXCNT_Msk          (0xfful << USBD_CEPRXCNT_RXCNT_Pos)               /*!< USBD_T::CEPRXCNT: RXCNT Mask              */

#define USBD_CEPDATCNT_DATCNT_Pos        (0)                                               /*!< USBD_T::CEPDATCNT: DATCNT Position        */
#define USBD_CEPDATCNT_DATCNT_Msk        (0xfffful << USBD_CEPDATCNT_DATCNT_Pos)           /*!< USBD_T::CEPDATCNT: DATCNT Mask            */

#define USBD_SETUP1_0_SETUP0_Pos         (0)                                               /*!< USBD_T::SETUP1_0: SETUP0 Position         */
#define USBD_SETUP1_0_SETUP0_Msk         (0xfful << USBD_SETUP1_0_SETUP0_Pos)              /*!< USBD_T::SETUP1_0: SETUP0 Mask             */

#define USBD_SETUP1_0_SETUP1_Pos         (8)                                               /*!< USBD_T::SETUP1_0: SETUP1 Position         */
#define USBD_SETUP1_0_SETUP1_Msk         (0xfful << USBD_SETUP1_0_SETUP1_Pos)              /*!< USBD_T::SETUP1_0: SETUP1 Mask             */

#define USBD_SETUP3_2_SETUP2_Pos         (0)                                               /*!< USBD_T::SETUP3_2: SETUP2 Position         */
#define USBD_SETUP3_2_SETUP2_Msk         (0xfful << USBD_SETUP3_2_SETUP2_Pos)              /*!< USBD_T::SETUP3_2: SETUP2 Mask             */

#define USBD_SETUP3_2_SETUP3_Pos         (8)                                               /*!< USBD_T::SETUP3_2: SETUP3 Position         */
#define USBD_SETUP3_2_SETUP3_Msk         (0xfful << USBD_SETUP3_2_SETUP3_Pos)              /*!< USBD_T::SETUP3_2: SETUP3 Mask             */

#define USBD_SETUP5_4_SETUP4_Pos         (0)                                               /*!< USBD_T::SETUP5_4: SETUP4 Position         */
#define USBD_SETUP5_4_SETUP4_Msk         (0xfful << USBD_SETUP5_4_SETUP4_Pos)              /*!< USBD_T::SETUP5_4: SETUP4 Mask             */

#define USBD_SETUP5_4_SETUP5_Pos         (8)                                               /*!< USBD_T::SETUP5_4: SETUP5 Position         */
#define USBD_SETUP5_4_SETUP5_Msk         (0xfful << USBD_SETUP5_4_SETUP5_Pos)              /*!< USBD_T::SETUP5_4: SETUP5 Mask             */

#define USBD_SETUP7_6_SETUP6_Pos         (0)                                               /*!< USBD_T::SETUP7_6: SETUP6 Position         */
#define USBD_SETUP7_6_SETUP6_Msk         (0xfful << USBD_SETUP7_6_SETUP6_Pos)              /*!< USBD_T::SETUP7_6: SETUP6 Mask             */

#define USBD_SETUP7_6_SETUP7_Pos         (8)                                               /*!< USBD_T::SETUP7_6: SETUP7 Position         */
#define USBD_SETUP7_6_SETUP7_Msk         (0xfful << USBD_SETUP7_6_SETUP7_Pos)              /*!< USBD_T::SETUP7_6: SETUP7 Mask             */

#define USBD_CEPBUFSTART_SADDR_Pos       (0)                                               /*!< USBD_T::CEPBUFSTART: SADDR Position       */
#define USBD_CEPBUFSTART_SADDR_Msk       (0xffful << USBD_CEPBUFSTART_SADDR_Pos)           /*!< USBD_T::CEPBUFSTART: SADDR Mask           */

#define USBD_CEPBUFEND_EADDR_Pos         (0)                                               /*!< USBD_T::CEPBUFEND: EADDR Position         */
#define USBD_CEPBUFEND_EADDR_Msk         (0xffful << USBD_CEPBUFEND_EADDR_Pos)             /*!< USBD_T::CEPBUFEND: EADDR Mask             */

#define USBD_DMACTL_EPNUM_Pos            (0)                                               /*!< USBD_T::DMACTL: EPNUM Position            */
#define USBD_DMACTL_EPNUM_Msk            (0xful << USBD_DMACTL_EPNUM_Pos)                  /*!< USBD_T::DMACTL: EPNUM Mask                */

#define USBD_DMACTL_DMARD_Pos            (4)                                               /*!< USBD_T::DMACTL: DMARD Position            */
#define USBD_DMACTL_DMARD_Msk            (0x1ul << USBD_DMACTL_DMARD_Pos)                  /*!< USBD_T::DMACTL: DMARD Mask                */

#define USBD_DMACTL_DMAEN_Pos            (5)                                               /*!< USBD_T::DMACTL: DMAEN Position            */
#define USBD_DMACTL_DMAEN_Msk            (0x1ul << USBD_DMACTL_DMAEN_Pos)                  /*!< USBD_T::DMACTL: DMAEN Mask                */

#define USBD_DMACTL_SGEN_Pos             (6)                                               /*!< USBD_T::DMACTL: SGEN Position             */
#define USBD_DMACTL_SGEN_Msk             (0x1ul << USBD_DMACTL_SGEN_Pos)                   /*!< USBD_T::DMACTL: SGEN Mask                 */

#define USBD_DMACTL_DMARST_Pos           (7)                                               /*!< USBD_T::DMACTL: DMARST Position           */
#define USBD_DMACTL_DMARST_Msk           (0x1ul << USBD_DMACTL_DMARST_Pos)                 /*!< USBD_T::DMACTL: DMARST Mask               */

#define USBD_DMACNT_DMACNT_Pos           (0)                                               /*!< USBD_T::DMACNT: DMACNT Position           */
#define USBD_DMACNT_DMACNT_Msk           (0xffffful << USBD_DMACNT_DMACNT_Pos)             /*!< USBD_T::DMACNT: DMACNT Mask               */

#define USBD_EPDAT_EPDAT_Pos             (0)                                               /*!< USBD_EP_T::EPDAT: EPDAT Position            */
#define USBD_EPDAT_EPDAT_Msk             (0xfffffffful << USBD_EPDAT_EPDAT_Pos)            /*!< USBD_EP_T::EPDAT: EPDAT Mask                */

#define USBD_EPINTSTS_BUFFULLIF_Pos      (0)                                               /*!< USBD_EP_T::EPINTSTS: BUFFULLIF Position     */
#define USBD_EPINTSTS_BUFFULLIF_Msk      (0x1ul << USBD_EPINTSTS_BUFFULLIF_Pos)            /*!< USBD_EP_T::EPINTSTS: BUFFULLIF Mask         */

#define USBD_EPINTSTS_BUFEMPTYIF_Pos     (1)                                               /*!< USBD_EP_T::EPINTSTS: BUFEMPTYIF Position    */
#define USBD_EPINTSTS_BUFEMPTYIF_Msk     (0x1ul << USBD_EPINTSTS_BUFEMPTYIF_Pos)           /*!< USBD_EP_T::EPINTSTS: BUFEMPTYIF Mask        */

#define USBD_EPINTSTS_SHORTTXIF_Pos      (2)                                               /*!< USBD_EP_T::EPINTSTS: SHORTTXIF Position     */
#define USBD_EPINTSTS_SHORTTXIF_Msk      (0x1ul << USBD_EPINTSTS_SHORTTXIF_Pos)            /*!< USBD_EP_T::EPINTSTS: SHORTTXIF Mask         */

#define USBD_EPINTSTS_TXPKIF_Pos         (3)                                               /*!< USBD_EP_T::EPINTSTS: TXPKIF Position        */
#define USBD_EPINTSTS_TXPKIF_Msk         (0x1ul << USBD_EPINTSTS_TXPKIF_Pos)               /*!< USBD_EP_T::EPINTSTS: TXPKIF Mask            */

#define USBD_EPINTSTS_RXPKIF_Pos         (4)                                               /*!< USBD_EP_T::EPINTSTS: RXPKIF Position        */
#define USBD_EPINTSTS_RXPKIF_Msk         (0x1ul << USBD_EPINTSTS_RXPKIF_Pos)               /*!< USBD_EP_T::EPINTSTS: RXPKIF Mask            */

#define USBD_EPINTSTS_OUTTKIF_Pos        (5)                                               /*!< USBD_EP_T::EPINTSTS: OUTTKIF Position       */
#define USBD_EPINTSTS_OUTTKIF_Msk        (0x1ul << USBD_EPINTSTS_OUTTKIF_Pos)              /*!< USBD_EP_T::EPINTSTS: OUTTKIF Mask           */

#define USBD_EPINTSTS_INTKIF_Pos         (6)                                               /*!< USBD_EP_T::EPINTSTS: INTKIF Position        */
#define USBD_EPINTSTS_INTKIF_Msk         (0x1ul << USBD_EPINTSTS_INTKIF_Pos)               /*!< USBD_EP_T::EPINTSTS: INTKIF Mask            */

#define USBD_EPINTSTS_PINGIF_Pos         (7)                                               /*!< USBD_EP_T::EPINTSTS: PINGIF Position        */
#define USBD_EPINTSTS_PINGIF_Msk         (0x1ul << USBD_EPINTSTS_PINGIF_Pos)               /*!< USBD_EP_T::EPINTSTS: PINGIF Mask            */

#define USBD_EPINTSTS_NAKIF_Pos          (8)                                               /*!< USBD_EP_T::EPINTSTS: NAKIF Position         */
#define USBD_EPINTSTS_NAKIF_Msk          (0x1ul << USBD_EPINTSTS_NAKIF_Pos)                /*!< USBD_EP_T::EPINTSTS: NAKIF Mask             */

#define USBD_EPINTSTS_STALLIF_Pos        (9)                                               /*!< USBD_EP_T::EPINTSTS: STALLIF Position       */
#define USBD_EPINTSTS_STALLIF_Msk        (0x1ul << USBD_EPINTSTS_STALLIF_Pos)              /*!< USBD_EP_T::EPINTSTS: STALLIF Mask           */

#define USBD_EPINTSTS_NYETIF_Pos         (10)                                              /*!< USBD_EP_T::EPINTSTS: NYETIF Position        */
#define USBD_EPINTSTS_NYETIF_Msk         (0x1ul << USBD_EPINTSTS_NYETIF_Pos)               /*!< USBD_EP_T::EPINTSTS: NYETIF Mask            */

#define USBD_EPINTSTS_ERRIF_Pos          (11)                                              /*!< USBD_EP_T::EPINTSTS: ERRIF Position         */
#define USBD_EPINTSTS_ERRIF_Msk          (0x1ul << USBD_EPINTSTS_ERRIF_Pos)                /*!< USBD_EP_T::EPINTSTS: ERRIF Mask             */

#define USBD_EPINTSTS_SHORTRXIF_Pos      (12)                                              /*!< USBD_EP_T::EPINTSTS: SHORTRXIF Position     */
#define USBD_EPINTSTS_SHORTRXIF_Msk      (0x1ul << USBD_EPINTSTS_SHORTRXIF_Pos)            /*!< USBD_EP_T::EPINTSTS: SHORTRXIF Mask         */

#define USBD_EPINTEN_BUFFULLIEN_Pos      (0)                                               /*!< USBD_EP_T::EPINTEN: BUFFULLIEN Position     */
#define USBD_EPINTEN_BUFFULLIEN_Msk      (0x1ul << USBD_EPINTEN_BUFFULLIEN_Pos)            /*!< USBD_EP_T::EPINTEN: BUFFULLIEN Mask         */

#define USBD_EPINTEN_BUFEMPTYIEN_Pos     (1)                                               /*!< USBD_EP_T::EPINTEN: BUFEMPTYIEN Position    */
#define USBD_EPINTEN_BUFEMPTYIEN_Msk     (0x1ul << USBD_EPINTEN_BUFEMPTYIEN_Pos)           /*!< USBD_EP_T::EPINTEN: BUFEMPTYIEN Mask        */

#define USBD_EPINTEN_SHORTTXIEN_Pos      (2)                                               /*!< USBD_EP_T::EPINTEN: SHORTTXIEN Position     */
#define USBD_EPINTEN_SHORTTXIEN_Msk      (0x1ul << USBD_EPINTEN_SHORTTXIEN_Pos)            /*!< USBD_EP_T::EPINTEN: SHORTTXIEN Mask         */

#define USBD_EPINTEN_TXPKIEN_Pos         (3)                                               /*!< USBD_EP_T::EPINTEN: TXPKIEN Position        */
#define USBD_EPINTEN_TXPKIEN_Msk         (0x1ul << USBD_EPINTEN_TXPKIEN_Pos)               /*!< USBD_EP_T::EPINTEN: TXPKIEN Mask            */

#define USBD_EPINTEN_RXPKIEN_Pos         (4)                                               /*!< USBD_EP_T::EPINTEN: RXPKIEN Position        */
#define USBD_EPINTEN_RXPKIEN_Msk         (0x1ul << USBD_EPINTEN_RXPKIEN_Pos)               /*!< USBD_EP_T::EPINTEN: RXPKIEN Mask            */

#define USBD_EPINTEN_OUTTKIEN_Pos        (5)                                               /*!< USBD_EP_T::EPINTEN: OUTTKIEN Position       */
#define USBD_EPINTEN_OUTTKIEN_Msk        (0x1ul << USBD_EPINTEN_OUTTKIEN_Pos)              /*!< USBD_EP_T::EPINTEN: OUTTKIEN Mask           */

#define USBD_EPINTEN_INTKIEN_Pos         (6)                                               /*!< USBD_EP_T::EPINTEN: INTKIEN Position        */
#define USBD_EPINTEN_INTKIEN_Msk         (0x1ul << USBD_EPINTEN_INTKIEN_Pos)               /*!< USBD_EP_T::EPINTEN: INTKIEN Mask            */

#define USBD_EPINTEN_PINGIEN_Pos         (7)                                               /*!< USBD_EP_T::EPINTEN: PINGIEN Position        */
#define USBD_EPINTEN_PINGIEN_Msk         (0x1ul << USBD_EPINTEN_PINGIEN_Pos)               /*!< USBD_EP_T::EPINTEN: PINGIEN Mask            */

#define USBD_EPINTEN_NAKIEN_Pos          (8)                                               /*!< USBD_EP_T::EPINTEN: NAKIEN Position         */
#define USBD_EPINTEN_NAKIEN_Msk          (0x1ul << USBD_EPINTEN_NAKIEN_Pos)                /*!< USBD_EP_T::EPINTEN: NAKIEN Mask             */

#define USBD_EPINTEN_STALLIEN_Pos        (9)                                               /*!< USBD_EP_T::EPINTEN: STALLIEN Position       */
#define USBD_EPINTEN_STALLIEN_Msk        (0x1ul << USBD_EPINTEN_STALLIEN_Pos)              /*!< USBD_EP_T::EPINTEN: STALLIEN Mask           */

#define USBD_EPINTEN_NYETIEN_Pos         (10)                                              /*!< USBD_EP_T::EPINTEN: NYETIEN Position        */
#define USBD_EPINTEN_NYETIEN_Msk         (0x1ul << USBD_EPINTEN_NYETIEN_Pos)               /*!< USBD_EP_T::EPINTEN: NYETIEN Mask            */

#define USBD_EPINTEN_ERRIEN_Pos          (11)                                              /*!< USBD_EP_T::EPINTEN: ERRIEN Position         */
#define USBD_EPINTEN_ERRIEN_Msk          (0x1ul << USBD_EPINTEN_ERRIEN_Pos)                /*!< USBD_EP_T::EPINTEN: ERRIEN Mask             */

#define USBD_EPINTEN_SHORTRXIEN_Pos      (12)                                              /*!< USBD_EP_T::EPINTEN: SHORTRXIEN Position     */
#define USBD_EPINTEN_SHORTRXIEN_Msk      (0x1ul << USBD_EPINTEN_SHORTRXIEN_Pos)            /*!< USBD_EP_T::EPINTEN: SHORTRXIEN Mask         */

#define USBD_EPDATCNT_DATCNT_Pos         (0)                                               /*!< USBD_EP_T::EPDATCNT: DATCNT Position        */
#define USBD_EPDATCNT_DATCNT_Msk         (0xfffful << USBD_EPDATCNT_DATCNT_Pos)            /*!< USBD_EP_T::EPDATCNT: DATCNT Mask            */

#define USBD_EPDATCNT_DMALOOP_Pos        (16)                                              /*!< USBD_EP_T::EPDATCNT: DMALOOP Position       */
#define USBD_EPDATCNT_DMALOOP_Msk        (0x7ffful << USBD_EPDATCNT_DMALOOP_Pos)           /*!< USBD_EP_T::EPDATCNT: DMALOOP Mask           */

#define USBD_EPRSPCTL_FLUSH_Pos          (0)                                               /*!< USBD_EP_T::EPRSPCTL: FLUSH Position         */
#define USBD_EPRSPCTL_FLUSH_Msk          (0x1ul << USBD_EPRSPCTL_FLUSH_Pos)                /*!< USBD_EP_T::EPRSPCTL: FLUSH Mask             */

#define USBD_EPRSPCTL_MODE_Pos           (1)                                               /*!< USBD_EP_T::EPRSPCTL: MODE Position          */
#define USBD_EPRSPCTL_MODE_Msk           (0x3ul << USBD_EPRSPCTL_MODE_Pos)                 /*!< USBD_EP_T::EPRSPCTL: MODE Mask              */

#define USBD_EPRSPCTL_TOGGLE_Pos         (3)                                               /*!< USBD_EP_T::EPRSPCTL: TOGGLE Position        */
#define USBD_EPRSPCTL_TOGGLE_Msk         (0x1ul << USBD_EPRSPCTL_TOGGLE_Pos)               /*!< USBD_EP_T::EPRSPCTL: TOGGLE Mask            */

#define USBD_EPRSPCTL_HALT_Pos           (4)                                               /*!< USBD_EP_T::EPRSPCTL: HALT Position          */
#define USBD_EPRSPCTL_HALT_Msk           (0x1ul << USBD_EPRSPCTL_HALT_Pos)                 /*!< USBD_EP_T::EPRSPCTL: HALT Mask              */

#define USBD_EPRSPCTL_ZEROLEN_Pos        (5)                                               /*!< USBD_EP_T::EPRSPCTL: ZEROLEN Position       */
#define USBD_EPRSPCTL_ZEROLEN_Msk        (0x1ul << USBD_EPRSPCTL_ZEROLEN_Pos)              /*!< USBD_EP_T::EPRSPCTL: ZEROLEN Mask           */

#define USBD_EPRSPCTL_SHORTTXEN_Pos      (6)                                               /*!< USBD_EP_T::EPRSPCTL: SHORTTXEN Position     */
#define USBD_EPRSPCTL_SHORTTXEN_Msk      (0x1ul << USBD_EPRSPCTL_SHORTTXEN_Pos)            /*!< USBD_EP_T::EPRSPCTL: SHORTTXEN Mask         */

#define USBD_EPRSPCTL_DISBUF_Pos         (7)                                               /*!< USBD_EP_T::EPRSPCTL: DISBUF Position        */
#define USBD_EPRSPCTL_DISBUF_Msk         (0x1ul << USBD_EPRSPCTL_DISBUF_Pos)               /*!< USBD_EP_T::EPRSPCTL: DISBUF Mask            */

#define USBD_EPMPS_EPMPS_Pos             (0)                                               /*!< USBD_EP_T::EPMPS: EPMPS Position            */
#define USBD_EPMPS_EPMPS_Msk             (0x7fful << USBD_EPMPS_EPMPS_Pos)                 /*!< USBD_EP_T::EPMPS: EPMPS Mask                */

#define USBD_EPTXCNT_TXCNT_Pos           (0)                                               /*!< USBD_EP_T::EPTXCNT: TXCNT Position          */
#define USBD_EPTXCNT_TXCNT_Msk           (0x7fful << USBD_EPTXCNT_TXCNT_Pos)               /*!< USBD_EP_T::EPTXCNT: TXCNT Mask              */

#define USBD_EPCFG_EPEN_Pos              (0)                                               /*!< USBD_EP_T::EPCFG: EPEN Position             */
#define USBD_EPCFG_EPEN_Msk              (0x1ul << USBD_EPCFG_EPEN_Pos)                    /*!< USBD_EP_T::EPCFG: EPEN Mask                 */

#define USBD_EPCFG_EPTYPE_Pos            (1)                                               /*!< USBD_EP_T::EPCFG: EPTYPE Position           */
#define USBD_EPCFG_EPTYPE_Msk            (0x3ul << USBD_EPCFG_EPTYPE_Pos)                  /*!< USBD_EP_T::EPCFG: EPTYPE Mask               */

#define USBD_EPCFG_EPDIR_Pos             (3)                                               /*!< USBD_EP_T::EPCFG: EPDIR Position            */
#define USBD_EPCFG_EPDIR_Msk             (0x1ul << USBD_EPCFG_EPDIR_Pos)                   /*!< USBD_EP_T::EPCFG: EPDIR Mask                */

#define USBD_EPCFG_EPNUM_Pos             (4)                                               /*!< USBD_EP_T::EPCFG: EPNUM Position            */
#define USBD_EPCFG_EPNUM_Msk             (0xful << USBD_EPCFG_EPNUM_Pos)                   /*!< USBD_EP_T::EPCFG: EPNUM Mask                */

#define USBD_EPBUFSTART_SADDR_Pos        (0)                                               /*!< USBD_EP_T::EPBUFSTART: SADDR Position       */
#define USBD_EPBUFSTART_SADDR_Msk        (0xffful << USBD_EPBUFSTART_SADDR_Pos)            /*!< USBD_EP_T::EPBUFSTART: SADDR Mask           */

#define USBD_EPBUFEND_EADDR_Pos          (0)                                               /*!< USBD_EP_T::EPBUFEND: EADDR Position         */
#define USBD_EPBUFEND_EADDR_Msk          (0xffful << USBD_EPBUFEND_EADDR_Pos)              /*!< USBD_EP_T::EPBUFEND: EADDR Mask             */

#define USBD_DMAADDR_DMAADDR_Pos         (0)                                               /*!< USBD_T::DMAADDR: DMAADDR Position         */
#define USBD_DMAADDR_DMAADDR_Msk         (0xfffffffful << USBD_DMAADDR_DMAADDR_Pos)        /*!< USBD_T::DMAADDR: DMAADDR Mask             */

#define USBD_PHYCTL_DPPUEN_Pos           (8)                                               /*!< USBD_T::PHYCTL: DPPUEN Position           */
#define USBD_PHYCTL_DPPUEN_Msk           (0x1ul << USBD_PHYCTL_DPPUEN_Pos)                 /*!< USBD_T::PHYCTL: DPPUEN Mask               */

#define USBD_PHYCTL_PHYEN_Pos            (9)                                               /*!< USBD_T::PHYCTL: PHYEN Position            */
#define USBD_PHYCTL_PHYEN_Msk            (0x1ul << USBD_PHYCTL_PHYEN_Pos)                  /*!< USBD_T::PHYCTL: PHYEN Mask                */

#define USBD_PHYCTL_WKEN_Pos             (24)                                              /*!< USBD_T::PHYCTL: WKEN Position             */
#define USBD_PHYCTL_WKEN_Msk             (0x1ul << USBD_PHYCTL_WKEN_Pos)                   /*!< USBD_T::PHYCTL: WKEN Mask                 */

#define USBD_PHYCTL_VBUSDET_Pos          (31)                                              /*!< USBD_T::PHYCTL: VBUSDET Position          */
#define USBD_PHYCTL_VBUSDET_Msk          (0x1ul << USBD_PHYCTL_VBUSDET_Pos)                /*!< USBD_T::PHYCTL: VBUSDET Mask              */

/**@}*/ /* USBD_CONST */
/**@}*/ /* end of USBD register group */


/*---------------------- Watch Dog Timer Controller -------------------------*/
/**
    @addtogroup WDT Watch Dog Timer Controller(WDT)
    Memory Mapped Structure for WDT Controller
@{ */

typedef struct {


    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x00  Watchdog Timer Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |RSTCNT    |Clear Watchdog Timer (Write Protect)
     * |        |          |0 = No effect.
     * |        |          |1 = Reset the internal 18-bit WDT counter.
     * |        |          |Note: This bit will be automatically cleared by hardware.
     * |[1]     |RSTEN     |Watchdog Timer Reset Enable Control (Write Protect)
     * |        |          |Setting this bit will enable the Watchdog Timer time-out reset function If the WDT counter value has not been cleared after the specific WDT reset delay period expires.
     * |        |          |0 = Watchdog Timer time-out reset function Disabled.
     * |        |          |1 = Watchdog Timer time-out reset function Enabled.
     * |[2]     |RSTF      |Watchdog Timer Reset Flag
     * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
     * |        |          |0 = Watchdog Timer time-out reset did not occur.
     * |        |          |1 = Watchdog Timer time-out reset occurred.
     * |        |          |Note: This bit is cleared by writing 1 to this bit.
     * |[3]     |IF        |Watchdog Timer Interrupt Flag
     * |        |          |This bit will set to 1 while WDT counter value reaches the selected WDT time-out interval
     * |        |          |0 = Watchdog Timer time-out interrupt did not occur.
     * |        |          |1 = Watchdog Timer time-out interrupt occurred.
     * |        |          |Note: This bit is cleared by writing 1 to this bit.
     * |[4]     |WKEN      |Watchdog Timer Wake-Up Function Enable Control (Write Protect)
     * |        |          |If this bit is set to 1, while WDT interrupt flag (WDT_CTL[3] IF) is generated to 1 and INTEN (WDT_CTL[6] WDT interrupt enable) is enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.
     * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
     * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
     * |        |          |Note: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz oscillator.
     * |[5]     |WKF       |Watchdog Timer Wake-Up Flag
     * |        |          |This bit indicates the interrupt wake-up flag status of WDT
     * |        |          |0 = Watchdog Timer does not cause chip wake-up.
     * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |[6]     |INTEN     |Watchdog Timer Interrupt Enable Control (Write Protect)
     * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
     * |        |          |0 = Watchdog Timer interrupt Disabled.
     * |        |          |1 = Watchdog Timer interrupt Enabled.
     * |[7]     |WDTEN     |Watchdog Timer Enable Control (Write Protect)
     * |        |          |0 = Watchdog Timer Disabled (This action will reset the internal counter).
     * |        |          |1 = Watchdog Timer Enabled.
     * |        |          |Note: If CWDTEN (Config0[31] watchdog enable) bit is set to 0, this bit is forced as 1 and software cannot change this bit to 0.
     * |[8:10]  |TOUTSEL   |Watchdog Timer Time-Out Interval Selection (Write Protect)
     * |        |          |These three bits select the time-out interval period for the Watchdog Timer.
     * |        |          |000 = 2^4 * TWDT.
     * |        |          |001 = 2^6 * TWDT.
     * |        |          |010 = 2^8 * TWDT.
     * |        |          |011 = 2^10 * TWDT.
     * |        |          |100 = 2^12 * TWDT.
     * |        |          |101 = 2^14 * TWDT.
     * |        |          |110 = 2^16 * TWDT.
     * |        |          |111 = 2^18 * TWDT.
     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
     * |        |          |0 = ICE debug mode acknowledgement affects Watchdog Timer counting.
     * |        |          |Watchdog Timer counter will be held while CPU is held by ICE.
     * |        |          |1 = ICE debug mode acknowledgement Disabled.
     * |        |          |Watchdog Timer counter will keep going no matter CPU is held by ICE or not.
    */
    __IO uint32_t CTL;

    /**
     * ALTCTL
     * ===================================================================================================
     * Offset: 0x04  Watchdog Timer Alternative Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:1]   |RSTDSEL   |Watchdog Timer Reset Delay Selection (Write Protect)
     * |        |          |When WDT time-out happened, software has a time named WDT reset delay period to clear WDT counter to prevent WDT time-out reset happened.
     * |        |          |Software can select a suitable value of WDT reset delay period for different WDT time-out period.
     * |        |          |00 = Watchdog Timer reset delay period is (1024+2) * WDT_CLK.
     * |        |          |01 = Watchdog Timer reset delay period is (128+2) * WDT_CLK.
     * |        |          |10 = Watchdog Timer reset delay period is (16+2) * WDT_CLK.
     * |        |          |11 = Watchdog Timer reset delay period is (1+2) * WDT_CLK.
     * |        |          |Note: This register will be reset to 0 if WDT time-out reset happened
    */
    __IO uint32_t ALTCTL;

} WDT_T;

/**
    @addtogroup WDT_CONST WDT Bit Field Definition
    Constant Definitions for WDT Controller
@{ */

#define WDT_CTL_RSTCNT_Pos               (0)                                               /*!< WDT_T::CTL: RSTCNT Position               */
#define WDT_CTL_RSTCNT_Msk               (0x1ul << WDT_CTL_RSTCNT_Pos)                     /*!< WDT_T::CTL: RSTCNT Mask                   */

#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT_T::CTL: RSTEN Position                */
#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT_T::CTL: RSTEN Mask                    */

#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT_T::CTL: RSTF Position                 */
#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT_T::CTL: RSTF Mask                     */

#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT_T::CTL: IF Position                   */
#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT_T::CTL: IF Mask                       */

#define WDT_CTL_WKEN_Pos                 (4)                                               /*!< WDT_T::CTL: WKEN Position                 */
#define WDT_CTL_WKEN_Msk                 (0x1ul << WDT_CTL_WKEN_Pos)                       /*!< WDT_T::CTL: WKEN Mask                     */

#define WDT_CTL_WKF_Pos                  (5)                                               /*!< WDT_T::CTL: WKF Position                  */
#define WDT_CTL_WKF_Msk                  (0x1ul << WDT_CTL_WKF_Pos)                        /*!< WDT_T::CTL: WKF Mask                      */

#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT_T::CTL: INTEN Position                */
#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT_T::CTL: INTEN Mask                    */

#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT_T::CTL: WDTEN Position                */
#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT_T::CTL: WDTEN Mask                    */

#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT_T::CTL: TOUTSEL Position              */
#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT_T::CTL: TOUTSEL Mask                  */

#define WDT_CTL_ICEDEBUG_Pos             (31)                                              /*!< WDT_T::CTL: ICEDEBUG Position             */
#define WDT_CTL_ICEDEBUG_Msk             (0x1ul << WDT_CTL_ICEDEBUG_Pos)                   /*!< WDT_T::CTL: ICEDEBUG Mask                 */

#define WDT_ALTCTL_RSTDSEL_Pos           (0)                                               /*!< WDT_T::ALTCTL: RSTDSEL Position           */
#define WDT_ALTCTL_RSTDSEL_Msk           (0x3ul << WDT_ALTCTL_RSTDSEL_Pos)                 /*!< WDT_T::ALTCTL: RSTDSEL Mask               */

/**@}*/ /* WDT_CONST */
/**@}*/ /* end of WDT register group */


/*---------------------- Window Watchdog Timer -------------------------*/
/**
    @addtogroup WWDT Window Watchdog Timer(WWDT)
    Memory Mapped Structure for WWDT Controller
@{ */

typedef struct {


    /**
     * RLDCNT
     * ===================================================================================================
     * Offset: 0x00  Window Watchdog Timer Reload Counter Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:31]  |RLDCNT    |WWDT Reload Counter Bit
     * |        |          |Writing 0x00005AA5 to this register will reload the Window Watchdog Timer counter value to 0x3F.
     * |        |          |Note: Software can only write RLDCNT to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT.
     * |        |          |If software writes RLDCNT when current WWDT counter value is larger than CMPDAT, WWDT reset signal will generate immediately.
    */
    __O  uint32_t RLDCNT;

    /**
     * CTL
     * ===================================================================================================
     * Offset: 0x04  Window Watchdog Timer Control Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |WWDTEN    |WWDT Enable Control
     * |        |          |Set this bit to enable Window Watchdog Timer counter counting.
     * |        |          |0 = Window Watchdog Timer counter is stopped.
     * |        |          |1 = Window Watchdog Timer counter is starting counting.
     * |[1]     |INTEN     |WWDT Interrupt Enable Control
     * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.
     * |        |          |0 = WWDT counter compare match interrupt Disabled.
     * |        |          |1 = WWDT counter compare match interrupt Enabled.
     * |[8:11]  |PSCSEL    |WWDT Counter Prescale Period Selection
     * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT.
     * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT.
     * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT.
     * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT.
     * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT.
     * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT.
     * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT.
     * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT.
     * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT.
     * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT.
     * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT.
     * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT.
     * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT.
     * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT.
     * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT.
     * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT.
     * |[16:21] |CMPDAT    |WWDT Window Compare Bits
     * |        |          |Set this register to adjust the valid reload window.
     * |        |          |Note: Software can only write RLDCNT to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT.
     * |        |          |If Software writes RLDCNT when current WWDT counter value larger than CMPDAT, WWDT reset signal will generate immediately.
     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control
     * |        |          |0 = ICE debug mode acknowledgement effects WWDT counting.
     * |        |          |WWDT down counter will be held while CPU is held by ICE.
     * |        |          |1 = ICE debug mode acknowledgement Disabled.
     * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
    */
    __IO uint32_t CTL;

    /**
     * STATUS
     * ===================================================================================================
     * Offset: 0x08  Window Watchdog Timer Status Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
     * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches CMPDAT value.
     * |        |          |0 = No effect.
     * |        |          |1 = WWDT counter value matches CMPDAT value.
     * |        |          |Note: This bit is cleared by writing 1 to it.
     * |[1]     |WWDTRF    |WWDT Timer-Out Reset Flag
     * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
     * |        |          |0 = WWDT time-out reset did not occur.
     * |        |          |1 = WWDT time-out reset occurred.
     * |        |          |Note: This bit is cleared by writing 1 to it.
    */
    __IO uint32_t STATUS;

    /**
     * CNT
     * ===================================================================================================
     * Offset: 0x0C  Window Watchdog Timer Counter Value Register
     * ---------------------------------------------------------------------------------------------------
     * |Bits    |Field     |Descriptions
     * | :----: | :----:   | :---- |
     * |[0:5]   |CNTDAT    |WWDT Counter Value
     * |        |          |This register reflects the current WWDT counter value and is read only.
    */
    __I  uint32_t CNT;

} WWDT_T;

/**
    @addtogroup WWDT_CONST WWDT Bit Field Definition
    Constant Definitions for WWDT Controller
@{ */

#define WWDT_RLDCNT_RLDCNT_Pos           (0)                                               /*!< WWDT_T::RLDCNT: RLDCNT Position           */
#define WWDT_RLDCNT_RLDCNT_Msk           (0xfffffffful << WWDT_RLDCNT_RLDCNT_Pos)          /*!< WWDT_T::RLDCNT: RLDCNT Mask               */

#define WWDT_CTL_WWDTEN_Pos              (0)                                               /*!< WWDT_T::CTL: WWDTEN Position              */
#define WWDT_CTL_WWDTEN_Msk              (0x1ul << WWDT_CTL_WWDTEN_Pos)                    /*!< WWDT_T::CTL: WWDTEN Mask                  */

#define WWDT_CTL_INTEN_Pos               (1)                                               /*!< WWDT_T::CTL: INTEN Position               */
#define WWDT_CTL_INTEN_Msk               (0x1ul << WWDT_CTL_INTEN_Pos)                     /*!< WWDT_T::CTL: INTEN Mask                   */

#define WWDT_CTL_PSCSEL_Pos              (8)                                               /*!< WWDT_T::CTL: PSCSEL Position              */
#define WWDT_CTL_PSCSEL_Msk              (0xful << WWDT_CTL_PSCSEL_Pos)                    /*!< WWDT_T::CTL: PSCSEL Mask                  */

#define WWDT_CTL_CMPDAT_Pos              (16)                                              /*!< WWDT_T::CTL: CMPDAT Position              */
#define WWDT_CTL_CMPDAT_Msk              (0x3ful << WWDT_CTL_CMPDAT_Pos)                   /*!< WWDT_T::CTL: CMPDAT Mask                  */

#define WWDT_CTL_ICEDEBUG_Pos            (31)                                              /*!< WWDT_T::CTL: ICEDEBUG Position            */
#define WWDT_CTL_ICEDEBUG_Msk            (0x1ul << WWDT_CTL_ICEDEBUG_Pos)                  /*!< WWDT_T::CTL: ICEDEBUG Mask                */

#define WWDT_STATUS_WWDTIF_Pos           (0)                                               /*!< WWDT_T::STATUS: WWDTIF Position           */
#define WWDT_STATUS_WWDTIF_Msk           (0x1ul << WWDT_STATUS_WWDTIF_Pos)                 /*!< WWDT_T::STATUS: WWDTIF Mask               */

#define WWDT_STATUS_WWDTRF_Pos           (1)                                               /*!< WWDT_T::STATUS: WWDTRF Position           */
#define WWDT_STATUS_WWDTRF_Msk           (0x1ul << WWDT_STATUS_WWDTRF_Pos)                 /*!< WWDT_T::STATUS: WWDTRF Mask               */

#define WWDT_CNT_CNTDAT_Pos              (0)                                               /*!< WWDT_T::CNT: CNTDAT Position              */
#define WWDT_CNT_CNTDAT_Msk              (0x3ful << WWDT_CNT_CNTDAT_Pos)                   /*!< WWDT_T::CNT: CNTDAT Mask                  */

/**@}*/ /* WWDT_CONST */
/**@}*/ /* end of WWDT register group */

#if defined ( __CC_ARM   )
#pragma no_anon_unions
#endif


/*@}*/ /* end of group NUC472_442_Peripherals */

/** @addtogroup NUC472_442_PERIPHERAL_MEM_MAP NUC472/NUC442 Peripheral Memory Base
  Memory Mapped Structure for NUC472/NUC442 Peripheral
  @{
 */
/* Peripheral and SRAM base address */
#define FLASH_BASE           ((uint32_t)0x00000000)      /*!< Flash base address      */
#define SRAM_BASE            ((uint32_t)0x20000000)      /*!< SRAM Base Address       */
#define PERIPH_BASE          ((uint32_t)0x40000000)      /*!< Peripheral Base Address */
#define AHBPERIPH_BASE       PERIPH_BASE                 /*!< AHB Base Address */
#define APBPERIPH_BASE       (PERIPH_BASE + 0x00040000)  /*!< APB Base Address */

/*!< AHB peripherals */
#define SYS_BASE               (AHBPERIPH_BASE + 0x00000)
#define CLK_BASE               (AHBPERIPH_BASE + 0x00200)
#define GPIOA_BASE             (AHBPERIPH_BASE + 0x04000)
#define GPIOB_BASE             (AHBPERIPH_BASE + 0x04040)
#define GPIOC_BASE             (AHBPERIPH_BASE + 0x04080)
#define GPIOD_BASE             (AHBPERIPH_BASE + 0x040C0)
#define GPIOE_BASE             (AHBPERIPH_BASE + 0x04100)
#define GPIOF_BASE             (AHBPERIPH_BASE + 0x04140)
#define GPIOG_BASE             (AHBPERIPH_BASE + 0x04180)
#define GPIOH_BASE             (AHBPERIPH_BASE + 0x041C0)
#define GPIOI_BASE             (AHBPERIPH_BASE + 0x04200)
#define GPIO_DBCTL_BASE        (AHBPERIPH_BASE + 0x04440)
#define GPIO_PIN_DATA_BASE     (AHBPERIPH_BASE + 0x04800)
#define PDMA_BASE              (AHBPERIPH_BASE + 0x08000)
#define USBH_BASE              (AHBPERIPH_BASE + 0x09000)
#define EMAC_BASE              (AHBPERIPH_BASE + 0x0B000)
#define FMC_BASE               (AHBPERIPH_BASE + 0x0C000)
#define SD_BASE                (AHBPERIPH_BASE + 0x0D000)
#define EBI_BASE               (AHBPERIPH_BASE + 0x10000)
#define UDC20_BASE             (AHBPERIPH_BASE + 0x19000)
#define CAP_BASE               (AHBPERIPH_BASE + 0x30000)
#define CRC_BASE               (AHBPERIPH_BASE + 0x31000)

/*!< APB2 peripherals */
#define WDT_BASE              (APBPERIPH_BASE + 0x00000)
#define WWDT_BASE             (APBPERIPH_BASE + 0x00100)
#define OPA_BASE              (APBPERIPH_BASE + 0x06000)
#define I2S0_BASE             (APBPERIPH_BASE + 0x08000)
#define TIMER0_BASE           (APBPERIPH_BASE + 0x10000)
#define TIMER1_BASE           (APBPERIPH_BASE + 0x10020)
#define PWM0_BASE             (APBPERIPH_BASE + 0x18000)
#define EPWM0_BASE            (APBPERIPH_BASE + 0x1C000)
#define SPI0_BASE             (APBPERIPH_BASE + 0x20000)
#define SPI2_BASE             (APBPERIPH_BASE + 0x22000)
#define UART0_BASE            (APBPERIPH_BASE + 0x30000)
#define UART2_BASE            (APBPERIPH_BASE + 0x32000)
#define UART4_BASE            (APBPERIPH_BASE + 0x34000)
#define I2C0_BASE             (APBPERIPH_BASE + 0x40000)
#define I2C2_BASE             (APBPERIPH_BASE + 0x42000)
#define I2C4_BASE             (APBPERIPH_BASE + 0x44000)
#define SC0_BASE              (APBPERIPH_BASE + 0x50000)
#define SC2_BASE              (APBPERIPH_BASE + 0x52000)
#define SC4_BASE              (APBPERIPH_BASE + 0x54000)
#define CAN0_BASE             (APBPERIPH_BASE + 0x60000)
#define QEI0_BASE             (APBPERIPH_BASE + 0x70000)
#define ECAP0_BASE            (APBPERIPH_BASE + 0x74000)
#define PS2D_BASE             (APBPERIPH_BASE + 0xA0000)

/*!< APB1 peripherals */
#define RTC_BASE              (APBPERIPH_BASE + 0x01000)
#define ADC_BASE              (APBPERIPH_BASE + 0x03000)
#define EADC_BASE             (APBPERIPH_BASE + 0x04000)
#define ACMP_BASE             (APBPERIPH_BASE + 0x05000)
#define I2S1_BASE             (APBPERIPH_BASE + 0x09000)
#define OTG_BASE              (APBPERIPH_BASE + 0x0D000)
#define TIMER2_BASE           (APBPERIPH_BASE + 0x11000)
#define TIMER3_BASE           (APBPERIPH_BASE + 0x11020)
#define PWM1_BASE             (APBPERIPH_BASE + 0x19000)
#define EPWM1_BASE            (APBPERIPH_BASE + 0x1D000)
#define SPI1_BASE             (APBPERIPH_BASE + 0x21000)
#define SPI3_BASE             (APBPERIPH_BASE + 0x23000)
#define UART1_BASE            (APBPERIPH_BASE + 0x31000)
#define UART3_BASE            (APBPERIPH_BASE + 0x33000)
#define UART5_BASE            (APBPERIPH_BASE + 0x35000)
#define I2C1_BASE             (APBPERIPH_BASE + 0x41000)
#define I2C3_BASE             (APBPERIPH_BASE + 0x43000)
#define SC1_BASE              (APBPERIPH_BASE + 0x51000)
#define SC3_BASE              (APBPERIPH_BASE + 0x53000)
#define SC5_BASE              (APBPERIPH_BASE + 0x55000)
#define CAN1_BASE             (APBPERIPH_BASE + 0x61000)
#define QEI1_BASE             (APBPERIPH_BASE + 0x71000)
#define ECAP1_BASE            (APBPERIPH_BASE + 0x75000)
#define CRPT_BASE             (0x50080000UL)

/*@}*/ /* end of group NUC472_442_PERIPHERAL_MEM_MAP */


/** @addtogroup NUC472_442_PERIPHERAL_DECLARATION NUC472/NUC442 Peripheral Pointer
  The Declaration of NUC472/NUC442 Peripheral
  @{
 */

#define SYS                  ((SYS_T *)   SYS_BASE)
#define CLK                  ((CLK_T *)   CLK_BASE)
#define PA                   ((GPIO_T *)  GPIOA_BASE)
#define PB                   ((GPIO_T *)  GPIOB_BASE)
#define PC                   ((GPIO_T *)  GPIOC_BASE)
#define PD                   ((GPIO_T *)  GPIOD_BASE)
#define PE                   ((GPIO_T *)  GPIOE_BASE)
#define PF                   ((GPIO_T *)  GPIOF_BASE)
#define PG                   ((GPIO_T *)  GPIOG_BASE)
#define PH                   ((GPIO_T *)  GPIOH_BASE)
#define GPA                  ((GPIO_T *)  GPIOA_BASE)
#define GPB                  ((GPIO_T *)  GPIOB_BASE)
#define GPC                  ((GPIO_T *)  GPIOC_BASE)
#define GPD                  ((GPIO_T *)  GPIOD_BASE)
#define GPE                  ((GPIO_T *)  GPIOE_BASE)
#define GPF                  ((GPIO_T *)  GPIOF_BASE)
#define GPG                  ((GPIO_T *)  GPIOG_BASE)
#define GPH                  ((GPIO_T *)  GPIOH_BASE)
#define GPI                  ((GPIO_T *)  GPIOI_BASE)
#define GPIO                 ((GPIO_DB_T *) GPIO_DBCTL_BASE)
#define PDMA                 ((PDMA_T *)  PDMA_BASE)
#define USBH                 ((USBH_T *)  USBH_BASE)
#define EMAC                 ((EMAC_T *)  EMAC_BASE)
#define FMC                  ((FMC_T *)   FMC_BASE)
#define SD                   ((SDH_T *)    SD_BASE)
#define EBI                  ((EBI_T *)   EBI_BASE)
#define ICAP                  ((CAP_T *)   CAP_BASE)
#define CRC                  ((CRC_T *)   CRC_BASE)

#define WDT                  ((WDT_T *)   WDT_BASE)
#define WWDT                 ((WWDT_T *)  WWDT_BASE)
#define RTC                  ((RTC_T *)   RTC_BASE)
#define ADC                  ((ADC_T *)   ADC_BASE)
#define EADC                  ((EADC_T *) EADC_BASE)
#define ACMP                 ((ACMP_T *)  ACMP_BASE)

#define I2S0                 ((I2S_T *)   I2S0_BASE)
#define I2S1                 ((I2S_T *)   I2S1_BASE)
#define USBD                 ((USBD_T *)  UDC20_BASE)
#define OTG                  ((OTG_T *)   OTG_BASE)
#define TIMER0               ((TIMER_T *) TIMER0_BASE)
#define TIMER1               ((TIMER_T *) TIMER1_BASE)
#define TIMER2               ((TIMER_T *) TIMER2_BASE)
#define TIMER3               ((TIMER_T *) TIMER3_BASE)
#define PWM0                 ((PWM_T *)   PWM0_BASE)
#define PWM1                 ((PWM_T *)   PWM1_BASE)
#define EPWM0                ((EPWM_T *)  EPWM0_BASE)
#define EPWM1                ((EPWM_T *)  EPWM1_BASE)
#define ECAP0                ((ECAP_T *)  ECAP0_BASE)
#define ECAP1                ((ECAP_T *)  ECAP1_BASE)
#define QEI0                 ((QEI_T *)   QEI0_BASE)
#define QEI1                 ((QEI_T *)   QEI1_BASE)
#define SPI0                 ((SPI_T *)   SPI0_BASE)
#define SPI1                 ((SPI_T *)   SPI1_BASE)
#define SPI2                 ((SPI_T *)   SPI2_BASE)
#define SPI3                 ((SPI_T *)   SPI3_BASE)
#define UART0                ((UART_T *)  UART0_BASE)
#define UART1                ((UART_T *)  UART1_BASE)
#define UART2                ((UART_T *)  UART2_BASE)
#define UART3                ((UART_T *)  UART3_BASE)
#define UART4                ((UART_T *)  UART4_BASE)
#define UART5                ((UART_T *)  UART5_BASE)
#define I2C0                 ((I2C_T *)   I2C0_BASE)
#define I2C1                 ((I2C_T *)   I2C1_BASE)
#define I2C2                 ((I2C_T *)   I2C2_BASE)
#define I2C3                 ((I2C_T *)   I2C3_BASE)
#define I2C4                 ((I2C_T *)   I2C4_BASE)
#define SC0                  ((SC_T *)    SC0_BASE)
#define SC1                  ((SC_T *)    SC1_BASE)
#define SC2                  ((SC_T *)    SC2_BASE)
#define SC3                  ((SC_T *)    SC3_BASE)
#define SC4                  ((SC_T *)    SC4_BASE)
#define SC5                  ((SC_T *)    SC5_BASE)
#define CAN0                 ((CAN_T *)   CAN0_BASE)
#define CAN1                 ((CAN_T *)   CAN1_BASE)
#define PS2                  ((PS2_T *)  PS2D_BASE)
#define CRPT                 ((CRPT_T *)  CRPT_BASE)
/*@}*/ /* end of group NUC472_442_PERIPHERAL_DECLARATION */

/** @addtogroup NUC472_442_IO_ROUTINE NUC472/NUC442 I/O Routines
  The Declaration of NUC472/NUC442 I/O Routines
  @{
 */

typedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
typedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
typedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type

/**
  * @brief Get a 8-bit unsigned value from specified address
  * @param[in] addr Address to get 8-bit data from
  * @return  8-bit unsigned value stored in specified address
  */
#define M8(addr)  (*((vu8  *) (addr)))

/**
  * @brief Get a 16-bit unsigned value from specified address
  * @param[in] addr Address to get 16-bit data from
  * @return  16-bit unsigned value stored in specified address
  * @note The input address must be 16-bit aligned
  */
#define M16(addr) (*((vu16 *) (addr)))

/**
  * @brief Get a 32-bit unsigned value from specified address
  * @param[in] addr Address to get 32-bit data from
  * @return  32-bit unsigned value stored in specified address
  * @note The input address must be 32-bit aligned
  */
#define M32(addr) (*((vu32 *) (addr)))

/**
  * @brief Set a 32-bit unsigned value to specified I/O port
  * @param[in] port Port address to set 32-bit data
  * @param[in] value Value to write to I/O port
  * @return  None
  * @note The output port must be 32-bit aligned
  */
#define outpw(port,value)     *((volatile unsigned int *)(port)) = value

/**
  * @brief Get a 32-bit unsigned value from specified I/O port
  * @param[in] port Port address to get 32-bit data from
  * @return  32-bit unsigned value stored in specified I/O port
  * @note The input port must be 32-bit aligned
  */
#define inpw(port)            (*((volatile unsigned int *)(port)))

/**
  * @brief Set a 16-bit unsigned value to specified I/O port
  * @param[in] port Port address to set 16-bit data
  * @param[in] value Value to write to I/O port
  * @return  None
  * @note The output port must be 16-bit aligned
  */
#define outps(port,value)     *((volatile unsigned short *)(port)) = value

/**
  * @brief Get a 16-bit unsigned value from specified I/O port
  * @param[in] port Port address to get 16-bit data from
  * @return  16-bit unsigned value stored in specified I/O port
  * @note The input port must be 16-bit aligned
  */
#define inps(port)            (*((volatile unsigned short *)(port)))

/**
  * @brief Set a 8-bit unsigned value to specified I/O port
  * @param[in] port Port address to set 8-bit data
  * @param[in] value Value to write to I/O port
  * @return  None
  */
#define outpb(port,value)     *((volatile unsigned char *)(port)) = value

/**
  * @brief Get a 8-bit unsigned value from specified I/O port
  * @param[in] port Port address to get 8-bit data from
  * @return  8-bit unsigned value stored in specified I/O port
  */
#define inpb(port)            (*((volatile unsigned char *)(port)))

/**
  * @brief Set a 32-bit unsigned value to specified I/O port
  * @param[in] port Port address to set 32-bit data
  * @param[in] value Value to write to I/O port
  * @return  None
  * @note The output port must be 32-bit aligned
  */
#define outp32(port,value)    *((volatile unsigned int *)(port)) = value

/**
  * @brief Get a 32-bit unsigned value from specified I/O port
  * @param[in] port Port address to get 32-bit data from
  * @return  32-bit unsigned value stored in specified I/O port
  * @note The input port must be 32-bit aligned
  */
#define inp32(port)           (*((volatile unsigned int *)(port)))

/**
  * @brief Set a 16-bit unsigned value to specified I/O port
  * @param[in] port Port address to set 16-bit data
  * @param[in] value Value to write to I/O port
  * @return  None
  * @note The output port must be 16-bit aligned
  */
#define outp16(port,value)    *((volatile unsigned short *)(port)) = value

/**
  * @brief Get a 16-bit unsigned value from specified I/O port
  * @param[in] port Port address to get 16-bit data from
  * @return  16-bit unsigned value stored in specified I/O port
  * @note The input port must be 16-bit aligned
  */
#define inp16(port)           (*((volatile unsigned short *)(port)))

/**
  * @brief Set a 8-bit unsigned value to specified I/O port
  * @param[in] port Port address to set 8-bit data
  * @param[in] value Value to write to I/O port
  * @return  None
  */
#define outp8(port,value)     *((volatile unsigned char *)(port)) = value

/**
  * @brief Get a 8-bit unsigned value from specified I/O port
  * @param[in] port Port address to get 8-bit data from
  * @return  8-bit unsigned value stored in specified I/O port
  */
#define inp8(port)            (*((volatile unsigned char *)(port)))


/*@}*/ /* end of group NUC472_442_IO_ROUTINE */

/******************************************************************************/
/*                Legacy Constants                                            */
/******************************************************************************/
/** @addtogroup NUC472_442_legacy_Constants NUC472/NUC442 Legacy Constants
  NUC472/NUC442 Legacy Constants
  @{
*/

#ifndef NULL
#define NULL           (0)      ///< NULL pointer
#endif

#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value

#define ENABLE         (1)      ///< Enable, define to use in API parameters
#define DISABLE        (0)      ///< Disable, define to use in API parameters

/* Define one bit mask */
#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer

/* Byte Mask Definitions */
#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer

#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */

/*@}*/ /* end of group NUC472_442_legacy_Constants */


/******************************************************************************/
/*                         Peripheral header files                            */
/******************************************************************************/
#include "sys.h"
#include "clk.h"

#include "acmp.h"
#include "adc.h"
#include "eadc.h"
#include "cap.h"
#include "crypto.h"
#include "pdma.h"
#include "ebi.h"
#include "emac.h"
#include "fmc.h"
#include "gpio.h"
#include "i2c.h"
#include "pwm.h"
#include "epwm.h"
#include "rtc.h"
#include "sc.h"
#include "scuart.h"
#include "spi.h"
#include "timer.h"
#include "uart.h"
#include "usbd.h"
#include "wdt.h"
#include "wwdt.h"
#include "i2s.h"
#include "can.h"
#include "sd.h"
#include "ps2.h"
#include "crc.h"

#ifdef __cplusplus
}
#endif

#endif  /* __NUC472_442_H__ */

/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/

