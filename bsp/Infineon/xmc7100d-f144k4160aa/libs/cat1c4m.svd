<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Infineon Technologies</vendor>
  <vendorID>Infineon</vendorID>
  <name>cat1c4m</name>
  <series>XMC7100</series>
  <version>1.0</version>
  <description>XMC7100</description>
  <licenseText>(c) (2016-2024), Cypress Semiconductor Corporation (an Infineon company)\n
    or an affiliate of Cypress Semiconductor Corporation.\n
\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM7</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral interconnect</description>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TIMEOUT_CTL</name>
          <description>Timeout control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <description>This field specifies a number of clock cycles (clk_slow). If an AHB-Lite bus transfer takes more than the specified number of cycles (timeout detection), the bus transfer is terminated with an AHB-Lite bus error and a fault is generated (and possibly recorded in the fault report structure(s)).
'0x0000'-'0xfffe': Number of clock cycles.
'0xffff': This value is the default/reset value and specifies that no timeout detection is performed: a bus transfer will never be terminated and a fault will never be generated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>Trigger command</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0001FFF</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when ACTIVATE is '1'. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GROUP_SEL</name>
              <description>Specifies the trigger group:
'0'-'15': trigger multiplexer groups.
'16'-'31': trigger 1-to-1 groups.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_EDGE</name>
              <description>Specifies if the activated  trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive. The trigger reflects TR_CMD.ACTIVATE.
'1': edge sensitive trigger. The trigger is activated for two clk_peri cycles.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.

Note: this field is not used for trigger 1-to-1 groups.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVATE</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL, TR_EDGE and OUT_SEL. HW sets this field to '0' for edge sensitive triggers AFTER the selected trigger is activated for two clk_peri cycles.

Note: when ACTIVATE is '1', SW should not modify the other register fields.
SW MUST NOT set ACTIVATE bit to '1' while updating the other register bits simultaneously. At first the SW MUST update the other register bits as needed, and then set ACTIVATE to '1' with a new register write.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000</resetValue>
          <resetMask>0xFF0507FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where the parity is injected.
- On a 32-bit write access to this SRAM address and when ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC:
'0': Disabled (on write ECC parity bits will not be correctly written).
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for PERI protection structure SRAM.
When '1', the parity (PARITY) is used when a write is done to the WORD_ADDR word address of the SRAM.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>10</dim>
          <dimIncrement>64</dimIncrement>
          <name>GR[%s]</name>
          <description>Peripheral group structure</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CLOCK_CTL</name>
            <description>Clock control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF00</resetMask>
            <fields>
              <field>
                <name>INT8_DIV</name>
                <description>Specifies a group clock divider (from the peripheral clock 'clk_peri' to the group clock 'clk_group[3/4/5/...15]'). Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. 
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL</name>
            <description>Slave control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLED_0</name>
                <description>Peripheral group, slave 0 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_1</name>
                <description>Peripheral group, slave 1 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect, master interface MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_2</name>
                <description>Peripheral group, slave 2 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect, PCLK group  MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_3</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_4</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_7</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_8</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_9</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_10</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_11</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_12</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_13</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_14</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_15</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>13</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_GR[%s]</name>
          <description>Trigger group</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x13FF</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>11</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_1TO1_GR[%s]</name>
          <description>Trigger 1-to-1 group</description>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1301</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger:
'0'': constant signal level '0'.
'1': input trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PERI_MS</name>
      <description>Peripheral interconnect, master interface</description>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_PR[%s]</name>
          <description>Programmable protection structure pair</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>579</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_FX[%s]</name>
          <description>Fixed protection structure pair</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFC</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PERI_PCLK</name>
      <description>Peripheral PCLK groups</description>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>8192</dimIncrement>
          <name>GR[%s]</name>
          <description>PERI clock domains</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DIV_CMD</name>
            <description>Divider command</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF03FF</resetValue>
            <resetMask>0xC3FF03FF</resetMask>
            <fields>
              <field>
                <name>DIV_SEL</name>
                <description>(TYPE_SEL, DIV_SEL) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TYPE_SEL</name>
                <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PA_DIV_SEL</name>
                <description>(PA_TYPE_SEL, PA_DIV_SEL) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_DIV_SEL is '255' and PA_TYPE_SEL is '3', 'clk_pclk_root[i]' is used as reference.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PA_TYPE_SEL</name>
                <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE</name>
                <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_pclk_root[i]' (typical usage) or to ANY enabled divider.
 
The PA_DIV_SEL and PA_TYPE_SEL fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_pclk_root[i]'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_pclk_root[i]' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>CLOCK_CTL[%s]</name>
            <description>Clock control</description>
            <addressOffset>0xC00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>DIV_SEL</name>
                <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_pclk_root[i]' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '255' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TYPE_SEL</name>
                <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_8_CTL[%s]</name>
            <description>Divider control (for 8.0 divider)</description>
            <addressOffset>0x1000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF01</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INT8_DIV</name>
                <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_16_CTL[%s]</name>
            <description>Divider control (for 16.0 divider)</description>
            <addressOffset>0x1400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF01</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INT16_DIV</name>
                <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[23:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_16_5_CTL[%s]</name>
            <description>Divider control (for 16.5 divider)</description>
            <addressOffset>0x1800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF9</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FRAC5_DIV</name>
                <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_pclk_root[i]' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT16_DIV</name>
                <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[23:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>255</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_24_5_CTL[%s]</name>
            <description>Divider control (for 24.5 divider)</description>
            <addressOffset>0x1C00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFF9</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FRAC5_DIV</name>
                <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_pclk_root[i]' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT24_DIV</name>
                <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRYPTO</name>
      <description>Cryptography component</description>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10002</resetValue>
          <resetMask>0x800300F3</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the P field for the user/privileged access control ('hprot[1]').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NS</name>
              <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the NS field for the secure/non-secure access control ('hprot[4]').</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PC</name>
              <description>Protection context.

This field is set with the protection context of the transaction that writes this register; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the PC field for the protection context. There is one exception: the LOAD_DEV_KEY instruction IP master transactions are always performed with protection context '0'.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers, instruct FIFO, internal component state machines) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled. When the  IP is enabled, the IP register buffer is set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_CTL</name>
          <description>SRAM power control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Set power mode for memory buffer SRAM.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_DELAY_CTL</name>
          <description>SRAM power delay control</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x96</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE001FFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where the parity is injected.
- On a 32-bit write access to this SRAM address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERROR_STATUS0</name>
          <description>Error status 0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Specifies error description information.
- For INSTR_OPC_ERROR/ INSTR_CC_ERROR/ INSTR_DEV_KEY_ERROR:
  - Violating instruction (from instruction FIFO).
- For BUS_ERROR:
  - Violating transfer, address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERROR_STATUS1</name>
          <description>Error status 1</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>DATA24</name>
              <description>Specifies error description information.
- For BUS_ERROR:
  - Violating transfer, read attribute (DATA[0]).
  - Violating transfer, size attribute (DATA[5:4]). '0': 8-bit transfer, '1': 16 bits transfer, '2': 32-bit transfer.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDX</name>
              <description>Error source:
'0': INSTR_OPC_ERROR (instruction FIFO decoder error).
'1': INSTR_CC_ERROR (instruction FIFO decoder, VU CC error).
'2': BUS_ERROR (bus master interface AHB-Lite bus error).
'3': TR_AP_DETECT_ERROR.
'4': TR_RC_DETECT_ERROR.
'5': INSTR_DEV_KEY_ERROR.
'6'-'7': Undefined.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Specifies if ERROR_STATUS0 and ERROR_STATUS1 specify valid error information. No new error information is captured as long as VALID is '1'; i.e. the error information of the first detected error is NOT overwritten.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction FIFO event is activated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction FIFO overflows (an attempt is made to write to a full FIFO).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator is initialized.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator has generated a data value of the specified bit size.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the pseudo random number generator has generated a data value.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction decoder encounters an instruction with a non-defined operation code (opcode). 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction decoder encounters an instruction with a non-defined condition code. This error is only generated for VU instructions. 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when a AHB-Lite bus error is observed on the AHB-Lite master interface. 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator monitor adaptive proportion test detects a repetition of a specific bit value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator monitor adaptive proportion test detects a disproportionate occurrence of a specific bit value.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the LOAD_DEV_KEY instruction tries to load a device key whose DEV_KEY_ADDR_CTL.VALID or DEV_KEY_CTL.ALLOWED is set to '0'.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL0</name>
          <description>Pseudo random LFSR control 0</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xD8959BC9</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. This register needs to be initialized by SW. The initialization value should be different from '0'.

The three PR_LFSR_CTL registers represents the state of a 32-bit, 31-bit and 29-bit LFSR. Individually, these LFSRs generate a pseudo random bit sequence that repeats itself after (2^32)-1, (2^31)-1 and (2^29)-1 bits. The numbers (2^32)-1, (2^31)-1 and (2^29)-1 are relatively prime (their greatest common denominator is '1'). The three bit sequence are combined (XOR'd) into a single bitstream to create a pseudo random bit sequence that repeats itself after ((2^32)-1) * ((2^31)-1) * ((2*29)-1) bits.

The following polynomials are used:
- 32-bit irreducible polynomial: x^32+x^30+x^26+x^25+1.
- 31-bit irreducible polynomial: x^31+x^28+1.
- 29-bit irreducible polynomial: x^29+x^27+1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL1</name>
          <description>Pseudo random LFSR control 1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2BB911F8</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR31</name>
              <description>State of a 31-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. See PR_LFSR_CTL0.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL2</name>
          <description>Pseudo random LFSR control 2</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x60C31B7</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR29</name>
              <description>State of a 29-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. See PR_LFSR_CTL0.</description>
              <bitRange>[28:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_MAX_CTL</name>
          <description>Pseudo random maximum control</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Maximum value of to be generated random number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_CMD</name>
          <description>Pseudo random command</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>Pseudo random command. On a generated number, HW sets this field to '0' and sets INTR.PR_DATA_AVAILABLE to '1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_RESULT</name>
          <description>Pseudo random result</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Result of a pseudo random number generation operation. The resulting value DATA is in the range [0, PR_MAX_CTL.DATA32]. The PR_DATA_AVAILABLE interrupt cause is activated when the number is generated.

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL0</name>
          <description>True random control 0</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30000</resetValue>
          <resetMask>0x31FFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_CLOCK_DIV</name>
              <description>Specifies the clock divider that is used to sample oscillator data. This clock divider is wrt. 'clk_sys'.
'0': sample clock is 'clk_sys'.
'1': sample clock is 'clk_sys'/2.
...
'255': sample clock is 'clk_sys'/256.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RED_CLOCK_DIV</name>
              <description>Specifies the clock divider that is used to produce reduced bits. 
'0': 1 reduced bit is produced for each sample.
'1': 1 reduced bit is produced for each 2 samples.
...
'255': 1 reduced bit is produced for each 256 samples.

The reduced bits are considered random bits and shifted into TR_RESULT0.DATA32.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_DELAY</name>
              <description>Specifies an initialization delay: number of removed/dropped samples before reduced bits are generated. This field should be programmed in the range [1, 255]. After starting the oscillators, at least the first 2 samples should be removed/dropped to clear the state of internal synchronizers. In addition, it is advised to drop at least the second 2 samples from the oscillators (to circumvent the semi-predictable oscillator startup behavior). This result in the default field value of '3'. Field encoding is as follows:
'0': 1 sample is dropped.
'1': 2 samples are dropped.
...
'255': 256 samples are dropped.

The TR_INITIALIZED interrupt cause is set to '1', when the initialization delay is passed.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VON_NEUMANN_CORR</name>
              <description>Specifies if the 'von Neumann corrector' is disabled or enabled:
'0': disabled.
'1': enabled.
The 'von Neumann corrector' post-processes the reduced bits to remove a '0' or '1' bias. The corrector operates on reduced bit pairs ('oldest bit, newest bit'):
'00': no bit is produced.
'01': '0' bit is produced (oldest bit).
'10': '1' bit is produced (oldest bit).
'11': no bit is produced.
Note that the corrector produces bits at a random pace and at a frequency that is 1/4 of the reduced bit frequency (reduced bits are processed in pairs, and half of the pairs do NOT produce a bit).</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_AP_DETECT</name>
              <description>Specifies if TRNG functionality is stopped on an adaptive proportion test detection (when HW sets INTR.TR_AP_DETECT to '1'):
'0': Functionality is NOT stopped.
'1': Functionality is stopped (TR_CTL1 fields are set to '0' by HW).</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_RC_DETECT</name>
              <description>Specifies if TRNG functionality is stopped on a repetition count test detection (when HW sets INTR.TR_RC_DETECT to '1'):
'0': Functionality is NOT stopped.
'1': Functionality is stopped (TR_CTL1 fields are set to '0' by HW).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL1</name>
          <description>True random control 1</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>RO11_EN</name>
              <description>FW sets this field to '1' to enable the ring oscillator with 11 inverters.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RO15_EN</name>
              <description>FW sets this field to '1' to enable the ring oscillator with 15 inverters.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GARO15_EN</name>
              <description>FW sets this field to '1' to enable the fixed Galois ring oscillator with 15 inverters.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GARO31_EN</name>
              <description>FW sets this field to '1' to enable the programmable Galois ring oscillator with up to 31 inverters. The TR_GARO_CTL register specifies the programmable polynomial.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRO15_EN</name>
              <description>FW sets this field to '1' to enable the fixed Fibonacci ring oscillator with 15 inverters.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRO31_EN</name>
              <description>FW sets this field to '1' to enable the programmable Fibonacci ring oscillator with up to 31 inverters. The TR_FIRO_CTL register specifies the programmable polynomial.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL2</name>
          <description>True random control 2</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>SIZE</name>
              <description>Bit size of generated random number in TR_RESULT. Legal range is in [0, 32].</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_STATUS</name>
          <description>True random status</description>
          <addressOffset>0x28C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INITIALIZED</name>
              <description>Reflects the state of the true random number generator:
'0': Not initialized (TR_CTL0.INIT_DELAY has NOT passed).
'1': Initialized (TR_CTL0.INIT_DELAY has passed).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>True random command</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>True random command. On completion of the command, HW sets this field to '0' and sets INTR.TR_DATA_AVAILABLE to '1 when:
- A random number is generated in TR_RESULT.
- All ring oscillators are off (per TR_CTL1).
- A repetition count (RC) or adaptive proportion (AP) error is detected during the random number generation (INTR.TR_RC/AP_DETECT_ERROR). 

Note: On completion of the command, SW should check TR_CTL1 and INTR.TR_RC/AP_DETECT_ERROR to ensure that no unexpected error occurred during random number generation.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_RESULT</name>
          <description>True random result</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Generated true random number. HW generates the number in the least significant bit positions (TR_CTL2.SIZE) of this field. The TR_DATA_AVAILABLE interrupt cause is activated when the number is generated.

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_GARO_CTL</name>
          <description>True random GARO control</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL31</name>
              <description>Polynomial for programmable Galois ring oscillator. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned such that the more significant bits (bit 30 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_FIRO_CTL</name>
          <description>True random FIRO control</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL31</name>
              <description>Polynomial for programmable Fibonacci ring oscillator. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned such that the more significant bits (bit 30 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_CTL</name>
          <description>True random monitor control</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>BITSTREAM_SEL</name>
              <description>Selection of the bitstream:
'0': DAS bitstream.
'1': RED bitstream.
'2': TR bitstream.
'3': Undefined.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_CMD</name>
          <description>True random monitor command</description>
          <addressOffset>0x2C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>START_AP</name>
              <description>Adaptive proportion (AP) test enable:
'0': Stopped.
'1': Started.

On a AP detection, HW sets this field to '0' and sets INTR.TR_AP_DETECT to '1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START_RC</name>
              <description>Repetition count (RC) test enable:
'0': Disabled.
'1': Enabled.

On a RC detection, HW sets this field to '0' and sets INTR.TR_RC_DETECT to '1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_CTL</name>
          <description>True random monitor RC control</description>
          <addressOffset>0x2D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CUTOFF_COUNT8</name>
              <description>Cutoff count (legal range is [1, 255]):
'0': Illegal.
'1': 1 repetition.
...
'255': 255 repetitions.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_STATUS0</name>
          <description>True random monitor RC status 0</description>
          <addressOffset>0x2D8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BIT</name>
              <description>Current active bit value:
'0': '0'.
'1': '1'.

This field is only valid when TR_MON_RC_STATUS1.REP_COUNT is NOT equal to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_STATUS1</name>
          <description>True random monitor RC status 1</description>
          <addressOffset>0x2DC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>REP_COUNT</name>
              <description>Number of repetitions of the current active bit counter:
'0': 0 repetitions.
...
'255': 255 repetitions.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_CTL</name>
          <description>True random monitor AP control</description>
          <addressOffset>0x2E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CUTOFF_COUNT16</name>
              <description>Cutoff count (legal range is [1, 65535]).
'0': Illegal.
'1': 1 occurrence.
...
'65535': 65535 occurrences.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WINDOW_SIZE</name>
              <description>Window size (minus 1) :
'0': 1 bit.
...
'65535': 65536 bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_STATUS0</name>
          <description>True random monitor AP status 0</description>
          <addressOffset>0x2E8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BIT</name>
              <description>Current active bit value:
'0': '0'.
'1': '1'.

This field is only valid when TR_MON_AP_STATUS1.OCC_COUNT is NOT equal to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_STATUS1</name>
          <description>True random monitor AP status 1</description>
          <addressOffset>0x2EC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OCC_COUNT</name>
              <description>Number of occurrences of the current active bit counter:
'0': 0 occurrences
...
'65535': 65535 occurrences</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WINDOW_INDEX</name>
              <description>Counter to keep track of the current index in the window (counts from '0' to TR_MON_AP_CTL.WINDOW_SIZE to '0').</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the IP:
'0': Idle/no busy.
'1': Busy:
  - Instruction is pending in the instruction FIFO.
  - Instruction is busy in a IP component (e.g. SHA1, SHA2, SHA3, DES, TDES, AES, CHACHA, ...).
  - Store FIFO is busy.
  - TR or PR command is busy.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_CTL</name>
          <description>Instruction FIFO control</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20000</resetValue>
          <resetMask>0x30007</resetMask>
          <fields>
            <field>
              <name>EVENT_LEVEL</name>
              <description>Event level. When the number of entries in the instruction FIFO is less than the amount of this field, an event is generated:
- 'event' = INSTR_FF_STATUS.USED &lt; EVENT_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the instruction FIFO is cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.

HW sets this field to '1' on when a INSTR_OPC_ERROR, INSTR_CC_ERROR or BUS_ERROR interrupt cause is activated.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>This field specifies the behavior when an instruction is written to a full FIFO (INSTR_FIFO_WR MMIO register):
'0': The write is ignored/dropped and the INTR.INSTR_FF_OVERFLOW interrupt cause is set to '1'.
'1': The write is blocked, resulting in AHB-Lite wait states and the INTR.INSTR_FF_OVERFLOW interrupt cause is set to '1' (this cause may be masked out). The instruction is written to the FIFO as soon as a FIFO entry becomes available. The maximum time is roughly the time of the execution of the slowest/longest instruction. Note that this setting may 'lock up' /stall the CPU. When the CPU is 'locked up'/stalled it can not respond to any system interrupts. As a result, the interrupt latency is increased. Note that this may not be an issue if the associated CPU is only performing cryptography functionality, e.g. the CM0+ during boot time.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_STATUS</name>
          <description>Instruction FIFO status</description>
          <addressOffset>0x1044</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1000F</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of instructions in the instruction FIFO. The value of this field ranges from 0 to 8.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT</name>
              <description>Instruction FIFO  event.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_WR</name>
          <description>Instruction FIFO write</description>
          <addressOffset>0x1048</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Instruction or instruction operand data that is written to the instruction FIFO.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD0_FF_STATUS</name>
          <description>Load 0 FIFO status</description>
          <addressOffset>0x10C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>Number of Bytes in the FIFO. The value of this field is in the range [0, 19].</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the FIFO:
'0': FIFO load engine is idle and a new FIFO instruction can be accepted.
'1': FIFO load engine is busy and NO new FIFO instruction can be accepted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD1_FF_STATUS</name>
          <description>Load 1 FIFO status</description>
          <addressOffset>0x10D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>See LOAD1_FF_STATUS.USED.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>See LOAD1_FF_STATUS.BUSY.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STORE_FF_STATUS</name>
          <description>Store FIFO status</description>
          <addressOffset>0x10F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>Number of Bytes in the FIFO. The value of this field is in the range [0, 16].</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the FIFO:
'0': FIFO store engine is idle and a new FIFO instruction can be accepted (USED is '0').
'1': FIFO store engine is busy and NO new FIFO instruction can be accepted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_CTL</name>
          <description>AES control</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>KEY_SIZE</name>
              <description>AES key size:
'0': 128-bit key, 10 rounds AES (inverse) cipher operation. 
'1': 192-bit key, 12 rounds AES (inverse) cipher operation. 
'2': 256-bit key, 14 rounds AES (inverse) cipher operation. 
'3': Undefined</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AES128</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AES192</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AES256</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT</name>
          <description>Result</description>
          <addressOffset>0x1180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>BLOCK_CMP operation (DATA[0]):
'0': source 0 equals source 1.
'1': source 0 does NOT equal source 1.

CRC operation (DATA[31:0]). State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x1410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x1420</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x1440</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x1448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_REM_CTL0.REM_REVERSE and CRC_REM_CTL1.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL0</name>
          <description>Vector unit control 0</description>
          <addressOffset>0x1480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALWAYS_EXECUTE</name>
              <description>Specifies if a conditional instruction is executed or not, when its condition code evaluates to false/'0'.
'0': The instruction is NOT executed. As a result, the instruction may be handled faster than when it is executed.
'1': The instruction is executed, but the execution result (including status field information) is not reflected in the IP. The instruction is handled just as fast as when it is executed.

Note: a conditional instruction with a condition code that evaluates to false/'0' does not affect the architectural state: VU_STATUS fields, memory or register-file data.

Note: Always execution is useful to prevent/complicate differential timing and differential power attacks.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL1</name>
          <description>Vector unit control 1</description>
          <addressOffset>0x1484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>ADDR24</name>
              <description>Specifies the memory address for the vector unit operand memory region. The register-file registers provide 13-bit word offsets within this memory region. Given ADDR[31:8], VU_VTL2.MASK[14:8] and a 13-bit word offset offset[14:2], a vector operand memory address VU_OPERAND_ADDR[31:0] is calculated as follows:
- VU_OPERAND_ADDR[31:15] = ADDR[31:15]
- VU_OPERAND_ADDR[14:8] = (ADDR[14:8] &amp; MASK[14:8]) | (offset[14:8] &amp; ~MASK[14:8])
- VU_OPERAND_ADDR[7:2] = offset[7:2]
- VU_OPERAND_ADDR[1:0] = 0 (always word aligned)

The vector unit operand memory region uses either the IP's memory buffer or system memory. For best performance, the IP's memory buffer should be used and ADDR should be set to MEM_BUFF and MASK should specify the IP memory buffer size. 

If a vector operand memory address is mapped on a memory hole, read accesses return a '0' and write accesses are ignored.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL2</name>
          <description>Vector unit control 2</description>
          <addressOffset>0x1488</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7F00</resetValue>
          <resetMask>0x7F00</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>Specifies the size of  the vector operand memory region. Legal values:
'0b0000000': 32 KB memory region (VU_VTL1.ADDR[14:8] ignored).
'0b1000000': 16 KB memory region (VU_VTL1.ADDR[13:8] ignored).
'0b1100000': 8 KB memory region (VU_VTL1.ADDR[12:8] ignored).
'0b1110000': 4 KB memory region (VU_VTL1.ADDR[11:8] ignored).
'0b1111000': 2 KB memory region (VU_VTL1.ADDR[10:8] ignored).
'0b1111100': 1 KB memory region (VU_VTL1.ADDR[9:8] ignored).
'0b1111110': 512 B memory region (VU_VTL1.ADDR[8] ignored).
'0b1111111': 256 B memory region.

Note: the default specifies a 256 B memory region.</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_STATUS</name>
          <description>Vector unit status</description>
          <addressOffset>0x1490</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CARRY</name>
              <description>STATUS CARRY field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVEN</name>
              <description>STATUS EVEN field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ZERO</name>
              <description>STATUS ZERO field.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ONE</name>
              <description>STATUS ONE field.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>VU_RF_DATA[%s]</name>
          <description>Vector unit register-file</description>
          <addressOffset>0x14C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Vector unit register-file data. A register-file register has the following layout:
DATA[28:16]: data (typically used as a word offset in vector unit operand memory).
DATA[12:0]: bit size minus 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR0_CTL</name>
          <description>Device key address 0 control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Specifies if the address in the associated DEV_KEY_ADDR0 is valid:
'0': Address not valid; i.e. no device key specified.
'1': Address valid; i.e. device key specified.

Note: A LOAD_DEV_KEY instruction requires that the device key's valid field is '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR0</name>
          <description>Device key address 0</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR32</name>
              <description>Specifies the memory address of the device key in memory. A LOAD_DEV_KEY instruction uses this address to load a device key from memory into the IP register buffer blocks 4 and 5.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR1_CTL</name>
          <description>Device key address 1 control</description>
          <addressOffset>0x2020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>See DEV_KEY_ADDR0_CTL.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR1</name>
          <description>Device key address 1 control</description>
          <addressOffset>0x2024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR32</name>
              <description>See DEV_KEY_ADDR0.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_STATUS</name>
          <description>Device key status</description>
          <addressOffset>0x2080</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>LOADED</name>
              <description>Specifies if a device key is present in the IP register buffer blocks 4 and 5.

HW sets this field to '1' on successful completion of a LOAD_DEV_KEY instruction.
HW clears this field to '0' when a CLEAR instruction is executed (the CLEAR instruction also sets the IP register buffer to '0').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_CTL0</name>
          <description>Device key control 0</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALLOWED</name>
              <description>Specifies if a LOAD_DEV_KEY instruction is allowed to use the device key in memory:
'0': Not allowed.
'1': Allowed.

Note: For successful completion of a LOAD_DEV_KEY instruction, both the associated DEV_KEY_ADDR_CTL.VALID and DEV_KEY_CTL.ALLOWED fields must be '1'. On successful instruction completion, DEV_KEY_STATUS.LOADED is set to '1'. On unsuccessful completion, the instruction FIFO is cleared and the IP is locked; an Active reset or an IP reset (CTL.ENABLED), which reinitializes the IP, is required.

Note: A LOAD_DEV_KEY loads the device key from memory with protection context '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_CTL1</name>
          <description>Device key control 1</description>
          <addressOffset>0x2120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALLOWED</name>
              <description>See DEV_KEY_CTL0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU subsystem (CPUSS)</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>NvicMux0</name>
        <description>CPU User Interrupt #0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>NvicMux1</name>
        <description>CPU User Interrupt #1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>NvicMux2</name>
        <description>CPU User Interrupt #2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>NvicMux3</name>
        <description>CPU User Interrupt #3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>NvicMux4</name>
        <description>CPU User Interrupt #4</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>NvicMux5</name>
        <description>CPU User Interrupt #5</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>NvicMux6</name>
        <description>CPU User Interrupt #6</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>NvicMux7</name>
        <description>CPU User Interrupt #7</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>Internal0</name>
        <description>Internal SW Interrupt #0</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>Internal1</name>
        <description>Internal SW Interrupt #1</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>Internal2</name>
        <description>Internal SW Interrupt #2</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>Internal3</name>
        <description>Internal SW Interrupt #3</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>Internal4</name>
        <description>Internal SW Interrupt #4</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>Internal5</name>
        <description>Internal SW Interrupt #5</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>Internal6</name>
        <description>Internal SW Interrupt #6</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>Internal7</name>
        <description>Internal SW Interrupt #7</description>
        <value>15</value>
      </interrupt>
      <registers>
        <register>
          <name>IDENTITY</name>
          <description>Identity</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>This field specifies the privileged setting ('0': user mode; '1': privileged mode) of the transfer that reads the register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>This field specifies the security setting ('0': secure mode; '1': non-secure mode) of the transfer that reads the register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>This field specifies the protection context of the transfer that reads the register.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>This field specifies the bus master identifier of the transfer that reads the register.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_0_STATUS</name>
          <description>CM7 0 status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x13</resetValue>
          <resetMask>0x1E13</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DONE</name>
              <description>After a PWR_MODE change this flag indicates if the new power mode has taken effect or not. 
Note: this flag can also change as a result of  a change in debug power up req</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCMC_CM7_1_MS</name>
              <description>Outstanding transactions from CM7 1.
'0': There are no outstanding transactions to the CM7 I/D-TCM slave port (AHBS) from CM7 1.
'1': There are outstanding transactions to the CM7 I/D-TCM slave port (AHBS) from CM7 1. Do not switch the CM7 power off.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCMC_EXT_MS_2_TO_0</name>
              <description>Outstanding transactions from external AXI masters 2 to 0.
'0': There are no outstanding transactions to the CM7 I/D-TCM slave port (AHBS) from external AXI masters 2 to 0.
'1': There are outstanding transactions to the CM7 I/D-TCM slave port (AHBS) from external AXI masters 2 to 0. Do not switch the CM7 power off.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCMC_EXT_MS_3</name>
              <description>Outstanding transactions from external AXI master 3.
'0': There are no outstanding transactions to the CM7 I/D-TCM slave port (AHBS) from external AXI master 3.
'1': There are outstanding transactions to the CM7 I/D-TCM slave port (AHBS) from external AXI master 3. Do not switch the CM7 power off.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCMC_AHB_MS</name>
              <description>Ongoing AHB transaction.
'0': There is no ongoing transaction to the CM7 I/D-TCM slave port (AHBS) from an AHB master.
'1': There is an ongoing transaction to the CM7 I/D-TCM slave port (AHBS) from an AHB master. Do not switch the CM7 power off.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_0_CLOCK_CTL</name>
          <description>Fast 0 clock control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF8</resetMask>
          <fields>
            <field>
              <name>FRAC_DIV</name>
              <description>Fractional division by (FRAC_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf&lt;x&gt;' cycle longer than other clock periods.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_DIV</name>
              <description>Integer division by (1+INT_DIV). Allows for integer divisions in the range [1, 256] (INT_DIV is in the range [0, 255]).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_0_CTL</name>
          <description>CM7 0 control</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F</resetValue>
          <resetMask>0x9FFF0F1F</resetMask>
          <fields>
            <field>
              <name>PPB_LOCK</name>
              <description>Write disable for specific CPU registers:
Bit 0: ITCMR register. '0': enabled; '1': disabled.
Bit 1: DTCMR register. '0': enabled; '1': disabled.
Bit 2: AHBPCR register. '0': enabled; '1': disabled.
Bit 3: VTOR register. '0': enabled; '1': disabled.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_WAIT</name>
              <description>When this signal is '1' out of reset, it forces the CPU into a quiescent state that delays its boot-up sequence and instruction execution until this signal is driven '0'. This allows the TCMs to be loaded by the system before the CPU performs any TCM accesses. The CPU AHBS interface functions while CPU_WAIT is '1' and services transactions initiated by the system (e.g. DMA controller) to load the TCMs.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_TCM_EN</name>
              <description>TCM enable initialization after reset:
Bit 0: ITCM. '0': disabled; '1': enabled.
Bit 1: DTCM. '0': disabled; '1': enabled.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_RMW_EN</name>
              <description>TCM read-modify-write enable initialization after reset:
Bit 0: ITCM. '0': disabled; '1': enabled.
Bit 1: DTCM. '0': disabled; '1': enabled.

Note: When TCM ECC is enabled, the read-modify-write functionality should be enabled. This prevents partial (sub-word) writes to the TCM.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCM_ECC_EN</name>
              <description>ITCM ECC enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCM_ECC_INJ_EN</name>
              <description>ITCM ECC error injection enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCM_READ_WS</name>
              <description>ITCM read wait states (writes have no wait states).
'0': 0 wait states.
'1': 1 wait state.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCM_ECC_CHECK_DIS</name>
              <description>Disable ECC checking and thus fault reports. This also disables ECC correction (required to enable initialization). Intended usage is initialization. This bit is ignored when TCM_ECC_EN=0.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCM_ECC_EN</name>
              <description>DTCM ECC enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCM_ECC_INJ_EN</name>
              <description>DTCM ECC error injection enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCM_READ_WS</name>
              <description>DTCM read wait states (writes have no wait states).
'0': 0 wait states.
'1': 1 wait state.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCMC_EN</name>
              <description>CM7 TCMC access control:
'0': Disable access to the CM7 I/D-TCM slave port (AHBS). Access attempts will get a bus error response.
'1': Enable access to the CM7 I/D-TCM slave port (AHBS). 

Before switching the CM7 power off, set this field to 0, and confirm that there are no outstanding AXI transactions and no ongoing AHB transactions to the CM7 TCMs, by checking that bits TCMC_* in CM7_x_STATUS are '0'.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IOC_MASK</name>
              <description>CPU floating point unit (FPU) exception mask for the CPU's FPCSR.IOC 'invalid operation' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: the ARM architecture does NOT support FPU exceptions; i.e. there is no precise FPU exception handler. Instead, FPU conditions are captured in the CPU's FPCSR register and the conditions are provided as CPU interface signals. The interface signals are 'masked' with the fields a provide by this register (CM7_0_CTL). The 'masked' signals are reduced/OR-ed into a single CPU floating point interrupt signal. The associated CPU interrupt handler allows for imprecise handling of FPU exception conditions.

Note: the CPU's FPCSR exception conditions are 'sticky'. Typically, the CPU FPU interrupt handler will clear the exception condition(s) to '0'.

Note: by default, the FPU exception masks are '0'. Therefore, FPU exception conditions will NOT activate the CPU's floating point interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.DZC 'divide by zero' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.OFC 'overflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.UFC 'underflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IXC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IXC 'inexact' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.

Note: the 'inexact' condition is set as a result of rounding. Rounding may occur frequently and is typically not an error condition. To prevent frequent CPU FPU interrupts as a result of rounding, this field is typically set to '0'.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IDC 'input denormalized' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: if the CPU FPCSR.FZ field is set to '1', denormalized inputs are 'flushed to zero'. Dependent on the FPU algorithm, this may or may not occur frequently. To prevent frequent CPU FPU interrupts as a result of denormalized inputs, this field may be set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM7_0_INT_STATUS[%s]</name>
          <description>CM7 0 interrupt status</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM7_0 activated system interrupt index for CPU interrupt.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_0_VECTOR_TABLE_BASE</name>
          <description>CM7 0 vector table base</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0xFFFFFF80</resetMask>
          <fields>
            <field>
              <name>ADDR25</name>
              <description>The default CM7 vector table base address is 0x0100:0000 (CM7 VTOR and reset exception handler address after reset). This is the location of the system ROM memory.

The system ROM is mirrored at 0x0000:0000. This is required for the CM0+ boot process (the CM0+ VTOR and reset exception handler address is at fixed address 0x0000:00000 after reset). The system ROM requires mirroring as the CM7 CPUs' ITCMs are located at base address 0x0000:0000 and effectively cut a hole in the system ROM mirror address space (but the 0x0100:0000 address space is not affected).</description>
              <bitRange>[31:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM7_0_NMI_CTL[%s]</name>
          <description>CM7 0 NMI control</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Set Power mode for UDBs</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM7_0_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>See CM7_0_PWR_CTL</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM7_0_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM7_0_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_DELAY_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRC_DBG_CLOCK_CTL</name>
          <description>Trace and debug clock control</description>
          <addressOffset>0x320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200</resetValue>
          <resetMask>0xFF00</resetMask>
          <fields>
            <field>
              <name>INT_DIV</name>
              <description>Integer division by (1+INT_DIV). Allows for integer divisions in the range [1, 256] (INT_DIV is in the range [0, 255]).
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_1_STATUS</name>
          <description>CM7 1status</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x13</resetValue>
          <resetMask>0x1D13</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DONE</name>
              <description>After a PWR_MODE change this flag indicates if the new power mode has taken effect or not. 
Note: this flag can also change as a result of  a change in debug power up req</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCMC_CM7_0_MS</name>
              <description>Outstanding transactions from CM7 0.
'0': There are no outstanding transactions to the CM7 I/D-TCM slave port (AHBS) from CM7 0.
'1': There are outstanding transactions to the CM7 I/D-TCM slave port (AHBS) from CM7 0. Do not switch the CM7 power off.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCMC_EXT_MS_2_TO_0</name>
              <description>Refer CM7_0_STATUS description.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCMC_EXT_MS_3</name>
              <description>Refer CM7_0_STATUS description.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCMC_AHB_MS</name>
              <description>Refer CM7_0_STATUS description.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_1_CLOCK_CTL</name>
          <description>Fast 1 clock control</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF8</resetMask>
          <fields>
            <field>
              <name>FRAC_DIV</name>
              <description>Refer FAST_0_CLOCK_CTL description.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_DIV</name>
              <description>Refer FAST_0_CLOCK_CTL description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_1_CTL</name>
          <description>CM7 1 control</description>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F</resetValue>
          <resetMask>0x9FFF0F1F</resetMask>
          <fields>
            <field>
              <name>PPB_LOCK</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_WAIT</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_TCM_EN</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_RMW_EN</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCM_ECC_EN</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCM_ECC_INJ_EN</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCM_READ_WS</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCM_ECC_CHECK_DIS</name>
              <description>Disable ECC checking and thus fault reports. This also disables ECC correction (required to enable initialization). Intended usage is initialization. This bit is ignored when TCM_ECC_EN=0.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCM_ECC_EN</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCM_ECC_INJ_EN</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCM_READ_WS</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCMC_EN</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IOC_MASK</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZC_MASK</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OFC_MASK</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UFC_MASK</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IXC_MASK</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDC_MASK</name>
              <description>Refer CM7_0_CTL description.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM7_1_INT_STATUS[%s]</name>
          <description>CM7 1 interrupt status</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM7_1 activated system interrupt index for CPU interrupt 0.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_1_VECTOR_TABLE_BASE</name>
          <description>CM7 1 vector table base</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0xFFFFFF80</resetMask>
          <fields>
            <field>
              <name>ADDR25</name>
              <description>The default CM7 vector table base address is 0x0100:0000 (CM7 VTOR and reset exception handler address after reset). This is the location of the system ROM memory.

The system ROM is mirrored at 0x0000:0000. This is required for the CM0+ boot process (the CM0+ VTOR and reset exception handler address is at fixed address 0x0000:00000 after reset). The system ROM requires mirroring as the CM7 CPUs' ITCMs are located at base address 0x0000:0000 and effectively cut a hole in the system ROM mirror address space (but the 0x0100:0000 address space is not affected).</description>
              <bitRange>[31:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM7_1_NMI_CTL[%s]</name>
          <description>CM7 1 NMI control</description>
          <addressOffset>0x640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Refer CM7_0_NMI_CTL description.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CTL</name>
          <description>CM0+ control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050002</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>SLV_STALL</name>
              <description>Processor debug access control:
'0': Access.
'1': Stall access.

This field is used to stall/delay debug accesses. This is useful to protect execution of code that needs to be protected from debug accesses.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Processor enable:
'0': Disabled. Processor clock is turned off and reset is activated. After SW clears this field to '0', HW automatically sets this field to '1'. This effectively results in a CM0+ reset, followed by a CM0+ warm boot.
'1': Enabled.
Note: The intent is that this bit is modified only through an external probe or by the CM7 while the CM0+ is in Sleep or DeepSleep power mode. If this field is cleared to '0' by the CM0+ itself, it should be done under controlled conditions (such that undesirable side effects can be prevented).

Note: The CM0+ CPU has a AIRCR.SYSRESETREQ register field that allows the CM0+ to reset the complete device (ENABLED only disables/enables the CM0+), resulting in a warm boot. This CPU register field has similar 'built-in protection' as this CM0_CTL register to prevent accidental system writes (the upper 16-bits of the register need to be written with a 0x05fa key value; see CPU user manual for more details).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.
Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ status</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CLOCK_CTL</name>
          <description>Slow clock control</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00</resetMask>
          <fields>
            <field>
              <name>INT_DIV</name>
              <description>Specifies the slow clock divider (from the memory/AXI clock 'clk_mem' to the slow clock 'clk_slow'). Integer division by (1+INT_DIV). Allows for integer divisions in the range [1, 256] (INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERI_CLOCK_CTL</name>
          <description>Peripheral interconnect clock control</description>
          <addressOffset>0x100C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00</resetMask>
          <fields>
            <field>
              <name>INT_DIV</name>
              <description>Integer division by (1+INT_DIV). Allows for integer divisions in the range [1, 256] (INT_DIV is in the range [0, 255]).
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM_CLOCK_CTL</name>
          <description>Memory clock control</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00</resetMask>
          <fields>
            <field>
              <name>INT_DIV</name>
              <description>Integer division by (1+INT_DIV). Allows for integer divisions in the range [1, 256] (INT_DIV is in the range [0, 255]).
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT0_STATUS</name>
          <description>CM0+ interrupt 0 status</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 0.

Multiple system interrupts can be mapped on the same CPU interrupt.The selected system interrupt is the system interrupt with the lowest system interrupt index that has an activated interrupt request at the time of the fetch (system_interrupts[SYSTEM_INT_IDX] is '1'). 

The CPU interrupt handler SW can read SYSTEM_INT_IDX to determine the system interrupt that activated the handler.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>Valid indication for SYSTEM_INT_IDX. When '0', no system interrupt for CPU interrupt 0 is valid/activated.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT1_STATUS</name>
          <description>CM0+ interrupt 1 status</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT2_STATUS</name>
          <description>CM0+ interrupt 2 status</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT3_STATUS</name>
          <description>CM0+ interrupt 3 status</description>
          <addressOffset>0x110C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT4_STATUS</name>
          <description>CM0+ interrupt 4 status</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT5_STATUS</name>
          <description>CM0+ interrupt 5 status</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT6_STATUS</name>
          <description>CM0+ interrupt 6 status</description>
          <addressOffset>0x1118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT7_STATUS</name>
          <description>CM0+ interrupt 7 status</description>
          <addressOffset>0x111C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_VECTOR_TABLE_BASE</name>
          <description>CM0+ vector table base</description>
          <addressOffset>0x1120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>ADDR24</name>
              <description>The default CM0+ vector table base address is 0x0000:0000 (CM0+ VTOR and reset exception handler address after reset). This is the location of the mirror system ROM memory.

This register is provided for SW purposes. It 'survives' a CM0+ warm reset cycle (CM0_CTL.ENABLED).

Note: the use of the mirror system ROM memory can be disabled using the protection infrastructure (SMPU).</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_NMI_CTL[%s]</name>
          <description>CM0+ NMI control</description>
          <addressOffset>0x1140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_0_PWR_CTL</name>
          <description>CM7 0 power control</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050000</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Switch CM7_0 off
Power off, clock off, isolate, reset and no retain.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset CM7_0
Clock off, no isolated, no retain and reset.
...</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM7_0 in Retained mode
This can only become effective if CM7_0 is in SleepDeep mode. Check PWR_DONE flag to see if CM7_0 RETAINED state has been reached.
Power off, clock off, isolate, no reset and retain.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Switch CM7_0 on.
Power on, clock on, no isolate, no reset and no retain.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_0_PWR_DELAY_CTL</name>
          <description>CM7 0 power delay control</description>
          <addressOffset>0x1204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_1_PWR_CTL</name>
          <description>CM7 1 power control</description>
          <addressOffset>0x1210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050000</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Refer CM7_0_PWR_CTL description.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Refer CM7_0_PWR_CTL description.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Refer CM7_0_PWR_CTL description.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Refer CM7_0_PWR_CTL description.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Refer CM7_0_PWR_CTL description.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Refer CM7_0_PWR_CTL description.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_1_PWR_DELAY_CTL</name>
          <description>CM7 1 power delay control</description>
          <addressOffset>0x1214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_CTL0</name>
          <description>RAM 0 control</description>
          <addressOffset>0x1300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0xF0303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow') intefrace. The number of wait states is expressed in 'clk_mem' clock domain cycles.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast_0/1') interface. The number of wait states is expressed in 'clk_mem' clock domain cycles.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable ECC parity injection. Instead of calculating the parity from the write data to the RAM, the parity is taken from ECC_CTL PARITY upon a match of ECC_CTL WORD_ADDR. The write data can be of any size. This bit is ignored when ECC_EN=0.
Note: Parity injection invalidates the write buffer for this word address. If only a part of 64-bit data is written and consistency should be maintained, RAMC#_STATUS WB_EMPTY=1 should be checked before.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_CHECK_DIS</name>
              <description>Disable ECC checking and thus fault reports. This also disables ECC correction (required to enable initialization). Intended usage is initialization. This bit is ignored when ECC_EN=0.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_STATUS</name>
          <description>RAM 0 status</description>
          <addressOffset>0x1304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>RAM0_PWR_MACRO_CTL[%s]</name>
          <description>RAM 0 power control</description>
          <addressOffset>0x1340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Turn OFF the SRAM. This will trun OFF both array and periphery power of the SRAM and SRAM memory contents are lost.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Keep SRAM in Retained mode. This will turn OFF the SRAM periphery power, but array power is ON to retain memory contents.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enable SRAM for regular operation.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.
Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL0</name>
          <description>RAM 1 control</description>
          <addressOffset>0x1380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0xF0303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Refer RAM0_CTL0 descriotion.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Refer RAM0_CTL0 descriotion.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Refer RAM0_CTL0 descriotion.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>Refer RAM0_CTL0 descriotion.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable ECC parity injection. Instead of calculating the parity from the write data to the RAM, the parity is taken from ECC_CTL PARITY upon a match of ECC_CTL WORD_ADDR. The write data can be of any size. This bit is ignored when ECC_EN=0.
Note: Parity injection invalidates the write buffer for this word address. If only a part of 64-bit data is written and consistency should be maintained, RAMC#_STATUS WB_EMPTY=1 should be checked before.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_CHECK_DIS</name>
              <description>Disable ECC checking and thus fault reports. This also disables ECC correction (required to enable initialization). Intended usage is initialization. This bit is ignored when ECC_EN=0.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_STATUS</name>
          <description>RAM 1 status</description>
          <addressOffset>0x1384</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Refer RAM0_STATUS description.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_PWR_CTL</name>
          <description>RAM 1 power control</description>
          <addressOffset>0x1388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Refer RAM0_PWR_MACRO_CTL description.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Refer RAM0_PWR_MACRO_CTL description.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Refer RAM0_PWR_MACRO_CTL description.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Refer RAM0_PWR_MACRO_CTL description.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_CTL0</name>
          <description>RAM 2 control</description>
          <addressOffset>0x13A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0xF0303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Refer RAM0_CTL0 descriotion.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Refer RAM0_CTL0 descriotion.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Refer RAM0_CTL0 descriotion.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>Refer RAM0_CTL0 descriotion.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable ECC parity injection. Instead of calculating the parity from the write data to the RAM, the parity is taken from ECC_CTL PARITY upon a match of ECC_CTL WORD_ADDR. The write data can be of any size. This bit is ignored when ECC_EN=0.
Note: Parity injection invalidates the write buffer for this word address. If only a part of 64-bit data is written and consistency should be maintained, RAMC#_STATUS WB_EMPTY=1 should be checked before.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_CHECK_DIS</name>
              <description>Disable ECC checking and thus fault reports. This also disables ECC correction (required to enable initialization). Intended usage is initialization. This bit is ignored when ECC_EN=0.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_STATUS</name>
          <description>RAM 2 status</description>
          <addressOffset>0x13A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Refer RAM0_STATUS description.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_PWR_CTL</name>
          <description>RAM 2 power control</description>
          <addressOffset>0x13A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Refer RAM0_PWR_MACRO_CTL description.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Refer RAM0_PWR_MACRO_CTL description.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Refer RAM0_PWR_MACRO_CTL description.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Refer RAM0_PWR_MACRO_CTL description.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_DELAY_CTL</name>
          <description>Power up delay used for all SRAM power domains</description>
          <addressOffset>0x13C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x96</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control</description>
          <addressOffset>0x13C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_mem' clock domain cycles.

Timing paths to and from the memory have a (fixed) minimum duration  that always needs to be considered/met. The 'clk_mem' clock domain frequency determines this field's value such that the timing paths minimum duration is met. 
ROM_CTL.SLOW_WS = '0' when clk_mem &lt;=100 MHz.
ROM_CTL.SLOW_WS = '1' when 100MHz &lt; clk_mem &lt;=200MHz.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_mem' clock domain cycles.
ROM_CTL.FAST_WS = '0' when clk_mem &lt;= 200MHz.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x13C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM address and when the corresponding RAM0/RAM1/RAM2/ITCM/DTCM ECC_INJ_EN bit is '1', the parity (PARITY) is injected.
This field needs to be written with the offset address within the memory, divided by the ECC word width in bytes (for RAM0/RAM1/RAM2/ITCM this is 8, for DTCM this is 4). For example, if the RAM0 start address is 0x2800000, and an error is to be injected to address 0x28000080, then this field needs to configured to 0x000010.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR. For the DTCM which has only 7 parity bits, PARITY[6:0] is used as ECC parity.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRODUCT_ID</name>
          <description>Product identifier and version (same as CoreSight RomTables)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FAMILY_ID</name>
              <description>Family ID. Common ID for a product family.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR_REV</name>
              <description>Major Revision, starts with 1, increments with all layer tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR_REV</name>
              <description>Minir Revision, starts with 1, increments with metal layer only tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DP_STATUS</name>
          <description>Debug port status</description>
          <addressOffset>0x1410</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SWJ_CONNECTED</name>
              <description>Specifies if the SWJ debug port is connected; i.e. debug host interface is active:
'0': Not connected/not active.
'1': Connected/active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_DEBUG_EN</name>
              <description>Specifies if SWJ debug is enabled, i.e. CDBGPWRUPACK is '1' and thus debug clocks are on:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_JTAG_SEL</name>
              <description>Specifies if the JTAG or SWD interface is selected. This signal is valid when DP_CTL.PTM_SEL is '0' (SWJ mode selected) and SWJ_CONNECTED is '1' (SWJ is connected).
'0': SWD selected.
'1': JTAG selected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AP_CTL</name>
          <description>Access port control</description>
          <addressOffset>0x1414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70007</resetMask>
          <fields>
            <field>
              <name>CM0_ENABLE</name>
              <description>Enables the CM0 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM7_ENABLE</name>
              <description>Enables the CM7_0 and CM7_1 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_ENABLE</name>
              <description>Enables the system AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM0_DISABLE</name>
              <description>Disables the CM0 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM0_DISABLE is '0' and CM0_ENABLE is '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM7_DISABLE</name>
              <description>Disables the CM7_0 and CM7_1 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM7_DISABLE is '0' and CM7_ENABLE is '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_DISABLE</name>
              <description>Disables the system AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when SYS_DISABLE is '0' and SYS_ENABLE is '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUFF_CTL</name>
          <description>Buffer control</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WRITE_BUFF</name>
              <description>Specifies if write transfer can be buffered in the bus infrastructure bridges:
'0': Write transfers are not buffered, independent of the transfer's bufferable attribute.
'1': Write transfers can be buffered, if the transfer's bufferable attribute indicates that the transfer is a bufferable/posted write.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICK_CTL</name>
          <description>SysTick timer control</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000147</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>TENMS</name>
              <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SOURCE</name>
              <description>Specifies an external clock source:
'0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
'1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
'3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').

Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
'0': Precise.
'1': Imprecise.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Specifies if an external clock source is provided:
'0': An external clock source is provided. 
'1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MBIST_STAT</name>
          <description>Memory BIST status</description>
          <addressOffset>0x1704</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SFP_READY</name>
              <description>Flag indicating the BIST run is done. Note that after starting a BIST run this flag must be set before a new run can be started. For the first BIST run this will be 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFP_FAIL</name>
              <description>Report status of the BIST run, only valid if SFP_READY=1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_SET</name>
          <description>Calibration support set and read</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read without side effect, write 1 to set</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_CLR</name>
          <description>Calibration support clear and reset</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read side effect: when read all bits are cleared, write 1 to clear a specific bit 
Note: no exception for the debug host, it also causes the read side effect</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC_CTL</name>
          <description>CM0+ protection context control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Valid fields for the protection context handler CM0_PCi_HANDLER registers:
Bit 0: Valid field for CM0_PC0_HANDLER.
Bit 1: Valid field for CM0_PC1_HANDLER.
Bit 2: Valid field for CM0_PC2_HANDLER.
Bit 3: Valid field for CM0_PC3_HANDLER.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC0_HANDLER</name>
          <description>CM0+ protection context 0 handler</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 0 handler. This field is used to detect entry to Cypress 'trusted' code through an exception/interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC1_HANDLER</name>
          <description>CM0+ protection context 1 handler</description>
          <addressOffset>0x2044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 1 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC2_HANDLER</name>
          <description>CM0+ protection context 2 handler</description>
          <addressOffset>0x2048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 2 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC3_HANDLER</name>
          <description>CM0+ protection context 3 handler</description>
          <addressOffset>0x204C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 3 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection status</description>
          <addressOffset>0x20C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>STATE</name>
              <description>Protection state:
'0': UNKNOWN.
'1': VIRGIN.
'2': NORMAL.
'3': SECURE.
'4': DEAD.

The following state transistions are allowed (and enforced by HW):
- UNKNOWN =&gt; VIRGIN/NORMAL/SECURE/DEAD
- NORMAL =&gt; DEAD
- SECURE =&gt; DEAD
An attempt to make a NOT allowed state transition will NOT affect this register field.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNKNOWN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIRGIN</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SECURE</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEAD</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_ROM_CTL</name>
          <description>ROM trim control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_RAM_CTL</name>
          <description>RAM trim control for less than 100MHz SRAMs</description>
          <addressOffset>0x2104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_RAM200_CTL</name>
          <description>RAM trim control for 100MHz - 200MHz SRAMs</description>
          <addressOffset>0x2108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>See TRIM_RAM_CTL for description.
System SRAM memories (SRAM0,1,2) are connected to this register.

System SRAM0 uses bias control power switch,so bits [7:5] of this register controls the bias pins of the SRAM0 power switch.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_RAM350_CTL</name>
          <description>RAM trim control for more than 200MHz SRAMs</description>
          <addressOffset>0x210C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>See TRIM_RAM_CTL for description.
CM7 Cache and TCM memories are connected to this register.

All CM7 cache and TCM SRAM macros are controlled using bias control power switches, so bits [7:5] of this register controls the bias pins of the CM7 cache and TCM SRAM power switches.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_SYSTEM_INT_CTL[%s]</name>
          <description>CM0+ system interrupt control</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CM0_CPU_INT_IDX</name>
              <description>CPU interrupt index (legal range [0, 7]). This field specifies to which CPU interrupt the system interrupt is mapped. E.g., if CPU_INT_IDX is '6', the system interrupt is mapped to CPU interrupt '6'.

Note: it is possible to map multiple system interrupts to the same CPU interrupt. It is advised to assign different priorities to the CPU interrupts and to assign system interrupts to CPU interrupts accordingly.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Interrupt enable:
'0': Disabled. The system interrupt will NOT be mapped to any CPU interrupt.
'1': Enabled. The system interrupt is mapped on CPU interrupt CPU_INT_IDX.

Note: the CPUs have dedicated XXX_SYSTEM_INT_CTL registers. In other words, the CPUs can use different CPU interrupts for the same system interrupt. However, typically only one of the CPUs will have the ENABLED field of a specific system interrupt set to '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM7_0_SYSTEM_INT_CTL[%s]</name>
          <description>CM7 0 system interrupt control</description>
          <addressOffset>0xA000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>CPU interrupt index (legal range [0, 15]). This field specifies to which CPU interrupt the system interrupt is mapped. E.g., if CPU_INT_IDX is '6', the system interrupt is mapped to CPU interrupt '6'.

Note: it is possible to map multiple system interrupts to the same CPU interrupt. It is advised to assign different priorities to the CPU interrupts and to assign system interrupts to CPU interrupts accordingly.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Interrupt enable:
'0': Disabled. The system interrupt will NOT be mapped to any CPU interrupt.
'1': Enabled. The system interrupt is mapped on CPU interrupt CPU_INT_IDX.

Note: the CPUs have dedicated XXX_SYSTEM_INT_CTL registers. In other words, the CPUs can use different CPU interrupts for the same system interrupt. However, typically only one of the CPUs will have the ENABLED field of a specific system interrupt set to '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM7_1_SYSTEM_INT_CTL[%s]</name>
          <description>CM7 1 system interrupt control</description>
          <addressOffset>0xC000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>Refer CM7_0_SYSTEM_INT_CTL description.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Refer CM7_0_SYSTEM_INT_CTL description.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FAULT</name>
      <description>Fault structures</description>
      <baseAddress>0x40210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>256</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>Fault structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Fault control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>TR_EN</name>
                <description>Trigger output enable:
'0': Disabled. The trigger output 'tr_fault' is '0'.
'1': Enabled. The trigger output 'tr_fault' reflects STATUS.VALID. The trigger can be used to initiate a Datawire transfer of the FAULT data (FAULT_DATA0 through FAULT_DATA3).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_EN</name>
                <description>IO output signal enable:
'0': Disabled. The IO output signal 'fault_out' is '0'. The IO output enable signal 'fault_out_en' is '0'.
'1': Enabled. The IO output signal 'fault_out' reflects STATUS.VALID. The IO output enable signal 'fault_out_en' is '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_REQ_EN</name>
                <description>Reset request enable:
'0': Disabled.
'1': Enabled. The output reset request signal 'fault_reset_req' reflects STATUS.VALID. This reset causes a warm/soft/core reset. This warm/soft/core reset does not affect the fault logic STATUS, DATA0, ..., DATA3 registers (allowing for post soft reset failure analysis).

The 'fault_reset_req' signals of the individual fault report structures are combined (logically OR'd) into a single SRSS 'fault_reset_req' signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Fault status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>IDX</name>
                <description>The fault source index for which fault information is captured in DATA0 through DATA3. The fault information is fault source specific and described below.

Note: this register field (and associated fault source data in DATA0 through DATA3) should only be considered valid, when VALID is '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Valid indication:
'0': Invalid.
'1': Valid. STATUS.IDX, DATA0, ..., DATA3 specify the fault.

Note: Typically, HW sets this field to '1' (on an activated HW fault source that is 'enabled' by the MASK registers) and SW clears this field to '0' (typically by boot code SW (after a warm system reset, when the fault is handled). In this typical use case scenario, the HW source fault data is simultaneously captured into DATA0, ..., DATA3 when the VALID field is set to '1'. 

An exceptional SW use case scenario is identified as well. In this scenario, SW sets this field to '1' with a fault source index different to one of the defined HW fault sources. SW update is not restricted by the MASK registers). In both use case scenarios, the following holds:
- STATUS.IDX, DATA0, ..., DATA3 can only be written when STATUS.VALID is '0'; the fault structure is not in use yet. Writing STATUS.VALID to '1' effectively locks the fault structure (until SW clears STATUS.VALID to '0'). This restriction requires a SW update to sequentially update the DATA registers followed by an update of the STATUS register.

Note: For the exceptional SW use case, sequential updates to the DATA and STATUS registers may be 'interrupted' by a HW fault capture. In this case, the SW DATA register updates are overwritten by the HW update (and the STATUS.IDX field will reflect the HW capture)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA[%s]</name>
            <description>Fault data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Captured fault source data. 

Note: the DATA registers can only be written when STATUS.VALID is '0'.

Note: the fault source index STATUS.IDX specifies the format of the DATA registers.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING0</name>
            <description>Fault pending 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: CM0 MPU.
Bit 1: CRYPTO MPU.
Bit 2: DW 0 MPU.
Bit 3: DW 1 MPU.
Bit 4: DMA controller MPU.
...
Bit 15: DAP MPU.
Bit 16: CM4 system bus MPU.
Bit 17: CM4 code bus MPU (for non FLASH controller accesses).
Bit 18: CM4 code bus MPU (for FLASH controller accesses).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING1</name>
            <description>Fault pending 1</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: Peripheral group 0 PPU.
Bit 1: Peripheral group 1 PPU.
Bit 2: Peripheral group 2 PPU.
Bit 3: Peripheral group 3 PPU.
Bit 4: Peripheral group 4 PPU.
Bit 5: Peripheral group 5 PPU.
Bit 6: Peripheral group 6 PPU.
Bit 7: Peripheral group 7 PPU.
...
Bit 15: Peripheral group 15 PPU.

Bit 16 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING2</name>
            <description>Fault pending 2</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK0</name>
            <description>Fault mask 0</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 31 to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK1</name>
            <description>Fault mask 1</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 63 to 32.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK2</name>
            <description>Fault mask 2</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 95 to 64.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>This interrupt cause field is activated (HW sets the field to '1') when an enabled (MASK0/MASK1/MASK2) pending fault source is captured:
- STATUS.VALID is set to '1'.
- STATUS.IDX specifies the fault source index.
- DATA0 through DATA3 captures the fault source data.

SW writes a '1' to this field to clear the interrupt cause to '0'. SW clear STATUS.VALID to '0' to enable capture of the next fault. Note that when there is an enabled pending fault source, the pending fault source is captured immediately and INTR.FAULT is immediately activated (set to '1').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>IPC</name>
      <description>IPC</description>
      <baseAddress>0x40220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>32</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>IPC structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>ACQUIRE</name>
            <description>IPC acquire</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RELEASE</name>
            <description>IPC release</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NOTIFY</name>
            <description>IPC notification</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>IPC data 0</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>IPC data 1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK_STATUS</name>
            <description>IPC lock status</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>8</dim>
          <dimIncrement>32</dimIncrement>
          <name>INTR_STRUCT[%s]</name>
          <description>IPC interrupt structure</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PROT</name>
      <description>Protection</description>
      <baseAddress>0x40230000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>SMPU</name>
          <description>SMPU</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>MS0_CTL</name>
            <description>Master 0 protection context control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>Privileged setting ('0': user mode; '1': privileged mode).

Notes:
This field is ONLY used for masters that do NOT provide their own user/privileged access control attribute.
The default/reset field value provides privileged mode access capabilities.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Security setting ('0': secure mode; '1': non-secure mode).

Notes:
This field is ONLY used for masters that do NOT provide their own secure/non-secure access control attribute.
Note that the default/reset field value provides non-secure mode access capabilities to all masters.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Device wide bus arbitration priority setting ('0': highest priority, '3': lowest priority).

Notes: 
The AHB-Lite interconnect performs arbitration on the individual  beats/transfers of a burst (this optimizes latency over locality/bandwidth).
The AXI-Lite interconnects performs a single arbitration for the complete burst (this optimizes locality/bandwidth over latency).
Masters with the same priority setting form a 'priority group'. Within a 'priority group', round robin arbitration is performed.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>Protection context mask for protection context '0'. This field is a constant '0':
- PC_MASK_0 is '0': MPU MS_CTL.PC[3:0] can NOT be set to '0' and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>Protection context mask for protection contexts '15' down to '1'. Bit PC_MASK_15_TO_1[i] indicates if the MPU MS_CTL.PC[3:0] protection context field can be set to the value 'i+1':
- PC_MASK_15_TO_1[i] is '0': MPU MS_CTL.PC[3:0] can NOT be set to 'i+1'; and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.
- PC_MASK_15_TO_1[i] is '1': MPU MS_CTL.PC[3:0] can be set to 'i+1'.

Note: When CPUSS_CM0_PC_CTL.VALID[i] is '1' (the associated protection context handler is valid), write transfers to PC_MASK_15_TO_1[i-1] always write '0', regardless of data written. This ensures that when valid protection context handlers are used to enter protection contexts 1, 2 or 3 through (HW modifies MPU MS_CTL.PC[3:0] on entry of the handler), it is NOT possible for SW to enter those protection contexts (SW modifies MPU MS_CTL.PC[3:0]).</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS1_CTL</name>
            <description>Master 1 protection context control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS2_CTL</name>
            <description>Master 2 protection context control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS3_CTL</name>
            <description>Master 3 protection context control</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS4_CTL</name>
            <description>Master 4 protection context control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS5_CTL</name>
            <description>Master 5 protection context control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS6_CTL</name>
            <description>Master 6 protection context control</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS7_CTL</name>
            <description>Master 7 protection context control</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS8_CTL</name>
            <description>Master 8 protection context control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS9_CTL</name>
            <description>Master 9 protection context control</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS10_CTL</name>
            <description>Master 10 protection context control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS11_CTL</name>
            <description>Master 11 protection context control</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS12_CTL</name>
            <description>Master 12 protection context control</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS13_CTL</name>
            <description>Master 13 protection context control</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS14_CTL</name>
            <description>Master 14 protection context control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS15_CTL</name>
            <description>Master 15 protection context control</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>16</dim>
            <dimIncrement>64</dimIncrement>
            <name>SMPU_STRUCT[%s]</name>
            <description>SMPU structure</description>
            <addressOffset>0x00002000</addressOffset>
            <register>
              <name>ADDR0</name>
              <description>SMPU region address 0 (slave structure)</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (ATT0.REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by ATT0 applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT0.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT0</name>
              <description>SMPU region attributes 0 (slave structure)</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0x80000100</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evaluation'.
'1': PC field participates in 'matching'.

'Matching' process. For each protection structure, the process identifies if a transfer address is contained within the address range. This identifies the 'matching' regions.
'Access evaluation' process. For each protection structure, the process evaluates the bus transfer access attributes against the access control attributes.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ADDR1</name>
              <description>SMPU region address 1 (master structure)</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.

Two out of a total of eight 32 B subregions are enabled. These subregions includes region structures 0 and 1. 

Note: this field is read-only.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region.

'ADDR_DEF1': base address of structure.

Note: this field is read-only.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT1</name>
              <description>SMPU region attributes 1 (master structure)</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7000109</resetValue>
              <resetMask>0x9F00012D</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).

Note that this register is constant '1'; i.e. user read accesses are ALWAYS allowed.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).

Note that this register is constant '0'; i.e. user execute accesses are NEVER allowed.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).

Note that this register is constant '1'; i.e. privileged read accesses are ALWAYS allowed.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).

Note that this register is constant '0'; i.e. privileged execute accesses are NEVER allowed.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'7': 256 B region (8 32 B subregions)

Note: this field is read-only.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evaluation'.
'1': PC field participates in 'matching'.

'Matching' process. For each protection structure, the process identifies if a transfer address is contained within the address range. This identifies the 'matching' regions.
'Access evaluation' process. For each protection structure, the process evaluates the bus transfer access attributes against the access control attributes.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>1024</dimIncrement>
          <name>MPU[%s]</name>
          <description>MPU</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>MS_CTL</name>
            <description>Master control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Active protection context (PC). Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields. In addition, a write transfer with protection context '0' can change this field (protection context 0 has unrestricted access).

The CM0+ MPU MS_CTL register is special: the PC field is modifiable by BOTH HW and SW (for all other masters, the MPU MS_CTL.PC field is modifiable by SW ONLY. For CM0+ PC field HW modifications, the following holds:
* On entry of a CM0_PC0/1/2/3_HANDLER exception/interrupt handler:
   IF (the new PC is the same as MS_CTL.PC)
       PC is not affected; PC_SAVED is not affected.
   ELSE IF (CM0_PC_CTL.VALID[MS_CTL.PC])
       An AHB-Lite bus error is generated for the exception handler fetch;
       PC is not affected; PC_SAVED is not affected.
   ELSE
       PC = 'new PC'; PC_SAVED = PC (push operation).
* On entry of any other exception/interrupt handler:
   PC = PC_SAVED; PC_SAVED is not affected (pop operation).

Note that the CM0_PC0/1/2/3_HANDLER and CM0_PC_CTL registers are part of repecitve CPUSS MMIO registers.

Note: this field is NOT used by the DW controllers, DMA controller, AXI DMA controller, CRYPTO component and VIDEOSS.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Saved protection context. Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields.

Note: this field is ONLY used by the CM0+.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>127</dim>
            <dimIncrement>4</dimIncrement>
            <name>MS_CTL_READ_MIR[%s]</name>
            <description>Master control read mirror</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Read-only mirror of MS_CTL.PC</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Read-only mirror of MS_CTL.PC_SAVED</description>
                <bitRange>[19:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>8</dim>
            <dimIncrement>32</dimIncrement>
            <name>MPU_STRUCT[%s]</name>
            <description>MPU structure</description>
            <addressOffset>0x00000200</addressOffset>
            <register>
              <name>ADDR</name>
              <description>MPU region address</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by MPU_REGION_ATT applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT</name>
              <description>MPU region attrributes</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASHC</name>
      <description>Flash controller</description>
      <baseAddress>0x40240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>FLASH_CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x177330F</resetMask>
          <fields>
            <field>
              <name>WS</name>
              <description>FLASH macro wait states (same for main and work interfaces):
'0': 0 wait states.
...
'15': 15 wait states</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_MAP</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_MAP</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_BANK_MODE</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_BANK_MODE</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_EN</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_INJ_EN</name>
              <description>N/A</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro main interface (either a non-correctable ECC error or a FLASH macro main interface internal error):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned by the bus master interface. The erroneous data is NOT placed in a bus master interface's cache and/or buffer.

This field is ONLY used by CPU  (or debug i.e. SYS_AP/CM0_AP/CM7_0/1_AP) bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM0_STATUS, CM7_0_STATUS and CM7_1_STATUS) to register the occurrence of FLASH macro main interface internal errors (non-correctable ECC errors are NOT registered).

Note: fault reporting can be used to identify the error that occurred:
- FLASH macro main interface internal error. 
- FLASH macro main interface non-recoverable ECC error.
- FLASH macro main interface recoverable ECC error.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_EN</name>
              <description>N/A</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_INJ_EN</name>
              <description>N/A</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro work interface (either a non-correctable ECC error or a FLASH macro work interface internal error):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned by the bus master interface. The erroneous data is NOT placed in a bus master interface's cache and/or buffer.

This field is ONLY used by CPU (or debug i.e. SYS_AP/CM0_AP/CM7_0/1_AP) bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM0_STATUS, CM7_0_STATUS and CM7_1_STATUS) to register the occurrence of FLASH macro work interface internal errors (non-correctable ECC errors are NOT registered).

Note: fault reporting can be used to identify the error that occurred:
- FLASH macro work interface internal error. 
- FLASH macro work interface non-recoverable ECC error.
- FLASH macro work interface recoverable ECC error.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_SEQ_RD_EN</name>
              <description>Enable sequential read mode for Work Flash for read accesses on the AXI port. 
0: Sequential read mode for Work Flash is disabled.
1: Sequential read mode for Work Flash is enabled. This speeds up subsequent AXI read accesses to the same page (64 bytes) of the Work Flash.

Setting this field to '1' has a side effect on the round-robin arbitration of the Work Flash macro between the different ports. When this field is set to '1', then as soon as the arbitration of the Work Flash is given to the AXI port, it is not released before the current AXI read burst either has been completed or leaves the current Work Flash page (64 bytes). This means that AHB masters accessing the Work Flash that have the same priority as the AXI port will not get their fair share of the Work Flash bandwidth. While an AHB master can perform one Work Flash access per round-robin cycle (4 bytes), an AXI master can read a whole AXI burst, or up to the next Work Flash page boundary.
So if this field is set to '1', and an AHB master requires a high Work Flash bandwidth, then it should have a higher priority than the AXI masters accessing the Work Flash.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PWR_CTL</name>
          <description>Flash power control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Controls 'enable' pin of the Flash memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_HV</name>
              <description>Controls 'enable_hv' pin of the Flash memory.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CMD</name>
          <description>Command</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Invalidation of ALL caches (for CM0+) and ALL buffers. SW writes a '1' to clear the caches. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks. The caches LRU structures are also reset to their default state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFF_INV</name>
              <description>Invalidation of ALL buffers (does not invalidate the caches). SW writes a '1' to clear the buffers. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks.

Note: the caches only capture FLASH macro main array data. Therefore, invalidating just the buffers (BUFF_INV) does not invalidate captures main array data in the caches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>N/A</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL0</name>
          <description>eCT Flash SRAM ECC control 0</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_DATA</name>
              <description>32-bit data for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL1</name>
          <description>eCT Flash SRAM ECC control 1</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_PARITY</name>
              <description>7-bit parity for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL2</name>
          <description>eCT Flash SRAM ECC control 2</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CORRECTED_DATA</name>
              <description>32-bit corrected data output of the ECC syndrome logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL3</name>
          <description>eCT Flash SRAM ECC control 3</description>
          <addressOffset>0x2BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x111</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>ECC generation/check enable for eCT Flash SRAM memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>eCT Flash SRAM ECC error injection test enable. Follow the steps below for ECC logic test:
1. Write corrupted or uncorrupted 39-bit data to FM_SRAM_ECC_CTL0/1 registers.
2. Set the ECC_INJ_EN bit to '1'.
3. Confirm that the bit ECC_TEST_FAIL is '0'. If this is not the case, start over at item 1 because the eCT Flash was not idle.
4. Check the corrected data in FM_SRAM_ECC_CTL2.
5. Confirm that fault was reported to fault structure, and check syndrome (only applicable if
corrupted data was written in step 1).
6. If not finished, start over at 1 with different data.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_TEST_FAIL</name>
              <description>Status of ECC test.
1: ECC test failed because eCT Flash macro is busy and using the SRAM.
0: ECC was performed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL0</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>Enable ECC checking for cache accesses:
0: Disabled.
1: Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>Enable error injection for cache.
When '1', the parity (ECC_CTL.PARITY[6:0]) is used when a refill is done from the FLASH macro to the ECC_CTL.WORD_ADDR[24:0] word address.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>Cache enable:
0: Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
1: Enabled.G269</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL1</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM0 cache.
The following sequnece should be followed for truning OFF/ON the cache SRAM.
Turn OFF sequence:
a) Write CM0_CA_CTL0 to disable cache.
b) Write CM0_CA_CTL1 to turn OFF cache SRAM.
Turn ON sequence:
a) Write CM0_CA_CTL1 to turn ON cache SRAM.
b) Delay to allow power up of cache SRAM. Delay should be at a minimum of CM0_CA_CTL2.PWRUP_DELAY CLK_SLOW clock cycles.
c) Write CM0_CA_CTL0 to enable cache.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Power OFF the CM0 cache SRAM.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM0 cache SRAM in retained mode.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enable/Turn ON the CM0 cache SRAM.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.
Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL2</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS0</name>
          <description>CM0+ cache status 0</description>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>Sixteen valid bits of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS1</name>
          <description>CM0+ cache status 1</description>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>Cache line address of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS2</name>
          <description>CM0+ cache status 2</description>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>Six bit LRU representation of the cache set specified by CM0_CA_CTL.SET_ADDR. The encoding of the field is as follows ('X_LRU_Y' indicates that way X is Less Recently Used than way Y):
Bit 5: 0_LRU_1: way 0 less recently used than way 1.
Bit 4: 0_LRU_2.
Bit 3: 0_LRU_3.
Bit 2: 1_LRU_2.
Bit 1: 1_LRU_3.
Bit 0: 2_LRU_3.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ interface status</description>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurrence of a FLASH macro main interface internal error (typically the result of a read access while a program erase operation is ongoing) as a result of a CM0+ (or debug access via SYS_AP/CM0_AP) access. 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_0_STATUS</name>
          <description>CM7 #0 interface status</description>
          <addressOffset>0x4E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurrence of a FLASH macro main interface internal error (typically the result of a read access while a program erase operation is ongoing) as a result of a CM7_0 (or debug access via SYS_AP/CM7_0_AP) access. 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM7_0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM7_1_STATUS</name>
          <description>CM7 #1 interface status</description>
          <addressOffset>0x560</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurrence of a FLASH macro main interface internal error (typically the result of a read access while a program erase operation is ongoing) as a result of a CM7_1 (or debug access via SYS_AP/CM7_1_AP) access. 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM7_1_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_BUFF_CTL</name>
          <description>Cryptography buffer control</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW0_BUFF_CTL</name>
          <description>Datawire 0 buffer control</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW1_BUFF_CTL</name>
          <description>Datawire 1 buffer control</description>
          <addressOffset>0x680</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_BUFF_CTL</name>
          <description>DMA controller buffer control</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW0_MS_BUFF_CTL</name>
          <description>Slow external master 0 buffer control</description>
          <addressOffset>0x780</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW1_MS_BUFF_CTL</name>
          <description>Slow external master 1 buffer control</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>FM_CTL_ECT</name>
          <description>Flash Macro Registers</description>
          <addressOffset>0x0000F000</addressOffset>
          <register>
            <name>FM_CTL</name>
            <description>Flash Macro Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000001F</resetMask>
            <fields>
              <field>
                <name>FM_MODE</name>
                <description>Flash macro mode selection:
d0: Read/Idle - Normal mode, read array enabled
d1: Not Used - the 1st analog POR is done by enable/enable_hv
d2 - POR FUR Download - Downloads critical Flash initialization data from OTP (BG, rd, redu, etc....)
d3 - POR IRAM MMR Download - Downloads from OTP region the MMR / IRAM into to the 8051 RDL shadows
d4 - POR SW Download - Downloads from OTP region the SW code into to the 8051 MCU SRAM 
d5 - POR Code_Work Prepare - Loads the Code and Work Flash MG's to be ready for user mode operation
d6 - Not Used
d7 - Program 32b (WORK) - Used as program confirm command for  32 (Work) bits program
d8 - Program 64b (CODE) - Used as program confirm command for  64 (Code) bits program
d9 - Program 256b (CODE) - Used as program confirm command for  256 (Code) bits program
d10: Program Page (CODE) - Used as program confirm command for page program for Code flash
d11: Not Used
d12 - Sector Erase - Erase for all kinds of sectors (Code/Work/SMS)
d13 - Blank check Entry (UBC)
d14 - Blank Check Read 32bit (WORK) - Blank check mode
d15 - Blank check Exit
d16 - Not Used
d17 - Erase Suspend - Suspend command to the Erase operation
d18 - Erase Resume - Resume command to Erase suspended operation
d19 - Not Used
d20- Not Used
d21- Not Used
d22- Not Used
d23- Not Used
d24- Not Used
d25- Not Used
d26- Not Used
d27- Not Used
d28- Not Used
d29- Not Used
d30: Not Used
d31: Not Used</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EMB_START</name>
                <description>'0': not active
'1': starts the actual embedded operation</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_CODE_MARGIN</name>
            <description>Flash Macro Margin Mode on Code Flash</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3943</resetValue>
            <resetMask>0xE000FFFF</resetMask>
            <fields>
              <field>
                <name>MARGIN_DCS_TRIM</name>
                <description>see above table to set the DCS reference current value to be used during Margin mode. (default set to 5uS = 0x143) which gives a Margin to the Erase side. 7uA would probably be used for Margin to the PGM side</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_DCS_TRIM_EN</name>
                <description>0:  internal device defaults used from Margin reads reference current
1:  MARGIN_DCS_TRIM configuration is used during Margin read</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_RDREG_TRIM</name>
                <description>rdreg_c trim to be used in Margin mode if enabled by MARGIN_MODE_RDREG_CHNG_EN</description>
                <bitRange>[15:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_PGM_ERS_B</name>
                <description>0: ERS Margin is checked
1: PGM Margin is checked</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_MODE_RDREG_CHNG_EN</name>
                <description>when set will also use the MARGIN_RDREG_TRIM from above. Default is not to use</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_MODE_EN</name>
                <description>when set puts the s40ect Flash IP In Margin mode</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_ADDR</name>
            <description>Flash Macro Address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FM_ADDR</name>
                <description>Code or Work Flash Address to be used during write operations (PGM/ERS)</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INTR</name>
                <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt Set</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INTR_SET</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt Mask</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INTR_MASK</name>
                <description>Mask for corresponding field in the INTR register</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt Masked</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INTR_MASKED</name>
                <description>Logical and of corresponding request and mask fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ECC_OVERRIDE</name>
            <description>ECC Data In override information and control bits</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC00000FF</resetMask>
            <fields>
              <field>
                <name>ECC_OVERRIDE_SYNDROME</name>
                <description>The override syndrome itself to be used in case one of the enables are set. It will take [7:0] in the case of Code flash and [6:0] in the case of work flash, to bypass the internal generated syndrome</description>
                <bitRange>[7:0]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>ECC_OVERRIDE_WORK</name>
                <description>0: no override. Using internal ECC engine to calculate the ECC of the Work Flash</description>
                <bitRange>[30:30]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>ECC_OVERRIDE_CODE</name>
                <description>0: no override. Using internal ECC engine to calculate the ECC of the Code Flash</description>
                <bitRange>[31:31]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_DATA</name>
            <description>Flash macro data_in[31 to 0] both Code and Work Flash</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FM_DATA</name>
                <description>Pgm command data in going to the internal write buffer (WBUF).</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BOOKMARK</name>
            <description>Bookmark register - keeps the current FW HV seq</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BOOKMARK</name>
                <description>Used by FW. Keeps the Current HV cycle sequence</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MAIN_FLASH_SAFETY</name>
            <description>Main (Code) Flash Security enable</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>MAINFLASHWRITEENABLE</name>
                <description>'0': Main Flash embedded operations are blocked
'1': Main Flash embedded operations are enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status read from Flash Macro</description>
            <addressOffset>0x404</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xF800007F</resetMask>
            <fields>
              <field>
                <name>PGM_CODE</name>
                <description>Indicates if active PGM operation to the Code flash is taking place
0: not running
1: running</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PGM_WORK</name>
                <description>Indicates if active PGM operation to the Work flash is taking place
0: not running
1: running</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ERASE_CODE</name>
                <description>Indicates if active Erase operation to the Code flash is taking place
0: not running
1: running</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ERASE_WORK</name>
                <description>Indicates if active Erase operation to the Work flash is taking place
0: not running
1: running</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ERS_SUSPEND</name>
                <description>Indicates if Erase operation (Code/Work) is currently being suspended
0: not suspended
1: suspended</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BLANK_CHECK_WORK</name>
                <description>Indicates if Blank Check mode is currently running on the work flash
0: not running
1: running</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BLANK_CHCEK_PASS</name>
                <description>Indicates  the Blank check command result is PASS (Blank)
0: Not Blank
1: Blank (PASS)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POR_1B_ECC_CORRECTED</name>
                <description>Indicates internal ECC found 1b error while downloading info in POR from NVM to VM and fixed it. 
Valid after 2nd, 3rd and 4th POR phases (FUR, IREM &amp; MMR, SW DOWNLOAD). If Set it is not cleaned till additional POR (rst_hf_ac_t)
0: No error
1: 1b ECC Error corrected in POR</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POR_2B_ECC_ERROR</name>
                <description>Indicates an internal ECC error of 2b while downloading info in POR from NVM to VM. 
Valid after 2nd, 3rd and 4th POR phases (FUR, IREM &amp; MMR, SW DOWNLOAD). If Set it is not cleaned till additional POR (rst_hf_ac_t)
0: No error
1: ECC 2b Error in POR</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NATIVE_POR</name>
                <description>Indicates a Native Flash state (UV) or sorted one.
Valid only after 2nd phase of POR (FUR DOWNLOAD). 
Comment: not a retained flop, therefore reset (rst_hf_act_n) puts it back to 0. If Set it is not cleaned till additional POR (rst_hf_ac_t)
0: SORTED DEVICE (Non - Native)
1: NATIVE</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HANG</name>
                <description>After embedded operation (pgm/erase) this flag will tell if it was successful or failed
0: PASS
1: FAIL</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Whenever the device is in embedded mode the RDY goes low. Should be the same as c_interrupt pin of the IP (but inverted)
1: busy in embedded
0: rdy (high also in erase suspend)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WORK_FLASH_SAFETY</name>
            <description>Work Flash Security enable</description>
            <addressOffset>0x500</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WORKFLASHWRITEENABLE</name>
                <description>0: Work Flash embedded operations are blocked
1: Work Flash embedded operations are enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSS</name>
      <description>SRSS Core Registers (ver3)</description>
      <baseAddress>0x40260000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_LVD_STATUS</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Status Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OUT</name>
              <description>HVLVD1 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_STATUS2</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Status Register #2</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD2_OUT</name>
              <description>HVLVD2 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DSI_SELECT[%s]</name>
          <description>Clock DSI Select Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>DSI_MUX</name>
              <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_PATH_SELECT register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or as reference inputs for the FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DSI_OUT0</name>
                  <description>DSI0 - dsi_out[0]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT1</name>
                  <description>DSI1 - dsi_out[1]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT2</name>
                  <description>DSI2 - dsi_out[2]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT3</name>
                  <description>DSI3 - dsi_out[3]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT4</name>
                  <description>DSI4 - dsi_out[4]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT5</name>
                  <description>DSI5 - dsi_out[5]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT6</name>
                  <description>DSI6 - dsi_out[6]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT7</name>
                  <description>DSI7 - dsi_out[7]</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT8</name>
                  <description>DSI8 - dsi_out[8]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT9</name>
                  <description>DSI9 - dsi_out[9]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT10</name>
                  <description>DSI10 - dsi_out[10]</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT11</name>
                  <description>DSI11 - dsi_out[11]</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT12</name>
                  <description>DSI12 - dsi_out[12]</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT13</name>
                  <description>DSI13 - dsi_out[13]</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT14</name>
                  <description>DSI14 - dsi_out[14]</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT15</name>
                  <description>DSI15 - dsi_out[15]</description>
                  <value>15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO0</name>
                  <description>ILO0 - Internal Low-speed Oscillator #0</description>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator</description>
                  <value>17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock</description>
                  <value>18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low-speed Oscillator</description>
                  <value>19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>20</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_FAST</name>
          <description>Fast Clock Output Select Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>FAST_SEL0</name>
              <description>Select signal for fast clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL0 and HFCLK_SEL0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL0</name>
                  <description>Selects the clock path chosen by PATH_SEL0 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL0</name>
                  <description>Selects the output of the HFCLK_SEL0 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL0</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL0</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL0</name>
              <description>Selects a clock path to use in fast clock output #0 logic.  
0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL0</name>
              <description>Selects a HFCLK tree for use in fast clock output #0</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_SEL1</name>
              <description>Select signal for fast clock output #1</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL1 and HFCLK_SEL1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL1</name>
                  <description>Selects the clock path chosen by PATH_SEL1 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL1</name>
                  <description>Selects the output of the HFCLK_SEL1 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL1</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL1</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL1</name>
              <description>Selects a clock path to use in fast clock output #1 logic.  
0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL1</name>
              <description>Selects a HFCLK tree for use in fast clock output #1 logic</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_SLOW</name>
          <description>Slow Clock Output Select Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SLOW_SEL0</name>
              <description>Select signal for slow clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO0</name>
                  <description>Internal Low Speed Oscillator (ILO0)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>Internal Low Speed Oscillator (ILO1), if present on the product.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO Prescaler (ECO_PRESCALER)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO Prescaler (LPECO_PRESCALER)</description>
                  <value>12</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLOW_SEL1</name>
              <description>Select signal for slow clock output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO0</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>Internal Low Speed Oscillator (ILO1), if present on the product.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO Prescaler (ECO_PRESCALER)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO Prescaler (LPECO_PRESCALER)</description>
                  <value>12</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80FFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on fast clock output #0 (see CLK_OUTPUT_FAST). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.  Both clocks must be running or the measurement will not complete.  A stalled counter can be recovered by selecting valid clocks, waiting until the measurement completes, and discarding the first result.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on fast clock output  #1 (see CLK_OUTPUT_FAST). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.COUNTER=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.COUNTER)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x26</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Interrupt for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x26</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Set interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Set interrupt for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x26</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Mask for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Mask for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x26</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>System is resetting.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>At least one CPU is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>No CPUs are running.  Peripherals may be running.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEPSLEEP</name>
                  <description>Main high-frequency clock is off; low speed clocks are available.  Communication interface clocks may be present.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active.  Power modes behave differently to keep the debug session active.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether certain low power functions are ready.  The low current circuits take longer to startup after XRES, HIBERNATE wakeup, or supply supervision reset wakeup than the normal mode circuits.  HIBERNATE mode may be entered regardless of this bit.
0: If a low power circuit operation is requested, it will stay in its normal operating mode until it is ready.  If DEEPSLEEP is requested by all processors WFI/WFE, the device will instead enter SLEEP.  When low power circuits are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP and low power circuits operate as requested in other registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTL2</name>
          <description>Power Mode Control 2</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F731117</resetMask>
          <fields>
            <field>
              <name>LINREG_DIS</name>
              <description>Explicitly disable the linear Core Regulator.  Write zero for Traveo II devices.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Linear Core Regulator is not explicitly disabled.  Hardware disables it automatically for internal sequences, including for DEEPSLEEP, HIBERNATE, and XRES low power modes.  
1: Linear Core Regulator is explicitly disabled.  Only use this for special cases when another source supplies vccd during ACTIVE and SLEEP modes.  This setting is only legal when another source supplies vccd, but there is no special hardware protection for this case.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_OK</name>
              <description>Status of the linear Core Regulator.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LINREG_LPMODE</name>
              <description>Control the power mode of the Linear Regulator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Linear Regulator operates in normal mode.  Internal current consumption is 50uA and load current capability is 50mA to 300mA, depending on the number of regulator modules present in the product.
1: Linear Regulator operates in low power mode.  Internal current consumption is 5uA and load current capability is 25mA.  Firmware must ensure the current is kept within the limit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REG_DIS</name>
              <description>Explicity disable the DeepSleep regulator, including circuits shared with the Active Regulator.  This register must not be set except as part of a Cypress-provided sequence or API, such as the PMIC case described below.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  If the DeepSleep regulator is disabled, it is not supported to enable it again later by clearing this bit.
0: DeepSleep Regulator is not explicitly disabled.  This is the normal setting, and hardware automatically controls the DeepSleep regulator for most sequences, including for HIBERNATE and XRES low power modes.  This setting must be used if the Active Linear Regulator is used, because some circuitry is shared.
1: DeepSleep Regulator is explicitly disabled.  Only use this for special cases when another source supplies vccdpslp during DEEPSLEEP mode and there is no future intention to use the Active Regulator for ACTIVE/SLEEP modes.  For example, this setting is used as part of a Cypress-provided handover sequence to a PMIC that operates in ACTIVE, SLEEP, and DEEPSLEEP and disables both the Active Linear Regulator and DeepSleep Regulator.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_DIS</name>
              <description>Explicitly disable the Retention regulator.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Retention Regulator is not explicitly disabled.  Hardware disables it automatically for internal sequences, including for HIBERNATE and XRES low power modes.  Hardware keeps the Retention Regulator enabled during ACTIVE/SLEEP modes, so it is ready to enter DEEPSLEEP at any time.
1: Retention Regulator is explicitly disabled.  Only use this for special cases when another source supplies vccret during DEEPSLEEP mode.  This setting is only legal when another source supplies vccret, but there is no special hardware protection for this case.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_REG_DIS</name>
              <description>Explicitly disable the Nwell regulator.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Nwell Regulator is on.  Hardware disables it automatically for internal sequences, including for HIBERNATE and XRES low power modes.  Hardware keeps the Nwell Regulator enabled during ACTIVE/SLEEP modes, so it is ready to enter DEEPSLEEP at any time.
1: Nwell Regulator is explicitly disabled.  Only use this for special cases when another source supplies vnwell during DEEPSLEEP mode.  This setting is only legal when another source supplies vnwell, but there is no special hardware protection for this case.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFV_DIS</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFV_OK</name>
              <description>Indicates that the normal mode of the voltage reference is ready.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFVBUF_DIS</name>
              <description>Disable the voltage reference buffer.  Firmware should only disable the buffer when there is no connected circuit that is using it.  SRSS circuits that require it are the PLL and ECO.  A particular product may have circuits outside the SRSS that use the buffer.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFVBUF_OK</name>
              <description>Indicates that the voltage reference buffer is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting REFVBUF_DIS=1.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFVBUF_LPMODE</name>
              <description>Control the power mode of the 800mV voltage reference buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.
0: Voltage Reference Buffer operates in normal mode.  They work for vddd ramp rates of 100mV/us or less.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
1: Voltage Reference Buffer operates in low power mode.  Power supply rejection is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFI_DIS</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFI_OK</name>
              <description>Indicates that the current reference is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting REFI_DIS=1.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFI_LPMODE</name>
              <description>Control the power mode of the reference current generator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Current reference generator operates in normal mode.  It works for vddd ramp rates of 100mV/us or less.
1: Current reference generator operates in low power mode.  Response time is reduced to save current, and it works for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORBOD_LPMODE</name>
              <description>Control the power mode of the POR/BOD circuits.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: POR/BOD circuits operate in normal mode.  They work for vddd ramp rates of 100mV/us or less.
1: POR/BOD circuits operate in low power mode.  Response time is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BGREF_LPMODE</name>
              <description>Control the circuit-level power mode of the Bandgap Reference circuits.   
0: Bandgap Reference circuits operate in higher current mode.
1: Bandgap Reference circuits operate in low power.  Refer to documentation for restrictions.

HT-variant: This register will not set unless CLK_ILO0_CONFIG.ILO0_ENABLE==1.  When disabling low power operation, keep ILO0 enabled for at least 5 cycles after clearing this bit to allow for internal synchronization.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LS_BYPASS</name>
              <description>Bypass level shifter inside the PLL.  Unused, if no PLL is present in the product.
0: Do not bypass the level shifter.  This setting is ok for all operational modes and vccd target voltage.
1: Bypass the level shifter.  This may reduce jitter on the PLL output clock, but can only be used when vccd is targeted to 1.1V nominal.  Otherwise, it can result in clock degradation and static current.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIBERNATE</name>
          <description>HIBERNATE Mode Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCFFEFFFF</resetMask>
          <fields>
            <field>
              <name>TOKEN</name>
              <description>Contains a 8-bit token that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for FREEZE or HIBERNATE fields to operate.  Any other value in this register will cause FREEZE/HIBERNATE to have no effect, except as noted in the FREEZE description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>Firmware sets this bit to freeze the configuration, mode and state of all GPIOs and SIOs in the system.  When entering HIBERNATE mode, the first write instructs DEEPSLEEP peripherals that they cannot ignore the upcoming freeze command.  This occurs even in the illegal condition where UNLOCK is not set.  If UNLOCK and HIBERNATE are properly set, the IOs actually freeze on the second write.  Supply supervision is disabled during HIBERNATE mode.  HIBERNATE peripherals ignore resets (excluding XRES) while FREEZE==1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBALARM</name>
              <description>When set, HIBERNATE will wakeup for a RTC interrupt</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBWDT</name>
              <description>When set, HIBERNATE will wakeup for WDT interrupt</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY_HIBPIN</name>
              <description>Each bit sets the active polarity of the corresponding wakeup pin.
0: Pin input of 0 will wakeup the part from HIBERNATE
1: Pin input of 1 will wakeup the part from HIBERNATE</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBPIN</name>
              <description>When set, HIBERNATE will wakeup if the corresponding pin input matches the POLARITY_HIBPIN setting.  Each bit corresponds to one of the wakeup pins.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_DISABLE</name>
              <description>Hibernate disable bit.
0: Normal operation, HIBERNATE works as described
1: Further writes to this register are ignored
Note: This bit is a write-once bit until the next reset.  Avoid changing any other bits in this register while disabling HIBERNATE mode.  Also, it is recommended to clear the UNLOCK code, if it was previously written..</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE</name>
              <description>Firmware sets this bit to enter HIBERNATE mode.  The system will enter HIBERNATE mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP event.  Both UNLOCK and FREEZE must have been set correctly in a previous write operations.  Otherwise, it will not enter HIBERNATE.  External supplies must have been stable for 250us before entering HIBERNATE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL</name>
          <description>Buck Control Register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT1_SEL</name>
              <description>Voltage output selection for vccbuck1 output.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 0.85V
1: 0.875V
2: 0.90V
3: 0.95V
4: 1.05V
5: 1.10V
6: 1.15V
7: 1.20V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_EN</name>
              <description>Master enable for buck converter.    This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT1_EN</name>
              <description>Enable for vccbuck1 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.    This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.  The TRM specifies the required sequence when transitioning vccd from the LDO to SIMO Buck output #1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL2</name>
          <description>Buck Control Register 2</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT2_SEL</name>
              <description>Voltage output selection for vccbuck2 output.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 1.15V
1: 1.20V
2: 1.25V
3: 1.30V
4: 1.35V
5: 1.40V
6: 1.45V
7: 1.50V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_HW_SEL</name>
              <description>Hardware control for vccbuck2 output.  When this bit is set, the value in BUCK_OUT2_EN is ignored and a hardware signal is used instead.  If the product has supporting hardware, it can directly control the enable signal for vccbuck2.  The same charging time in BUCK_OUT2_EN applies.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_EN</name>
              <description>Enable for vccbuck2 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_CTL</name>
          <description>Supply Supervision Control Register</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8080808</resetValue>
          <resetMask>0x9D909D9</resetMask>
          <fields>
            <field>
              <name>BODVDDD_VSEL</name>
              <description>Selects the voltage threshold for BOD on vddd.  The BOD does not reliably monitor the supply during the transition. 
0: vddd&lt;2.7V
1: vddd&lt;3.0V</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDD_ENABLE</name>
              <description>Enable for BOD on vddd.  This cannot be disabled during normal operation.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDA_VSEL</name>
              <description>Selects the voltage threshold for BOD on vdda.  Ensure BODVDDA_ENABLE==0 before changing this setting to prevent false triggers.
0: vdda&lt;2.7V
1: vdda&lt;3.0V</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDA_ACTION</name>
              <description>Action taken when the BOD on vdda triggers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset the chip</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BODVDDA_ENABLE</name>
              <description>Enable for BOD on vdda.  BODVDDA_ACTION will be triggered when the BOD is disabled.  If no action is desired when disabling, firmware must first write BODVDDA_ACTION=NOTHING in a separate write cycle.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVCCD_ENABLE</name>
              <description>Enable for BOD on vccd.  This cannot be disabled during normal operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_VSEL</name>
              <description>Selects the voltage threshold for OVD on vddd.  The OVD does not reliably monitor the supply during the transition.
0: vddd&gt;5.5V
1: vddd&gt;5.0V</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_ENABLE</name>
              <description>Enable for OVD on vddd.  This cannot be disabled during normal operation.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDA_VSEL</name>
              <description>Selects the voltage threshold for OVD on vdda.  Ensure OVDVDDA_ENABLE==0 before changing this setting to prevent false triggers
0: vddd&gt;5.5V
1: vddd&gt;5.0V</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDA_ACTION</name>
              <description>Action taken when the OVD on vdda triggers.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset the chip</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVDVDDA_ENABLE</name>
              <description>Enable for OVD on vdda.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVCCD_ENABLE</name>
              <description>Enable for OVD on vccd.  This cannot be disabled during normal operation.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_STATUS</name>
          <description>Supply Supervision Status Register</description>
          <addressOffset>0x101C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x30505</resetValue>
          <resetMask>0x30707</resetMask>
          <fields>
            <field>
              <name>BODVDDD_OK</name>
              <description>BOD indicates vddd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVDDA_OK</name>
              <description>BOD indicates vdda is ok.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVCCD_OK</name>
              <description>BOD indicates vccd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDD_OK</name>
              <description>OVD indicates vddd is ok.  This will always read 1, because a detected over-voltage condition will reset the chip.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDA_OK</name>
              <description>OVD indicates vdda is ok.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVCCD_OK</name>
              <description>OVD indicates vccd is ok.    This will always read 1, because a detected over-over-voltage condition will reset the chip.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OCD_ACT_LINREG_OK</name>
              <description>OCD indicates the current drawn from the linear Active Regulator is ok.  This will always read 1, because a detected over-current condition will reset the chip.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OCD_DPSLP_REG_OK</name>
              <description>OCD indicates the current drawn from the linear DeepSleep Regulator is ok.    This will always read 1, because a detected over-current condition will reset the chip.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Configuration Register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7DFFF</resetMask>
          <fields>
            <field>
              <name>HVLVD1_TRIPSEL</name>
              <description>Threshold selection for HVLVD1.  Disable the detector (HVLVD1_EN=0) before changing the threshold.
0: rise=1.225V (nom), fall=1.2V (nom)
1: rise=1.425V (nom), fall=1.4V (nom)
2: rise=1.625V (nom), fall=1.6V (nom)
3: rise=1.825V (nom), fall=1.8V (nom)
4: rise=2.025V (nom), fall=2V (nom)
5: rise=2.125V (nom), fall=2.1V (nom)
6: rise=2.225V (nom), fall=2.2V (nom)
7: rise=2.325V (nom), fall=2.3V (nom)
8: rise=2.425V (nom), fall=2.4V (nom)
9: rise=2.525V (nom), fall=2.5V (nom)
10: rise=2.625V (nom), fall=2.6V (nom)
11: rise=2.725V (nom), fall=2.7V (nom)
12: rise=2.825V (nom), fall=2.8V (nom)
13: rise=2.925V (nom), fall=2.9V (nom)
14: rise=3.025V (nom), fall=3.0V (nom)
15: rise=3.125V (nom), fall=3.1V (nom)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_SRCSEL</name>
              <description>Source selection for HVLVD1</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDD</name>
                  <description>Select VDDD</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSA</name>
                  <description>Select AMUXBUSA (VDDD branch)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDIO</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSB</name>
                  <description>Select AMUXBUSB (VDDD branch)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_EN</name>
              <description>Enable HVLVD1 voltage monitor.  HVLVD1 does not function during DEEPSLEEP, but it automatically returns to its configured setting after DEEPSLEEP wakeup.  Do not change other HVLVD1 settings when enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_TRIPSEL_HT</name>
              <description>N/A</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_DPSLP_EN_HT</name>
              <description>Keep HVLVD1 voltage monitor enabled during DEEPSLEEP mode.  This field is only used when HVLVD1_EN_HT==1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_EN_HT</name>
              <description>Enable HVLVD1 voltage monitor.  This detector monitors vddd only.  Do not change other HVLVD1 settings when enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an action when the threshold is crossed.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_ACTION</name>
              <description>Action taken when the threshold is crossed in the programmed directions(s)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERRUPT</name>
                  <description>Generate an interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL2</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Configuration Register #2</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7DF00</resetMask>
          <fields>
            <field>
              <name>HVLVD2_TRIPSEL_HT</name>
              <description>N/A</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_DPSLP_EN_HT</name>
              <description>Keep HVLVD2 voltage monitor enabled during DEEPSLEEP mode.  This field is only used when HVLVD1_EN_HT==1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_EN_HT</name>
              <description>Enable HVLVD2 voltage monitor.  This detector monitors vddd only.  Do not change other HVLVD2 settings when enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an action when the threshold is crossed.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD2_ACTION</name>
              <description>Action taken when the threshold is crossed in the programmed directions(s)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERRUPT</name>
                  <description>Generate an interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_CTL</name>
          <description>REGHC Control Register</description>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000104</resetValue>
          <resetMask>0xFFFF7DFD</resetMask>
          <fields>
            <field>
              <name>REGHC_MODE</name>
              <description>REGHC control mode:
0: external transistor connected,
1: external PMIC connected</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_DRV_VOUT</name>
              <description>Setting for DRV_VOUT pin for PMIC mode.  See REGHC_VADJ for calculation of vadj. 
2'b00: DRV_VOUT=vccd*0.9/vadj;
2'b01: DRV_VOUT=vccd*0.8/vadj;
2'b10: DRV_VOUT=vccd*0.6/vadj;
2'b11: DRV_VOUT=vccd</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_VADJ</name>
              <description>Regulator output trim according to the formula vadj=(1.020V + REGHC_VADJ*0.005V) plus an offset described below.  For example, 0x1A=&gt;1.15V (nominal).

For transistor mode, REGHC will dynamically adjust DRV_VOUT so the supply targets the vadj voltage.  Adjust for die to die variation by adding the signed offset value in SFLASH SRSS_PWR_OFFSET.REGHC_TRANS_VADJ_OFFSET.
Note: SRSS_PWR_OFFSET.REGHC_TRANS_VADJ_OFFSET value is calculated using the default value of the REGHC_VADJ: 0x10 (1.1V) and applies to the full range of REGHC target voltages.

For PMIC mode, adjust for die to die variation by adding the signed offset value in SFLASH SRSS_PWR_OFFSET.PMIC_VADJ_OFFSET to the nominal calculated code.  For PMIC mode, also see REGHC_PMIC_DRV_VOUT.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_USE_LINREG</name>
              <description>For REGHC external PMIC mode, controls whether hardware sequencer keeps the internal Active Linear Regulator enabled to improve supply supervision of vccd.  When using this feature, if the PMIC fails to keep vccd above the internal regulator target, then the internal regulator will attempt to recover vccd.  If the regulator current is too high, the regulator triggers an over-current detector (OCD) reset.  
0: Internal Active Linear Regulator disabled after PMIC enabled.  OCD is disabled.;
1: Internal Active Linear Regulator kept enabled.  See datasheet for minimum PMIC vccd input to prevent OCD.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_USE_RADJ</name>
              <description>Controls whether hardware sequencer enables reset voltage adjustment circuit when enabling a PMIC.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_RADJ</name>
              <description>Reset voltage adjustment for PMIC as a factor (Vfbk/Vref) where Vfbk is the feedback voltage and Vref is the PMIC internal reference.  The reset voltage adjustment circuit is enabled by the hardware sequencer if REGHC_PMIC_USE_RADJ=1.  PMIC have Vref of 0.8V or 0.9V, and the resulting reset voltage (Vreset) are precalculated in the table below:
3'b000: Vfbk/Vref=1.0000, Vreset=.800V@(Vref=0.8V), .900V@(Vref=0.9V);
3'b001: Vfbk/Vref=1.0556, Vreset=.844V@(Vref=0.8V), .950V@(Vref=0.9V);
3'b010: Vfbk/Vref=1.1111, Vreset=.889V@(Vref=0.8V), 1.000V@(Vref=0.9V);
3'b011: Vfbk/Vref=1.1250, Vreset=.900V@(Vref=0.8V), 1.013V@(Vref=0.9V);
3'b100: Vfbk/Vref=1.1667, Vreset=.933V@(Vref=0.8V), 1.050V@(Vref=0.9V);
3'b101: Vfbk/Vref=1.1875, Vreset=.950V@(Vref=0.8V), 1.069V@(Vref=0.9V);
3'b110: Vfbk/Vref=1.2500, Vreset=1.000V@(Vref=0.8V), 1.125V@(Vref=0.9V);
3'b111: Vfbk/Vref=1.3125, Vreset=1.050V@(Vref=0.8V), 1.181V@(Vref=0.9V);</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_CTL_OUTEN</name>
              <description>Output enable for PMIC enable pin.  Set this bit high to enable the driver on this pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_CTL_POLARITY</name>
              <description>Polarity used to enable the PMIC.  The sequencer uses REGHC_PMIC_CTL_POLARITY to enable the PMIC, and it uses the complement to disable the PMIC.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_INEN</name>
              <description>Input buffer enable for PMIC status input.  Set this bit high to enable the input receiver.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_POLARITY</name>
              <description>The polarity used to trigger a reset action based on the PMIC status input.  The reset system triggers a reset when the unmasked PMIC status matches this value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_WAIT</name>
              <description>Wait count in 4us steps after PMIC status ok.  This is used by the hardware sequencer to allow additional settling time before disabling the internal regulator.  The LSB is 32 IMO periods which results in a nominal LSB step of 4us.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_TRANS_USE_OCD</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_CONFIGURED</name>
              <description>Indicates the REGHC has been configured.  This is used to know if REGHC should be enabled in response to a debug power up request.  It is recommended to not change REGHC settings after REGHC_CONFIGURED is set high, because it can cause failure if REGHC is enabled or transitioning.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_STATUS</name>
          <description>REGHC Status Register</description>
          <addressOffset>0x102C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80001307</resetMask>
          <fields>
            <field>
              <name>REGHC_ENABLED</name>
              <description>Indicates the state of the REGHC enable/disable sequencer.  This bit is only valid when REGHC_SEQ_BUSY==0.
0: REGHC sequencer indicates REGHC is disabled.
1: REGHC sequencer indicates REGHC is enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_OCD_OK</name>
              <description>Indicates the over-current detector is operating and the current drawn from REGHC is within limits.  OCD is only a choice for transistor mode, and it is disabled for PMIC mode.
0: Current measurement exceeds limit or detector is OFF,
1: Current measurement within limit</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_CKT_OK</name>
              <description>Indicates the REGHC circuit is enabled and operating.  It does not indicate that the voltage and current are within required limits for robust operation.
0: REGHC circuit is not ready.  This can occur if the REGHC circuit is disabled or if it was recently enabled.
1: REGHC circuit is enabled and operating.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_UV_OUT</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_OV_OUT</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_OK</name>
              <description>Indicates the PMIC status is ok.  This includes polarity adjustment according to REGHC_PMIC_STATUS_POLARITY.
0: PMIC status is not ok or PMIC input buffer is disabled (REGHC_PMIC_STATUS_INEN==0);
1: PMIC status input buffer is enabled and indicates ok</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_SEQ_BUSY</name>
              <description>Indicates the REGHC enable/disable sequencer is busy transitioning to/from REGHC.
0: Sequencer is not busy;
1: Sequencer is busy either enabling or disabling REGHC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_CTL2</name>
          <description>REGHC Control Register 2</description>
          <addressOffset>0x1030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>REGHC_PMIC_STATUS_TIMEOUT</name>
              <description>Timeout while waiting for REGHC_PMIC_STATUS_OK==1 when switching to PMIC.
0: disables timeout.
&gt;0: enables timeout of REGHC_PMIC_STATUS_TIMEOUT*128us (nominal, clocked by IMO).  Timeout expiration triggers reset.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_EN</name>
              <description>Enable REGHC.  This bit will not set if REGHC_CONFIGURED==0.  Use PWR_REGHC_STATUS.ENABLED to know the actual status of REGHC.  It will differ from this bit in the following cases: 
A) Do not enter DEEPSLEEP while the sequencer is busy (see PWR_REGHC_STATUS.REGHC_SEQ_BUSY).  The hardware sequencer disables REGHC during DEEPSLEEP entry and enables it upon wakeup.
B) The debugger requests the chip remain powered up.  Hardware prevents REGHC from disabling when this bit is cleared.  Hardware does not automatically enable REGHC in response to debugger power up request.  If this bit is low when the debugger deasserts the power up request, the hardware sequencer will disable REGHC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_CTL4</name>
          <description>REGHC Control Register 4</description>
          <addressOffset>0x1038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>REGHC_PMIC_VADJ_DIS</name>
              <description>When operating in PMIC mode, disables the VADJ circuitry.  This can be used to decrease current consumption if the entire feedback network is outside the device.
0: Device generates VADJ when PMIC is enabled.  This allows the feedback loop to compensate for voltage drops in the PCB and package.
1: Device does not generate VADJ, and it must not be part of the PMIC feedback loop.  This reduces current by turning off the internal resistor divider that generates VADJ.  This setting is ineffective when REGHC_PMIC_RADJ_EN==1, and VADJ is generated in that case when PMIC is enabled.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_DPSLP</name>
              <description>When operating in PMIC mode, configures PMIC behavior during DEEPSLEEP. 
0: Device operates from internal regulators during DEEPSLEEP.  If PMIC is enabled at the beginning of the DEEPSLEEP transition, hardware changes to the internal regulators and disables the PMIC.
1: DEEPSLEEP transition does not change PMIC enable.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>PWR_HIB_DATA[%s]</name>
          <description>HIBERNATE Data Register</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_DATA</name>
              <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL</name>
          <description>PMIC Control Register</description>
          <addressOffset>0x10C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x104</resetValue>
          <resetMask>0xBFFF85FC</resetMask>
          <fields>
            <field>
              <name>PMIC_VREF</name>
              <description>PMIC reference voltage setting.  This selects the scaling factor used to generate the output voltage (vout) given the feedback voltage (vfb) for the chosen PMIC.  For a PMIC that compares vfb to an internal reference voltage (vref) according to the formula vout=vref/vfb, select that vref below.  For a PMIC that contains an internal resistor divider and expects an unscaled feedback voltage, use the 'No scaling' choice.
2'b00: Scale for vref=0.9V, use PMIC_VADJ to set the vccd target;
2'b01: Scale for vref=0.8V, use PMIC_VADJ to set the vccd target;
2'b10: Scale for vref=0.6V, use PMIC_VADJ to set the vccd target;
2'b11: No scaling, PMIC_VADJ has no effect</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_VADJ</name>
              <description>Voltage adjustment output setting.  The lookup table in this field requires the proper setting in PMIC_VREF for the chosen PMIC.  This field has no effect when PMIC_VREF selects no scaling.  The feedback tap point is at a vccd pad inside the chip, so the voltage may be a little higher at the PMIC output.  Adjust for die to die variation by adding the signed offset value in SFLASH SRSS_PWR_OFFSET.PMIC_VADJ_OFFSET to desired code in this lookup table: 
0x03: 1.040V, 0x04: 1.049V,
0x05: 1.057V, 0x06: 1.066V,
0x07: 1.074V, 0x08: 1.083V,
0x09: 1.091V, 0x0A: 1.099V,
0x0B: 1.108V, 0x0C: 1.116V,
0x0D: 1.125V, 0x0E: 1.133V,
0x0F: 1.142V, 0x10: 1.150V,
0x11: 1.158V, 0x12: 1.167V,
0x13: 1.175V, 0x14: 1.184V,
0x15: 1.192V, 0x16: 1.201V,
0x17: 1.209V, 0x18: 1.218V,
0x19: 1.226V, 0x1A: 1.234V,
0x1B: 1.243V, 0x1C: 1.251V,
others: Illegal.  Behavior is undefined.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_USE_LINREG</name>
              <description>Controls whether hardware sequencer keeps the internal Active Linear Regulator enabled to improve supply supervision of vccd.  When using this feature, if the PMIC fails to keep vccd above the internal regulator target, then the internal regulator will attempt to recover vccd.  If the regulator current is too high, the regulator triggers an over-current detector (OCD) reset.  
0: Internal Active Linear Regulator disabled after PMIC enabled.  OCD is disabled.;
1: Internal Active Linear Regulator kept enabled.  See datasheet for minimum PMIC vccd input to prevent OCD.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_VADJ_BUF_EN</name>
              <description>Analog buffer enable on voltage adjust output.  Write this bit depending on the type of PMIC connected:
0: Bypass buffer.  This connects the resistor divider directly to the output pin.  Use this setting for a PMIC with a high-impedance feedback input, such as those that support a resistor divider on the PCB.  This setting can also be used with a low-impedance PMIC with PMIC_VREF=2'b11 (no scaling).
1: Use analog buffer.  This enables an analog buffer between the resistor divider output and the pin.  The buffer can drive a resistor divider on the PCB that feeds into the PMIC feedback input.  This allows targeting a different PMIC reference voltage from PMIC_VREF choices, while still supporting voltage adjustment using the internal divider.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CTL_OUTEN</name>
              <description>Output enable for PMIC enable pin.  Set this bit high to enable the driver on this pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CTL_POLARITY</name>
              <description>Polarity used to enable the PMIC.  The sequencer uses PMIC_CTL_POLARITY to enable the PMIC, and it uses the complement to disable the PMIC.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_INEN</name>
              <description>Input buffer enable for PMIC status input.  Set this bit high to enable the input receiver.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_POLARITY</name>
              <description>The polarity used to trigger a reset action based on the PMIC status input.  The reset system triggers a reset when the unmasked PMIC status matches this value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_WAIT</name>
              <description>Wait count in 4us steps after PMIC status ok.  This is used by the hardware sequencer to allow additional settling time before disabling the internal regulator.  The LSB is 32 IMO periods which results in a nominal LSB step of 4us.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CONFIGURED</name>
              <description>Indicates the PMIC has been configured.  This is used to know if PMIC should be enabled in response to a debug power up request.  Do not change PMIC settings after this bit is set high.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_STATUS</name>
          <description>PMIC Status Register</description>
          <addressOffset>0x10C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80001001</resetMask>
          <fields>
            <field>
              <name>PMIC_ENABLED</name>
              <description>Indicates the state of the PMIC enable/disable sequencer.  This bit is only valid when PMIC_SEQ_BUSY==0.
0: PMIC sequencer indicates PMIC is disabled.
1: PMIC sequencer indicates PMIC is enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_STATUS_OK</name>
              <description>Indicates the PMIC status is ok.  This includes polarity adjustment according to PMIC_STATUS_POLARITY.
0: PMIC status is not ok or PMIC input buffer is disabled (PMIC_STATUS_INEN==0);
1: PMIC status input buffer is enabled and indicates ok</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_SEQ_BUSY</name>
              <description>Indicates the PMIC enable/disable sequencer is busy transitioning to/from PMIC.
0: Sequencer is not busy;
1: Sequencer is busy either enabling or disabling PMIC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL2</name>
          <description>PMIC Control Register 2</description>
          <addressOffset>0x10C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>PMIC_STATUS_TIMEOUT</name>
              <description>Timeout while waiting for PMIC_STATUS_OK==1 when switching to PMIC.
0: disables timeout.  Do not change this register after setting PWR_PMIC_CTL.PMIC_CONFIGURED.
&gt;0: enables timeout of PMIC_STATUS_TIMEOUT*128us (nominal, clocked by IMO).  Timeout expiration triggers reset.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN</name>
              <description>Enable PMIC.  This bit will not set if PMIC_CONFIGURED==0.  Use PWR_PMIC_STATUS.ENABLED to know the actual status of PMIC.  It will differ from this bit in the following cases: 
A) Do not enter DEEPSLEEP while the sequencer is busy (see PWR_PMIC_STATUS.PMIC_SEQ_BUSY).  The hardware sequencer disables PMIC during DEEPSLEEP entry and enables it upon wakeup.
B) The debugger requests the chip remain powered up.  Hardware prevents PMIC from disabling when this bit is cleared.  Hardware does not automatically enable PMIC in response to debugger power up request.  If this bit is low when the debugger deasserts the power up request, the hardware sequencer will disable PMIC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL4</name>
          <description>PMIC Control Register 4</description>
          <addressOffset>0x10D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>PMIC_VADJ_DIS</name>
              <description>Disables the VADJ circuitry.  This can be used to decrease current consumption if the entire feedback network is outside the device.
0: Device generates VADJ when PMIC is enabled.  This allows the feedback loop to compensate for voltage drops in the PCB and package.
1: Device does not generate VADJ, and it must not be part of the PMIC feedback loop.  This reduces current by turning off the internal resistor divider that generates VADJ.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_DPSLP</name>
              <description>Configures PMIC behavior during DEEPSLEEP. 
0: Device operates from internal regulators during DEEPSLEEP.  If PMIC is enabled at the beginning of the DEEPSLEEP transition, hardware changes to the internal regulators and disables the PMIC.
1: DEEPSLEEP transition does not change PMIC enable.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PATH_SELECT[%s]</name>
          <description>Clock Path Select Register</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PATH_MUX</name>
              <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_MUX</name>
                  <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO - Low-Power External-Crystal Oscillator</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_ROOT_SELECT[%s]</name>
          <description>Clock Root Select Register</description>
          <addressOffset>0x1240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000013F</resetMask>
          <fields>
            <field>
              <name>ROOT_MUX</name>
              <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_PATH_SELECT[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PATH0</name>
                  <description>Select PATH0 (can be configured for FLL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH1</name>
                  <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH2</name>
                  <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH3</name>
                  <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH4</name>
                  <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH5</name>
                  <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH6</name>
                  <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH7</name>
                  <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH8</name>
                  <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH9</name>
                  <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH10</name>
                  <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH11</name>
                  <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH12</name>
                  <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH13</name>
                  <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH14</name>
                  <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH15</name>
                  <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROOT_DIV</name>
              <description>Selects predivider value for this clock root and DSI input.  This divider is after DIRECT_MUX.  For products with DSI, the output of this mux is routed to DSI for use as a signal.  For products with clock supervision, the output of this mux is the monitored clock for CSV_HF&lt;k&gt;.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIRECT_MUX</name>
              <description>Direct selection mux that allows IMO to bypass most of the clock mux structure.    For products with multiple regulators, this mux can be used to reduce current without requiring significant reconfiguration of the clocking network.  The default value of HFCLK&lt;0&gt;==ROOT_MUX, and the default value for other clock trees is product-specific.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Select IMO</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ROOT_MUX</name>
                  <description>Select ROOT_MUX selection</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CSV_HF</name>
          <description>Clock Supervisor (CSV) registers for Root clocks</description>
          <headerStructName>CSV_HF</headerStructName>
          <addressOffset>0x00001400</addressOffset>
          <cluster>
            <dim>8</dim>
            <dimIncrement>16</dimIncrement>
            <name>CSV[%s]</name>
            <description>Active domain Clock Supervisor (CSV) registers</description>
            <headerStructName>CSV_HF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC000FFFF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_ACTION</name>
                  <description>Specifies the action taken when an anomaly is detected on the monitored clock.  CSV in DeepSleep domain always do a Fault report (which also wakes up the system).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Do a Fault report.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RESET</name>
                      <description>Cause a power reset. This should only be used for clk_hf0.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock selection register</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07</resetMask>
          <fields>
            <field>
              <name>LFCLK_SEL</name>
              <description>Select source for LFCLK.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO0</name>
                  <description>ILO0 - Internal Low-speed Oscillator #0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator.  Requires Backup domain to be present and properly configured (including external watch crystal, if used).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO. If present, it works in DEEPSLEEP and higher modes.  Does not work in HIBERNATE mode.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO_PRESCALER - External-Crystal Oscillator after prescaling, if present.  Does not work in DEEPSLEEP or HIBERNATE modes.  Intended for applications that operate in ACTIVE/SLEEP modes only.  This option is only valid when ECO is present in the product.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO_PRESCALER - Low-Power External-Crystal Oscillator after prescaling, if present.  This choice works in ACTIVE/SLEEP/DEEPSLEEP modes.  This option is only valid when LPECO is present in the product.</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>N/A</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP_DIV</name>
              <description>N/A</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_ENABLE</name>
              <description>N/A</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO0_CONFIG</name>
          <description>ILO0 Configuration</description>
          <addressOffset>0x1508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000001</resetMask>
          <fields>
            <field>
              <name>ILO0_BACKUP</name>
              <description>This register indicates that ILO0 should stay enabled during XRES and HIBERNATE modes.  If backup voltage domain is implemented on the product, this bit also indicates if ILO0 should stay enabled through power-related resets on other supplies, e.g.. BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  This register is reset when the backup logic resets.
0: ILO0 turns off during XRES, HIBERNATE, and power-related resets.  ILO0 configuration and trims are reset by these events.
1: ILO0 stays enabled, as described above.  ILO0 configuration and trims are not reset by these events.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO0_MON_ENABLE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.

HT-variant: This register will not clear unless PWR_CTL2.BGREF_LPMODE==0. After enabling, the first ILO0 cycle occurs within 12us and is +/-10 percent accuracy.  Thereafter, ILO0 is +/-5 percent accurate.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO1_CONFIG</name>
          <description>ILO1 Configuration</description>
          <addressOffset>0x150C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>ILO1_MON_ENABLE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO1.

HT-variant: After enabling, the first ILO1 cycle occurs within 12us and is +/-10 percent accuracy.  Thereafter, ILO1 is +/-5 percent accurate.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x1518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the IMO during DEEPSLEEP, HIBERNATE, and XRES.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG</name>
          <description>ECO Configuration Register</description>
          <addressOffset>0x151C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x98000002</resetMask>
          <fields>
            <field>
              <name>AGC_EN</name>
              <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by CLK_ECO_CONFIG2.ATRIM.  When low, the amplitude is not explicitly controlled and can be as high as the vddd supply.  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_DIV_DISABLE</name>
              <description>ECO prescaler disable command (mutually exclusive with ECO_DIV_ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
HW sets ECO_DIV_DISABLE field to '0' immediately and HW sets CLK_ECO_PRESCALE.ECO_DIV_EN field to '0' immediately.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_DIV_ENABLE</name>
              <description>ECO prescaler enable command (mutually exclusive with ECO_DIV_DISABLE). ECO Prescaler only works in ACTIVE and SLEEP modes.  SW sets this field to '1' to enable the divider and HW sets this field to '0' to indicate that divider enabling has completed. When the divider is enabled, its integer and fractional counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the ECO_DIV_DISABLE field.
1: Configure CLK_ECO_PRESCALE registers.
2: Enable the divider using the ECO_DIV_ENABLE field.
 
HW sets the ECO_DIV_ENABLE field to '0' when the enabling is performed and HW set CLK_ECO_PRESCALER.ENABLED to '1' when the enabling is performed.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_EN</name>
              <description>Master enable for ECO oscillator.  Configure the settings in CLK_ECO_CONFIG2 to work with the selected crystal, before enabling ECO.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_PRESCALE</name>
          <description>ECO Prescaler Configuration Register</description>
          <addressOffset>0x1520</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF01</resetMask>
          <fields>
            <field>
              <name>ECO_DIV_ENABLED</name>
              <description>ECO prescaler enabled. HW sets this field to '1' as a result of an CLK_ECO_CONFIG.ECO_DIV_ENABLE command. HW sets this field to '0' as a result on a CLK_ECO_CONFIG.ECO_DIV_DISABLE command.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_FRAC_DIV</name>
              <description>8-bit fractional value, sufficient to get prescaler output within the +/-65ppm calibration range.  Do not change this setting when ECO Prescaler is enabled.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_INT_DIV</name>
              <description>10-bit integer value allows for ECO frequencies up to 33.55MHz.  Subtract one from the desired divide value when writing this field.  For example, to divide by 1, write ECO_INT_DIV=0.  Do not change this setting when ECO Prescaler is enabled.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_STATUS</name>
          <description>ECO Status Register</description>
          <addressOffset>0x1524</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ECO_OK</name>
              <description>Indicates the ECO internal oscillator circuit has sufficient amplitude.  It may not meet the PPM accuracy or duty cycle spec.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_READY</name>
              <description>Indicates the ECO internal oscillator circuit has had enough time to fully stabilize.  This is the output of a counter since ECO was enabled, and it does not check the ECO output.  It is recommended to also confirm ECO_OK==1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_PILO_CONFIG</name>
          <description>Precision ILO Configuration Register</description>
          <addressOffset>0x1528</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xE00003FF</resetMask>
          <fields>
            <field>
              <name>PILO_FFREQ</name>
              <description>Fine frequency trim allowing +/-250ppm accuracy with periodic calibration.  The nominal step size of the LSB is 8Hz.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_CLK_EN</name>
              <description>Enable the PILO clock output.  See PILO_EN field for required sequencing.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RESET_N</name>
              <description>Reset the PILO.  See PILO_EN field for required sequencing.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_EN</name>
              <description>Enable PILO.  When enabling PILO, set PILO_EN=1, wait 1ms, then PILO_RESET_N=1 and PILO_CLK_EN=1.  When disabling PILO, clear PILO_EN=0, PILO_RESET_N=0, and PLO_CLK_EN=0 in the same write cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG</name>
          <description>FLL Configuration Register</description>
          <addressOffset>0x1530</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x8103FFFF</resetMask>
          <fields>
            <field>
              <name>FLL_MULT</name>
              <description>Multiplier to determine CCO frequency in multiples of the frequency of the selected reference clock (Fref).

Ffll = (FLL_MULT)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV+1)</description>
              <bitRange>[17:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: no division
1: divide by 2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_ENABLE</name>
              <description>Master enable for FLL.  The FLL requires firmware sequencing when enabling and disabling.  Hardware handles sequencing automatically when entering/exiting DEEPSLEEP.

To enable the FLL, use the following sequence:
1) Configure FLL and CCO settings.  Do not modify CLK_FLL_CONFIG3.BYPASS_SEL (must be AUTO) or CLK_FLL_CONFIG.FLL_ENABLE (must be 0).
2) Enable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=1
3) Wait until CLK_FLL_STATUS.CCO_READY==1.
4) Ensure the reference clock has stabilized.
5) Write FLL_ENABLE=1.
6) Optionally wait until CLK_FLL_STATUS.LOCKED==1.  The hardware automatically changes to the FLL output when LOCKED==1.

To disable the FLL, use the following sequence:
1) Write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF.
2) Read CLK_FLL_CONFIG3.BYPASS_SEL to ensure the write completes (read is not optional).  
3) Wait at least ten cycles of either FLL reference clock or FLL output clock, whichever is slower.  It is recommended to use a HW counter (e.g. clock calibration counter, event generator) running on the slower clock.
4) Disable FLL with FLL_ENABLE=0.  
5) Disable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=0.
6) Write CLK_FLL_CONFIG3.BYPASS_SEL=AUTO.
7) Read CLK_FLL_CONFIG3.BYPASS_SEL to ensure the write completes (read is not optional).  
8) Wait three cycles of FLL reference clock. It is recommended to use a HW counter (e.g. clock calibration counter, event generator) running on the reference clock.

0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG2</name>
          <description>FLL Configuration Register 2</description>
          <addressOffset>0x1534</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20001</resetValue>
          <resetMask>0xFFFF1FFF</resetMask>
          <fields>
            <field>
              <name>FLL_REF_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
8191: divide by 8191</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_TOL</name>
              <description>Lock tolerance sets the error threshold for when the FLL output is considered locked to the reference input.  A high tolerance can be used to lock more quickly or allow less accuracy.  The tolerance is the allowed difference between the count value for the ideal formula and the measured value. 
0: tolerate error of 1 count value
1: tolerate error of 2 count values
...
255: tolerate error of 256 count values</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDATE_TOL</name>
              <description>Update tolerance sets the error threshold for when the FLL will update the CCO frequency settings.  The update tolerance is the allowed difference between the count value for the ideal formula and the measured value. UPDATE_TOL should be less than LOCK_TOL.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG3</name>
          <description>FLL Configuration Register 3</description>
          <addressOffset>0x1538</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2800</resetValue>
          <resetMask>0x301FFFFF</resetMask>
          <fields>
            <field>
              <name>FLL_LF_IGAIN</name>
              <description>FLL Loop Filter Gain Setting #1.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_LF_PGAIN</name>
              <description>FLL Loop Filter Gain Setting #2.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SETTLING_COUNT</name>
              <description>Number of undivided reference clock cycles to wait after changing the CCO trim until the loop measurement restarts.  A delay allows the CCO output to settle and gives a more accurate measurement.  The default is tuned to an 8MHz reference clock since the IMO is expected to be the most common use case.
0: no settling time
1: wait one reference clock cycle
...
8191: wait 8191 reference clock cycles</description>
              <bitRange>[20:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after FLL output.  This register can be written while the FLL is enabled.  When changing BYPASS_SEL, do not turn off the reference clock or CCO clock for five cycles (whichever is slower).  In case of disabling FLL(FLL_ENABLE=0), additional five cycles are required. Refer to FLL disable sequence for more details in CLK_FLL_CONFIG-&gt;FLL_ENABLE.  Whenever BYPASS_SEL is changed, it is required to read CLK_FLL_CONFIG3 to ensure the change takes effect.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects FLL reference input (bypass mode).  When locked, automatically selects FLL output.  This can allow some processing to occur while the FLL is locking, such as after DEEPSLEEP wakeup.  It is incompatible with clock supervision, because the frequency changes based on the lock signal.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED_OR_NOTHING</name>
                  <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_REF</name>
                  <description>Select FLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_OUT</name>
                  <description>Select FLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG4</name>
          <description>FLL Configuration Register 4</description>
          <addressOffset>0x153C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xC1FF07FF</resetMask>
          <fields>
            <field>
              <name>CCO_LIMIT</name>
              <description>Maximum CCO offset allowed (used to prevent FLL dynamics from selecting an CCO frequency that the logic cannot support)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_RANGE</name>
              <description>Frequency range of CCO</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RANGE0</name>
                  <description>Target frequency is in range [48, 64) MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE1</name>
                  <description>Target frequency is in range [64, 85) MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE2</name>
                  <description>Target frequency is in range [85, 113) MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE3</name>
                  <description>Target frequency is in range [113, 150) MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE4</name>
                  <description>Target frequency is in range [150, 200] MHz</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCO_FREQ</name>
              <description>CCO frequency code.  This is updated by HW when the FLL is enabled.  It can be manually updated to use the CCO in an open loop configuration.  The meaning of each frequency code depends on the range.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_HW_UPDATE_DIS</name>
              <description>Disable CCO frequency update by FLL hardware
0: Hardware update of CCO settings is allowed.  Use this setting for normal FLL operation.
1: Hardware update of CCO settings is disabled.  Use this setting for open-loop FLL operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_ENABLE</name>
              <description>Enable the CCO.  It is required to enable the CCO before using the FLL.  
0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_STATUS</name>
          <description>FLL Status Register</description>
          <addressOffset>0x1540</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>FLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the FLL is enabled and goes out of lock.  This bit stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_READY</name>
              <description>This indicates that the CCO is internally settled and ready to use.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG2</name>
          <description>ECO Configuration Register 2</description>
          <addressOffset>0x1544</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x7FF7</resetMask>
          <fields>
            <field>
              <name>WDTRIM</name>
              <description>Watch Dog Trim.  Sets the minimum oscillation amplitude (Vp) for the crystal drive level.  The minimum amplitude detector output is readable in CLK_ECO_STATUS.ECO_OK.
0x0: Vp &gt; 0.05V
0x1: Vp &gt; 0.10V
0x2: Vp &gt; 0.15V
0x3: Vp &gt; 0.20V
0x4: Vp &gt; 0.25V
0x5: Vp &gt; 0.30V
0x6: Vp &gt; 0.35V
0x7: Vp &gt; 0.40V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIM</name>
              <description>Amplitude trim.  Sets maximum oscillation amplitude (Vp) to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  When AGC_EN=0, most values of this register are unused, except as noted.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
0x0: Vp &lt; 0.35V
0x1: Vp &lt; 0.40V
0x2: Vp &lt; 0.45V
0x3: Vp &lt; 0.50V
0x4: Vp &lt; 0.55V
0x5: Vp &lt; 0.60V
0x6: Vp &lt; 0.65V
0x7: Vp &lt; 0.70V
0x8: Vp &lt; 0.75V
0x9: Vp &lt; 0.80V
0xA: Vp &lt; 0.85V
0xB: Vp &lt; 0.90V
0xC: Vp &lt; 0.95V
0xD: Vp &lt; 1.00V
0xE: Vp &lt; 1.05V
0xF: Vp &lt; 1.10V when AGC_EN=1.  When AGC_EN=0, this setting enables maximum swing between vddd and vssd.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FTRIM</name>
              <description>Filter Trim - 3rd harmonic oscillation</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTRIM</name>
              <description>Feedback resistor Trim</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GTRIM</name>
              <description>Gain Trim - Startup time.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_CONFIG[%s]</name>
          <description>PLL Configuration Register</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20116</resetValue>
          <resetMask>0xBE1F1F7F</resetMask>
          <fields>
            <field>
              <name>FEEDBACK_DIV</name>
              <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-21: illegal (undefined behavior)
22: divide by 22
...
112: divide by 112
&gt;112: illegal (undefined behavior)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFERENCE_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
20: divide by 20
others: illegal (undefined behavior)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior) 
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_DELAY</name>
              <description>N/A</description>
              <bitRange>[26:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LF_MODE</name>
              <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
0: VCO frequency is [200MHz, 400MHz]
1: VCO frequency is [170MHz, 200MHz)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.  When changing BYPASS_SEL, do not turn off the reference clock or PLL clock for five cycles (whichever is slower).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.  If ENABLE=0, automatically selects PLL reference input.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED_OR_NOTHING</name>
                  <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.  If ENABLE=0, no clock is output.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_REF</name>
                  <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_OUT</name>
                  <description>Select PLL output.  Ignores lock indicator.  If ENABLE=0, no clock is output.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  

Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled.  When the PLL disables, hardware controls the bypass mux as described in BYPASS_SEL, before disabling the PLL circuit.
1: Block is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_STATUS[%s]</name>
          <description>PLL Status Register</description>
          <addressOffset>0x1640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>PLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSV_REF_SEL</name>
          <description>Select CSV Reference clock for Active domain</description>
          <addressOffset>0x1700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>REF_MUX</name>
              <description>Selects a source for clock clk_ref_hf.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.   It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CSV_REF</name>
          <description>CSV registers for the CSV Reference clock</description>
          <headerStructName>CSV_REF</headerStructName>
          <addressOffset>0x00001710</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>Active domain Clock Supervisor (CSV) registers for CSV Reference clock</description>
            <headerStructName>CSV_REF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC000FFFF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_ACTION</name>
                  <description>Specifies the action taken when an anomaly is detected on the monitored clock.  CSV in DeepSleep domain always do a Fault report (which also wakes up the system).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Do a Fault report.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RESET</name>
                      <description>Cause a power reset. This should only be used for clk_hf0.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSV_LF</name>
          <description>CSV registers for LF clock</description>
          <headerStructName>CSV_LF</headerStructName>
          <addressOffset>0x00001720</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>LF clock Clock Supervisor registers</description>
            <headerStructName>CSV_LF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.
CSV in Backup domain: Clock supervision operates during Hibernate mode, can be configured to wake from Hibernate, and continues operating during reboot.

A CSV error detection is reported to the Fault structure.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF00FF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSV_ILO</name>
          <description>CSV registers for HVILO clock</description>
          <headerStructName>CSV_ILO</headerStructName>
          <addressOffset>0x00001730</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>ILO0 clock DeepSleep domain Clock Supervisor registers</description>
            <headerStructName>CSV_ILO_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.
CSV in Backup domain: Clock supervision operates during Hibernate mode, can be configured to wake from Hibernate, and continues operating during reboot.

A CSV error detection is reported to the Fault structure.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF00FF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x77FF01FF</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A basic WatchDog Timer (WDT) reset has occurred since last power cycle.  ULP products: This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).

For products that support high-voltage cause detection, this bit blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>Fault logging system requested a reset from its Active logic.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_DPSLP_FAULT</name>
              <description>Fault logging system requested a reset from its DeepSleep logic.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_TC_DBGRESET</name>
              <description>Test controller or debugger asserted reset. Only resets debug domain.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>A CPU requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT0</name>
              <description>Multi-Counter Watchdog timer reset #0.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT1</name>
              <description>Multi-Counter Watchdog timer reset #1.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT2</name>
              <description>Multi-Counter Watchdog timer reset #2.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT3</name>
              <description>Multi-Counter Watchdog timer reset #3.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_XRES</name>
              <description>External XRES pin was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDD</name>
              <description>External VDDD supply crossed brown-out limit.  Note that this cause will only be observable as long as the VDDD supply does not go below the POR (power on reset) detection limit.  Below this limit it is not possible to reliably retain information in the device.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDA</name>
              <description>External VDDA supply crossed the brown-out limit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVCCD</name>
              <description>Internal VCCD core supply crossed the brown-out limit.  Note that this detector will detect gross issues with the internal core supply, but may not catch all brown-out conditions.  Functional and timing supervision (CSV, WDT) is provided to create fully failsafe internal crash detection.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDD</name>
              <description>Overvoltage detection on the external VDDD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDA</name>
              <description>Overvoltage detection on the external VDDA supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVCCD</name>
              <description>Overvoltage detection on the internal core VCCD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_ACT_LINREG</name>
              <description>Overcurrent detection on the internal VCCD supply when supplied by the ACTIVE power mode linear regulator.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_DPSLP_LINREG</name>
              <description>Overcurrent detection on the internal VCCD supply when supplied by the DEEPSLEEP power mode linear regulator.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_REGHC</name>
              <description>Overcurrent detection from REGHC (if present).  If REGHC is not present, hardware will never set this bit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PMIC</name>
              <description>PMIC status triggered a reset.  If PMIC control is not present, hardware will never set this bit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PXRES</name>
              <description>PXRES triggered.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_STRUCT_XRES</name>
              <description>Structural reset was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PORVDDD</name>
              <description>Indicator that a POR occurred.  This is a high-voltage cause bit, and hardware clears the other bits when this one is set.  It does not block further recording of other high-voltage causes.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE2</name>
          <description>Reset Cause Observation Register 2</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFFF</resetMask>
          <fields>
            <field>
              <name>RESET_CSV_HF</name>
              <description>Clock supervision logic requested a reset due to loss or frequency violation of a high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_REF</name>
              <description>Clock supervision logic requested a reset due to loss or frequency violation of the reference clock source that is used to monitor the other HF clock sources.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>16</dimIncrement>
          <name>CLK_PLL400M[%s]</name>
          <description>400MHz PLL Configuration Register</description>
          <headerStructName>CLK_PLL400M</headerStructName>
          <addressOffset>0x00001900</addressOffset>
          <register>
            <name>CONFIG</name>
            <description>400MHz PLL Configuration Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x20116</resetValue>
            <resetMask>0xB61F1FFF</resetMask>
            <fields>
              <field>
                <name>FEEDBACK_DIV</name>
                <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-15: illegal (undefined behavior)
16: divide by 16
...
200: divide by 200
&gt;200: illegal (undefined behavior)

When using fractional mode, the jitter specs are met over the restricted range of 27 to 47, inclusive.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REFERENCE_DIV</name>
                <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
16: divide by 16
others: illegal (undefined behavior)

When using fractional mode, the jitter specs are met over the restricted range of 1 to 4, inclusive.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUTPUT_DIV</name>
                <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior) 
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK_DELAY</name>
                <description>N/A</description>
                <bitRange>[26:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS_SEL</name>
                <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.  When changing BYPASS_SEL, do not turn off the reference clock or PLL clock for five cycles (whichever is slower).</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>AUTO</name>
                    <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.  If ENABLE=0, automatically selects PLL reference input.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LOCKED_OR_NOTHING</name>
                    <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.  If ENABLE=0, no clock is output.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PLL_REF</name>
                    <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PLL_OUT</name>
                    <description>Select PLL output.  Ignores lock indicator.  If ENABLE=0, no clock is output.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.

fOUT = (FEEDBACK_DIV + FRAC_EN*FRAC_DIV/2^24)  * (fREF / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled.  When the PLL disables, hardware controls the bypass mux as described in BYPASS_SEL, before disabling the PLL circuit.
1: Block is enabled</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG2</name>
            <description>400MHz PLL Configuration Register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0FFFFFF</resetMask>
            <fields>
              <field>
                <name>FRAC_DIV</name>
                <description>Control bits for fractional divider.  This value is interpreted as a fraction of the PFD frequency, i.e. fPFD * (FRAC_DIV/2^24).  This field can be dynamically updated within the 1000ppm control limit. It takes up to 115 AHB cycles to transfer the setting to the PLL, and writes that occur faster may be silently ignored and require the application to write again after the previous update has finished.  Reading the register returns the accepted value.  The PLL will start targeting the new value, but it may take significant time (milliseconds) to stabilize at the new average value.  Do not change the FRAC_DIV setting while the PLL is initially locking.</description>
                <bitRange>[23:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAC_DITHER_EN</name>
                <description>N/A</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAC_EN</name>
                <description>Enables fractional division mode.  When using fractional division mode, see CLK_PLL400M_CONFIG.LOCK_DELAY for an additional configuration requirement.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG3</name>
            <description>400MHz PLL Configuration Register 3</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x910703FF</resetMask>
            <fields>
              <field>
                <name>SSCG_DEPTH</name>
                <description>N/A</description>
                <bitRange>[9:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_RATE</name>
                <description>N/A</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_DITHER_EN</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_MODE</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_EN</name>
                <description>Enables spreading mode.  When using spreading, see CLK_PLL400M_CONFIG.LOCK_DELAY for an additional configuration requirement.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>400MHz PLL Status Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>LOCKED</name>
                <description>PLL Lock Indicator</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>UNLOCK_OCCURRED</name>
                <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CLK_TRIM_ILO0_CTL</name>
          <description>ILO0 Trim Register</description>
          <addressOffset>0x3014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x52C</resetValue>
          <resetMask>0xF3F</resetMask>
          <fields>
            <field>
              <name>ILO0_FTRIM</name>
              <description>ILO0 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO0_MONTRIM</name>
              <description>ILO0 internal monitor trim.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_PWRSYS_CTL</name>
          <description>Power System Trim Register</description>
          <addressOffset>0x3108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x17</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>ACT_REG_TRIM</name>
              <description>Trim for the Active-Regulator.  This sets the output voltage level.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  The nominal output voltage is vccd=812.5mV + ACT_REG_TRIM*12.5mV.  The actual output voltage will vary depending on conditions and load.  The following settings are explicitly shown for convenience, and other values may be calculated using the formula:
5'h07: 900mV (nominal)
5'h17: 1100mV (nominal)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REG_BOOST</name>
              <description>Controls the tradeoff between output current and internal operating current for the Active Regulator.  The maximum output current depends on the silicon implementation, but an application may limit its maximum current to less than that.  This may allow a reduction in the internal operating current of the regulator.  The regulator internal operating current depends on the boost setting:
2'b00: 50uA
2'b01: 100uA
2'b10: 150uA
2'b11: 200uA

The allowed setting is a lookup table based on the chip-specific maximum (set in factory) and an application-specific maximum (set by customer).  The defaults are set assuming the application consumes the maximum allowed by the chip.
50mA chip: 2'b00 (default);
100mA chip: 2'b00 (default);
150mA chip: 50..100mA app =&gt; 2'b00, 150mA app =&gt; 2'b01 (default);
200mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200mA app =&gt; 2'b10 (default);
250mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200..250mA app =&gt; 2'b10 (default);
300mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01, 200..250mA app =&gt; 2'b10, 300mA app =&gt; 2'b11 (default);

This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL</name>
          <description>PILO Trim Register</description>
          <addressOffset>0x3114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108500F</resetValue>
          <resetMask>0x7DFF703F</resetMask>
          <fields>
            <field>
              <name>PILO_CFREQ</name>
              <description>Coarse frequency trim to meet 32.768kHz +/-2 percent across PVT without calibration.  The nominal step size of the LSB is 1kHz.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_OSC_TRIM</name>
              <description>Trim for current in oscillator block.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_COMP_TRIM</name>
              <description>Trim for comparator bias current.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_NBIAS_TRIM</name>
              <description>Trim for biasn by trimming sub-Vth NMOS width in beta-multiplier</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RES_TRIM</name>
              <description>Trim for beta-multiplier branch current</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_ISLOPE_TRIM</name>
              <description>Trim for beta-multiplier current slope</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_VTDIFF_TRIM</name>
              <description>Trim for VT-DIFF output (internal power supply)</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL2</name>
          <description>PILO Trim Register 2</description>
          <addressOffset>0x3118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xDA10E0</resetValue>
          <resetMask>0xFF1FFF</resetMask>
          <fields>
            <field>
              <name>PILO_VREF_TRIM</name>
              <description>Trim for voltage reference</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREFBM_TRIM</name>
              <description>Trim for beta-multiplier current reference</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREF_TRIM</name>
              <description>Trim for current reference</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL3</name>
          <description>PILO Trim Register 3</description>
          <addressOffset>0x311C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4800</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PILO_ENGOPT</name>
              <description>Engineering options for PILO circuits
0: Short vdda to vpwr
1: Beta:mult current change
2: Iref generation Ptat current addition
3: Disable current path in secondary Beta:mult startup circuit
4: Double oscillator current
5: Switch between deep:sub:threshold and sub:threshold stacks in Vref generation block
6: Spare
7: Ptat component increase in Iref
8: vpwr_rc and vpwr_dig_rc shorting testmode
9: Switch b/w psub connection for cascode nfet for vref generation
10: Switch between sub:threshold and deep:sub:threshold stacks in comparator.
15-11: Frequency fine trim.  See AKK-444 for an overview of the trim strategy.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO1_CTL</name>
          <description>ILO1 Trim Register</description>
          <addressOffset>0x3220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x52C</resetValue>
          <resetMask>0xF3F</resetMask>
          <fields>
            <field>
              <name>ILO1_FTRIM</name>
              <description>ILO1 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO1_MONTRIM</name>
              <description>ILO1 internal monitor trim.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>256</dimIncrement>
          <name>MCWDT[%s]</name>
          <description>Multi-Counter Watchdog Timer</description>
          <headerStructName>MCWDT</headerStructName>
          <addressOffset>0x00008000</addressOffset>
          <cluster>
            <dim>2</dim>
            <dimIncrement>32</dimIncrement>
            <name>CTR[%s]</name>
            <description>MCWDT Configuration for Subcounter 0 and 1</description>
            <headerStructName>MCWDT_CTR</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CTL</name>
              <description>MCWDT Subcounter Control Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000001</resetMask>
              <fields>
                <field>
                  <name>ENABLED</name>
                  <description>Indicates actual state of this subcounter.  May lag ENABLE by up to two clk_lf cycles.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ENABLE</name>
                  <description>Enable subcounter.  May take up to 2 clk_lf cycles to take effect.  When ENABLE changes from 1-&gt;0, the counter is cleared.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LOWER_LIMIT</name>
              <description>MCWDT Subcounter Lower Limit Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER_LIMIT</name>
                  <description>Lower limit for this MCWDT subcounter.  See LOWER_ACTION.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>UPPER_LIMIT</name>
              <description>MCWDT Subcounter Upper Limit Register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>UPPER_LIMIT</name>
                  <description>Upper limit for this MCWDT subcounter.  See UPPER_ACTION.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>WARN_LIMIT</name>
              <description>MCWDT Subcounter Warn Limit Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WARN_LIMIT</name>
                  <description>Warn limit for this MCWDT subcounter.  See WARN_ACTION.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CONFIG</name>
              <description>MCWDT Subcounter Configuration Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xD0001133</resetMask>
              <fields>
                <field>
                  <name>LOWER_ACTION</name>
                  <description>Action taken if this watchdog is serviced before LOWER_LIMIT is reached.  LOWER_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected and/or when the corresponding processor is in SLEEPDEEP.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NOTHING</name>
                      <description>Do nothing</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Trigger a fault.  It can take up to 3 clk_lf cycles for the fault to be transferred to the fault manager.
For LOWER_LIMIT &gt;= 1: The action is triggered on same edge when it meets this condition.
For LOWER_LIMIT == 0: No action is triggered.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FAULT_THEN_RESET</name>
                      <description>Trigger a fault.  Further, trigger a system-wide reset if the fault is not serviced and the watchdog is not cleared within 6 clk_lf cycles.  It can take up to 3 clk_lf cycles for the fault to be transferred to the fault manager, which gives at least 3 clk_lf cycles for software to respond.
For LOWER_LIMIT &gt;= 1: The action is triggered on same edge when it meets this condition.
For LOWER_LIMIT == 0: No action is triggered.</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UPPER_ACTION</name>
                  <description>Action taken if this watchdog is not serviced before UPPER_LIMIT is reached.  The counter stops counting when UPPER_LIMIT is reached, regardless of UPPER_ACTION setting.  UPPER_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NOTHING</name>
                      <description>Do nothing</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Trigger a fault.
For UPPER_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For UPPER_LIMIT &lt; 2: The action may take up to one extra clk_lf cycle to trigger.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FAULT_THEN_RESET</name>
                      <description>Trigger a fault.  Further, trigger a system-wide reset if the fault is not serviced and the watchdog is not cleared within 6 clk_lf cycles.  It can take up to 3 clk_lf cycles for the fault to be transferred to the fault manager, which gives at least 3 clk_lf cycles for software to respond.
For UPPER_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For UPPER_LIMIT &lt; 2: The action may take up to one extra clk_lf cycle to trigger.</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>WARN_ACTION</name>
                  <description>Action taken when the count value reaches WARN_LIMIT.  The minimum setting to achieve a periodic interrupt is WARN_LIMIT==1.  A setting of zero will trigger once but not periodically.
For WARN_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For WARN_LIMIT == [0,1]  : The action may take up to one extra clk_lf cycle to trigger.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NOTHING</name>
                      <description>Do nothing</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INT</name>
                      <description>Trigger an interrupt.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>AUTO_SERVICE</name>
                  <description>Automatically service when the count value reaches WARN_LIMIT.  This allows creation of a periodic interrupt if this counter is not needed as a watchdog.  This field is ignored when LOWER_ACTION&lt;&gt;NOTHING or when UPPER_ACTION&lt;&gt;NOTHING.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEBUG_TRIGGER_EN</name>
                  <description>Enables the trigger input for this MCWDT to pause the counter during debug mode.  To pause at a breakpoint while debugging, configure the trigger matrix to connect the related CPU halted signal to the trigger input for this MCWDT, and then set this bit.  It takes up to two clk_lf cycles for the trigger signal to be processed.  Triggers that are less than two clk_lf cycles may be missed.  Synchronization errors can accumulate each time it is halted.
0: Pauses the counter whenever a debug probe is connected.
1: Pauses the counter whenever a debug probe is connected and the trigger input is high.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SLEEPDEEP_PAUSE</name>
                  <description>Pauses/runs this counter when the corresponding processor is in SLEEPDEEP.  Note it may take up to two clk_lf cycles for the counter to pause and up to two clk_lf cycles for it to unpause, due to internal synchronization.  After wakeup, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.
0: Counter runs normally regardless of processor mode.
1: Counter pauses when corresponding processor is in SLEEPDEEP.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEBUG_RUN</name>
                  <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_lf cycles for the counter to pause, due to internal synchronization.  

When (DEBUG_RUN==1 or DEBUG_TRIGGER_EN==0) and the debugger is connected for at least two clk_lf cycles, the LOWER_ACTION is ignored until after the first service after the debugger is disconnected.  After the debugger is disconnected, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.  If the debugger is disconnected before two clk_lf cycles, the LOWER_ACTION may or may not be ignored.

0: When debugger connected, counter pauses incrementing as configured in DEBUG_TRIGGER_EN.  
1: When debugger connected, counter increments normally, but reset generation is blocked.  To block LOWER_ACTION fault generation, write DEBUG_TRIGGER_EN==0.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CNT</name>
              <description>MCWDT Subcounter Count Register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CNT</name>
                  <description>Current value of subcounter for this MCWDT.  This field may lag the actual count value by up to one clk_lf cycle, due to internal synchronization.  When this subcounter is disabled and unlocked, the count value can be written for verification and debugging purposes.  Software writes are always ignored when the subcounter is enabled.This register retains information during DeepSleep mode if SLEEPDEEP_PAUSE == 1.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>CPU_SELECT</name>
            <description>MCWDT CPU selection register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>CPU_SEL</name>
                <description>Assigns this MCWDT to a CPU.  This selects which CPU SLEEPDEEP signal is used for SLEEPDEEP_PAUSE.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTR2_CTL</name>
            <description>MCWDT Subcounter 2 Control register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Indicates actual state of this subcounter.  May lag ENABLE by up to two clk_lf cycles.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Enable subcounter.  May take up to 2 clk_lf cycles to take effect.  When ENABLE changes from 1-&gt;0, the counter is cleared.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTR2_CONFIG</name>
            <description>MCWDT Subcounter 2 Configuration register</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xD01F0001</resetMask>
            <fields>
              <field>
                <name>ACTION</name>
                <description>Action taken when the specified BIT toggles.
Action will be triggered on the same edge where BITS to observe toggle.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Trigger an interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BITS</name>
                <description>Bit to observe for a toggle:
0: Do ACTION after CNT[0] toggles (i.e. every tick)
.
31: Do ACTION after CNT[31] toggles (i.e. every 2^31 ticks)</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_TRIGGER_EN</name>
                <description>Enables the trigger input for this MCWDT to pause the counter during debug mode.  To pause at a breakpoint while debugging, configure the trigger matrix to connect the related CPU halted signal to the trigger input for this MCWDT, and then set this bit.  It takes up to two clk_lf cycles for the trigger signal to be processed.  Triggers that are less than two clk_lf cycles may be missed.  Synchronization errors can accumulate each time it is halted.
0: Pauses the counter whenever a debug probe is connected.
1: Pauses the counter whenever a debug probe is connected and the trigger input is high.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEEPDEEP_PAUSE</name>
                <description>Pauses/runs this counter when the corresponding processor is in SLEEPDEEP.  Note it may take up to two clk_lf cycles for the counter to pause and up to two clk_lf cycles for it to unpause, due to internal synchronization.  
0: Counter runs normally regardless of processor mode.
1: Counter pauses when corresponding processor is in SLEEPDEEP.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_RUN</name>
                <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_lf cycles for the counter to pause and another two cycles to unpause, due to internal synchronization.  
0: When debugger connected, counter pauses incrementing as configured in DEBUG_TRIGGER_EN.  
1: When debugger connected, counter increments normally, but reset generation is blocked.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTR2_CNT</name>
            <description>MCWDT Subcounter 2 Count Register</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT2</name>
                <description>Current value of subcounter 2 for this MCWDT.  This field may lag the actual count value by up to one clk_lf cycle, due to internal synchronization.  When this subcounter is disabled and unlocked, the count value can be written for verification and debugging purposes.  Software writes are always ignored when the subcounter is enabled. This register retains information during DeepSleep mode if SLEEPDEEP_PAUSE == 1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>MCWDT Lock Register</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>MCWDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this MCWDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  Each MCWDT has a separate local lock.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SERVICE</name>
            <description>MCWDT Service Register</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>CTR0_SERVICE</name>
                <description>Services subcounter 0.  This resets the count value for subcounter 0 to zero.  This may take up to three clk_lf cycles to take effect.  Hardware clears this bit, after necessary synchronization.  To ensure a pending CTR0_SERVICE write is reflected, firmware should wait until this bit reads low before attempting to write CTR0_SERVICE=1.  If subcounter 0 is disabled, CTR0_SERVICE will not trigger a LOWER_ACTION and will not clear a preloaded count value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR1_SERVICE</name>
                <description>Services subcounter 1.  This resets the count value for subcounter 1 to zero.  This may take up to three clk_lf cycles to take effect.  Hardware clears this bit, after necessary synchronization.  To ensure a pending CTR1_SERVICE write is reflected, firmware should wait until this bit reads low before attempting to write CTR1_SERVICE=1.  If subcounter 1 is disabled, CTR1_SERVICE will not trigger a LOWER_ACTION and will not clear a preloaded count value.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>MCWDT Interrupt Register</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CTR0_INT</name>
                <description>MCWDT Interrupt Request for sub-counter 0.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR1_INT</name>
                <description>MCWDT Interrupt Request for sub-counter 1.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR2_INT</name>
                <description>MCWDT Interrupt Request for sub-counter 2.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>MCWDT Interrupt Set Register</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CTR0_INT</name>
                <description>Set interrupt for MCWDT_INT0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR1_INT</name>
                <description>Set interrupt for MCWDT_INT1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR2_INT</name>
                <description>Set interrupt for MCWDT_INT2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>MCWDT Interrupt Mask Register</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CTR0_INT</name>
                <description>Interrupt Mask for sub-counter 0 for warning interrupt. The bit controls if the interrupt is forwarded to the CPU. The interrupt is blocked when the value of the bit is 0. The interrupt is forwarded if the value of the bit is 1.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR1_INT</name>
                <description>Interrupt Mask for sub-counter 1 for warning interrupt.  The bit controls if the interrupt is forwarded to the CPU. The interrupt is blocked when the value of the bit is 0. The interrupt is forwarded if the value of the bit is 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR2_INT</name>
                <description>Interrupt Mask for sub-counter 2.  The bit controls if the interrupt is forwarded to the CPU. The interrupt is blocked when the value of the bit is 0. The interrupt is forwarded if the value of the bit is 1.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>MCWDT Interrupt Masked Register</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CTR0_INT</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CTR1_INT</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CTR2_INT</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>WDT</name>
          <description>Watchdog Timer</description>
          <headerStructName>WDT</headerStructName>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <name>CTL</name>
            <description>WDT Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000001</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Indicates actual state of watchdog.  May lag ENABLE by up to three clk_ilo0 cycles.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Enable watchdog.  May take up to three clk_ilo0 cycles to take effect.  When ENABLE changes from 1-&gt;0, the counter is cleared.  Do not enter DEEPSLEEP or HIBERNATE mode if ENABLE&lt;&gt;ENABLED.  This can be done by waiting until ENABLE==ENABLED whenever ENABLE is changed.
0: Counter is disabled (not clocked).
1: Counter is enabled (counting up)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOWER_LIMIT</name>
            <description>WDT Lower Limit Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOWER_LIMIT</name>
                <description>Lower limit for watchdog.  See LOWER_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UPPER_LIMIT</name>
            <description>WDT Upper Limit Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UPPER_LIMIT</name>
                <description>Upper limit for watchdog.  See UPPER_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WARN_LIMIT</name>
            <description>WDT Warn Limit Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WARN_LIMIT</name>
                <description>Warn limit for watchdog.  See WARN_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>WDT Configuration Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xF0001111</resetMask>
            <fields>
              <field>
                <name>LOWER_ACTION</name>
                <description>Action taken if this watchdog is serviced before LOWER_LIMIT is reached.  LOWER_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected and/or when the chip is in DEEPSLEEP/HIBERNATE modes.
For LOWER_LIMIT &gt;= 1: The action is triggered on same edge when it meets this condition.
For LOWER_LIMIT == 0: No action is triggered.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Trigger a reset.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UPPER_ACTION</name>
                <description>Action taken if this watchdog is not serviced before UPPER_LIMIT is reached.  The counter stops counting when UPPER_LIMIT is reached, regardless of UPPER_ACTION setting.   UPPER_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected.
For UPPER_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For UPPER_LIMIT &lt; 2: The action may take up to one extra clk_ilo0 cycle to trigger.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Trigger a reset.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WARN_ACTION</name>
                <description>Action taken when the count value reaches WARN_LIMIT.  The minimum setting to achieve a periodic interrupt is WARN_LIMIT==1.  A setting of zero will trigger once but not periodically.
For WARN_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For WARN_LIMIT &lt; 2  : The action may take up to one extra clk_ilo0 cycle to trigger.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Trigger an interrupt.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTO_SERVICE</name>
                <description>Automatically service when the count value reaches WARN_LIMIT.  This allows creation of a periodic interrupt if this counter is not needed as a watchdog.  This field is ignored when LOWER_ACTION&lt;&gt;NOTHING or when UPPER_ACTION&lt;&gt;NOTHING.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_TRIGGER_EN</name>
                <description>Enables the trigger input for WDT to pause the counter during debug mode.  To pause at a breakpoint while debugging, configure the trigger matrix to connect the related CPU halted signal to the trigger input for this WDT, and then set this bit.  It takes up to two clk_ilo0 cycles for the trigger signal to be processed.  Triggers that are less than two clk_ilo0 cycles may be missed.  Synchronization error can accumulate each time it is halted.
0: Pauses the counter whenever a debug probe is connected.
1: Pauses the counter whenever a debug probe is connected and the trigger input is high.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DPSLP_PAUSE</name>
                <description>Pauses/runs this counter when the system is in DEEPSLEEP.  Note it may take up to two clk_ilo0 cycles for the counter to pause, due to internal synchronization.  During DEEPSLEEP wakeup, the pause request is removed when clk_hf0 starts clocking, and then it may take up to two clk_ilo0 cycles for the counter to start.  After wakeup, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.
0: Counter behaves normally during DEEPSLEEP.
1: Counter pauses during DEEPSLEEP.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HIB_PAUSE</name>
                <description>Pauses/runs this counter when the system is in HIBERNATE.  Note it may take up to two clk_ilo0 cycles for the counter to pause, due to internal synchronization.  After wakeup, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.
0: Counter behaves normally during HIBERNATE.
1: Counter pauses during HIBERNATE.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_RUN</name>
                <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_ilo0 cycles for the counter to pause and another two cycles to unpause, due to internal synchronization.  If the debugger is connected for at least two clk_ilo0 cycles, the LOWER_ACTION is ignored until after the first service after the debugger is disconnected.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.  If the debugger is disconnected before two clk_ilo0 cycles, the LOWER_ACTION may or may not be ignored.
0: When debugger connected, counter pauses incrementing as configured in DEBUG_TRIGGER_EN.
1: When debugger connected, counter increments normally, but reset generation is blocked.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNT</name>
            <description>WDT Count Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Current value of subcounter for this WDT.  This field may lag the actual count value by up to one clk_ilo0 cycle, due to internal synchronization.  When this subcounter is disabled and unlocked, the count value can be written for verification and debugging purposes.  Software writes are always ignored when the subcounter is enabled. This register retains information during DeepSleep or Hiberbate mode if DPSLP_PAUSE == 1 or HIB_PAUSE == 1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>WDT Lock register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>WDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this WDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  This register also locks the clk_ilo0 settings.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SERVICE</name>
            <description>WDT Service register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>SERVICE</name>
                <description>Services the watchdog.  This resets the count value to zero.  This may take up to three clk_ilo0 cycle to take effect.  Hardware clears this bit, after necessary synchronization.  To ensure a pending SERVICE write is reflected, firmware should wait until this bit reads low before attempting to write SERVICE=1.  If WDT is disabled, SERVICE will not trigger a LOWER_ACTION and will not clear a preloaded count value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>WDT Interrupt Register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>WDT Interrupt Request.  This bit is set as configured by WDT action and limits.  Due to internal synchronization, it takes up to 8 SYSCLK cycles to update after a W1C or reading this register and during this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>WDT Interrupt Set Register</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Set interrupt.
Due to internal synchronization, it takes up to 8 SYSCLK cycles to update after a W1S or reading from this register and during this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>WDT Interrupt Mask Register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>WDT Interrupt Masked Register</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Logical and of corresponding request and mask bits.
Due to internal synchronization, it takes up to 8 SYSCLK cycles to read from this register.  During this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>BACKUP</name>
      <description>SRSS Backup Domain (ver3)</description>
      <baseAddress>0x40270000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0F3308</resetMask>
          <fields>
            <field>
              <name>WCO_EN</name>
              <description>Watch-crystal oscillator (WCO) enable.  If there is a write in progress when this bit is cleared, the WCO will be internally kept on until the write completes.
After enabling the WCO software must wait until STATUS.WCO_OK=1 before configuring any component that depends on clk_lf/clk_bak, like for example RTC or WDTs.  Follow the procedure in BACKUP_RTC_RW to access this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock select for RTC clock</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-crystal oscillator input, available in Active, DeepSleep, Hibernate, and XRES.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTBAK</name>
                  <description>This allows to use the LFCLK selection as an alternate backup domain clock. Note that LFCLK is only available in Active and DeepSleep power modes.
Note that LFCLK clock glitches can propagate into the backup logic when the clock is stopped.  For this reason, if the WCO or ILO is intended as the clock source then choose it directly instead of routing through LFCLK.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low frequency Oscillator, available in Active, DeepSleep, Hibernate, and XRES.
For Hibernate operation CLK_ILO_CONFIG. ILO_BACKUP must be set.  If there are multiple ILO, this is ILO0.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>Low-power external crystal oscillator prescaler output, available in Active, DeepSleep, Hibernate, and XRES.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRESCALER</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WCO_BYPASS</name>
              <description>Configures the WCO for different board-level connections to the WCO pins.  For example, this can be used to connect an external watch crystal oscillator instead of a watch crystal.   In all cases, the two related GPIO pins (WCO input and output pins) must be configured as analog connections using GPIO registers, and they must be hooked at the board level as described below.  Configure this field before enabling the WCO, and do not change this setting when WCO_EN=1.
0: Watch crystal.  Connect a 32.768 kHz watch crystal between WCO input and output pins.
1: Clock signal, either a square wave or sine wave.  See PRESCALER field for connection information.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDBAK_CTL</name>
              <description>Controls the behavior of the switch that generates vddbak from vbackup or vddd.
0: automatically select vddd if its brownout detector says it is valid.  If the brownout says its not valid, then use vmax which is the highest of vddd or vbackup.
1,2,3: force vddbak and vmax to select vbackup, regardless of its voltage.</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBACKUP_MEAS</name>
              <description>Connect vbackup supply to the vbackup_meas output for measurement by an ADC attached to amuxbusa_adft_vddd.  The vbackup_meas signal is scaled to 10 percent of vbackup, so it is within the supply range of the ADC.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CHARGE_KEY</name>
              <description>When set to 3C, the supercap charger circuit is enabled.  Any other code disables the supercap charger.  THIS CHARGING CIRCUIT IS FOR A SUPERCAP ONLY AND CANNOT SAFELY CHARGE A BATTERY.  DO NOT WRITE THIS KEY WHEN VBACKUP IS CONNECTED TO A BATTERY.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_RW</name>
          <description>RTC Read Write register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>Read bit
When this bit is set the RTC registers will be copied to user registers and frozen so that a coherent RTC value can safely be read. The RTC will keep on running.
Do not set the read bit if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Write bit is set. Do not set the Read bit at the same time that the Write bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE</name>
              <description>Write bit
Only when this bit is set can the RTC registers be written to (otherwise writes are ignored). This bit cannot be set if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Read bit is set or getting set. 
The user writes to the RTC user registers, when the Write bit is cleared by the user then the user registers content is copied to the actual RTC registers. 
Only user RTC registers that were written to will get copied, others will not be affected. 
When the SECONDS field is updated then TICKS will also be reset (WDT is not affected).
When the Write bit is cleared by a reset (brown out/DeepSleep) then the RTC update will be ignored/lost.
Do not set the Write bit if the RTC if the RTC is still busy with a previous update (see RTC_BUSY).  Do not set the Write bit at the same time that the Read bit is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_CTL</name>
          <description>Oscillator calibration for absolute frequency</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xB000007F</resetMask>
          <fields>
            <field>
              <name>CALIB_VAL</name>
              <description>Calibration value for absolute frequency (at a fixed temperature).  Each step causes 128 ticks to be added or removed each hour.  Effectively that means that each step is 1.085ppm (= 128/(60*60*32,768)).
Positive values 0x01-0x3c (1..60) add pulses, negative values remove pulses, thus giving a range of +/-65.1 ppm (limited by 60 minutes per hour, not the range of this field)

Calibration is performed hourly, starting at 59 minutes and 59 seconds, and applied as 64 ticks every 30 seconds until there have been 2*CALIB_VAL adjustments.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CALIB_SIGN</name>
              <description>Calibration sign:
0= Negative sign: remove pulses (it takes more clock ticks to count one second)
1= Positive sign: add pulses (it takes less clock ticks to count one second)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_SEL</name>
              <description>Select calibration wave output signal</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAL512</name>
                  <description>512Hz wave, not affected by calibration setting (not supported for 50/60Hz input clock: CTL.PRESCALER!=0)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL2</name>
                  <description>2Hz wave, includes the effect of the calibration setting, (not supported for 50/60Hz input clock: CTL.PRESCALER!=0)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL1</name>
                  <description>1Hz wave, includes the effect of the calibration setting (supported for all input clocks)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAL_OUT</name>
              <description>Output enable for wave signal for calibration and allow CALIB_VAL to be written.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x5</resetMask>
          <fields>
            <field>
              <name>RTC_BUSY</name>
              <description>Pending RTC write</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WCO_OK</name>
              <description>Indicates that output has transitioned.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TIME</name>
          <description>Calendar Seconds, Minutes, Hours, Day of Week</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x75F3F3F</resetMask>
          <fields>
            <field>
              <name>RTC_SEC</name>
              <description>Calendar seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MIN</name>
              <description>Calendar minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_HOUR</name>
              <description>Calendar hours, value depending on 12/24HR mode
0=24HR: [20:16]=0-23
1=12HR: [20]:0=AM, 1=PM, [19:16]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL_12HR</name>
              <description>Select 12/24HR mode: 1=12HR, 0=24HR</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_DAY</name>
              <description>Calendar Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DATE</name>
          <description>Calendar Day of Month, Month,  Year</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x7F0F1F</resetMask>
          <fields>
            <field>
              <name>RTC_DATE</name>
              <description>Calendar Day of the Month, 1-31
Automatic Leap Year Correction</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MON</name>
              <description>Calendar Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_YEAR</name>
              <description>Calendar year, 0-99</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_TIME</name>
          <description>Alarm 1 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x879FBFBF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours, value depending on 12/24HR mode
24HR: [4:0]=0-23
12HR: [4]:0=AM, 1=PM, [3:0]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_DATE</name>
          <description>Alarm 1 Day of Month, Month</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80008F9F</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month, 1-31
Leap Year corrected</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 1.
0: Alarm 1 is disabled.  Fields for date and time are ignored.
1: Alarm 1 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_TIME</name>
          <description>Alarm 2 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x879FBFBF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours, value depending on 12/24HR mode
24HR: [4:0]=0-23
12HR: [4]:0=AM, 1=PM, [3:0]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_DATE</name>
          <description>Alarm 2 Day of Month, Month</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80008F9F</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month, 1-31
Leap Year corrected</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 2.
0: Alarm 2 is disabled.  Fields for date and time are ignored.
1: Alarm 2 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Alarm 1 Interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Alarm 2 Interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Century overflow interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_CTL</name>
          <description>PMIC control register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0000000</resetValue>
          <resetMask>0xE001FF00</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for PMIC to be disabled.  When the UNLOCK code is not present: writes to PMIC_EN field are ignored and the hardware ignores the value in PMIC_EN.  Do not change PMIC_EN in the same write cycle as setting/clearing the UNLOCK code; do these in separate write cycles.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN_OUTEN</name>
              <description>Output enable for the output driver in the PMIC_EN pad.
0: Output pad is tristate for PMIC_EN pin.  This can allow this pin to be used for another purpose. Tristate condition is kept only if the UNLOCK key (0x3A) is present
1: Output pad is enabled for PMIC_EN pin.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_ALWAYSEN</name>
              <description>Override normal PMIC controls to prevent accidentally turning off the PMIC by errant firmware.
0: Normal operation, PMIC_EN and PMIC_OUTEN work as described
1: PMIC_EN and PMIC_OUTEN are ignored and the output pad is forced enabled.
Note: This bit is a write-once bit until the next backup reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN</name>
              <description>Enable for external PMIC that supplies vddd (if present).  This bit will only clear if UNLOCK was written correctly in a previous write operation and PMIC_ALWAYSEN=0.  When PMIC_EN=0, the system functions normally until vddd is no longer present (OFF w/Backup mode).  Firmware can set this bit, if it does so before vddd is actually removed.  This bit is also set by any RTC alarm or PMIC pin wakeup event regardless of UNLOCK setting.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET</name>
          <description>Backup reset register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Writing 1 to this register resets the backup logic.  Hardware clears it when the reset is complete.  After setting this register, firmware should confirm it reads as 0 before attempting to write other backup registers.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPECO_CTL</name>
          <description>Low-power external crystal oscillator control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xD0001130</resetMask>
          <fields>
            <field>
              <name>LPECO_CRANGE</name>
              <description>Specifies the load capacitance of the chosen crystal.
2'b00: load is in range [5pF, 10pF],
2'b01: load is in range (10pF, 15pF],
2'b10: load is in range (15pF, 20pF],
2'b11: load is in range (20pF, 25pF]</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPECO_FRANGE</name>
              <description>Specifies the crystal frequency range.
0: Crystal frequency is in range [4, 6) MHz
1: Crystal frequency is in range [6, 8] MHz.  Use this setting for 6 MHz.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPECO_AMP_SEL</name>
              <description>Selects the oscillation amplitude.  WARNING: the crystal can be permanently damaged by selecting an amplitude that exceeds the crystal limits.
0: maximum amplitude is 1.35V.  This is the lowest power setting.
1: maximum amplitude is 1.8V.  This is the lowest jitter setting.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPECO_DIV_ENABLE</name>
              <description>LPECO prescaler enable.  Do not set this to '1' when LPECO_EN==0.  SW sets this field to '1' to enable the divider and HW sets this field to '0' to indicate that divider enabling has completed. When the divider is enabled, its integer and fractional counters are initialized to '0'. 
 
HW sets the LPECO_DIV_ENABLE field to '0' when the enabling is performed and HW set CLK_LPECO_PRESCALER.ENABLED to '1' when the enabling is performed.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPECO_AMPDET_EN</name>
              <description>Minimum amplitude detector enable/disable.  Ignored when LPECO_EN==0.
0: Initially enabled, and then automatically disabled when amplitude detector detects sufficient amplitude.
1: Keep minimum amplitude detector enabled as long as LPECO is enabled.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPECO_EN</name>
              <description>Master enable for LPECO oscillator.  This also disables the LPECO prescaler.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPECO_PRESCALE</name>
          <description>Low-power external crystal oscillator prescaler</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF01</resetMask>
          <fields>
            <field>
              <name>LPECO_DIV_ENABLED</name>
              <description>LPECO prescaler enabled. HW sets this field to '1' as a result of an BACKUP_LPECO_CTL.LPECO_DIV_ENABLE.  HW sets this field to '0' as a result of writing CLK_LPECO_CONFIG.LPECO_EN==0.  This field does not update unless LPECO clock is toggling.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LPECO_FRAC_DIV</name>
              <description>Fractional value, sufficient to get prescaler output within the +/-65ppm calibration range.  Do not change this setting when LPECO Prescaler is enabled.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPECO_INT_DIV</name>
              <description>Integer divide value allows for LPECO frequencies up to 8MHz to generate 32768 Hz.  Subtract one from the desired divide value when writing this field.  For example, to divide by 1, write LPECO_INT_DIV=0.  Do not change this setting when LPECO Prescaler is enabled.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPECO_STATUS</name>
          <description>Low-power external crystal oscillator status</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>LPECO_AMPDET_OK</name>
              <description>Indicates sufficient oscillation amplitude reported by LPECO amplitude detector.  This field will read as zero when the amplitude detector is off (see LPECO_CTL.LPECO_AMPDET_EN).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LPECO_READY</name>
              <description>Indicates the LPECO has had enough time to start.  This field is driven by a stabilization counter clocked by IMO.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG[%s]</name>
          <description>Backup register region</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DW0</name>
      <description>Datawire Controller</description>
      <headerStructName>DW</headerStructName>
      <baseAddress>0x40280000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. Disabling the IP activates the IP's Active logic reset: Active logic and non-retention MMIO registers are reset (retention MMIO registers are not affected).
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>Active channel, user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Active channel, secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>B</name>
              <description>Active channel, non-bufferable/bufferable access control:
'0': non-bufferable
'1': bufferable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Active channel protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Active channel priority.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>Active channel preemptable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_IDX</name>
              <description>Active channel index.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the DW controller. 
'0': Default/inactive state.
'1': Loading descriptor.
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': CRC functionality (only used for CRC transfer descriptor type).
'5': Update of active control information (e.g. source and destination addresses) and wait for trigger de-activation.
'6': Error.</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Active channel present: 
'0': No.
'1': Yes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_CTL</name>
          <description>Active descriptor control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_SRC</name>
          <description>Active descriptor source</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_SRC of the currently active descriptor.

Base address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_DST</name>
          <description>Active descriptor destination</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_DST of the currently active descriptor.

Base address of destination location. 

Note: For a CRC transfer descriptor, this field should be programmed with the address of the CRC_LFSR_CTL register. The calculated CRC LFSR state is written to this address (through the CRYPTO AHB-Lite master interface) when the input trigger is processed. The write transfer will be submitted to the CPUSS and PERI protection schemes.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_X_CTL</name>
          <description>Active descriptor X loop control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_X_CTL of the currently active descriptor.

[11:0] SRC_X_INCR
Specifies increment of source address for each X loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the source address is not incremented. This is useful for reading from RX FIFO structures.

[23:12] DST_X_INCR
Specifies increment of destination address for each X loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the destination address is not incremented. This is useful for writing to TX FIFO structures.

Note: this field is not used for CRC transfer descriptors and must be set to '0'.

[31:24] X_COUNT
Number of iterations (minus 1) of the 'X loop' (X_COUNT+1 is the number of single transfers in a 1D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For a single transfer descriptor type, descriptor will not have X_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_Y_CTL</name>
          <description>Active descriptor Y loop control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_Y_CTL of the currently active descriptor.

[11:0] SRC_Y_INCR
Specifies increment of source address for each Y loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[23:12] DST_Y_INCR
Specifies increment of destination address for each Y loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[31:24] Y_COUNT
Number of iterations (minus 1) of the 'Y loop' (X_COUNT+1)*(Y_COUNT+1) is the number of single transfers in a 2D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For single, 1D and CRC transfer descriptor types, descriptor will not have Y_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_NEXT_PTR</name>
          <description>Active descriptor next pointer</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Copy of DESCR_NEXT_PTR of the currently active descriptor.

[31:2] ADDR
Address of next descriptor in descriptor list. When this field is '0', this is the last descriptor in the descriptor list.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_SRC</name>
          <description>Active source</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>Current address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DST</name>
          <description>Active destination</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>Current address of destination location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE0003FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM word address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_LFSR_CTL</name>
          <description>CRC LFSR control</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage (through either CRC_LFSR_CTL or CRC_REM_RESULT).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_CTL.REM_REVERSE and CRC_REM_CTL.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>100</dim>
          <dimIncrement>64</dimIncrement>
          <name>CH_STRUCT[%s]</name>
          <description>DW channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CH_CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000300</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the NS field for the secure/non-secure access control ('hprot[4]').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register;  i.e.  the 'write data' is ignored and instead the context is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel uses the PC field for the protection context.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority group with pending channels is identified. Second, within this priority group, round robin arbitration is applied. Round robin arbitration (within a priority group) gives the highest priority to the lower channel indices (within the priority group).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>Specifies if the channel is preemptable.
'0': Not preemptable.
'1': Preemptable. This field allows higher priority pending channels (from a higher priority group; i.e. an active channel can NOT be preempted by a pending channel in the same priority group) to preempt the active channel in between 'single transfers' (a 1D transfer consists out of X_COUNT single transfers; a 2D transfer consists out of X_COUNT*Y_COUNT single transfers). Preemption will NOT affect the pending status of channel. As a result, after completion of a higher priority activated channel, the current channel may be reactivated.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' on an error interrupt cause (the specific error is specified by CH_STATUS.INTR_CAUSE).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_STATUS</name>
            <description>Channel status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>INTR_CAUSE</name>
                <description>Specifies the source of the interrupt cause:
'0': No interrupt generated
'1': Interrupt based on transfer complettion configuration based on INTR_TYPE
'2': Source transfer bus error
'3': Destination transfer bus error
'4': Source address misalignment
'5': Destination address misalignment
'6': Current descriptor pointer is null
'7': Active channel is disabled
'8': Descriptor bus error
'9'-'15': Not used.

For error related interrupt causes (INTR_CAUSE is '2', '3', ..., '8'), the channel is disabled (HW sets CH_CTL.ENABLED to '0').</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PENDING</name>
                <description>Specifies pending DW channels; i.e. enabled channels whose trigger got activated. This field includes all channels that are in the pending state (not scheduled) or active state (scheduled and performing data transfer(s)).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_IDX</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Y_IDX</name>
                <description>Specifies the Y loop index, with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_CURR_PTR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: Typically, when SW updates the current descriptor pointer CH_CURR_PTR, it also sets CH_IDX.X_IDX and CH_IDX.Y_IDX to '0'.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Set to '1', when event (as specified by CH_STATUS.INTR_CAUSE) is detected. Write INTR.CH field with '1', to clear bit. Write INTR_SET.CH field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR.CH field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA0</name>
            <description>SRAM data 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA1</name>
            <description>SRAM data 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channel software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DW0">
      <name>DW1</name>
      <baseAddress>0x40290000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC</description>
      <baseAddress>0x402A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ACTIVE</name>
          <description>Active channels</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Specifies active channels; i.e. enabled channels whose trigger got activated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>DMA controller channel</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x800003F7</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the NS field for the secure/non-secure access control ('hprot[4]').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel uses the PC field for the protection context.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group and within this priority group, the following 'roundrobin' arbitration is applied. 
A 'round' consists of a contiguous sequence of channel activations, within this priority group, without any repetition. Within a round, higher priority is given to the lower channel indices. The notion of a round guarantees that within a group, higher channel indices do not yield to lower indices indefinitely.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' when an error interrupt cause is activated.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>Y</name>
                <description>Specifies the Y loop index, with Y_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor..</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRC</name>
            <description>Channel current source address</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DST</name>
            <description>Channel current destination address</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of destination location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channle software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_STATUS</name>
            <description>Channel descriptor status</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>VALID</name>
                <description>Indicates whether the descriptor information present in DESCR_CTL, DESCR_SRC, DESCR_DST, DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE, DESCR_Y_INCR, DESCR_NEXT status registers is valid or not.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_CTL</name>
            <description>Channel descriptor control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>Specifies whether the controller should wait for the input trigger to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller with the agent that generated the trigger. This field is ONLY used at the completion of the transfer as specified by TR_IN. E.g., a TX FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the controller AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW controller performance.
'0': Do not wait for trigger de-activation (for pulse sensitive triggers).
'1': Wait for up to 4 cycles.
'2': Wait for up to 16 cycles.
'3': Wait indefinitely. This option may result in controller lockup if the trigger is not de-activated.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INTR_TYPE</name>
                <description>Specifies when a completion interrupt is generated (CH_STATUS.INTR_CAUSE is set to COMPLETION):
'0': An interrupt is generated after a single transfer. 
'1': An interrupt is generated after a single 1D transfer or a memory copy transfer
- If the descriptor type is 'single', the interrupt is generated after a single transfer.
- If the descriptor type is '1D' or '2D', the interrupt is generated after the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the interrupt is generated after the execution of a memory copy transfer.
- If the descriptor type is 'scatter' the interrupt is generated after the execution of a scatter transfer.
'2': An interrupt is generated after the execution of the current descriptor (independent of the value of DESCR_NEXT_PTR.ADDR of the current descriptor).
'3': An interrupt is generated after the execution of the current descriptor and the current descriptor's DESCR_NEXT_PTR.ADDR is '0'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_OUT_TYPE</name>
                <description>Specifies when an output trigger is generated:
'0': An output trigger is generated after a single transfer. 
'1': An output trigger is generated after a single 1D transfer or a memory copy transfer.
- If the descriptor type is 'single', the output trigger is generated after a single transfer.
- If the descriptor type is '1D' or '2D', the output trigger is generated after the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the output trigger is generated after the execution of a memory copy transfer.
- If the descriptor type is 'scatter', the output trigger is generated after the execution of a scatter transfer.
'2': An output trigger is generated after the execution of the current descriptor. 
'3': An output trigger is generated after the execution of a descriptor list: after the execution of the current descriptor AND the current descriptor's DESCR_NEXT_PTR.ADDR is '0'.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_IN_TYPE</name>
                <description>Specifies the input trigger type (not to be confused with the descriptor type):
'0': A trigger results in the execution of a single transfer. The descriptor type can be single, 1D or 2D.
'1': A trigger results in the execution of a single 1D transfer.
- If the descriptor type is 'single', the trigger results in the execution of a single transfer.
- If the descriptor type is '1D' or '2D', the trigger results in the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the trigger results in the execution of a memory copy transfer.
- If the descriptor type is 'scatter', the trigger results in the execution of an scatter transfer.
'2': A trigger results in the execution of the current descriptor. 
'3': A trigger results in the execution of the current descriptor and continues (without requiring another input trigger) with the execution of the next descriptor using the next descriptor's information.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_PREFETCH</name>
                <description>Source data prefetch:
'0': No source data prefetch. Source data transfers are only initiated AFTER the input trigger is activated.
'1': Source data prefetch. Source data transfers are initiated as soon as the channel is enabled, the current descriptor pointer is NOT '0' and there is space available in the channel's data FIFO. When the input trigger is activated, the trigger can initiate destination data transfers with data that is already in the channel's data FIFO. This effectively shortens the initial delay of the data transfer.

Note: data prefetch should be used with care, to ensure that data coherency is guaranteed and that prefetches do not cause undesired side effects.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>Specifies the data element size:
'0': Byte (8 bits).
'1': Halfword (16 bits).
'2': Word (32 bits).
DATA_SIZE, SRC_TRANSFER_SIZE and DST_TRANSFER_SIZE together determine how data elements are transferred. The following are the 9 legal settings:
- DATA is 8 bit, SRC is 8 bit, DST is 8 bit.
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 8 bit.
- DATA is 8 bit, SRC is 8 bit, DST is 32 bit (higher 24 bits are made '0').
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 32 bit (higher 24 bits are made '0').
- DATA is 16 bit, SRC is 16 bit, DST is 16 bit.
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 16 bit.
- DATA is 16 bit, SRC is 16 bit, DST is 32 bit (higher 16 bits are made '0').
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 32 bit (higher 16 bits are made '0').
- DATA is 32 bit, SRC is 32 bit, DST is 32 bit.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '2' for a 'initialization' descriptor type.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_DISABLE</name>
                <description>Specifies whether the channel is disabled or not after completion of the current descriptor (independent of the value of the DESCR_NEXT_PTR value):
'0': Channel is not disabled.
'1': Channel is disabled.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the source location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for source components with data elements that are smaller than their 32-bit bus interface width. E.g., an ADC source has a 32-bit bus transfer size, but only provides a 16-bit data element.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '1' for a 'scatter' descriptor type.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the destination location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for destination components with data elements that are smaller than their 32-bit bus interface width. E.g., a DAC destination has a 32-bit bus transfer size, but only requires a 16-bit data element.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '1' for a 'scatter' descriptor type.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_TYPE</name>
                <description>Specifies the descriptor type (not to be confused with the trigger type):
'0': Single transfer.
The DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR registers are NOT present. The DESCR_NEXT_PTR is at offset 0x0c.
'1': 1D transfer.
The DESCR_X_SIZE and DESCR_X_INCR registers are present, the DESCR_Y_SIZE and DESCR_Y_INCR are NOT present. A 1D transfer consists out of DESCR_X_SIZE.X_COUNT+1 single transfers. The DESCR_NEXT_PTR is at offset 0x14.
'2': 2D transfer.
The DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR registers are present. A 2D transfer consists of (DESCR_X_SIZE.X_COUNT+1)*(DESCR_Y_SIZE.Y_COUNT+1) single transfers. The DESCR_NEXT_PTR is at offset 0x1c.
'3': Memory copy.
The DESCR_X_SIZE register is present, the DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR are NOT present. A memory copy transfer copies DESCR_X_SIZE.X_COUNT+1 Bytes and may use Byte, halfword and word transfers. The DESCR_NEXT_PTR is at offset 0x10.
'4': Scatter transfer. The DESCR_X_SIZE register is present, the DESCR_DST, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR are NOT present.
'5'-'7': Undefined.

After the execution of the current descriptor, the DESCR_NEXT_PTR address is copied to the channel's CH_CURR_PTR address and CH_STATUS.X_IDX and CH_STATUS.Y_IDX are set to '0'.</description>
                <bitRange>[30:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_SRC</name>
            <description>Channel descriptor source</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_DST</name>
            <description>Channel descriptor destination</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of destination location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_SIZE</name>
            <description>Channel descriptor X size</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_COUNT</name>
                <description>Number of iterations (minus 1) of the 'X loop' (X_COUNT+1 is the number of single transfers in a 1D transfer). This field is an unsigned number in the range [0, 65535], representing 1 through 65536 iterations.

For the 'memory copy' descriptor type, (X_COUNT + 1) is the number of transferred Bytes. For the 'scatter' descriptor type, ceiling(X_COUNT/2) is the number of (address, write data) initialization pairs processed.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_INCR</name>
            <description>Channel descriptor X increment</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_X</name>
                <description>Specifies increment of source address for each X loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number (sign-magnitude format) in the range [-32768, 32767]. If this field is '0', the source address is not incremented. This is useful for reading from RX FIFO structures.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_X</name>
                <description>Specifies increment of destination address for each X loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number (sign-magnitude format) in the range [-32768, 32767]. If this field is '0', the destination address is not incremented. This is useful for writing to TX FIFO structures.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_SIZE</name>
            <description>Channel descriptor Y size</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>Y_COUNT</name>
                <description>Number of iterations (minus 1) of the 'Y loop' (X_COUNT+1)*(Y_COUNT+1) is the number of single transfers in a 2D transfer). This field is an unsigned number in the range [0, 65535], representing 1 through 65536 iterations.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_INCR</name>
            <description>Channel descriptor Y increment</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_Y</name>
                <description>Specifies increment of source address for each Y loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-32768, 32767].</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_Y</name>
                <description>Specifies increment of destination address for each Y loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-32768, 32767].</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_NEXT</name>
            <description>Channel descriptor next pointer</description>
            <addressOffset>0x7C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>Address of next descriptor in descriptor list. When this field is '0', this is the last descriptor in the descriptor list.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Activated (set to '1') on completion of data transfer(s) as specified by the descriptor's CH_DESCR_CTL.INTR_TYPE.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load from the source.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a store to the destination.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the source address.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the destination address.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Activated (set to '1') when the channel is enabled (CH_CTL.ENABLED is '1') and CH_CURR_PTR is '0'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Activated (set to '1') if the channel is disabled by SW (accidentally/incorrectly) when the data transfer engine is busy.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load of the descriptor.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Write this field with '1' to set INTR.COMPLETION field to '1' (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.SRC_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.DST_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Write this field with '1' to set INTR.SRC_MISAL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Write this field with '1' to set INTR.DST_MISAL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Write this field with '1' to set INTR.CURR_PTR_NULL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Write this field with '1' to set INTR.ACT_CH_DISABLED field to '1' (a write of '0' has no effect).</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.DESCR_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Mask for INTR.COMPLETION interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Mask for INTR.SRC_BUS_ERROR interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Mask for INTR.DST_BUS_ERROR interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Mask for INTR.SRC_MISAL interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Mask for INTR.DST_MISAL interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Mask for INTR.CURR_PTR_NULL interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Mask for INTR.ACTIVE_CH_DISABLED interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Mask for INTR.DESCR_BUS_ERROR interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Logical and of corresponding INTR.COMPLETION and INTR_MASK.COMPLETION fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.SRC_BUS_ERROR and INTR_MASK.SRC_BUS_ERROR fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.DST_BUS_ERROR and INTR_MASK.DST_BUS_ERROR fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Logical and of corresponding INTR.SRC_MISAL and INTR_MASK.SRC_MISAL fields.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Logical and of corresponding INTR.DST_MISAL and INTR_MASK.DST_MISAL fields.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Logical and of corresponding INTR.CURR_PTR_NULL and INTR_MASK.CURR_PTR_NULL fields.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Logical and of corresponding INTR.ACTIVE_CH_DISABLED and INTR_MASK.ACTIVE_CH_DISABLED fields.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.DESCR_BUS_ERROR and INTR_MASK.DESCR_BUS_ERROR fields.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSE</name>
      <description>EFUSE MXS40 registers</description>
      <baseAddress>0x402C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>512</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST</name>
          <description>Test</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MARG_READ</name>
              <description>Margin Read</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOWR</name>
                  <description>Low Resistance: -50 percent from nominal</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEFAULTR</name>
                  <description>Nominal resistance (Default read condition)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGHR</name>
                  <description>High Resistance: +50 percent from nominal</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGHERR</name>
                  <description>Higher Resistance: +100 percent from nominal</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x800F1F71</resetMask>
          <fields>
            <field>
              <name>BIT_DATA</name>
              <description>Bit data. This field specifies the bit value that is to be programmed into the eFUSE macro array. The address of the bit is specified by the BIT_ADDR, BYTE_ADDR, and MACRO_ADDR fields. This bit is a don't care for the MXS40 Macro.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ADDR</name>
              <description>Bit address. This field specifies a bit within a Byte.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_ADDR</name>
              <description>Byte address. This field specifies a Byte within a eFUSE macro (each macro has 32 B).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MACRO_ADDR</name>
              <description>Macro address. This field specifies an eFUSE macro.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>FW sets this field to '1' to start a program operation. HW sets this field to '0' to indicate that the operation has completed.

Note: it is good practice to verify the result of a program operation by reading back a programmed eFUSE memory location. Programming can only change an eFUSE memory bit from '0' to '1'; i.e. a programming operation is a 'one-off' operation for each eFUSE memory bit: once a bit is changed to '1', it can NEVER be changed back to '0' as a hardware fuse is blown.

Programming a memory bit to '1' requires blowing a fuse and requires an eFUSE macro operation. Therefore, this programmiong operation takes time (as specified by the SEQ_PROGRAM_CTL reguisters). Programming amemory bit to '0' does not require an eFUSE macro operation (it is the default eFUSE macro state). Therefore, this programming operation is almost instantaneous.

Note: during a program operation, a read operation can not be performed. An AHB-Lite read transfer to the eFUSE memory during a program operation results in an AHB-Lite bus error.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_DEFAULT</name>
          <description>Sequencer Default value</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1D0000</resetValue>
          <resetMask>0x7F0000</resetMask>
          <fields>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_0</name>
          <description>Sequencer read control 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_1</name>
          <description>Sequencer read control 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_2</name>
          <description>Sequencer read control 2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_3</name>
          <description>Sequencer read control 3</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540003</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_4</name>
          <description>Sequencer read control 4</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_5</name>
          <description>Sequencer read control 5</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_0</name>
          <description>Sequencer program control 0</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_1</name>
          <description>Sequencer program control 1</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x220020</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_2</name>
          <description>Sequencer program control 2</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_3</name>
          <description>Sequencer program control 3</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310005</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_4</name>
          <description>Sequencer program control 4</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80350006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_5</name>
          <description>Sequencer program control 5</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x803D0019</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>33</dim>
          <dimIncrement>16</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL0</name>
            <description>Port selection 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects the peripheral connections of Pin 0. Note that available connectivity options vary depending on the device, port and the pin. See the device Datasheet for a list of peripheral connections available at each pin.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>GPIO controls 'out'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>GPIO controls 'out', DSI controls 'output enable'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controls 'out' and 'output enable'</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controls 'out', GPIO controls 'output enable'</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>Analog mux bus A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>Analog mux bus B</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA_DSI</name>
                    <description>Analog mux bus A, DSI control</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB_DSI</name>
                    <description>Analog mux bus B, DSI control</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Active functionality 0</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Active functionality 1</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Active functionality 2</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Active functionality 3</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_0</name>
                    <description>DeepSleep functionality 0</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_1</name>
                    <description>DeepSleep functionality 1</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>DeepSleep functionality 2</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>DeepSleep functionality 3</description>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_4</name>
                    <description>Active functionality 4</description>
                    <value>16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_5</name>
                    <description>Active functionality 5</description>
                    <value>17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_6</name>
                    <description>Active functionality 6</description>
                    <value>18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_7</name>
                    <description>Active functionality 7</description>
                    <value>19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_8</name>
                    <description>Active functionality 8</description>
                    <value>20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_9</name>
                    <description>Active functionality 9</description>
                    <value>21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_10</name>
                    <description>Active functionality 10</description>
                    <value>22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_11</name>
                    <description>Active functionality 11</description>
                    <value>23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_12</name>
                    <description>Active functionality 12</description>
                    <value>24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_13</name>
                    <description>Active functionality 13</description>
                    <value>25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_14</name>
                    <description>Active functionality 14</description>
                    <value>26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_15</name>
                    <description>Active functionality 15</description>
                    <value>27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_4</name>
                    <description>DeepSleep functionality 4</description>
                    <value>28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_5</name>
                    <description>DeepSleep functionality 5</description>
                    <value>29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_6</name>
                    <description>DeepSleep functionality 6</description>
                    <value>30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_7</name>
                    <description>DeepSleep functionality 7</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects the peripheral connections of Pin 1.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects the peripheral connections of Pin 2.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects the peripheral connections of Pin 3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT_SEL1</name>
            <description>Port selection 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO4_SEL</name>
                <description>Selects the peripheral connections of Pin 4. See PORT_SEL0 for connection details.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects the peripheral connections of Pin 4.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects the peripheral connections of Pin 5.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects the peripheral connections of Pin 6.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_0</name>
          <description>Power/Ground Monitor cell control 0</description>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_1</name>
          <description>Power/Ground Monitor cell control 1</description>
          <addressOffset>0x2204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_2</name>
          <description>Power/Ground Monitor cell control 2</description>
          <addressOffset>0x2208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_3</name>
          <description>Power/Ground Monitor cell control 3</description>
          <addressOffset>0x220C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALT_JTAG_EN</name>
          <description>Alternate JTAG IF selection register</description>
          <addressOffset>0x2240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Provides the selection for alternate JTAG IF connectivity.
0: Primary JTAG interface is selected
1: Secondary (alternate) JTAG interface is selected.

This connectivity works ONLY in ACTIVE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40310000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>33</dim>
          <dimIncrement>128</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>OUT</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO output data for pin 0
'0': Output state set to '0'
'1': Output state set to '1'</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO output data for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO output data for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO output data for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO output data for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO output data for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO output data for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO output data for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO clear output for pin 0:
'0': Output state not affected.
'1': Output state set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO clear output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO clear output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO clear output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO clear output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO clear output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO clear output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO clear output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO set output for pin 0:
'0': Output state not affected.
'1': Output state set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO set output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO set output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO set output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO set output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO set output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO set output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO set output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO invert output for pin 0:
'0': Output state not affected.
'1': Output state inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO invert output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO invert output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO invert output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO invert output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO invert output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO invert output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO invert output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IN</name>
            <description>Port input state register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>IN0</name>
                <description>IO pin state for pin 0
'0': Low logic level present on pin.
'1': High logic level present on pin.
On reset assertion , IN register will get reset. The Pad value takes 2 clock cycles to be reflected into IN Register.  It's value then depends on the external pin value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN</name>
                <description>Reads of this register return the logical state of the filtered pin as selected in the INTR_CFG.FLT_SEL register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detect for IO pin 0
'0': No edge was detected on pin.
'1': An edge was detected on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detect for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detect for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detect for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detect for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detect for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detect for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detect for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_IN0</name>
                <description>IO pin state for pin 0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN_IN</name>
                <description>Filtered pin state for pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Port interrupt mask register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Masks edge interrupt on IO pin 0
'0': Pin interrupt forwarding disabled
'1': Pin interrupt forwarding enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Masks edge interrupt on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Masks edge interrupt on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Masks edge interrupt on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Masks edge interrupt on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Masks edge interrupt on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Masks edge interrupt on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Masks edge interrupt on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Masks edge interrupt on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Port interrupt masked status register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detected AND masked on IO pin 0
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detected and masked on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detected and masked on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detected and masked on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detected and masked on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detected and masked on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detected and masked on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detected and masked on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected and masked on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Port interrupt set register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Sets edge detect interrupt for IO pin 0
'0': Interrupt state not affected
'1': Interrupt set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Sets edge detect interrupt for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Sets edge detect interrupt for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Sets edge detect interrupt for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Sets edge detect interrupt for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Sets edge detect interrupt for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Sets edge detect interrupt for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Sets edge detect interrupt for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Sets edge detect interrupt for filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 0</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 1</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 2</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 3</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 4</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 5</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 6</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 7</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Sets which edge will trigger an IRQ for the glitch filtered pin (selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG</name>
            <description>Port configuration register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_MODE0</name>
                <description>The GPIO drive mode for IO pin 0. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN0</name>
                <description>Enables the input buffer for IO pin 0.  This bit should be cleared when analog signals are present on the pin to avoid crowbar currents.  The output buffer can be used to drive analog signals high or low without issue.
'0': Input buffer disabled
'1': Input buffer enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE1</name>
                <description>The GPIO drive mode for IO pin 1. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN1</name>
                <description>Enables the input buffer for IO pin 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE2</name>
                <description>The GPIO drive mode for IO pin 2. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN2</name>
                <description>Enables the input buffer for IO pin 2</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE3</name>
                <description>The GPIO drive mode for IO pin 3. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN3</name>
                <description>Enables the input buffer for IO pin 3</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE4</name>
                <description>The GPIO drive mode for IO pin 4. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN4</name>
                <description>Enables the input buffer for IO pin 4</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE5</name>
                <description>The GPIO drive mode for IO pin 5. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN5</name>
                <description>Enables the input buffer for IO pin 5</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE6</name>
                <description>The GPIO drive mode for IO pin 6. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN6</name>
                <description>Enables the input buffer for IO pin 6</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE7</name>
                <description>The GPIO drive mode for IO pin 7. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN7</name>
                <description>Enables the input buffer for IO pin 7</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN</name>
            <description>Port input buffer configuration register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_0</name>
                <description>Configures the pin 0 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS</name>
                    <description>PSoC6:: Input buffer compatible with CMOS and I2C interfaces
Traveo II: full encoding is shown in CFG_IN_AUTOLVL.VTRIP_SEL0_1</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TTL</name>
                    <description>PSoC6:: Input buffer compatible with TTL and MediaLB interfaces
Traveo II: full encoding is shown in CFG_IN_AUTOLVL.VTRIP_SEL0_1</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_0</name>
                <description>Configures the pin 1 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_0</name>
                <description>Configures the pin 2 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_0</name>
                <description>Configures the pin 3 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_0</name>
                <description>Configures the pin 4 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_0</name>
                <description>Configures the pin 5 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_0</name>
                <description>Configures the pin 6 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_0</name>
                <description>Configures the pin 7 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT</name>
            <description>Port output buffer configuration register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF00FF</resetMask>
            <fields>
              <field>
                <name>SLOW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW1</name>
                <description>Enables slow slew rate for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW2</name>
                <description>Enables slow slew rate for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW3</name>
                <description>Enables slow slew rate for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW4</name>
                <description>Enables slow slew rate for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW5</name>
                <description>Enables slow slew rate for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW6</name>
                <description>Enables slow slew rate for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW7</name>
                <description>Enables slow slew rate for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ZERO</name>
                    <description>Please refer to architecture TRM section I/O System</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ONE</name>
                    <description>Please refer to architecture TRM section I/O System</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_TWO</name>
                    <description>Please refer to architecture TRM section I/O System</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_THREE</name>
                    <description>Please refer to architecture TRM section I/O System</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_SEL1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VREG_EN01</name>
                <description>The regulated output mode is selected ONLY if the CFG.DRIVE_MODE bits are set to the strong pull up (Z_1 = '5') mode If the CFG.DRIVE_MODE bits are set to any other mode the regulated output buffer will be disabled and the standard CMOS output buffer is used.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL01</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL01</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL01</name>
                <description>N/A</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL01</name>
                <description>Selects trip-point of input buffer. In single ended input buffer mode (IBUF01_SEL = '0'):
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.
In differential input buffer mode (IBUF01_SEL = '1'):                                                                  VTRIP_SEL=0:                                                                                                                                a) VREF_SEL=00, VOH_SEL=X -&gt; Trip point=50 percent of vddio
b) VREF_SEL=01, VOH_SEL=000 -&gt; Trip point=Vohref (buffered)
c) VREF_SEL=01, VOH_SEL=[1-7] -&gt; Input buffer functions as CMOS input buffer.                                                                                                                                             
d) VREF_SEL=10/11, VOH_SEL=000 -&gt; Trip point=Amuxbus_a/b (buffered)
e) VREF_SEL=10/11, VOH_SEL=[1-7]  -&gt;  Input buffer functions as CMOS input buffer.                                                                                                                                             VTRIP_SEL=1:                                                                                                                                a) VREF_SEL=00, VOH_SEL=X -&gt; Trip point=40 percent of vddio
b) VREF_SEL=01, VOH_SEL=000 -&gt; Trip point=0.5*Vohref
c) VREF_SEL=01, VOH_SEL=[1-7] -&gt; Input buffer functions as LVTTL input buffer.                                                                                                                                            d) VREF_SEL=10/11, VOH_SEL=000 -&gt; Trip point=0.5*Amuxbus_a/b (buffered)
e) VREF_SEL=10/11, VOH_SEL=[1-7]  -&gt; Input buffer functions as LVTTL input buffer.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN23</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL23</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL23</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL23</name>
                <description>N/A</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL23</name>
                <description>N/A</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN45</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL45</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL45</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL45</name>
                <description>N/A</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL45</name>
                <description>N/A</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN67</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL67</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL67</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL67</name>
                <description>N/A</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL67</name>
                <description>N/A</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN_AUTOLVL</name>
            <description>Port input buffer AUTOLVL configuration register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_1</name>
                <description>Configures the input buffer mode (trip points and hysteresis) for GPIO upper bit.  Lower bit is still selected by CFG_IN.VTRIP_SEL0_0 field.  This field is used along with CFG_IN.VTRIP_SEL0_0 field as below:
{CFG_IN_AUTOLVL.VTRIP_SEL0_1,CFG_IN.VTRIP_SEL0_0}:
0,0: CMOS
0,1: TTL
1,0: input buffer is compatible with automotive.
1,1: input buffer is compatible with automotive.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS_OR_TTL</name>
                    <description>Input buffer compatible with CMOS/TTL interfaces as described in CFG_IN.VTRIP_SEL0_0.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AUTO</name>
                    <description>Input buffer compatible with AUTO (elevated Vil) interfaces when used along with CFG_IN.VTRIP_SEL0_0.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE0</name>
          <description>Interrupt port cause register 0</description>
          <addressOffset>0x4000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE1</name>
          <description>Interrupt port cause register 1</description>
          <addressOffset>0x4004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE2</name>
          <description>Interrupt port cause register 2</description>
          <addressOffset>0x4008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE3</name>
          <description>Interrupt port cause register 3</description>
          <addressOffset>0x400C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_ACTIVE</name>
          <description>Extern power supply detection register</description>
          <addressOffset>0x4010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Indicates presence or absence of VDDIO supplies (i.e. other than VDDD, VDDA) on the device (supplies are numbered 0..n-1).  Note that VDDIO supplies have basic (crude) supply detectors only.  If separate, robust, brown-out detection is desired on IO supplies, on-chip or off-chip analog resources need to provide it.  For these bits to work reliable, the supply must be within valid spec range (per datasheet) or held at ground.  Any in-between voltage has an undefined result.
'0': Supply is not present
'1': Supply is present

When multiple VDDIO supplies are present, they will be assigned in alphanumeric ascending order to these bits during implementation.
For example 'vddusb, vddio_0, vddio_a, vbackup, vddio_r, vddio_1' are present then they will be assigned to these bits as below:
0: vbackup, 
1: vddio_0, 
2: vddio_1,
3: vddio_a,
4: vddio_r,
5: vddusb'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>This bit indicates presence of the VDDD supply.  This bit will always read-back 1.  The VDDD supply has robust brown-out protection monitoring and it is not possible to read back this register without a valid supply. (This bit is used in certain test-modes to observe the brown-out detector status.)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR</name>
          <description>Supply detection interrupt register</description>
          <addressOffset>0x4014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply state change detected.
'0': No change to supply detected
'1': Change to supply detected</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>The VDDD supply is always present during operation so a supply transition can not occur. This bit will always read back '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASK</name>
          <description>Supply detection interrupt mask register</description>
          <addressOffset>0x4018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Masks supply interrupt on VDDIO.
'0': VDDIO interrupt forwarding disabled
'1': VDDIO interrupt forwarding enabled</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASKED</name>
          <description>Supply detection interrupt masked register</description>
          <addressOffset>0x401C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply transition detected AND masked
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_SET</name>
          <description>Supply detection interrupt set register</description>
          <addressOffset>0x4020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Sets supply interrupt.
'0': Interrupt state not affected
'1': Interrupt set</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMARTIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x40320000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>18</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and SMARTIO fabric is always bypassed.
'0': No bypass (programmable SMARTIO fabric is exposed). 
'1': Bypass (programmable SMARTIOIO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_smartio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_smartio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'17': clk_smartio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_smartio' (note that 'clk_smartio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'18': Same as '17'. Note that the M0S8 SMARTIO version used the Hibernate reset for this value, but the MXS40 SMARTIO version does not support Hibernate functionality.  
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': asynchronous mode/'1'.  Select this when clockless operation is configured.

NOTE: Two positive edges of the selected clock are required for the block to be enabled (to deactivate reset).  In asynchronous (clockless) mode clk_sys is used to enable the block, but is not available for clocking.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep power mode, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the SMARTIO is supposed to deliver DeepSleep output functionality on these IO pads. This field is used to control the hold override functionality from the SMARTIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The SMARTIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the SMARTIO sets hold override to 'pwr_hld_ovr_hib' to enable SMARTIO functionality in DeepSleep power mode (but disables it in Hibernate or Stop power mode).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>EVTGEN0</name>
      <description>Event generator</description>
      <headerStructName>EVTGEN</headerStructName>
      <baseAddress>0x403F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP0_STATUS</name>
          <description>Comparator structures comparator 0 status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0_OUT</name>
              <description>Active comparator 'comp0_out[]' outputs.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP1_STATUS</name>
          <description>Comparator structures comparator 1 status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1_OUT</name>
              <description>DeepSleep comparator 'comp1_out_lf[]' outputs (synchronized from clk_lf to the IP clock).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTER_STATUS</name>
          <description>Counter status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Active counter validity:
'0': Invalid.
'1': Valid.

The COUNTER register field INT32 is only valid when VALID is '1'. 

The COUNTER_STATUS and COUNTER registers are non-retention registers; i.e. the COUNTER_STATUS and COUNTER registers are reset during DeepSleep power mode. After entering the Active power mode, the Active counter is initialized with the DeepSleep counter. This initialization may take up to 1 clk_lf cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTER</name>
          <description>Counter</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INT32</name>
              <description>Active counter 'counter_int[31:0]' on clk_ref_div.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RATIO_CTL</name>
          <description>Ratio control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0070000</resetMask>
          <fields>
            <field>
              <name>DYNAMIC_MODE</name>
              <description>Weighted average calculation (only used when DYNAMIC is '1'):
'0': new RATIO value = (RATIO + measurement + 1) / 2.
'1': new RATIO value = (3*RATIO + measurement + 2) / 4.
'2': new RATIO value = (7*RATIO + measurement + 4) / 8.
'3': new RATIO value = (15*RATIO + measurement + 8) / 16.
'4': new RATIO value = (31*RATIO + measurement + 16) / 32.
'5': new RATIO value = (63*RATIO + measurement + 32) / 64.
'6': new RATIO value = (127*RATIO + measurement + 64) / 128.
'7': new RATIO value = (255*RATIO + measurement + 128) / 256.

Note: 'measurement' (integer component only) is defined as: 256 * 'number of measured clk_ref_div cycles per clk_lf cycle'. The RATIO value (integer and fractional component) is defined as: 256*RATIO.INT16 + RATIO.FRAC8 (RATIO.INT16 = RATIO &gt;&gt; 8 and RATIO.FRAC8 = RATIO  percent 256).</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYNAMIC</name>
              <description>Specifies if RATIO_CTL.VALID and RATIO are under SW or HW control:
'0': SW control.
'1: HW control. Auto calibration is used to derive the RATIO value. HW measures the number of clk_ref_div cycles per clk_lf cycle. This measurement is combined with the current ratio value to calculate a new ratio value.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Ratio value valid:
'0': Invalid.
'1': Valid.

The RATIO register fields INT16 and FRAC8 are only valid when VALID is '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RATIO</name>
          <description>Ratio</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>FRAC8</name>
              <description>Fractional component of ratio value.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16</name>
              <description>Integer component of ratio value.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REF_CLOCK_CTL</name>
          <description>Reference clock control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT_DIV</name>
              <description>Divider control for clk_ref_div:
'0': Divide by 1.
...
'255': Divide by '256'.

Fclk_ref_div = Fclk_ref / (INT_DIV + 1)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>This interrupt cause field is activated (HW sets the field to '1') when a comparator 0 event is generated (Active counter 'counter_int[31:0]' becomes greater or equal to COMP0.INT[31:0]).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set</description>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked</description>
          <addressOffset>0x70C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_DPSLP</name>
          <description>DeepSleep interrupt</description>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>This interrupt cause field is activated (HW sets the field to '1') when a comparator 1 event is generated (DeepSleep counter 'counter_int_lf[31:0]' becomes greater or equal to COMP1.INT[31:0]).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_DPSLP_SET</name>
          <description>DeepSleep interrupt set</description>
          <addressOffset>0x714</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_DPSLP_MASK</name>
          <description>DeepSleep interrupt mask</description>
          <addressOffset>0x718</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_DPSLP_MASKED</name>
          <description>DeepSleep interrupt masked</description>
          <addressOffset>0x71C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>32</dimIncrement>
          <name>COMP_STRUCT[%s]</name>
          <description>Comparator structure</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>COMP_CTL</name>
            <description>Comparator control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80010003</resetMask>
            <fields>
              <field>
                <name>COMP0_EN</name>
                <description>Active comparator (COMP0) enable:
'0': Disabled. The comparator output 'comp0_out' is '0'.
'1': Enabled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMP1_EN</name>
                <description>DeepSleep comparator (COMP1) enable:
'0': Disabled. The comparator output 'comp1_out_lf' is '0'.
'1': Enabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_OUT_EDGE</name>
                <description>Specifies the 'tr_out' output trigger:
'0': The trigger is a level sensitive trigger. The Active comparator output ('comp0_out') is reflected on 'tr_out'.
'1': The trigger is an edge sensitive trigger. Activation of the Active comparator output (rising edge on 'comp0_out') results in a two cycle '1'/high pulse on 'tr_out'.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Comparator structure enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COMP0</name>
            <description>Comparator 0 (Active functionality)</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INT32</name>
                <description>This value is a 32-bit unsigned integer in the range [0, 2^32-1]. The comparator 'comp0_out' output is activated when the Active counter 'counter_int[31:0]' becomes greater or equal to COMP0.

Note: SW must ensure that COMP_CTL.COMP_EN[0] is '0' when COMP0 is written.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COMP1</name>
            <description>Comparator 1 (DeepSleep functionality)</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INT32</name>
                <description>This value is a 32-bit unsigned integer in the range [0, 2^32-1]. The comparator 'comp1_out_lf' output is activated when the DeepSleep counter 'counter_int_lf[31:0]' becomes greater or equal to COMP1.

Note: SW must ensure that COMP_CTL.COMP_EN[1] is '0' when COMP1 is written.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMIF0</name>
      <description>Serial Memory Interface</description>
      <headerStructName>SMIF</headerStructName>
      <baseAddress>0x40420000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x503400</resetValue>
          <resetMask>0x81F77FF1</resetMask>
          <fields>
            <field>
              <name>XIP_MODE</name>
              <description>Mode of operation.

Note: this field should only be changed when the IP is disabled or when STATUS.BUSY is '0' and SW should not be executing from the XIP interface or MMIO interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MMIO_MODE</name>
                  <description>'0': MMIO mode. Individual MMIO accesses to TX and RX FIFOs are used to generate a sequence of SPI transfers. This mode of operation allows for large flexibility in terms of the SPI transfers that can be generated.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XIP_MODE</name>
                  <description>'1': XIP mode. eXecute-In-Place mode: incoming read and write transfers over the AHB-Lite bus infrastructure are automatically translated in SPI transfers to read data from and write data to a device. This mode of operation allow for efficient device read and write operations. This mode is only supported in SPI_MODE.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_IF_TX_SEL</name>
              <description>Specifies device interface transmitter clock options.
'0': SDR. Memory interface clock 'spihb_clk_out' is divided (by 2) interface clock 'clk_if', memory interface data signals are driven by divided (by 2) interface clock 'clk_if' with different phase than 'spihb_clk_out'. 
Results in driving memory interface data signals at falling 'spihb_clk_out' edge.
'1': DDR. Memory interface clock 'spihb_clk_out' is divided (by 2) inverted interface clock 'clk_if_inv', memory interface data signals are driven with interface clock 'clk_if'. 
Results in driving memory interface data signals 90 degrees before rising and falling 'spihb_clk_out' edge.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY_LINE_SEL</name>
              <description>Specifies the delay line used for RX data capturing with 
- output / feedback clock based capturing (when CLOCK_IF_RX_SEL = [0..3] and DELAY_TAP_ENABLED = 1)
- internal clock based capturing (when CLOCK_IF_RX_SEL = [4..5], INT_CLOCK_CAPTURE_PRESENT = 1 and DELAY_TAP_ENABLED = 1)
- RWDS based capturing (when CLOCK_IF_RX_SEL = [6..7])</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY_TAP_ENABLED</name>
              <description>Delay Line Tap Enable.
'0': Disabled. The delay line tap selections specified in registers DELAY_TAP_SEL or INT_CLOCK_DELAY_TAP_SEL0/1 are not used. The read data is directly captured by the RX data FIFO capture clock as specified by CLOCK_IF_RX_SEL and INT_CLOCK_CAPTURE_CYCLE.
'1': Enabled. The delay line tap selections specified in registers DELAY_TAP_SEL or INT_CLOCK_DELAY_TAP_SEL0/1 are used. Note that in RWDS based capture scheme (CLOCK_IF_RX_SEL = [6..7]), DELAY_TAP_ENABLED must be set to '1' as the RWDS based capture scheme requires to use the delay line.
If the output / feedback clock based capture scheme (CLOCK_IF_RX_SEL = [0..3]) or the RWDS based capture scheme (CLOCK_IF_RX_SEL = [6..7]) is selected then the register DELAY_TAP_SEL is used to select the capture clock. If the internal clock based capture scheme (CLOCK_IF_RX_SEL = [4..5] and INT_CLOCK_CAPTURE_PRESENT = 1) is selected then the registers INT_CLOCK_DELAY_TAP_SEL0/1 are used to select the capture clock per data bit line (read data is captured by the capture logic and afterwards transferred to the RX data FIFO).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_CLOCK_DL_ENABLED</name>
              <description>Data Learning Enable for internal RX clock based on Data Learning Pattern. Only applies when CLOCK_IF_RX_SEL = [4..5] for selecting the internal clock based capture scheme and when DELAY_TAP_ENABLED = 1.
'0': Disabled. The delay line tap selections specified in registers INT_CLOCK_DELAY_TAP_SEL0/1 are not modified by HW.
'1': Enabled. The delay linle tap selections specified in registers INT_CLOCK_DELAY_TAP_SEL0/1 are modified by HW based on the data learning pattern. From all capture clock delay line taps producing a match between the expected data learning pattern in register DLP and the captured data learning pattern from the memory device the middle one is selected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_CLOCK_CAPTURE_CYCLE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_IF_RX_SEL</name>
              <description>Specifies device interface receiver clock 'clk_if_rx' source. MISO data is captured on the rising edge of 'clk_if_rx' in SDR mode and on both edges of 'clk_if_rx' in DDR mode.
'0': 'spi_clk_out' (output clock) for SDR capturing with output clock
'1': !'spi_clk_out' (output clock) for DDR or SDR capturing with inverted output clock
'2': 'spi_clk_in' (feedback clock) for SDR capturing with feedback clock
'3': !'spi_clk_in' (feedback clock) for DDR or SDR capturing with inverted feedback clock
'4':  'clk_if_tx' (internal clock) for DDR or SDR capturing with internal clock
'5':  'clk_if_tx_inv' (internal clock) for DDR or SDR capturing with inverted internal clock
'6':  'sphb_rwds_inv' (RWDS / DQS strobe signal driven by memory device) for DDR capturing with RWDS / DQS in Hyperbus / Octal SPI mode or for SDR capturing with falling RWDS / DQS edge in Octal SPI mode
'7':  'sphb_rwds' (RWDS / DQS strobe signal driven by memory device) for SDR capturing with rising RWDS / DQS edge in Octal SPI mode</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESELECT_DELAY</name>
              <description>Specifies the minimum duration of SPI deselection ('spi_select_out[]' is high/'1') in between SPI transfers:
'0': 1 memory interface clock cycle.
'1': 2 memory interface clock cycles.
'2': 3 memory interface clock cycles.
'3': 4 memory interface clock cycles.
'4': 5 memory interface clock cycles.
'5': 6 memory interface clock cycles.
'6': 7 memory interface clock cycles.
'7': 8 memory interface clock cycles.

During SPI deselection, 'spi_select_out[]' are '1'/inactive, 'spi_data_out[]' are '1' and 'spi_clk_out' is '0'/inactive.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_SETUP_DELAY</name>
              <description>Specifies the duration between 'spi_select_out[]' becomes low/'0') to 1st 'spi_clk_out' edge:
'0': 0 memory interface clock cycles + min. duration (see below).
'1': 1 memory interface clock cycle   + min. duration (see below).
'2': 2 memory interface clock cycles + min. duration (see below).
'3': 3 memory interface clock cycles + min. duration (see below).

In addition to the number of cycles selected here there is a min. duration of:
- 1 memory interface clock cycle (= 2 clk_if cycle) for SDR timing (CLOCK_IF_TX_SEL = 0)
- 1/4 memory interface clock cycle (= 1/2 clk_if cycle) for DDR timing (CLOCK_IF_TX_SEL = 1)</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_HOLD_DELAY</name>
              <description>Specifies the duration between last 'spi_clk_out' edge to 'spi_select_out[]' becomes high/'1'):
'0': 0 memory interface clock cycles + min. duration (see below).
'1': 1 memory interface clock cycle   + min. duration (see below).
'2': 2 memory interface clock cycles + min. duration (see below).
'3': 3 memory interface clock cycles + min. duration (see below).

In addition to the number of cycles selected here there is a min. duration of:
- 1/2 memory interface clock cycle (= 1 clk_if cycles) for SDR timing (CLOCK_IF_TX_SEL = 0)
- 1/4 memory interface clock cycle (= 1/2 clk_if cycle) for DDR timing (CLOCK_IF_TX_SEL = 1)</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Specifies what happens for MMIO interface read accesses to an empty RX data FIFO or to a full TX format/data FIFO. Note: the FIFOs can only be accessed in MMIO_MODE.

This field is not used for test controller accesses.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BUS_ERROR</name>
                  <description>0': Generate an AHB-Lite bus error. This option is useful when SW decides to use polling on STATUS.TR_BUSY to determine if a interface transfer is no longer busy (transfer is completed). This option adds SW complexity, but limits the number of AHB-Lite wait states (and limits ISR latency).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_STATES</name>
                  <description>1': Introduce wait states. This setting potentially locks up the AHB-Lite infrastructure and may increase the CPU interrupt latency.This option is useful when SW performs TX/RX data FIFO accesses immediately after a command is setup using the TX format FIFO. This option has low SW complexity, but may result in a significant number of AHB-Lite wait states (and may increase ISR latency).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers are reset to their default value when the IP is disabled. When the IP is disabled, the XIP accesses produce AHB-Lite bus errors.
'1': Enabled.

Notes: 
- Before disabling the IP, SW should ensure that the IP is NOT busy (STATUS.BUSY is '0'), otherwise illegal interface transfers may occur.
- After CTL.ENABLED is set to 1 it takes up to 20 clk_if cycles until the memory interface registers are realeased from reset.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>AHB Cache, AXI interface, cryptography, XIP, device interface or any other logic busy in the IP:
'0': not busy
'1': busy
When BUSY is '0', the IP can be safely disabled without:
- the potential loss of transient write data.
- the potential risk of aborting an inflight SPI device interface transfer.
When BUSY is '0', the mode of operation (XIP_MODE or MMIO_MODE) can be safely changed.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLOCK_DELAY_TAP_SEL0</name>
          <description>Internal Clocking Delay Tap Select Register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_BIT0</name>
              <description>Delay line tap selection for data bit 0.
A value of 0 selects the receive capture clock source specified by CTL.CLOCK_IF_RX_SEL. All other values select a tap of the clock delay line. When the data learning pattern is enabled this value is set by HW.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_BIT1</name>
              <description>Delay line tap selection for data bit 1.
See DATA_BIT0.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_BIT2</name>
              <description>Delay line tap selection for data bit 2.
See DATA_BIT0.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_BIT3</name>
              <description>Delay line tap selection for data bit 3.
See DATA_BIT0.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLOCK_DELAY_TAP_SEL1</name>
          <description>Internal Clocking Delay Tap Select Register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_BIT4</name>
              <description>Delay line tap selection for data bit 4.
See DATA_BIT0.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_BIT5</name>
              <description>Delay line tap selection for data bit 5.
See DATA_BIT0.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_BIT6</name>
              <description>Delay line tap selection for data bit 6.
See DATA_BIT0.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_BIT7</name>
              <description>Delay line tap selection for data bit 7.
See DATA_BIT0.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLP</name>
          <description>Data Learning Pattern</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DLP</name>
              <description>Data Learning Pattern</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DL_STATUS0</name>
          <description>Data Learning Status Register 0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_BIT0</name>
              <description>Number of delay line taps for data bit 0 with correctly captured DLP in last read transaction. Legal range: [0, 255].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_BIT1</name>
              <description>Number of delay line taps for data bit 1 with correctly captured DLP in last read transaction. Legal range: [0, 255].</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_BIT2</name>
              <description>Number of delay line taps for data bit 2 with correctly captured DLP in last read transaction. Legal range: [0, 255].</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_BIT3</name>
              <description>Number of delay line taps for data bit 3 with correctly captured DLP in last read transaction. Legal range: [0, 255].</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DL_STATUS1</name>
          <description>Data Learning Status Register 1</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_BIT4</name>
              <description>Number of delay line taps for data bit 4 with correctly captured DLP in last read transaction. Legal range: [0, 255].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_BIT5</name>
              <description>Number of delay line taps for data bit 5 with correctly captured DLP in last read transaction. Legal range: [0, 255].</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_BIT6</name>
              <description>Number of delay line taps for data bit 6 with correctly captured DLP in last read transaction. Legal range: [0, 255].</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_BIT7</name>
              <description>Number of delay line taps for data bit 7 with correctly captured DLP in last read transaction. Legal range: [0, 255].</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DELAY_TAP_SEL</name>
          <description>Delay Tap Select Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>Delay line tap selection in output / feedback clock based capture scheme (CLOCK_IF_RX_SEL = [0..3]) and RWDS capture scheme (CLOCK_IF_RX_SEL = [6..7]). This is used to shift the strobe signal into the data eye.

Note: DELAY_TAP_SEL must not be changed while STATUS.BUSY=1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_STATUS</name>
          <description>Transmitter command FIFO status</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX command FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_WR</name>
          <description>Transmitter command FIFO write</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA27</name>
              <description>N/A</description>
              <bitRange>[26:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_CTL</name>
          <description>Transmitter data FIFO control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER_LEVEL</name>
              <description>Determines when the TX data FIFO 'tr_tx_req' trigger is activated  (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
- Trigger is active when TX_DATA_FIFO_STATUS.USED &lt;= TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_STATUS</name>
          <description>Transmitter data FIFO status</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR1</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR2</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR4</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>TX data (written to TX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>TX data (written to TX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR1ODD</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_CTL</name>
          <description>Receiver data MMIO FIFO control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>RX_TRIGGER_LEVEL</name>
              <description>Determines when RX data FIFO 'tr_rx_req' trigger is activated (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
- Trigger is active when RX_DATA_MMIO_FIFO_STATUS.USED &gt; TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_STATUS</name>
          <description>Receiver data MMIO FIFO status</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the RX data MMIO FIFO (only available in MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_STATUS</name>
          <description>Receiver data FIFO status</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>Number of entries that are used in the RX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 16].</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_SR_USED</name>
              <description>Data available in RX Shift Register, i.e. completely read from RX data FIFO (availabe in both XIP_MODE and MMIO_MODE).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_RD1</name>
          <description>Receiver data MMIO FIFO read</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_RD2</name>
          <description>Receiver data MMIO FIFO read</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_RD4</name>
          <description>Receiver data MMIO FIFO read</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>RX data (read from RX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>RX data (read from RX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_MMIO_FIFO_RD1_SILENT</name>
          <description>Receiver data MMIO FIFO silent read</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CA_CTL</name>
          <description>Slow cache control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xC3030000</resetMask>
          <fields>
            <field>
              <name>WAY</name>
              <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CA_CMD</name>
          <description>Slow cache command</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Cache and prefetch buffer invalidation. 
SW writes a '1' to clear the cache and prefetch buffer. The cache's LRU structure is also reset to its default state.
Note, 
A write access will invalidate the prefetch buffer automatically in hardware.
A write access should invalidate both fast and slow caches, by firmware.
Note, firmware should invalidate the cache and prefetch buffer only when STATUS.BUSY is '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_CA_CTL</name>
          <description>Fast cache control</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xC3030000</resetMask>
          <fields>
            <field>
              <name>WAY</name>
              <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_CA_CMD</name>
          <description>Fast cache command</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>See SLOW_CA_CMD.INV.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_CMD</name>
          <description>Cryptography Command</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>SW sets this field to '1' to start a AES-128 forward block cipher operation (on the address in CRYPTO_ADDR). HW sets this field to '0' to indicate that the operation has completed. Once completed, the result of the operation can be read from CRYPTO_RESULT0, ..., CRYPTO_RESULT3.

The operation takes roughly 13 clk_mem clock cycles.

Note: An operation can only be started in MMIO_MODE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT0</name>
          <description>Cryptography input 0</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[31:0] = CRYPTO_INPUT0.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT1</name>
          <description>Cryptography input 1</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[63:32] = CRYPTO_INPUT1.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT2</name>
          <description>Cryptography input 2</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[95:64] = CRYPTO_INPUT2.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT3</name>
          <description>Cryptography input 3</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[127:96] = CRYPTO_INPUT3.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY0</name>
          <description>Cryptography key 0</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[31:0] = CRYPTO_KEY0.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY1</name>
          <description>Cryptography key 1</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[63:32] = CRYPTO_KEY1.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY2</name>
          <description>Cryptography key 2</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[95:64] = CRYPTO_KEY2.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY3</name>
          <description>Cryptography key 3</description>
          <addressOffset>0x24C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[127:96] = CRYPTO_KEY3.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT0</name>
          <description>Cryptography output 0</description>
          <addressOffset>0x260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[31:0] = CRYPTO_OUTPUT0.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT1</name>
          <description>Cryptography output 1</description>
          <addressOffset>0x264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[63:32] = CRYPTO_OUTPUT1.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT2</name>
          <description>Cryptography output 2</description>
          <addressOffset>0x268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[95:64] = CRYPTO_OUTPUT2.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT3</name>
          <description>Cryptography output 3</description>
          <addressOffset>0x26C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[127:96] = CRYPTO_OUTPUT3.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CMD</name>
          <description>CRC Command</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>SW sets this field to '1' to start a CRC calculation over the 64 CRC input bits provided in CRC_INPUT0 and CRC_INPUT1, using 0xFF as CRC feedback. HW sets this field to '0' to indicate that the operation has completed. Once completed, the result of the operation can be read from CRC_OUTPUT.

A CRC calculation over 64 bits is done by writing the 64 input bits to CRC_INPUT0/1, performing a START command and reading the CRC result from CRC_OUTPUT.

Note: An operation can only be started in MMIO_MODE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUE</name>
              <description>SW sets this field to '1' to continue a CRC calculation over the 64 CRC input bits provided in CRC_INPUT0 and CRC_INPUT1, using the current CRC output in CRC_OUTPUT as CRC feedback. HW sets this field to '0' to indicate that the operation has completed. Once completed, the result of the operation can be read from CRC_OUTPUT.

This command is used to perform a CRC calculation over more than 64 intput bits. For example a CRC calculation over 128 bits is done by writing the first 64 input bits to CRC_INPUT0/1, performing a START command, writing the second 64 input bits to CRC_INPUT0/1, performing a CONTINUE command and reading the CRC result from CRC_OUTPUT. For a CRC calculation of even more input bits the CONTINUE command has to be used multiple times.

Note: An operation can only be started in MMIO_MODE.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_INPUT0</name>
          <description>CRC input 0</description>
          <addressOffset>0x320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Lower 32 input bits to the CRC engine.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_INPUT1</name>
          <description>CRC input 1</description>
          <addressOffset>0x324</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Higher 32 input bits to the CRC engine.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_OUTPUT</name>
          <description>CRC output</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CRC_OUTPUT</name>
              <description>CRC engine output.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x7C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3113F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Activated in MMIO mode, when a TX data FIFO trigger 'tr_tx_req' is activated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Activated in MMIO mode, when a RX data FIFO trigger 'tr_rx_req' is activated.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Activated in XIP mode, when:
- a write transfer is requested
and 
- Dual-Quad SPI mode (selected device's ADDR_CTL.DIV2 is '1') is selected or
- Octal SPI DDR mode (selected device's DATA_CTL.DDR_MODE = '1' and DATA_CTL.WIDTH = '3') or Hyperbus mode (selected device's ADDR_CTL.SIZE3 = '7') is selected without memory write byte masking (selected device's WR_DUMMY_CTL.RWDS_EN = '0')
and 
- the AHB-Lite / AXI bus transfer address is not a multiple of '2' or 
- the requested AHB-Lite / AXI bus transfer size is NOT a multiple of '2'.

Additionally, it is activated in XIP mode when the selected memory device does not support write byte masking (WR_DUMMY_CTL.RWDS_EN=0) and an AXI transfer occurs with not all of the AXI write strobes ('wstrb') enabled according to the transfer size ('assize'). 

Note: In dual-quad SPI mode (ADDR_CTL.DIV is '1'), each memory device contributes a 4-bit nibble for read data or write data. Write accesses are only possible if the request address is a multiple of 2 and the number of requested Bytes is a multiple of 2. Octal SPI DDR mode or Hyperbus mode are 16-bit word based protocols, writing single bytes is only possible when write byte masking is supported (via RWDS). Read accesses are always possible by extending the transfer size and / or aligning the address as needed and discarding the non-relevant byte(s).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX command FIFO (TX_CMD_FIFO_WR) with not enough free entries available.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX data FIFO (TX_DATA_FIFO_WR1, TX_DATA_FIFO_WR2, TX_DATA_FIFO_WR4) with not enough free entries available.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_MMIO_FIFO_UNDERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite read transfer from the RX data MMIO FIFO (RX_DATA_MMIO_FIFO_RD1, RX_DATA_MMIO_FIFO_RD2, RX_DATA_MMIO_FIFO_RD4) with not enough entries available. Only activated for NON test bus controller transfers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_FAIL</name>
              <description>Data Learning Failed (no DLP match found on at least one of the input data lines when CTL.INT_CLOCK_DL_ENABLED = 1).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_WARNING</name>
              <description>Data Learning Warning (for at least one input data line only 1 or 2 delay line taps resulted in a correct DLP capturing when CTL.INT_CLOCK_DL_ENABLED = 1).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERROR</name>
              <description>CRC Error. A read transfer data CRC check failed.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_STATUS_ERROR</name>
              <description>Functional Safety Status Error. A read transfer Functional Safety Status check failed (see definition in DEVICE_ver2.RD_CRC_CTL.STATUS_CHECK_MASK and DEVICE_ver2.RD_CRC_CTL.STATUS_CHECK_MASK_POL).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x7C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3113F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_MMIO_FIFO_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_FAIL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_WARNING</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_STATUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x7C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3113F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_MMIO_FIFO_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_FAIL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DL_WARNING</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_STATUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x7CC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3113F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_DATA_MMIO_FIFO_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DL_FAIL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DL_WARNING</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FS_STATUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>128</dimIncrement>
          <name>DEVICE[%s]</name>
          <description>Device (only used in XIP mode)</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF311</resetMask>
            <fields>
              <field>
                <name>WR_EN</name>
                <description>Write enable:
'0': write transfers are not allowed to this device. An attempt to write to this device results in an AHB-Lite bus error.
'1': write transfers are allowed to this device.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRYPTO_EN</name>
                <description>Cryptography on read/write accesses:
'0': disabled.
'1': enabled.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SEL</name>
                <description>Specifies the connection of the IP's data lines (spi_data[0], ..., spi_data[7]) to the device's data lines (SI/IO0, SO/IO1, IO2, IO3, IO4, IO5, IO6, IO7):
'0': spi_data[0] = IO0, spi_data[1] = IO1, ..., spi_data[7] = IO7. This value is allowed for single, dual, quad, dual quad and octal SPI modes. This value must be used for the first device in dual quad SPI mode. This value must be used for octal SPI mode.
'1': spi_data[2] = IO0, spi_data[3] = IO1. This value is only allowed for single and dual SPI modes.
'2': spi_data[4] = IO0, spi_data[5] = IO1, ..., spi_data[7] = IO3. This value is only allowed for single, dual, quad and dual quad  SPI modes. In dual quad SPI mode, this value must be used for the second device. 
'3': spi_data[6] = IO0, spi_data[7] = IO1. This value is only allowed for single and dual SPI modes.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MERGE_TIMEOUT</name>
                <description>Continuous transfer merge timeout in clk_mem cycles. This limits the standby time of the memory interface, i.e. the time the memory device is selected but no data is transferred.
The counting of the merge timeout period is done in the XIP block using clk_mem cycles. It starts when the last TX or RX byte is transferred to or from the data FIFOs.
After this period the memory device is deselected. A later transfer, even from a continuous address, starts with the overhead phases (command, address, mode, dummy cycles).</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>_1_cycle</name>
                    <description>Timeout after 1 clk_mem cycle. 
That means transfers will only be merged if the continuous transfer request is already available when the previous transfer is finished.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>_16_cycles</name>
                    <description>Timeout after 2^4 = 16 clk_mem cycles. 
At a clk_mem frequency of 200MHz this means 80ns.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>_256_cycles</name>
                    <description>Timeout after 2^8 = 256 clk_mem cycles. 
At a clk_mem frequency of 200MHz this means ~1.3us.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>_4096_cycles</name>
                    <description>Timeout after 2^12 = 4096 clk_mem cycles. 
At a clk_mem frequency of 200MHz this means ~20us.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>_65536_cycles</name>
                    <description>Timeout after 2^16 = 65536 clk_mem cycles. 
At a clk_mem frequency of 200MHz this means ~330us.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD5</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD6</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD7</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MERGE_EN</name>
                <description>Continous transfer merge enable:
'0': Disabled. No merging of transfers is done. Longest possible memory transfer is 16 Byte.
'1': Enabled. Merging of continous transfers is done. This skips the overhead (command, address, mode, dummy cycles) for a continuous (linear sequential) transfer.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOTAL_TIMEOUT</name>
                <description>Total transfer timeout in clk_mem cycles.
The counting of the total timout period is done in the XIP block using clk_mem cycles. It starts when the first command of a new (not merged) transaction is transferred to the TX command FIFO causing the interface logic to select the memory.
After this period the memory device is deselected.

This feature is needed for RAM devices requiring refresh cycles. The value needs to be derived from the RAMs maximum transaction length time (tCMS) minus the time of transferring 2x16byte data block (data granularity of the XIP ports is 16byte, 1 16byte block transfer outstanding, another available for merging). If the result in negative, MERGE_EN must be set to '0'.

Example: RAM device tCMS = 4us, interface clock frequency = 100MHz: total transfer timeout is 4us - 2x16x10ns = 3680ns. 
With clk_mem frequency of 200MHz the TOTAL_TIMEOUT value is 3680/5 = 736.

Note: In the unlikely case that the total transfer timeout is used (usually for RAM devices) while the page boundary crossing latency generation is enabled via RD_BOUND_CTL.PRESENT (usually for FLASH devices) the additional time needs to taken into account.</description>
                <bitRange>[29:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOTAL_TIMEOUT_EN</name>
                <description>Total transfer timeout enable.
'0': Disabled. There is no limit for the total transfer time. The continuous transfer merge timeout for limiting the idle time of the memory interface still applies.
'1': Enabled. The maximum total transfer time is limited by field TOTAL_TIMEOUT.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Device enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR</name>
            <description>Device region base address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Specifies the base address of the device region. If the device region is 2^m Bytes, ADDR MUST be a multiple of 2^m.

In dual quad SPI data transfer, the two devices should have the same ADDR and MASK register settings. The device control information (ADDR_CTL, RD_CMD_CTL, etc.) are provided by the MMIO control registers of the device with the lowest index.

The most significant bit fields are constants and set based on the SMIF_XIP_ADDR parameter. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK is 0xff00:0000 (16 MB XIP memory region), ADDR[31:24] = SMIF_XIP_ADDR[31:24].</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK</name>
            <description>Device region mask</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>MASK</name>
                <description>Specifies the size of the device region. All '1' bits are used to compare the incoming transfer request address A[31:0] with the address as specified in ADDR.ADDR: Address A is in the device when (A[31:8] &amp; MASK[31:8]) == ADDR.ADDR[31:8].

The most significant bit fields are constants and set to'1'. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK  is 0xff00:0000 (16 MB XIP memory region), MASK[31:24] = 0xff.

Note: a transfer request that is not in any device region results in an AHB-Lite bus error.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR_CTL</name>
            <description>Address control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x107</resetMask>
            <fields>
              <field>
                <name>SIZE3</name>
                <description>N/A</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV2</name>
                <description>Specifies if the AHB-Lite bus transfer address is divided by 2 or not:
'0': No divide by 2.
'1': Divide by 2.  

This functionality is used for read and write operation in XIP, dual quad SPI mode; i.e. this DIV2 must be set to '1' in dual quad SPI mode. 
If DIV2 is set to '1', the memory does not support write masking (WR_DUMMY_CTL.RWDS_EN = '0'), and in this configuration a write transfer is requested and the write transfer request address is NOT a multiple of 2 or the requested number of Bytes to be written is not a multiple of 2, the XIP_ALIGNMENT_ERROR interrupt cause is activated.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_STATUS</name>
            <description>Read status</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FS_STATUS</name>
                <description>Provides the Functional Safety Status Register of the memory received with the last read transfer.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_CMD_CTL</name>
            <description>Read command control</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC007FFFF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODEH</name>
                <description>Command high byte code.
This field specifies the most significant command byte, sent before the least significant command byte (CODE). It is only used when PRESENT2 = '2'.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of data transfer:
'0': 1 bit/cycle (single data transfer).
'1': 2 bits/cycle (dual data transfer).
'2': 4 bits/cycle (quad data transfer).
'3': 8 bits/cycle (octal data transfer).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate:
'0': SDR mode
'1': DDR mode</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of command field:
'0': not present
'1': present (1 Byte)
'2': present (2 Byte for OPI)

Note: For octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') either the HB protocol needs to be selected (by ADDR_CTL.SIZE3='7') or this field needs to be set to PRESENT2='2'.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_ADDR_CTL</name>
            <description>Read address control</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_MODE_CTL</name>
            <description>Read mode control</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC007FFFF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.
Note: If a mode field is present (PRESENT='1') for octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') the CODE is sent twice.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODEH</name>
                <description>Mode high byte code.
This field specifies the most significant mode byte, sent before the least significant mode byte (CODE). It is only used when PRESENT2 = '2'.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of mode field:
'0': not present
'1': present (1 Byte)
'2': present (2 Byte for OPI)

Note: For octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') this field needs to be set to PRESENT2='2' to generate a mode field (or to PRESENT2='0').</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DUMMY_CTL</name>
            <description>Read dummy control</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC000001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.

Note: this field specifies dummy cycles, not dummy Bytes!</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present
'2': present - Dummy cycles are doubled when RWDS refresh indicator is high during CA cycle. (HyperRAM variable latency mode)

Notes: 
- If CLOCK_IF_TX_SEL = '0' for transmitting command, address and mode fields in SDR mode (driving data between falling edges of spihb_clk_out) and the memory is driving read data in DDR mode (based on memory type and transmitted command), then there must be at least 1 latency / dummy cycle specified (RD_DUMMY_CTL.PRESENT2 &gt; 0') to prevent controller and memory driving data signals at the same time. 
The same is true for the theoretical (practically irrelevant case) of transmitting at least one of the command, address and mode fields in DDR mode but receiving data from the memory in SDR mode.

- When using the RWDS / DQS based capturing scheme (CTL.CLK_IF_RX_SEL=[6,7]), then there is a minimum number of latency / dummy cycles required (RD_DUMMY_CTL.PRESENT2 &gt; 0). For the Hyperbus protocol (DDR_CTL.SIZE3=7) at least 1 latency / dummy cycle has to be specified, for SPI with DQS capturing at least 2 latency / dummy cycles need to be selected (RD_DUMMY_CTL.SIZE5 &gt; 0, exception see following note).

- In case of falling edge RWDS / DQS capturing (CTL.CLOCK_IF_RX_SEL = '6') and SDR mode, SW should reduce the number of dummy cycles by 1 compared to the latency cycles required by the memory device.

- For Hyperbus, set RD DUMMY_CTL.SIZE5=initial latency cycles-2</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DATA_CTL</name>
            <description>Read data control</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_CRC_CTL</name>
            <description>Read Bus CRC control</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFF00</resetValue>
            <resetMask>0xDFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STATUS_CHECK_MASK</name>
                <description>Specifies which of the Functional Safety Status field bits are checked. There is 1 mask bit for each Functional Safety Status bit. 
'0': The associated Functional Safety Status bit is not checked.
'1': The associated Functional Safety Status bit is checked. If the received Funciontal Safety Status bit = Functional Safety Status Error Polarity (STATUS_ERROR_POLARITY), then a Functional Safety Status error interrupt and a XIP bus error response is generated.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STATUS_ERROR_POL</name>
                <description>Specifies the polarity of the Functional Safety Status field bits. There is 1 polarity bit for each Functional Safety Status bit. 
'0': The associated Functional Safety Status bit is active-low.
'1': The associated Functional Safety Status bit is active-high.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_INPUT_SIZE</name>
                <description>Number of input data bytes for CRC generation (minus 1), i.e. number of data bytes over which the data CRC field is generated (minus 1):
'0': 1 byte
...
'255': 256 bytes.

Note: For octal data transfer with DDR mode (RD_DATA_CTL.WIDTH='3' and RD_DATA_CTL.DDR_MODE='1') the number of bytes for CRC generation must be even (i.e. DATA_CRC_INPUT_SIZE must be odd).</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_WIDTH</name>
                <description>Width of command / address CRC field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_DDR_MODE</name>
                <description>Mode of transfer rate of command / address CRC field.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_INPUT</name>
                <description>Specifies which fields are included in the command / address CRC generation.
'0': The command / address CRC field is generated over the address and (if present) mode fields only.
'1': The command / address CRC field is generated over the command, address and (if present) mode fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_CHECK</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_PRESENT</name>
                <description>Presence of command / address CRC field:
'0': not present
'1': present

Note: For octal data transfer with DDR mode (RD_CRC_CTL.WIDTH='3' and RD_CRC_CTL.DDR_MODE='1') the command / address CRC byte is sent twice, otherwise the command / address CRC byte is only sent once.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_PRESENT</name>
                <description>Presence of data CRC field:
'0': not present
'1': present

Note: Width and data transfer mode (SDR or DDR) of read data CRC fields are the same as for the associated read data fields, i.e. are specified by RD_DATA_CTL.WIDTH and RD_DATA_CTL.DDR_MODE.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_BOUND_CTL</name>
            <description>Read boundary control</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100000</resetValue>
            <resetMask>0x9033001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of base latency cycles (minus 1) used for calculating the number of fist page boundary crossing latency cycles:
'0': base_latency = 1 cycles
...
'31': base_latency = 32 cycles.

The actual latency cycles when crossing the first page boundary depend on the start address of the transaction and is calculated as follows:
if ((page_size - base_latency) &lt; Start_Addr &amp; (sub_page_size - 1))
  { ((Start_Addr &amp; (sub_page_size - 1)) - page_size + base_latency) }
else 
  { 0 }</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_PAGE_SIZE</name>
                <description>Specifies the size of a memory sub page 'sub_page_size'.
'0': sub_page_size = 8   words = 16 bytes (default).
'1': sub_page_size = 16 words = 32 bytes.
'2': sub_page_size = 32 words = 64 bytes.
'3': sub_page_size = 64 words = 128 bytes.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_PAGE_NR</name>
                <description>Specifies the number of sub pages per page.
'0': 1 sub pages per page, i.e. page_size = sub_page_size
'1': 2 sub pages per page, i.e. page_size = 2 x sub_page_size
'2': 4 sub pages per page, i.e. page_size = 4 x sub_page_size
'3': 8 sub pages per page, i.e. page_size = 8 x sub_page_size</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUBSEQ_BOUND_EN</name>
                <description>Enable subsequent page boundary latency cycles.
'0': Disabled. 
The page crossing latency cycles are only generated when crossing the first page boundary (i.e. the first time when the SUB_PAGE_NRth sub page boundary is crossed, e.g. with 2 sub pages per page when the 2nd sub page boundary is crossed).
'1': Enabled. 
The page crossing latency cycles are generated when crossing the first and subsequent page boundaries (i.e. every time when a SUB_PAGE_NRth sub page boundary is crossed, e.g. with 2 sub pages per page when the 2nd, 4th, 6th, ... sub page boundary is crossed).

Note: This only applies when the number of base latency cycles (SIZE5+1) is greater than the size of a page (base_latency &gt; page_size).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of first page boundary latency cycles:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_CMD_CTL</name>
            <description>Write command control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC007FFFF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODEH</name>
                <description>Command high byte code.
This field specifies the most significant command byte, sent before the least significant command byte (CODE). It is only used when PRESENT2 = '2'.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of command field:
'0': not present
'1': present (1 Byte)
'2': present (2 Byte for OPI)

Note: For octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') either the HB protocol needs to be selected (by ADDR_CTL.SIZE3='7') or this field needs to be set to PRESENT2='2'.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_ADDR_CTL</name>
            <description>Write address control</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_MODE_CTL</name>
            <description>Write mode control</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC007FFFF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODEH</name>
                <description>Mode high byte code.
This field specifies the most significant mode byte, sent before the least significant mode byte (CODE). It is only used when PRESENT2 = '2'.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of mode field:
'0': not present
'1': present (1 Byte)
'2': present (2 Byte for OPI)

Note: For octal data transfer with DDR mode (WIDTH='3' and DDR_MODE='1') this field needs to be set to PRESENT2='2' to generate a mode field (or to PRESENT2='0').</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DUMMY_CTL</name>
            <description>Write dummy control</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC002001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWDS_EN</name>
                <description>Read-Write-Data-Strobe Enable. Specifies whether the RWDS output signal should be driven starting in the last dummy cycle until DESELECT. This is needed for write transactions with byte masking via RWDS (e.g. Hyperbus).
'0': do not drive RWDS output
'1': drive RWDS output starting in last dummy cycle until DESELECT

Note: this field is located in the WR_DUMMY_CTL register (and not in the WR_DATA_CTL register) since the RWDS signal needs to be driven already in the last dummy cycle.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT2</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present
'2': present - Dummy cycles are doubled when RWDS refresh indicator is high during CA cycle. (HyperRAM variable latency mode)</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DATA_CTL</name>
            <description>Write data control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDR_MODE</name>
                <description>Mode of transfer rate.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_CRC_CTL</name>
            <description>Write Bus CRC control</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCFFF0000</resetMask>
            <fields>
              <field>
                <name>DATA_CRC_INPUT_SIZE</name>
                <description>Number of input data bytes for CRC generation (minus 1), i.e. number of data bytes over which the data CRC field is generated (minus 1):
'0': 1 byte
...
'255': 256 bytes.

Note: For octal data transfer with DDR mode (WR_DATA_CTL.WIDTH='3' and WR_DATA_CTL.DDR_MODE='1') the number of bytes for CRC generation must be even (i.e. DATA_CRC_INPUT_SIZE must be odd).</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_WIDTH</name>
                <description>Width of command / address CRC field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_DDR_MODE</name>
                <description>Mode of transfer rate of command / address CRC field.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_INPUT</name>
                <description>Specifies which fields are included in the command / address CRC generation.
'0': The command / address CRC field is generated over the address and (if present) mode fields only.
'1': The command / address CRC field is generated over the command, address and (if present) mode fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_ADDR_CRC_PRESENT</name>
                <description>Presence of command / address CRC field:
'0': not present
'1': present

Note: For octal data transfer with DDR mode (RD_CRC_CTL.WIDTH='3' and RD_CRC_CTL.DDR_MODE='1') the command / address CRC byte is sent twice, otherwise the command / address CRC byte is only sent once.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_PRESENT</name>
                <description>Presence of data CRC field:
'0': not present
'1': present

Note: Width and data transfer mode (SDR or DDR) of read data CRC fields are the same as for the associated read data fields, i.e. are specified by RD_DATA_CTL.WIDTH and RD_DATA_CTL.DDR_MODE.

Note: For octal data transfer with DDR mode (RD_DATA_CTL.WIDTH='3' and RD_DATA_CTL.DDR_MODE='1') the data CRC byte is sent twice, otherwise the data CRC byte is only sent once.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDHC0</name>
      <description>SD/eMMC Host Controller</description>
      <headerStructName>SDHC</headerStructName>
      <baseAddress>0x40460000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>WRAP</name>
          <description>MMIO at SDHC wrapper level</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Top level wrapper control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>IP Enable:
0: IP disabled, RAM in DeepSleep, SDHC_CORE regs are inaccessible (any attempts to access will result in AHB Error responses), IP is NOT held in reset but the clocks are gated
1: IP enabled, normal operation</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>CORE</name>
          <description>MMIO for Synopsys Mobile Storage Host Controller IP</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>SDMASA_R</name>
            <description>SDMA System Address register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BLOCKCNT_SDMASA</name>
                <description>32-bit Block Count (SDMA System Address)
- SDMA System Address (Host Version 4 Enable = 0): This
register contains the system memory address for an
SDMA transfer in the 32-bit addressing mode. When the
Host Controller stops an SDMA transfer, this register
points to the system address of the next contiguous data
position. It can be accessed only if no transaction is
executing. Reading this register during data transfers may
return an invalid value.
- 32-bit Block Count (Host Version 4 Enable = 1): From the
Host Controller Version 4.10 specification, this register is
redefined as 32-bit Block Count. The Host Controller
decrements the block count of this register for every block
transfer and the data transfer stops when the count
reaches zero. This register must be accessed when no
transaction is executing. Reading this register during data
transfers may return invalid value.
Following are the values for BLOCKCNT_SDMASA:
- 0xFFFF_FFFF - 4G - 1 Block
- ......
- 0x0000_0002 - 2 Blocks
- 0x0000_0001 - 1 Block
- 0x0000_0000 - Stop Count
Note:
- When Host Version 4 Enable = 0, SDMA uses this register as system address and hence Auto CMD23 cannot be used with SDMA since this register is assigned for Auto CMD23 as 32-bit Block Count register. 
-When Host Version 4 Enable = 1, SDMA uses ADMA system address register and this register is reassigned to 32-bit Block Count. This register must be programmed with a non-zero value for data transfer if the 32-bit Block count register is used instead of the 16-bit Block count register. SDMA may use Auto CMD23 if 32-bit Block Count register is used.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLOCKSIZE_R</name>
            <description>Block Size register</description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>XFER_BLOCK_SIZE</name>
                <description>Transfer Block Size
These bits specify the block size of data transfers. In case of
memory, it is set to 512 bytes. It can be accessed only if no
transaction is executing. Read operations during transfers
may return an invalid value, and write operations are
ignored. Following are the values for XFER_BLOCK_SIZE:
- 0x1: 1 byte
- 0x2: 2 bytes
- 0x3: 3 bytes
- ......
- 0x1FF: 511 byte
- 0x200: 512 bytes
- ......
- 0x800: 2048 bytes
Note: This register must be programmed with a non-zero
value for data transfer.</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDMA_BUF_BDARY</name>
                <description>SDMA Buffer Boundary
These bits specify the size of contiguous buffer in system
memory. The SDMA transfer waits at every boundary
specified by these fields and the Host Controller generates
the DMA interrupt to request the Host Driver to update the
SDMA System Address register.
Values:
- 0x0 (BYTES_4K): 4K bytes SDMA Buffer Boundary
- 0x1 (BYTES_8K): 8K bytes SDMA Buffer Boundary
- 0x2 (BYTES_16K): 16K bytes SDMA Buffer Boundary
- 0x3 (BYTES_32K): 32K bytes SDMA Buffer Boundary
- 0x4 (BYTES_64K): 64K bytes SDMA Buffer Boundary
- 0x5 (BYTES_128K): 128K bytes SDMA Buffer Boundary
- 0x6 (BYTES_256K): 256K bytes SDMA Buffer Boundary
- 0x7 (BYTES_512K): 512K bytes SDMA Buffer Boundary</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLOCKCOUNT_R</name>
            <description>16-bit Block Count register</description>
            <addressOffset>0x6</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BLOCK_CNT</name>
                <description>16-bit Block Count
- If the Host Version 4 Enable bit is set 0 or the 16-bit Block
Count register is set to non-zero, the 16-bit Block Count
register is selected.
- If the Host Version 4 Enable bit is set 1 and the 16-bit
Block Count register is set to zero, the 32-bit Block Count
register is selected.
Following are the values for BLOCK_CNT:
- 0x0: Stop Count
- 0x1: 1 Block
- 0x2: 2 Blocks
- ... - ...
- 0xFFFF: 65535 Blocks
Note: For Host Version 4 Enable = 0, this register must be
set to 0000h before programming the 32-bit block count
register when Auto CMD23 is enabled for non-DMA and
ADMA modes.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARGUMENT_R</name>
            <description>Argument register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARGUMENT</name>
                <description>Command Argument
These bits specify the SD/eMMC command argument that is
specified in bits 39-8 of the Command format.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XFER_MODE_R</name>
            <description>Transfer Mode register</description>
            <addressOffset>0xC</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DMA_ENABLE</name>
                <description>DMA Enable
This bit enables the DMA functionality. If this bit is set to 1, a
DMA operation begins when the Host Driver writes to the
Command register. You can select one of the DMA modes by
using DMA Select in the Host Control 1 register.
Values:
- 0x1 (ENABLED): DMA Data transfer
- 0x0 (DISABLED): No data transfer or Non-DMA data
transfer</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BLOCK_COUNT_ENABLE</name>
                <description>Block Count Enable
This bit is used to enable the Block Count register, which is
relevant for multiple block transfers. If this bit is set to 0, the
Block Count register is disabled, which is useful in executing
an infinite transfer. The Host Driver must set this bit to 0
when ADMA is used.  When 16-bit Block Count register is used, the Host Driver can set this bit to 0 in ADMA2 mode to enable larger data transfer than the maximum of 65535 block counts supported by the 16-bit Block Count register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_CMD_ENABLE</name>
                <description>Auto Command Enable
This field determines use of Auto Command functions.
Note: In SDIO, this field must be set as 00b (Auto Command
Disabled).
Values:
- 0x0 (AUTO_CMD_DISABLED): Auto Command Disabled
- 0x1 (AUTO_CMD12_ENABLED): Auto CMD12 Enable
- 0x2 (AUTO_CMD23_ENABLED): Auto CMD23 Enable
- 0x3 (AUTO_CMD_AUTO_SEL): Auto CMD Auto Select</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_XFER_DIR</name>
                <description>Data Transfer Direction Select
This bit defines the direction of DAT line data transfers. This
bit is set to 1 by the Host Driver to transfer data from the
SD/eMMC card to the Host Controller and it is set to 0 for all
other commands.
Values:
- 0x1 (READ): Read (Card to Host)
- 0x0 (WRITE): Write (Host to Card)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MULTI_BLK_SEL</name>
                <description>Multi/Single Block Select
This bit is set when issuing multiple-block transfer
commands using the DAT line. If this bit is set to 0, it is not
necessary to set the Block Count register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_TYPE</name>
                <description>Response Type R1/R5
This bit selects either R1 or R5 as a response type when the
Response Error Check is selected.
Error statuses checked in R1:
- OUT_OF_RANGE
- ADDRESS_ERROR
- BLOCK_LEN_ERROR
- WP_VIOLATION
- CARD_IS_LOCKED
- COM_CRC_ERROR
- CARD_ECC_FAILED
- CC_ERROR
- ERROR
Response Flags checked in R5:
- COM_CRC_ERROR
- ERROR
- FUNCTION_NUMBER
- OUT_OF_RANGE
Values:
- 0x0 (RESP_R1): R1 (Memory)
- 0x1 (RESP_R5): R5 (SDIO)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_ERR_CHK_ENABLE</name>
                <description>Response Error Check Enable
The Host Controller supports response check function to
avoid overhead of response error check by Host driver.
Response types of only R1 and R5 can be checked by the
Controller. If the Host Controller checks the response error,
set this bit to 1 and set Response Interrupt Disable to 1. If an
error is detected, the Response Error interrupt is generated
in the Error Interrupt Status register.
Note:
- Response error check must not be enabled for any
response type other than R1 and R5.
Values:
- 0x0 (DISABLED): Response Error Check is disabled
- 0x1 (ENABLED): Response Error Check is enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_INT_DISABLE</name>
                <description>Response Interrupt Disable
The Host Controller supports response check function to
avoid overhead of response error check by the Host driver.
Response types of only R1 and R5 can be checked by the
Controller.
If Host Driver checks the response error, set this bit to 0 and
wait for Command Complete Interrupt and then check the
response register.
If the Host Controller checks the response error, set this bit
to 1 and set the Response Error Check Enable bit to 1. The
Command Complete Interrupt is disabled by this bit
regardless of the Command Complete Signal Enable.
Values:
- 0x0 (ENABLED): Response Interrupt is enabled
- 0x1 (DISABLED): Response Interrupt is disabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_R</name>
            <description>Command register</description>
            <addressOffset>0xE</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>RESP_TYPE_SELECT</name>
                <description>Response Type Select
This bit indicates the type of response expected from the
card.
Values:
- 0x0 (NO_RESP): No Response
- 0x1 (RESP_LEN_136): Response Length 136
- 0x2 (RESP_LEN_48): Response Length 48
- 0x3 (RESP_LEN_48B): Response Length 48; Check
Busy after response</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_CMD_FLAG</name>
                <description>Sub Command Flag
This bit distinguishes between a main command and a sub
command.
Values:
- 0x0 (MAIN): Main Command
- 0x1 (SUB): Sub Command</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_CRC_CHK_ENABLE</name>
                <description>Command CRC Check Enable
This bit enables the Host Controller to check the CRC field in
the response. If an error is detected, it is reported as a
Command CRC error.
Note:
- CRC Check enable must be set to 0 for the command
with no response, R3 response, and R4 response.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_IDX_CHK_ENABLE</name>
                <description>Command Index Check Enable
This bit enables the Host Controller to check the index field in
the response to verify if it has the same value as the
command index. If the value is not the same, it is reported as
a Command Index error.
Note:
- Index Check enable must be set to 0 for the command
with no response, R2 response, R3 response and R4
response.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_PRESENT_SEL</name>
                <description>Data Present Select
This bit is set to 1 to indicate that data is present and that the
data is transferred using the DAT line. This bit is set to 0 in
the following instances:
- Command using the CMD line
- Command with no data transfer but using busy signal on
the DAT[0] line
- Resume Command
Values:
- 0x0 (NO_DATA): No Data Present
- 0x1 (DATA): Data Present</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_TYPE</name>
                <description>Command Type
These bits indicate the command type.
Note: While issuing Abort CMD using CMD12/CMD52 or
reset CMD using CMD0/CMD52, CMD_TYPE field shall be
set to 0x3.
Values:
- 0x3 (ABORT_CMD): Abort
- 0x2 (RESUME_CMD): Resume
- 0x1 (SUSPEND_CMD): Suspend
- 0x0 (NORMAL_CMD): Normal</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_INDEX</name>
                <description>Command Index
These bits are set to the command number that is specified
in bits 45-40 of the Command Format.</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESP01_R</name>
            <description>Response Register 0/1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP01</name>
                <description>Command Response
These bits reflect 39-8 bits of SD/eMMC Response Field.
Note: For Auto CMD, the 32-bit response (bits 39-8 of the
Response Field) is updated in the RESP67_R register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESP23_R</name>
            <description>Response Register 2/3</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP23</name>
                <description>Command Response
These bits reflect 71-40 bits of the SD/eMMC Response</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESP45_R</name>
            <description>Response Register 4/5</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP45</name>
                <description>Command Response
These bits reflect 103-72 bits of the Response Field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESP67_R</name>
            <description>Response Register 6/7</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP67</name>
                <description>Command Response
These bits reflect bits 135-104 of SD/EMMC Response
Field.
Note: For Auto CMD, this register also reflects the 32-bit
response (bits 39-8 of the Response Field).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUF_DATA_R</name>
            <description>Buffer Data Port Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BUF_DATA</name>
                <description>Buffer Data
These bits enable access to the Host Controller packet
buffer.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PSTATE_REG</name>
            <description>Present State Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1BFF0FF7</resetMask>
            <fields>
              <field>
                <name>CMD_INHIBIT</name>
                <description>Command Inhibit (CMD)
This bit indicates the following :
- SD/eMMC mode: If this bit is set to 0, it indicates that the
CMD line is not in use and the Host controller can issue
an SD/eMMC command using the CMD line. This bit is
set when the command register is written. This bit is
cleared when the command response is received. This bit
is not cleared by the response of auto CMD12/23 but
cleared by the response of read/write command.
Values:
- 0x0 (READY): Host Controller is ready to issue a
command
- 0x1 (NOT_READY): Host Controller is not ready to issue
a command</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMD_INHIBIT_DAT</name>
                <description>Command Inhibit (DAT)
This bit is applicable for SD/eMMC mode and is generated if
either DAT line active or Read transfer active is set to 1. If
this bit is set to 0, it indicates that the Host Controller can
issue subsequent SD/eMMC commands.
Values:
- 0x0 (READY): Can issue command which used DAT line
- 0x1 (NOT_READY): Cannot issue command which used
DAT line</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DAT_LINE_ACTIVE</name>
                <description>DAT Line Active (SD/eMMC Mode only)
This bit indicates whether one of the DAT lines on the
SD/eMMC bus is in use.
In the case of read transactions, this bit indicates whether a
read transfer is executing on the SD/eMMC bus.
In the case of write transactions, this bit indicates whether a
write transfer is executing on the SD/eMMC bus.
For a command with busy, this status indicates whether the
command executing busy is executing on an SD or eMMC
bus.
Values:
- 0x0 (INACTIVE): DAT Line Inactive
- 0x1 (ACTIVE): DAT Line Active</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DAT_7_4</name>
                <description>DAT[7:4] Line Signal Level
This bit is used to check the DAT line level to recover from
errors and for debugging. These bits reflect the value of the
sd_dat_in (upper nibble) signal.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_XFER_ACTIVE</name>
                <description>Write Transfer Active
This status indicates whether a write transfer is active for
SD/eMMC mode.
Values:
- 0x0 (INACTIVE): No valid data
- 0x1 (ACTIVE): Transferring data</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RD_XFER_ACTIVE</name>
                <description>Read Transfer Active
This bit indicates whether a read transfer is active for
SD/eMMC mode.
Values:
- 0x0 (INACTIVE): No valid data
- 0x1 (ACTIVE): Transferring data</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUF_WR_ENABLE</name>
                <description>Buffer Write Enable
This bit is used for non-DMA transfers. This bit is set if space
is available for writing data.
Values:
- 0x0 (DISABLED): Write disable
- 0x1 (ENABLED): Write enable</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUF_RD_ENABLE</name>
                <description>Buffer Read Enable
This bit is used for non-DMA transfers. This bit is set if valid
data exists in the Host buffer.
Values:
- 0x0 (DISABLED): Read disable
- 0x1 (ENABLED): Read enable</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CARD_INSERTED</name>
                <description>Card Inserted
This bit indicates whether a card has been inserted. The
Host Controller debounces this signal so that Host Driver
need not wait for it to stabilize.
Values:
- 0x0 (FALSE): Reset, Debouncing, or No card
- 0x1 (TRUE): Card Inserted</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CARD_STABLE</name>
                <description>Card Stable
This bit indicates the stability of the Card Detect Pin Level. A
card is not detected if this bit is set to 1 and the value of the
CARD_INSERTED bit is 0.
Values:
- 0x0 (FALSE): Reset or Debouncing
- 0x1 (TRUE): No Card or Inserted</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CARD_DETECT_PIN_LEVEL</name>
                <description>Card Detect Pin Level
This bit reflects the inverse synchronized value of the
card_detect_n signal.
Values:
- 0x0 (FALSE): No card present
- 0x1 (TRUE): Card Present</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_PROTECT_SW_LVL</name>
                <description>Write Protect Switch Pin Level
This bit is supported only for memory and combo cards. This
bit reflects the synchronized value of the card_write_prot
signal.
Values:
- 0x0 (FALSE): Write protected
- 0x1 (TRUE): Write enabled</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DAT_3_0</name>
                <description>DAT[3:0] Line Signal Level
This bit is used to check the DAT line level to recover from
errors and for debugging. These bits reflect the value of the
sd_dat_in (lower nibble) signal.</description>
                <bitRange>[23:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMD_LINE_LVL</name>
                <description>Command-Line Signal Level
This bit is used to check the CMD line level to recover from
errors and for debugging. These bits reflect the value of the
sd_cmd_in signal.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HOST_REG_VOL</name>
                <description>Host Regulator Voltage Stable
This bit is used to check whether the host regulator voltage is
stable for switching the voltage of UHS-I mode. This bit
reflects the synchronized value of the host_reg_vol_stable
signal.
Values:
- 0x0 (FALSE): Host Regulator Voltage is not stable
- 0x1 (TRUE): Host Regulator Voltage is stable</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMD_ISSU_ERR</name>
                <description>Command Not Issued by Error
This bit is set if a command cannot be issued after setting
the command register due to an error except the Auto
CMD12 error.
Values:
- 0x0 (FALSE): No error for issuing a command
- 0x1 (TRUE): Command cannot be issued</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUB_CMD_STAT</name>
                <description>Sub Command Status
This bit is used to distinguish between a main command and
a sub command status.
Values:
- 0x0 (FALSE): Main Command Status
- 0x1 (TRUE): Sub Command Status</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTRL1_R</name>
            <description>Host Control 1 Register</description>
            <addressOffset>0x28</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>LED_CTRL</name>
                <description>LED Control
This bit is used to caution the user not to remove the card
while the SD card is being accessed. The value is reflected
on the led_ctrl ouput.
Values:
- 0x0 (OFF): LED off
- 0x1 (ON): LED on</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAT_XFER_WIDTH</name>
                <description>Data Transfer Width
For SD/eMMC mode,this bit selects the data transfer width of
the Host Controller. The Host Driver sets it to match the data
width of the SD/eMMC card.
Values:
- 0x1 (FOUR_BIT): 4-bit mode
- 0x0 (ONE_BIT): 1-bit mode</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HIGH_SPEED_EN</name>
                <description>High Speed Enable (SD/eMMC Mode only)
Before setting this bit, the Host Driver checks the High Speed
Support in the Capabilities register.
Note: SDHC always outputs the sd_cmd_out and
sd_dat_out lines at the rising edge of card clock
irrespective of this bit.
Values:
- 0x1 (HIGH_SPEED): High Speed mode
- 0x0 (NORMAL_SPEED): Normal Speed mode</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_SEL</name>
                <description>N/A</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXT_DAT_XFER</name>
                <description>Extended Data Transfer Width
This bit controls 8-bit bus width mode of embedded device.
Values:
- 0x1 (EIGHT_BIT): 8-bit Bus Width
- 0x0 (DEFAULT): Bus Width is selected by the Data
Transfer Width</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_DETECT_TEST_LVL</name>
                <description>Card Detect Test Level
This bit is enabled while the Card Detect Signal Selection is
set to 1 and it indicates whether a card inserted or not.
Values:
- 0x1 (CARD_INSERTED): Card Inserted
- 0x0 (No_CARD): No Card</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_DETECT_SIG_SEL</name>
                <description>Card Detect Signal Selection
This bit selects a source for card detection. When the source
for the card detection is switched, the interrupt must be
disabled during the switching period.
Values:
- 0x1 (CARD_DT_TEST_LEVEL): Card Detect Test Level
is selected (for test purpose)
- 0x0 (card_detect_n): card_detect_n signal is
selected (for normal use)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_CTRL_R</name>
            <description>Power Control Register</description>
            <addressOffset>0x29</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>SD_BUS_PWR_VDD1</name>
                <description>SD Bus Power for VDD1
This bit enables VDD1 power of the card. This setting is
available on the card_if_pwr_en output so that it
can be used to control the VDD1 power supply of the card.
Before setting this bit, the SD Host Driver sets the SD Bus
Voltage Select bit. If the Host Controller detects a No Card
state, this bit is cleared.
In SD mode, if this bit is cleared, the Host Controller stops
the SD Clock by clearing the SD_CLK_IN bit in the
CLK_CTRL_R register.
Values:
- 0x0 (OFF): Power off
- 0x1 (ON): Power on</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SD_BUS_VOL_VDD1</name>
                <description>These bits are NON-operational (they can be written and read but they have no effect).  In a generic HCI host these would select the card supply voltage.  But, for the applications targeted for this block it is assumed that the card supply voltage is always fixed at the board level.  If for some reason there is a variable power supply then that can be managed through normal GPIO programming separately.</description>
                <bitRange>[3:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BGAP_CTRL_R</name>
            <description>Block Gap Control Register</description>
            <addressOffset>0x2A</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>STOP_BG_REQ</name>
                <description>Stop At Block Gap Request
This bit is used to stop executing read and write transactions
at the next block gap for non-DMA, SDMA, and ADMA
transfers.
Values:
- 0x0 (XFER): Transfer
- 0x1 (STOP): Stop</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTINUE_REQ</name>
                <description>Continue Request
This bit is used to restart the transaction, which was stopped
using the Stop At Block Gap Request. The Host Controller
automatically clears this bit when the transaction restarts. If
stop at block gap request is set to 1, any write to this bit is
ignored.
Values:
- 0x0 (NO_AFFECT): No Affect
- 0x1 (RESTART): Restart</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RD_WAIT_CTRL</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_AT_BGAP</name>
                <description>Interrupt At Block Gap
This bit is valid only in the 4-bit mode of an SDIO card and is
used to select a sample point in the interrupt cycle. Setting to
1 enables interrupt detection at the block gap for a multiple
block transfer.
Values:
- 0x0 (DISABLE): Disabled
- 0x1 (ENABLE): Enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WUP_CTRL_R</name>
            <description>Wakeup Control Register</description>
            <addressOffset>0x2B</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>WUP_CARD_INT</name>
                <description>Wakeup Event Enable on SDIO Card Interrupt (through DAT[1]).
This bit enables wakeup event through an SDIO Card Interrupt
assertion in the Normal Interrupt Status register. This bit can
be set to 1 if FN_WUS (Wake Up Support) in CIS is set to 1.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WUP_CARD_INSERT</name>
                <description>Wakeup Event Enable on SD Card Insertion
This bit enables wakeup event through Card Insertion
assertion in the Normal Interrupt Status register. FN_WUS
(Wake Up Support) in CIS does not affect this bit.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WUP_CARD_REMOVAL</name>
                <description>Wakeup Event Enable on SD Card Removal
This bit enables wakeup event through Card Removal
assertion in the Normal Interrupt Status register. For the
SDIO card, Wake Up Support (FN_WUS) in the Card
Information Structure (CIS) register does not affect this bit.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLK_CTRL_R</name>
            <description>Clock Control Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFEF</resetMask>
            <fields>
              <field>
                <name>INTERNAL_CLK_EN</name>
                <description>Internal Clock Enable
This bit is set to 0 when the Host Driver is not using the Host
Controller or the Host Controller awaits a wakeup interrupt.
The Host Controller must stop its internal clock to enter a
very low power state. Certain registers are not accessible when this bit is off.  So, to be safe turn it on for any register access.
Values:
- 0x0 (FALSE): Stop
- 0x1 (TRUE): Oscillate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INTERNAL_CLK_STABLE</name>
                <description>Internal Clock Stable
This bit enables the Host Driver to check the clock stability
twice after the Internal Clock Enable bit is set and after the
PLL Enable bit is set. This bit reflects the synchronized
value of the Internal Clock Stable signal after the Internal Clock
Enable bit is set to 1 and also reflects the synchronized
value of the Card Clock Stable signal after the PLL Enable bit is
set to 1.
Values:
- 0x0 (FALSE): Not Ready
- 0x1 (TRUE): Ready</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SD_CLK_EN</name>
                <description>SD/eMMC Clock Enable
This bit stops the clk_card output when set to 0. The
SDCLK Frequency Select bit can be changed when
this bit is set to 0.
Values:
- 0x0 (FALSE): Disable providing clk_card
- 0x1 (TRUE): Enable providing clk_card</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_ENABLE</name>
                <description>PLL Enable
This bit is used to activate the PLL (applicable when Host
Version 4 Enable = 1).
Values:
- 0x0 (FALSE): PLL is in low power mode
- 0x1 (TRUE): PLL is enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLK_GEN_SELECT</name>
                <description>Clock Generator Select
This bit is used to select the clock generator mode in
SDCLK Frequency Select.
Values:
- 0x0 (FALSE): Divided Clock Mode
- 0x1 (TRUE): Programmable Clock Mode</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UPPER_FREQ_SEL</name>
                <description>These bits specify the upper 2 bits of 10-bit SDCLK
Frequency Select control.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FREQ_SEL</name>
                <description>SDCLK Frequency Select
These bits are used to select the frequency of the SDCLK
signal.
10-bit Divided Clock Mode:
- 0x3FF - 1/2046 Divided clock
- ..........
- N - 1/2N Divided Clock
- ..........
- 0x002 - 1/4 Divided Clock
- 0x001 - 1/2 Divided Clock
- 0x000 - Base clock (10MHz - 255 MHz)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOUT_CTRL_R</name>
            <description>Timeout Control Register</description>
            <addressOffset>0x2E</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>TOUT_CNT</name>
                <description>N/A</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_RST_R</name>
            <description>Software Reset Register</description>
            <addressOffset>0x2F</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>SW_RST_ALL</name>
                <description>Software Reset For All
This reset affects the entire Host Controller except for the
card detection circuit. During its initialization, the Host Driver
sets this bit to 1 to reset the Host Controller. All registers are
reset except the capabilities register. If this bit is set to 1, the
Host Driver must issue reset command and reinitialize the
card.
Values:
- 0x0 (FALSE): Work
- 0x1 (TRUE): Reset</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SW_RST_CMD</name>
                <description>Software Reset For CMD line
This bit resets only a part of the command circuit to be able
to issue a command. This reset is effective only for a command
issuing circuit (including response error statuses related to
Command Inhibit (CMD) control) and does not affect the
data transfer circuit. Host Controller can continue data
transfer even after this reset is executed while handling
subcommand-response errors.
The following registers and bits are cleared by this bit:
- Present State register - Command Inhibit (CMD) bit
- Normal Interrupt Status register - Command Complete bit
- Error Interrupt Status - Response error statuses related
to Command Inhibit (CMD) bit
Values:
- 0x0 (FALSE): Work
- 0x1 (TRUE): Reset</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SW_RST_DAT</name>
                <description>Software Reset For DAT line
This bit is used in SD/eMMC mode and it resets only a part
of the data circuit and the DMA circuit is also reset.
The following registers and bits are cleared by this bit:
- Buffer Data Port register
- Buffer is cleared and initialized.
- Present state register
- Buffer Read Enable
- Buffer Write Enable
- Read Transfer Active
- Write Transfer Active
- DAT Line Active
- Command Inhibit (DAT)
- Block Gap Control register
- Continue Request
- Stop At Block Gap Request
- Normal Interrupt status register
- Buffer Read Ready
- Buffer Write Ready
- DMA Interrupt
- Block Gap Event
- Transfer Complete
Values:
- 0x0 (FALSE): Work
- 0x1 (TRUE): Reset</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NORMAL_INT_STAT_R</name>
            <description>Normal Interrupt Status Register</description>
            <addressOffset>0x30</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xE1FF</resetMask>
            <fields>
              <field>
                <name>CMD_COMPLETE</name>
                <description>Command Complete
In an SD/eMMC Mode, this bit is set when the end bit of a
response except for Auto CMD12 and Auto CMD23.
This interrupt is not generated when the Response Interrupt
Disable in Transfer Mode Register is set to 1.
Values:
- 0x0 (FALSE): No command complete
- 0x1 (TRUE): Command Complete</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XFER_COMPLETE</name>
                <description>Transfer Complete
This bit is set when a read/write transfer and a command
with status busy is completed.
Values:
- 0x0 (FALSE): Not complete
- 0x1 (TRUE): Command execution is completed</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGAP_EVENT</name>
                <description>Block Gap Event
This bit is set when both read/write transaction is stopped at
block gap due to a Stop at Block Gap Request.
Values:
- 0x0 (FALSE): No Block Gap Event
- 0x1 (TRUE): Transaction stopped at block gap</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_INTERRUPT</name>
                <description>DMA Interrupt
This bit is set if the Host Controller detects the SDMA Buffer
Boundary during transfer. In case of ADMA, by setting the Int
field in the descriptor table, the Host controller generates this
interrupt. This interrupt is not generated after a Transfer
Complete.
Values:
- 0x0 (FALSE): No DMA Interrupt
- 0x1 (TRUE): DMA Interrupt is generated</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_WR_READY</name>
                <description>Buffer Write Ready
This bit is set if the Buffer Write Enable changes from 0 to 1.
Values:
- 0x0 (FALSE): Not ready to write buffer
- 0x1 (TRUE): Ready to write buffer</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_RD_READY</name>
                <description>Buffer Read Ready
This bit is set if the Buffer Read Enable changes from 0 to 1.
Values:
- 0x0 (FALSE): Not ready to read buffer
- 0x1 (TRUE): Ready to read buffer</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INSERTION</name>
                <description>Card Insertion
This bit is set if the Card Inserted in the Present State
register changes from 0 to 1.
Values:
- 0x0 (FALSE): Card state stable or Debouncing
- 0x1 (TRUE): Card Inserted</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_REMOVAL</name>
                <description>Card Removal
This bit is set if the Card Inserted in the Present State
register changes from 1 to 0.
Values:
- 0x0 (FALSE): Card state stable or Debouncing
- 0x1 (TRUE): Card Removed</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INTERRUPT</name>
                <description>Card Interrupt
This bit reflects the synchronized value of:
- DAT[1] Interrupt Input for SD Mode
Values:
- 0x0 (FALSE): No Card Interrupt
- 0x1 (TRUE): Generate Card Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FX_EVENT</name>
                <description>FX Event
This status is set when R[14] of response register is set to 1
and Response Type R1/R5 is set to 0 in Transfer Mode
register. This interrupt is used with response check function.
Values:
- 0x0 (FALSE): No Event
- 0x1 (TRUE): FX Event is detected</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CQE_EVENT</name>
                <description>Command Queuing Event
This status is set if Command Queuing/Crypto related event
has occurred in eMMC/SD mode. Read CQHCI's
CQIS/CRNQIS register for more details. In UHS-II Mode,
this bit is irrelevant.
Values:
- 0x0 (FALSE): No Event
- 0x1 (TRUE): Command Queuing Event is detected</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INTERRUPT</name>
                <description>Error Interrupt
If any of the bits in the Error Interrupt Status register are set,
then this bit is set.
Values:
- 0x0 (FALSE): No Error
- 0x1 (TRUE): Error</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ERROR_INT_STAT_R</name>
            <description>Error Interrupt Status Register</description>
            <addressOffset>0x32</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFF</resetMask>
            <fields>
              <field>
                <name>CMD_TOUT_ERR</name>
                <description>Command Timeout Error
In SD/eMMC Mode,this bit is set only if no response is
returned within 64 SD clock cycles from the end bit of the
command. If the Host Controller detects a CMD line conflict,
along with Command CRC Error bit, this bit is set to 1,
without waiting for 64 SD/eMMC card clock cycles.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Time out</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_CRC_ERR</name>
                <description>Command CRC Error
Command CRC Error is generated in SD/eMMC mode for
following two cases.
- If a response is returned and the Command Timeout
Error is set to 0 (indicating no timeout), this bit is set to 1
when detecting a CRC error in the command response.
- The Host Controller detects a CMD line conflict by
monitoring the CMD line when a command is issued. If
the Host Controller drives the CMD line to 1 level, but
detects 0 level on the CMD line at the next SD clock
edge, then the Host Controller aborts the command (stop
driving CMD line) and set this bit to 1. The Command
Timeout Error is also set to 1 to distinguish a CMD line
conflict.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): CRC error generated</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_END_BIT_ERR</name>
                <description>Command End Bit Error
This bit is set when detecting that the end bit of a command
response is 0 in SD/eMMC mode.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): End Bit error generated</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_IDX_ERR</name>
                <description>Command Index Error
This bit is set if a Command Index error occurs in the
command respons in SD/eMMC mode.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_TOUT_ERR</name>
                <description>Data Timeout Error
This bit is set in SD/eMMC mode when detecting one of the
following timeout conditions:
- Busy timeout for R1b, R5b type
- Busy timeout after Write CRC status
- Write CRC Status timeout
- Read Data timeout
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Time out</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_ERR</name>
                <description>Data CRC Error
This error occurs in SD/eMMC mode when detecting CRC
error when transferring read data which uses the DAT line,
when detecting the Write CRC status having a value of other
than 010 or when write CRC status timeout.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_END_BIT_ERR</name>
                <description>Data End Bit Error
This error occurs in SD/eMMC mode either when detecting 0
at the end bit position of read data that uses the DAT line or
at the end bit position of the CRC status.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CUR_LMT_ERR</name>
                <description>Current Limit Error
By setting the SD Bus Power bit in the Power Control
register, the Host Controller is requested to supply power for
the SD Bus. If the Host Controller supports the Current Limit
function, it can be protected from an illegal card by stopping
power supply to the card in which case this bit indicates a
failure status. A reading of 1 for this bit means that the Host
Controller is not supplying power to the SD card due to some
failure. A reading of 0 for this bit means that the Host
Controller is supplying power and no error has occurred. The
Host Controller may require some sampling time to detect
the current limit. DWC_mshc Host Controller does not
support this function, this bit is always set to 0.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Power Fail</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_CMD_ERR</name>
                <description>Auto CMD Error
This error status is used by Auto CMD12 and Auto CMD23 in
SD/eMMC mode. This bit is set when detecting that any of
the bits D00 to D05 in Auto CMD Error Status register has
changed from 0 to 1. D07 is effective in case of Auto CMD12.
Auto CMD Error Status register is valid while this bit is set to
1 and may be cleared by clearing of this bit.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADMA_ERR</name>
                <description>ADMA Error
This bit is set when the Host Controller detects error during
ADMA-based data transfer. The error could be due to
following reasons:
- Error response received from System bus (Master I/F)
- ADMA3,ADMA2 Descriptors invalid
- CQE Task or Transfer descriptors invalid
When the error occurs, the state of the ADMA is saved in the
ADMA Error Status register.
In eMMC CQE mode:
The Host Controller generates this Interrupt when it detects
an invalid descriptor data (Valid=0) at the ST_FDS state.
ADMA Error State in the ADMA Error Status indicates that
an error has occurred in ST_FDS state. The Host Driver may
find that Valid bit is not set at the error descriptor.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TUNING_ERR</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_ERR</name>
                <description>Response Error
Host Controller Version 4.00 supports response error check
function to avoid overhead of response error check by Host
Driver during DMA execution. If Response Error Check
Enable is set to 1 in the Transfer Mode register, Host
Controller Checks R1 or R5 response. If an error is detected
in a response, this bit is set to 1.This is applicable in
SD/eMMC mode.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BOOT_ACK_ERR</name>
                <description>Boot Acknowledgement Error
This bit is set when there is a timeout for boot
acknowledgement or when detecting boot ack status having
a value other than 010. This is applicable only when boot
acknowledgement is expected in eMMC mode.
In SD mode, this bit is irrelevant.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NORMAL_INT_STAT_EN_R</name>
            <description>Normal Interrupt Status Enable Register</description>
            <addressOffset>0x34</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>CMD_COMPLETE_STAT_EN</name>
                <description>Command Complete Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XFER_COMPLETE_STAT_EN</name>
                <description>Transfer Complete Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGAP_EVENT_STAT_EN</name>
                <description>Block Gap Event Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_INTERRUPT_STAT_EN</name>
                <description>DMA Interrupt Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_WR_READY_STAT_EN</name>
                <description>Buffer Write Ready Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_RD_READY_STAT_EN</name>
                <description>Buffer Read Ready Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INSERTION_STAT_EN</name>
                <description>Card Insertion Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_REMOVAL_STAT_EN</name>
                <description>Card Removal Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INTERRUPT_STAT_EN</name>
                <description>Card Interrupt Status Enable
If this bit is set to 0, the Host Controller clears the interrupt
request to the System. The Card Interrupt detection is
stopped when this bit is cleared and restarted when this bit is
set to 1. The Host Driver may clear the Card Interrupt Status
Enable before servicing the Card Interrupt and may set this
bit again after all interrupt requests from the card are cleared
to prevent inadvertent interrupts.
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_A_STAT_EN</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_B_STAT_EN</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_C_STAT_EN</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RE_TUNE_EVENT_STAT_EN</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FX_EVENT_STAT_EN</name>
                <description>FX Event Status Enable
This bit is added from Version 4.10.
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CQE_EVENT_STAT_EN</name>
                <description>CQE Event Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ERROR_INT_STAT_EN_R</name>
            <description>Error Interrupt Status Enable Register</description>
            <addressOffset>0x36</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CMD_TOUT_ERR_STAT_EN</name>
                <description>Command Timeout Error Status Enable (SD/eMMC Mode
only).
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_CRC_ERR_STAT_EN</name>
                <description>ommand CRC Error Status Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_END_BIT_ERR_STAT_EN</name>
                <description>Command End Bit Error Status Enable (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_IDX_ERR_STAT_EN</name>
                <description>Command Index Error Status Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_TOUT_ERR_STAT_EN</name>
                <description>Data Timeout Error Status Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_ERR_STAT_EN</name>
                <description>Data CRC Error Status Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_END_BIT_ERR_STAT_EN</name>
                <description>Data End Bit Error Status Enable (SD/eMMC Mode only).
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CUR_LMT_ERR_STAT_EN</name>
                <description>Current Limit Error Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_CMD_ERR_STAT_EN</name>
                <description>Auto CMD Error Status Enable (SD/eMMC Mode only).
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADMA_ERR_STAT_EN</name>
                <description>ADMA Error Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TUNING_ERR_STAT_EN</name>
                <description>Tuning Error Status Enable (UHS-I Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_ERR_STAT_EN</name>
                <description>Response Error Status Enable (SD Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BOOT_ACK_ERR_STAT_EN</name>
                <description>Boot Acknowledgment Error (eMMC Mode only)
Setting this bit to 1 enables setting of Boot Acknowledgment
Error in Error Interrupt Status register
(ERROR_INT_STAT_R).
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_STAT_EN1</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_STAT_EN2</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_STAT_EN3</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NORMAL_INT_SIGNAL_EN_R</name>
            <description>Normal Interrupt Signal Enable Register</description>
            <addressOffset>0x38</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>CMD_COMPLETE_SIGNAL_EN</name>
                <description>Command Complete Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XFER_COMPLETE_SIGNAL_EN</name>
                <description>Transfer Complete Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGAP_EVENT_SIGNAL_EN</name>
                <description>Block Gap Event Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_INTERRUPT_SIGNAL_EN</name>
                <description>DMA Interrupt Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_WR_READY_SIGNAL_EN</name>
                <description>Buffer Write Ready Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_RD_READY_SIGNAL_EN</name>
                <description>Buffer Read Ready Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INSERTION_SIGNAL_EN</name>
                <description>Card Insertion Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_REMOVAL_SIGNAL_EN</name>
                <description>Card Removal Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INTERRUPT_SIGNAL_EN</name>
                <description>Card Interrupt Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_A_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_B_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_C_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RE_TUNE_EVENT_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FX_EVENT_SIGNAL_EN</name>
                <description>FX Event Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CQE_EVENT_SIGNAL_EN</name>
                <description>Command Queuing Engine Event Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ERROR_INT_SIGNAL_EN_R</name>
            <description>Error Interrupt Signal Enable Register</description>
            <addressOffset>0x3A</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CMD_TOUT_ERR_SIGNAL_EN</name>
                <description>Command Timeout Error Signal Enable (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_CRC_ERR_SIGNAL_EN</name>
                <description>Command CRC Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_END_BIT_ERR_SIGNAL_EN</name>
                <description>Command End Bit Error Signal Enable (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_IDX_ERR_SIGNAL_EN</name>
                <description>Command Index Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_TOUT_ERR_SIGNAL_EN</name>
                <description>Data Timeout Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_ERR_SIGNAL_EN</name>
                <description>Data CRC Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_END_BIT_ERR_SIGNAL_EN</name>
                <description>Data End Bit Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CUR_LMT_ERR_SIGNAL_EN</name>
                <description>Current Limit Error Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_CMD_ERR_SIGNAL_EN</name>
                <description>Auto CMD Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADMA_ERR_SIGNAL_EN</name>
                <description>ADMA Error Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TUNING_ERR_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_ERR_SIGNAL_EN</name>
                <description>Response Error Signal Enable (SD Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BOOT_ACK_ERR_SIGNAL_EN</name>
                <description>Boot Acknowledgment Error (eMMC Mode only).
Setting this bit to 1 enables generating interrupt signal when
Boot Acknowledgement Error in Error Interrupt Status
register is set.
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_SIGNAL_EN1</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_SIGNAL_EN2</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_SIGNAL_EN3</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AUTO_CMD_STAT_R</name>
            <description>Auto CMD Status Register</description>
            <addressOffset>0x3C</addressOffset>
            <size>16</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xBF</resetMask>
            <fields>
              <field>
                <name>AUTO_CMD12_NOT_EXEC</name>
                <description>Auto CMD12 Not Executed
If multiple memory block data transfer is not started due to a
command error, this bit is not set because it is not necessary
to issue an Auto CMD12. Setting this bit to 1 means that the
Host Controller cannot issue Auto CMD12 to stop multiple
memory block data transfer, due to some error. If this bit is
set to 1, error status bits (D04-D01) is meaningless.
This bit is set to 0 when Auto CMD Error is generated by
Auto CMD23.
Values:
- 0x1 (TRUE): Not Executed
- 0x0 (FALSE): Executed</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_TOUT_ERR</name>
                <description>Auto CMD Timeout Error
This bit is set if no response is returned with 64 SDCLK
cycles from the end bit of the command.
If this bit is set to 1, error status bits (D04-D01) are
meaningless.
Values:
- 0x1 (TRUE): Time out
- 0x0 (FALSE): No Error</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_CRC_ERR</name>
                <description>Auto CMD CRC Error
This bit is set when detecting a CRC error in the command
response.
Values:
- 0x1 (TRUE): CRC Error Generated
- 0x0 (FALSE): No Error</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_EBIT_ERR</name>
                <description>Auto CMD End Bit Error
This bit is set when detecting that the end bit of command
response is 0.
Values:
- 0x1 (TRUE): End Bit Error Generated
- 0x0 (FALSE): No Error</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_IDX_ERR</name>
                <description>Auto CMD Index Error
This bit is set if the command index error occurs in response
to a command.
Values:
- 0x1 (TRUE): Error
- 0x0 (FALSE): No Error</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_RESP_ERR</name>
                <description>Auto CMD Response Error
This bit is set when Response Error Check Enable in the
Transfer Mode register is set to 1 and an error is detected in
R1 response of either Auto CMD12 or CMD13. This status is
ignored if any bit between D00 to D04 is set to 1.
Values:
- 0x1 (TRUE): Error
- 0x0 (FALSE): No Error</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMD_NOT_ISSUED_AUTO_CMD12</name>
                <description>Command Not Issued By Auto CMD12 Error
If this bit is set to 1, CMD_wo_DAT is not executed due to an
Auto CMD12 Error (D04-D01) in this register.
This bit is set to 0 when Auto CMD Error is generated by
Auto CMD23.
Values:
- 0x1 (TRUE): Not Issued
- 0x0 (FALSE): No Error</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTRL2_R</name>
            <description>Host Control 2 Register</description>
            <addressOffset>0x3E</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFDFF</resetMask>
            <fields>
              <field>
                <name>UHS_MODE_SEL</name>
                <description>N/A</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SIGNALING_EN</name>
                <description>1.8V Signaling Enable
This bit controls voltage regulator for I/O cell in SD UHS-I mode. Setting this bit from 0 to 1 starts changing the
signal voltage from 3.3V to 1.8V. Host Controller clears this
bit if switching to 1.8V signaling fails per protocol. The value is reflected on the io_volt_sel output which can then be used to change an external regulator to supply 1.8V instead of 3.3V on the VDDIO pin associated with the CLK/CMD/DAT signals.
Note: This bit must be set for all UHS-I speed modes
(SDR12/SDR25/SDR50/DDR50).
Values:
- 0x0 (V_3_3): 3.3V Signalling
- 0x1 (V_1_8): 1.8V Signalling</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_STRENGTH_SEL</name>
                <description>Driver Strength Select
These bits are used to select the Host Controller output driver in
1.8V signaling UHS-I/eMMC speed modes. The value is reflected on the io_drive_strength[1:0] output.
- 0x0 (TYPEB): Driver TYPEB is selected
- 0x1 (TYPEA): Driver TYPEA is selected
- 0x2 (TYPEC): Driver TYPEC is selected
- 0x3 (TYPED): Driver TYPED is selected</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXEC_TUNING</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SAMPLE_CLK_SEL</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UHS2_IF_ENABLE</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADMA2_LEN_MODE</name>
                <description>ADMA2 Length Mode
This bit selects ADMA2 Length mode to be either 16-bit or
26-bit.
Values:
- 0x0 (FALSE): 16-bit Data Length Mode
- 0x1 (TRUE): 26-bit Data Length Mode</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD23_ENABLE</name>
                <description>CMD23 Enable
If the card supports CMD23, this bit is set to 1. This bit is
used to select Auto CMD23 or Auto CMD12 for ADMA3 data
transfer.
Values:
- 0x0 (FALSE): Auto CMD23 is disabled
- 0x1 (TRUE): Auto CMD23 is enabled</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HOST_VER4_ENABLE</name>
                <description>Host Version 4 Enable
This bit selects either Version 3.00 compatible mode or
Version 4 mode.
Functions of following fields are modified for Host Version 4
mode:
- SDMA Address: SDMA uses ADMA System Address
(05Fh-058h) instead of SDMA System Address register
(003h-000h)
- ADMA2/ADMA3 selection: ADMA3 is selected by DMA
select in Host Control 1 register
- 32-bit Block Count: SDMA System Address register
(003h-000h) is modified to 32-bit Block Count register
Note: It is recommended not to program ADMA3 Integrated
Descriptor Address registers and
Command Queuing registers (if applicable) while operating
in Host version less than 4 mode (Host Version 4 Enable =
0).
Values:
- 0x0 (FALSE): Version 3.00 compatible mode
- 0x1 (TRUE): Version 4 mode</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADDRESSING</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ASYNC_INT_ENABLE</name>
                <description>Asynchronous Interrupt Enable
This bit can be set if a card supports asynchronous
interrupts and Asynchronous Interrupt Support is set to 1 in
the Capabilities register.
Values:
- 0x0 (FALSE): Disabled
- 0x1 (TRUE): Enabled</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESET_VAL_ENABLE</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPABILITIES1_R</name>
            <description>Capabilities 1 Register - 0 to 31</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x276C6481</resetValue>
            <resetMask>0xFFEFFFBF</resetMask>
            <fields>
              <field>
                <name>TOUT_CLK_FREQ</name>
                <description>Timeout Clock Frequency
This bit shows the base clock frequency used to detect Data
Timeout Error. The Timeout Clock unit defines the unit of
timeout clock frequency. It can be KHz or MHz.
- 0x00 - Get information through another method
- 0x01 - 1KHz / 1MHz
- 0x02 - 2KHz / 2MHz
- 0x03 - 3KHz / 3MHz
- ...........
- 0x3F - 63KHz / 63MHz</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TOUT_CLK_UNIT</name>
                <description>Timeout Clock Unit
This bit shows the unit of base clock frequency used to
detect Data TImeout Error.
Values:
- 0x0 (KHZ): KHz
- 0x1 (MHZ): MHz</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BASE_CLK_FREQ</name>
                <description>Base Clock Frequency for SD clock
These bits indicate the base (maximum) clock frequency for
the SD Clock. The definition of these bits depend on the Host
Controller Version.
- 6-Bit Base Clock Frequency: This mode is supported by
the Host Controller version 1.00 and 2.00. The upper 2
bits are not effective and are always 0. The unit values
are 1 MHz. The supported clock range is 10 MHz to 63
MHz.
- 0x00 - Get information through another method
- 0x01 - 1 MHz
- 0x02 - 2 MHz
- .............
- 0x3F - 63 MHz
- 0x40-0xFF - Not Supported
- 8-Bit Base Clock Frequency: This mode is supported by
the Host Controller version 3.00. The unit values are 1
MHz. The supported clock range is 10 MHz to 255 MHz.
- 0x00 - Get information through another method
- 0x01 - 1 MHz
- 0x02 - 2 MHz
- ............
- 0xFF - 255 MHz
If the frequency is 16.5 MHz, the larger value is set to
0001001b (17 MHz) because the Host Driver uses this value
to calculate the clock divider value and it does not exceed
the upper limit of the SD Clock frequency. If these bits are all
0, the Host system has to get information using a different
method.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_BLK_LEN</name>
                <description>N/A</description>
                <bitRange>[17:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EMBEDDED_8_BIT</name>
                <description>8-bit Support for Embedded Device
This bit indicates whether the Host Controller is capable of
using an 8-bit bus width mode. This bit is not effective when
the Slot Type is set to 10b.
Values:
- 0x0 (FALSE): 8-bit Bus Width not Supported
- 0x1 (TRUE): 8-bit Bus Width Supported</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ADMA2_SUPPORT</name>
                <description>ADMA2 Support
This bit indicates whether the Host Controller is capable of
using ADMA2.
Values:
- 0x0 (FALSE): ADMA2 not Supported
- 0x1 (TRUE): ADMA2 Supported</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HIGH_SPEED_SUPPORT</name>
                <description>High Speed Support
This bit indicates whether the Host Controller and the Host
System supports High Speed mode and they can supply the
SD Clock frequency from 25 MHz to 50 MHz.
Values:
- 0x0 (FALSE): High Speed not Supported
- 0x1 (TRUE): High Speed Supported</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SDMA_SUPPORT</name>
                <description>SDMA Support
This bit indicates whether the Host Controller is capable of
using SDMA to transfer data between the system memory
and the Host Controller directly.
Values:
- 0x0 (FALSE): SDMA not Supported
- 0x1 (TRUE): SDMA Supported</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUS_RES_SUPPORT</name>
                <description>Suspense/Resume Support
This bit indicates whether the Host Controller supports
Suspend/Resume functionality. If this bit is 0, the Host Driver
does not issue either Suspend or Resume commands
because the Suspend and Resume mechanism is not
supported.
Values:
- 0x0 (FALSE): Not Supported
- 0x1 (TRUE): Supported</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VOLT_33</name>
                <description>Voltage Support 3.3V
Values:
- 0x0 (FALSE): 3.3V Not Supported
- 0x1 (TRUE): 3.3V Supported</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VOLT_30</name>
                <description>Voltage Support 3.0V
Values:
- 0x0 (FALSE): 3.0V Not Supported
- 0x1 (TRUE): 3.0V Supported</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VOLT_18</name>
                <description>Voltage Support 1.8V
Values:
- 0x0 (FALSE): 1.8V Not Supported
- 0x1 (TRUE): 1.8V Supported</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SYS_ADDR_64_V4</name>
                <description>64-bit System Address Support for V4
This bit sets the Host Controller to support 64-bit System
Addressing of V4 mode. When this bit is set to 1, full or part
of 64-bit address must be used to decode the Host Controller
Registers so that Host Controller Registers can be placed
above system memory area. 64-bit address decode of Host
Controller registers is effective regardless of setting to 64-bit
Addressing in Host Control 2.
If this bit is set to 1, 64-bit DMA Addressing for version 4 is
enabled by setting Host Version 4 Enable
(HOST_VER4_ENABLE = 1) and by setting 64-bit
Addressing (ADDRESSING =1) in the Host Control 2
register. SDMA can be used and ADMA2 uses 128-bit
Descriptor.
Values:
- 0x0 (FALSE): 64-bit System Address for V4 is Not
Supported
- 0x1 (TRUE): 64-bit System Address for V4 is Supported</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SYS_ADDR_64_V3</name>
                <description>64-bit System Address Support for V3
This bit sets the Host controller to support 64-bit System
Addressing of V3 mode.
SDMA cannot be used in 64-bit Addressing in Version 3
Mode.
If this bit is set to 1, 64-bit ADMA2 with using 96-bit
Descriptor can be enabled by setting Host Version 4 Enable
(HOST_VER4_ENABLE = 0) and DMA select (DMA_SEL =
11b).
Values:
- 0x0 (FALSE): 64-bit System Address for V3 is Not
Supported
- 0x1 (TRUE): 64-bit System Address for V3 is Supported</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ASYNC_INT_SUPPORT</name>
                <description>Asynchronous Interrupt Support (SD Mode only)
Values:
- 0x0 (FALSE): Asynchronous Interrupt Not Supported
- 0x1 (TRUE): Asynchronous Interrupt Supported</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SLOT_TYPE_R</name>
                <description>Slot Type
These bits indicate usage of a slot by a specific Host
System.
Values:
- 0x0 (REMOVABLE_SLOT): Removable Card Slot
- 0x1 (EMBEDDED_SLOT): Embedded Slot for one Device
- 0x2 (SHARED_SLOT): Shared Bus Slot (SD mode)
- 0x3 (UHS2_EMBEDDED_SLOT): UHS-II Multiple
Embedded Devices</description>
                <bitRange>[31:30]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPABILITIES2_R</name>
            <description>Capabilities Register - 32 to 63</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x8000077</resetValue>
            <resetMask>0x18FFEF7F</resetMask>
            <fields>
              <field>
                <name>SDR50_SUPPORT</name>
                <description>SDR50 Support (UHS-I only)
Thsi bit indicates that SDR50 is supported. The bit 13
(USE_TUNING_SDR50) indicates whether SDR50 requires
tuning or not.
Values:
- 0x0 (FALSE): SDR50 is not supported
- 0x1 (TRUE): SDR50 is supported</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SDR104_SUPPORT</name>
                <description>SDR104 Support (UHS-I only)
This bit mentions that SDR104 requires tuning.
Values:
- 0x0 (FALSE): SDR104 is not supported
- 0x1 (TRUE): SDR104 is supported (NOT ACTUALLY SUPPORTED)</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DDR50_SUPPORT</name>
                <description>DDR50 Support (UHS-I only)
Values:
- 0x0 (FALSE): DDR50 is not supported
- 0x1 (TRUE): DDR50 is supported</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>UHS2_SUPPORT</name>
                <description>UHS-II Support (UHS-II only)
This bit indicates whether Host Controller supports UHS-II.
Values:
- 0x0 (FALSE): UHS-II is not supported
- 0x1 (TRUE): UHS-II is supported</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DRV_TYPEA</name>
                <description>Driver Type A Support (UHS-I only)
This bit indicates support of Driver Type A for 1.8 Signaling.
Values:
- 0x0 (FALSE): Driver Type A is not supported
- 0x1 (TRUE): Driver Type A is supported</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DRV_TYPEC</name>
                <description>Driver Type C Support (UHS-I only)
This bit indicates support of Driver Type C for 1.8 Signaling.
Values:
- 0x0 (FALSE): Driver Type C is not supported
- 0x1 (TRUE): Driver Type C is supported</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DRV_TYPED</name>
                <description>Driver Type D Support (UHS-I only)
This bit indicates support of Driver Type D for 1.8 Signaling.
Values:
- 0x0 (FALSE): Driver Type D is not supported
- 0x1 (TRUE): Driver Type D is supported</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RETUNE_CNT</name>
                <description>N/A</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>USE_TUNING_SDR50</name>
                <description>Use Tuning for SDR50 (UHS-I only)
Values:
- 0x0 (ZERO): SDR50 does not require tuning
- 0x1 (ONE): SDR50 requires tuning</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RE_TUNING_MODES</name>
                <description>N/A</description>
                <bitRange>[15:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CLK_MUL</name>
                <description>Clock Multiplier
These bits indicate the clock multiplier of the programmable
clock generator. Setting these bits to 0 means that the Host
Controller does not support a programmable clock generator.
- 0x0: Clock Multiplier is not Supported
- 0x1: Clock Multiplier M = 2
- 0x2: Clock Multiplier M = 3
- .........
- 0xFF: Clock Multiplier M = 256</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ADMA3_SUPPORT</name>
                <description>ADMA3 Support
This bit indicates whether the Host Controller is capable of
using ADMA3.
Values:
- 0x0 (FALSE): ADMA3 not Supported
- 0x1 (TRUE): ADMA3 Supported</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VDD2_18V_SUPPORT</name>
                <description>1.8V VDD2 Support
This bit indicates support of VDD2 for the Host System.
Values:
- 0x0 (FALSE): 1.8V VDD2 is not Supported
- 0x1 (TRUE): 1.8V VDD2 is Supported</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR_CAPABILITIES1_R</name>
            <description>Current Capabilities Register - 0 to 31</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>MAX_CUR_33V</name>
                <description>Maximum Current for 3.3V
This bit specifies the Maximum Current for 3.3V VDD1 power
supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_CUR_30V</name>
                <description>Maximum Current for 3.0V
This bit specifies the Maximum Current for 3.0V VDD1 power
supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_CUR_18V</name>
                <description>Maximum Current for 1.8V
This bit specifies the Maximum Current for 1.8V VDD1 power
supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR_CAPABILITIES2_R</name>
            <description>Maximum Current Capabilities Register - 32 to 63</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MAX_CUR_VDD2_18V</name>
                <description>Maximum Current for 1.8V VDD2
This bit specifies the Maximum Current for 1.8V VDD2 power
supply for the UHS-II card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FORCE_AUTO_CMD_STAT_R</name>
            <description>Force Event Register for Auto CMD Error Status register</description>
            <addressOffset>0x50</addressOffset>
            <size>16</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xBF</resetMask>
            <fields>
              <field>
                <name>FORCE_AUTO_CMD12_NOT_EXEC</name>
                <description>Force Event for Auto CMD12 Not Executed
Values:
- 0x1 (TRUE): Auto CMD12 Not Executed Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_TOUT_ERR</name>
                <description>Force Event for Auto CMD Timeout Error
Values:
- 0x1 (TRUE): Auto CMD Timeout Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[1:1]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_CRC_ERR</name>
                <description>Force Event for Auto CMD CRC Error
Values:
- 0x1 (TRUE): Auto CMD CRC Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[2:2]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_EBIT_ERR</name>
                <description>Force Event for Auto CMD End Bit Error
Values:
- 0x1 (TRUE): Auto CMD End Bit Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[3:3]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_IDX_ERR</name>
                <description>Force Event for Auto CMD Index Error
Values:
- 0x1 (TRUE): Auto CMD Index Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[4:4]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_RESP_ERR</name>
                <description>Force Event for Auto CMD Response Error
Values:
- 0x1 (TRUE): Auto CMD Response Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[5:5]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_CMD_NOT_ISSUED_AUTO_CMD12</name>
                <description>Force Event for Command Not Issued By Auto CMD12 Error
Values:
- 0x1 (TRUE): Command Not Issued By Auto CMD12 Error
Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FORCE_ERROR_INT_STAT_R</name>
            <description>Force Event Register for Error Interrupt Status</description>
            <addressOffset>0x52</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>FORCE_CMD_TOUT_ERR</name>
                <description>Force Event for Command Timeout Error (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Command Timeout Error Status is set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CMD_CRC_ERR</name>
                <description>Force Event for Command CRC Error (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Command CRC Error Status is set</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CMD_END_BIT_ERR</name>
                <description>Force Event for Command End Bit Error (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Command End Bit Error Status is set</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CMD_IDX_ERR</name>
                <description>Force Event for Command Index Error (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Command Index Error Status is set</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_DATA_TOUT_ERR</name>
                <description>Force Event for Data Timeout Error (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Data Timeout Error Status is set</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_DATA_CRC_ERR</name>
                <description>Force Event for Data CRC Error (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Data CRC Error Status is set</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_DATA_END_BIT_ERR</name>
                <description>Force Event for Data End Bit Error (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Data End Bit Error Status is set</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CUR_LMT_ERR</name>
                <description>Force Event for Current Limit Error
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Current Limit Error Status is set</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_ERR</name>
                <description>Force Event for Auto CMD Error (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Auto CMD Error Status is set</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_ADMA_ERR</name>
                <description>Force Event for ADMA Error
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): ADMA Error Status is set</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_TUNING_ERR</name>
                <description>Force Event for Tuning Error (UHS-I Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Tuning Error Status is set</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_RESP_ERR</name>
                <description>Force Event for Response Error (SD Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Response Error Status is set</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_BOOT_ACK_ERR</name>
                <description>Force Event for Boot Ack error
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Boot ack Error Status is set</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_VENDOR_ERR1</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_VENDOR_ERR2</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_VENDOR_ERR3</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADMA_ERR_STAT_R</name>
            <description>ADMA Error Status Register</description>
            <addressOffset>0x54</addressOffset>
            <size>8</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>ADMA_ERR_STATES</name>
                <description>ADMA Error States
These bits indicate the state of ADMA when an error occurs
during ADMA data transfer.
Values:
- 0x0 (ST_STOP): Stop DMA - SYS_ADR register points to
a location next to the error descriptor
- 0x1 (ST_FDS): Fetch Descriptor - SYS_ADR register
points to the error descriptor
- 0x2 (UNUSED): Never set this state
- 0x3 (ST_TFR): Transfer Data - SYS_ADR register points
to a location next to the error descriptor</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ADMA_LEN_ERR</name>
                <description>ADMA Length Mismatch Error States
This error occurs in the following instances:
- While the Block Count Enable is being set, the total data
length specified by the Descriptor table is different from
that specified by the Block Count and Block Length
- When the total data length cannot be divided by the block
length
Values:
- 0x0 (NO_ERR): No Error
- 0x1 (ERROR): Error</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADMA_SA_LOW_R</name>
            <description>ADMA System Address Register - Low</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADMA_SA_LOW</name>
                <description>ADMA System Address
These bits indicate the lower 32 bits of the ADMA system
address.
- SDMA: If Host Version 4 Enable is set to 1, this register
stores the system address of the data location
- ADMA2: This register stores the byte address of the
executing command of the descriptor table
- ADMA3: This register is set by ADMA3. ADMA2
increments the address of this register that points to the
next line, every time a Descriptor line is fetched.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADMA_ID_LOW_R</name>
            <description>ADMA3 Integrated Descriptor Address Register - Low</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADMA_ID_LOW</name>
                <description>ADMA Integrated Descriptor Address
These bits indicate the lower 32-bit of the ADMA Integrated
Descriptor address. The start address of Integrated
Descriptor is set to these register bits. The ADMA3 fetches
one Descriptor Address and increments these bits to indicate
the next Descriptor address.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CNTRL_VERS_R</name>
            <description>Host Controller Version</description>
            <addressOffset>0xFE</addressOffset>
            <size>16</size>
            <access>read-only</access>
            <resetValue>0x5</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SPEC_VERSION_NUM</name>
                <description>N/A</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VENDOR_VERSION_NUM</name>
                <description>N/A</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQVER</name>
            <description>Command Queuing Version register</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x510</resetValue>
            <resetMask>0xFFF</resetMask>
            <fields>
              <field>
                <name>EMMC_VER_SUFFIX</name>
                <description>This bit indicates the eMMC version suffix (2nd digit right of
decimal point) in BCD format.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EMMC_VER_MINOR</name>
                <description>This bit indicates the eMMC minor version (1st digit right of
decimal point) in BCD format.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EMMC_VER_MAJOR</name>
                <description>This bit indicates the eMMC major version (1st digit left of
decimal point) in BCD format.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCAP</name>
            <description>Command Queuing Capabilities register</description>
            <addressOffset>0x184</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x30C8</resetValue>
            <resetMask>0x1000F3FF</resetMask>
            <fields>
              <field>
                <name>ITCFVAL</name>
                <description>Internal Timer Clock Frequency Value (ITCFVAL)
This field scales the frequency of the timer clock provided by
ITCFMUL. The Final clock frequency of actual timer clock is
calculated as ITCFVAL* ITCFMUL.</description>
                <bitRange>[9:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ITCFMUL</name>
                <description>N/A</description>
                <bitRange>[15:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CRYPTO_SUPPORT</name>
                <description>Crypto Support
This bit indicates whether the Host Controller supports
cryptographic operations.
Values:
- 0x0 (FALSE): Crypto not Supported
- 0x1 (TRUE): Crypto Supported</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCFG</name>
            <description>Command Queuing Configuration register</description>
            <addressOffset>0x188</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1103</resetMask>
            <fields>
              <field>
                <name>CQ_EN</name>
                <description>Enable command queuing engine (CQE).
When CQE is disable, the software controls the eMMC bus
using the registers between the addresses 0x000 to 0x1FF.
Before the software writes to this bit, the software verifies
that the eMMC host controller is in idle state and there are no
ongoing commands or data transfers. When software wants
to exit command queuing mode, it clears all previous tasks (if
any) before setting this bit to 0.
Values:
- 0x1 (CQE_ENABLE): Enable command queuing
- 0x0 (CQE_DISABLE): Disable command queuing</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CR_GENERAL_EN</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TASK_DESC_SIZE</name>
                <description>Bit Value Description
This bit indicates the size of task descriptor used in host
memory. This bit can only be configured when Command
Queuing Enable bit is 0 (command queuing is disabled).
Values:
- 0x1 (TASK_DESC_128b): Task descriptor size is 128 bits
- 0x0 (TASK_DESC_64b): Task descriptor size is 64 bits</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DCMD_EN</name>
                <description>This bit indicates to the hardware whether the Task
Descriptor in slot #31 of the TDL is a data transfer descriptor
or a direct-command descriptor. CQE uses this bit when a
task is issued in slot #31, to determine how to decode the
Task Descriptor.
Values:
- 0x1 (SLOT31_DCMD_ENABLE): Task descriptor in slot
#31 is a DCMD Task Descriptor
- 0x0 (SLOT31_DCMD_DISABLE): Task descriptor in slot
#31 is a data Transfer Task Descriptor</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCTL</name>
            <description>Command Queuing Control register</description>
            <addressOffset>0x18C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x101</resetMask>
            <fields>
              <field>
                <name>HALT</name>
                <description>Halt request and resume
Values:
- 0x1 (HALT_CQE): Software writes 1 to this bit when it
wants to acquire software control over the eMMC bus and
to disable CQE from issuing command on the bus.
For example, issuing a Discard Task command
(CMDQ_TASK_MGMT). When the software writes 1, CQE
completes the ongoing task (if any in progress). After the
task is completed and the CQE is in idle state, CQE does not
issue new commands and indicates to the software by
setting this bit to 1. The software can poll on this bit until it is
set to 1 and only then send commands on the eMMC bus.
- 0x0 (RESUME_CQE): Software writes 0 to this bit to exit
from the halt state and resume CQE activity.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLR_ALL_TASKS</name>
                <description>Clear all tasks
This bit can only be written when the controller is halted. This
bit does not clear tasks in the device. The software has to
use the CMDQ_TASK_MGMT command to clear device's
queue.
Values:
- 0x1 (CLEAR_ALL_TASKS): Clears all the tasks in the
controller
- 0x0 (NO_EFFECT): Programming 0 has no effect</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQIS</name>
            <description>Command Queuing Interrupt Status register</description>
            <addressOffset>0x190</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>HAC</name>
                <description>Halt complete interrupt
This status bit is asserted (only if CQISE.HAC_STE=1) when
halt bit in the CQCTL register transitions from 0 to 1
indicating that the host controller has completed its current
ongoing task and has entered halt state. A value of 1 clears
this status bit.
Values:
- 0x1 (SET): HAC Interrupt is set
- 0x0 (NOTSET): HAC Interrupt is not set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCC</name>
                <description>Task complete interrupt
This status bit is asserted (if CQISE.TCC_STE=1) when at
least one of the following conditions are met:
- A task is completed and the INT bit is set in its Task
Descriptor
- Interrupt caused by Interrupt Coalescing logic due to
timeout
- Interrupt Coalescing logic reached the configured
threshold
A value of 1 clears this status bit
Values:
- 0x1 (SET): TCC Interrupt is set
- 0x0 (NOTSET): TCC Interrupt is not set</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED</name>
                <description>Response error detected interrupt
This status bit is asserted (if CQISE.RED_STE=1) when a
response is received with an error bit set in the device status
field. Configure the CQRMEM register to identify device
status bit fields that may trigger an interrupt and that are
masked. A value of 1 clears this status bit.
Values:
- 0x1 (SET): RED Interrupt is set
- 0x0 (NOTSET): RED Interrupt is not set</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCL</name>
                <description>Task cleared interrupt
This status bit is asserted (if CQISE.TCL_STE=1) when a
task clear operation is completed by CQE. The completed
task clear operation is either an individual task clear (by
writing CQTCLR) or clearing of all tasks (by writing CQCTL).
A value of 1 clears this status bit.
Values:
- 0x1 (SET): TCL Interrupt is set
- 0x0 (NOTSET): TCL Interrupt is not set</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GCE</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICCE</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQISE</name>
            <description>Command Queuing Interrupt Status Enable register</description>
            <addressOffset>0x194</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>HAC_STE</name>
                <description>Halt complete interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.HAC is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.HAC is disabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCC_STE</name>
                <description>Task complete interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.TCC is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.TCC is disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_STE</name>
                <description>Response error detected interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.RED is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.RED is disabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCL_STE</name>
                <description>Task cleared interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.TCL is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.TCL is disabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GCE_STE</name>
                <description>General Crypto Error interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.GCE is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.GCE is disabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICCE_STE</name>
                <description>Invalid Crypto Configuration Error interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.ICCE is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.ICCE is disabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQISGE</name>
            <description>Command Queuing Interrupt signal enable register</description>
            <addressOffset>0x198</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>HAC_SGE</name>
                <description>Halt complete interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.HAC interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.HAC interrupt signal
generation is disabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCC_SGE</name>
                <description>Task complete interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.TCC interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.TCC interrupt signal
generation is disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_SGE</name>
                <description>Response error detected interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.RED interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.RED interrupt signal
generation is disabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCL_SGE</name>
                <description>Task cleared interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.TCL interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.TCL interrupt signal
generation is disabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GCE_SGE</name>
                <description>General Crypto Error interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.GCE interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.GCE interrupt signal
generation is disabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICCE_SGE</name>
                <description>Invalid Crypto Configuration Error interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.ICCE interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.ICCE interrupt signal
generation is disabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQIC</name>
            <description>Command Queuing Interrupt Coalescing register</description>
            <addressOffset>0x19C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80119FFF</resetMask>
            <fields>
              <field>
                <name>TOUT_VAL</name>
                <description>Interrupt Coalescing Timeout Value
Software uses this field to configure the maximum time
allowed between the completion of a task on the bus and the
generation of an interrupt.
Timer Operation: The timer is reset by software during the
interrupt service routine. It starts running when the first data
transfer task with INT=0 is completed, after the timer was
reset. When the timer reaches the value configured in
ICTOVAL field, it generates an interrupt and stops.
The timer's unit is equal to 1024 clock periods of the clock
whose frequency is specified in the Internal Timer Clock
Frequency field CQCAP register.
- 0x0: Timer is disabled. Timeout-based interrupt is not
generated
- 0x1: Timeout on 01x1024 cycles of timer clock frequency
- 0x2: Timeout on 02x1024 cycles of timer clock frequency
- ........
- 0x7f: Timeout on 127x1024 cycles of timer clock
frequency
In order to write to this field, the TOUT_VAL_WEN bit must
be set at the same write operation.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOUT_VAL_WEN</name>
                <description>When software writes 1 to this bit, the value TOUT_VAL is
updated with the contents written on the same cycle.
Values:
- 0x1 (WEN_SET): Sets TOUT_VAL_WEN
- 0x0 (WEN_CLR): clears TOUT_VAL_WEN</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>INTC_TH</name>
                <description>Interrupt Coalescing Counter Threshold filed
Software uses this field to configure the number of task
completions (only tasks with INT=0 in the Task Descriptor),
which are required in order to generate an interrupt.
Counter Operation: As data transfer tasks with INT=0
complete, they are counted by CQE. The counter is reset by
software during the interrupt service routine. The counter
stops counting when it reaches the value configured in
INTC_TH, and generates interrupt.
- 0x0: Interrupt coalescing feature disabled
- 0x1: Interrupt coalescing interrupt generated after 1 task
when INT=0 completes
- 0x2: Interrupt coalescing interrupt generated after 2 tasks
when INT=0 completes
- ........
- 0x1f: Interrupt coalescing interrupt generated after 31
tasks when INT=0 completes
To write to this field, the INTC_TH_WEN bit must be set
during the same write operation.</description>
                <bitRange>[12:8]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>INTC_TH_WEN</name>
                <description>Interrupt Coalescing Counter Threshold Write Enable
When software writes 1 to this bit, the value INTC_TH is
updated with the contents written on the same cycle.
Values:
- 0x1 (WEN_SET): Sets INTC_TH_WEN
- 0x0 (WEN_CLR): Clears INTC_TH_WEN</description>
                <bitRange>[15:15]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>INTC_RST</name>
                <description>Counter and Timer Reset
When host driver writes 1, the interrupt coalescing timer and
counter are reset.
Values:
- 0x1 (ASSERT_INTC_RESET): Interrupt coalescing timer
and counter are reset
- 0x0 (NO_EFFECT): No Effect</description>
                <bitRange>[16:16]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>INTC_STAT</name>
                <description>Interrupt Coalescing Status Bit
This bit indicates to the software whether any tasks (with
INT=0) have completed and counted towards interrupt
coalescing (that is, this is set if and only if INTC counter &gt; 0).
Values:
- 0x1 (INTC_ATLEAST1_COMP): At least one INT0 task
completion has been counted (INTC counter &gt; 0)
- 0x0 (INTC_NO_TASK_COMP): INT0 Task completions
have not occurred since last counter reset (INTC counter
== 0)</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INTC_EN</name>
                <description>Interrupt Coalescing Enable Bit
Values:
- 0x1 (ENABLE_INT_COALESCING): Interrupt coalescing
mechanism is active. Interrupts are counted and timed,
and coalesced interrupts are generated
- 0x0 (DISABLE_INT_COALESCING): Interrupt coalescing
mechanism is disabled (Default).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTDLBA</name>
            <description>Command Queuing Task Descriptor List Base Address register</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TDLBA</name>
                <description>This register stores the LSB bits (31:0) of the byte address of
the head of the Task Descriptor List in system memory.
The size of the task descriptor list is 32 * (Task Descriptor
size + Transfer Descriptor size) as configured by the host
driver. This address is set on 1 KB boundary. The lower 10
bits of this register are set to 0 by the software and are
ignored by CQE.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTDBR</name>
            <description>Command Queuing DoorBell register</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DBR</name>
                <description>The software configures TDLBA and TDLBAU, and enable
CQE in CQCFG before using this register.
Writing 1 to bit n of this register triggers CQE to start
processing the task encoded in slot n of the TDL. Writing 0
by the software does not have any impact on the hardware,
and does not change the value of the register bit.
CQE always processes tasks according to the order
submitted to the list by CQTDBR write transactions. CQE
processes Data Transfer tasks by reading the Task
Descriptor and sending QUEUED_TASK_PARAMS (CMD44)
and QUEUED_TASK_ADDRESS (CMD45) commands to
the device. CQE processes DCMD tasks (in slot #31, when
enabled) by reading the Task Descriptor, and generating the
command encoded by its index and argument.
The corresponding bit is cleared to 0 by CQE in one of the
following events:
- A task execution is completed (with success or error).
- The task is cleared using CQTCLR register.
- All tasks are cleared using CQCTL register.
- CQE is disabled using CQCFG register.
Software may initiate multiple tasks at the same time (batch
submission) by writing 1 to multiple bits of this register in the
same transaction. In the case of batch submission, CQE
processes the tasks in order of the task index, starting with
the lowest index. If one or more tasks in the batch are
marked with QBR, the ordering of execution is based on said
processing order.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTCN</name>
            <description>Command Queuing TaskClear Notification register</description>
            <addressOffset>0x1AC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCN</name>
                <description>Task Completion Notification
Each of the 32 bits are bit mapped to the 32 tasks.
- Bit-N(1): Task-N has completed execution (with success
or errors)
- Bit-N(0): Task-N has not completed, could be pending or
not submitted.
On task completion, software may read this register to know
tasks that have completed. After reading this register,
software may clear the relevant bit fields by writing 1 to the
corresponding bits.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQDQS</name>
            <description>Device queue status register</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DQS</name>
                <description>Device Queue Status
Each of the 32 bits are bit mapped to the 32 tasks.
- Bit-N(1): Device has marked task N as ready for
execution
- Bit-N(0): Task-N is not ready for execution. This task
could be pending in device or not submitted.
Host controller updates this register with response of the
Device Queue Status command.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQDPT</name>
            <description>Device pending tasks register</description>
            <addressOffset>0x1B4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DPT</name>
                <description>Device-Pending Tasks
Each of the 32 bits are bit mapped to the 32 tasks.
- Bit-N(1): Task-N has been successfully queued into the
device and is awaiting execution
- Bit-N(0): Task-N is not yet queued.
Bit n of this register is set if and only if
QUEUED_TASK_PARAMS (CMD44) and
QUEUED_TASK_ADDRESS (CMD45) were sent for this
specific task and if this task has not been executed.
The controller sets this bit after receiving a successful
response for CMD45. CQE clears this bit after the task has
completed execution.
Software reads this register in the task-discard procedure to
determine if the task is queued in the device.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTCLR</name>
            <description>Command Queuing DoorBell register</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCLR</name>
                <description>Writing 1 to bit n of this register orders CQE to clear a task
that the software has previously issued.
This bit can only be written when CQE is in Halt state as
indicated in CQCFG register Halt bit. When software writes 1
to a bit in this register, CQE updates the value to 1, and
starts clearing the data structures related to the task. CQE
clears the bit fields (sets a value of 0) in CQTCLR and in
CQTDBR once the clear operation is complete. Software
must poll on the CQTCLR until it is cleared to verify that a
clear operation was done.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQSSC1</name>
            <description>CQ Send Status Configuration 1 register</description>
            <addressOffset>0x1C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x11000</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>SQSCMD_IDLE_TMR</name>
                <description>This field configures the polling period to be used when
using periodic SEND_QUEUE_STATUS (CMD13) polling.
Periodic polling is used when tasks are pending in the
device, but no data transfer is in progress. When a
SEND_QUEUE_STATUS response indicates that no task is
ready for execution, CQE counts the configured time until it
issues the next SEND_QUEUE_STATUS.
Timer units are clock periods of the clock whose frequency is
specified in the Internal Timer Clock Frequency field CQCAP
register. The minimum value is 0001h (1 clock period) and
the maximum value is FFFFh (65535 clock periods).
For example, a CQCAP field value of 0 indicates a 19.2 MHz
clock frequency (period = 52.08 ns). If the setting in
CQSSC1.CIT is 1000h, the calculated polling period is
4096*52.08 ns= 213.33 ns.
Should be programmed only when CQCFG.CQ_EN is '0'.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SQSCMD_BLK_CNT</name>
                <description>This field indicates when SQS CMD is sent while data
transfer is in progress.
A value of 'n' indicates that CQE sends status command on
the CMD line, during the transfer of data block BLOCK_CNTn,
on the data lines, where BLOCK_CNT is the number of
blocks in the current transaction.
- 0x0: SEND_QUEUE_STATUS (CMD13) command is not
sent during the transaction. Instead, it is sent only when
the data lines are idle.
- 0x1: SEND_QUEUE_STATUS command is to be sent
during the last block of the transaction.
- 0x2: SEND_QUEUE_STATUS command when last 2
blocks are pending.
- 0x3: SEND_QUEUE_STATUS command when last 3
blocks are pending.
- ........
- 0xf: SEND_QUEUE_STATUS command when last 15
blocks are pending.
Should be programmed only when CQCFG.CQ_EN is '0'</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQSSC2</name>
            <description>CQ Send Status Configuration 2 register</description>
            <addressOffset>0x1C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SQSCMD_RCA</name>
                <description>This field provides CQE with the contents of the 16-bit RCA
field in SEND_QUEUE_STATUS (CMD13) command
argument.
CQE copies this field to bits 31:16 of the argument when
transmitting SEND_ QUEUE_STATUS (CMD13) command.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCRDCT</name>
            <description>Command response for direct command register</description>
            <addressOffset>0x1C8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DCMD_RESP</name>
                <description>This register contains the response of the command
generated by the last direct command (DCMD) task that was
sent.
Contents of this register are valid only after bit 31 of
CQTDBR register is cleared by the controller.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQRMEM</name>
            <description>Command response mode error mask register</description>
            <addressOffset>0x1D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFDF9A080</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP_ERR_MASK</name>
                <description>The bits of this field are bit mapped to the device response.
This bit is used as an interrupt mask on the device status
filed that is received in R1/R1b responses.
- 1: When a R1/R1b response is received, with a bit i in the
device status set, a RED interrupt is generated.
- 0: When a R1/R1b response is received, bit i in the device
status is ignored.
The reset value of this register is set to trigger an interrupt on
all 'Error' type bits in the device status.
Note: Responses to CMD13 (SQS) encode the QSR so that
they are ignored by this logic.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTERRI</name>
            <description>CQ Task Error Information register</description>
            <addressOffset>0x1D4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x9F3F9F3F</resetMask>
            <fields>
              <field>
                <name>RESP_ERR_CMD_INDX</name>
                <description>This field captures the index of the command that was
executed on the command line when the error occurred.</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESP_ERR_TASKID</name>
                <description>This field captures the ID of the task which was executed on
the command line when the error occurred.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESP_ERR_FIELDS_VALID</name>
                <description>This bit is updated when an error is detected while a
command transaction was in progress.
Values:
- 0x1 (SET): Response-related error is detected. Check
contents of RESP_ERR_TASKID and
RESP_ERR_CMD_INDX fields
- 0x0 (NOT_SET): Ignore contents of RESP_ERR_TASKID
and RESP_ERR_CMD_INDX</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TRANS_ERR_CMD_INDX</name>
                <description>This field captures the index of the command that was
executed and whose data transfer has errors.</description>
                <bitRange>[21:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TRANS_ERR_TASKID</name>
                <description>This field captures the ID of the task that was executed and
whose data transfer has errors.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TRANS_ERR_FIELDS_VALID</name>
                <description>This bit is updated when an error is detected while a data
transfer transaction was in progress.
Values:
- 0x1 (SET): data transfer related error detected. Check
contents of TRANS_ERR_TASKID and
TRANS_ERR_CMD_INDX fields
- 0x0 (NOT_SET): Ignore contents of
TRANS_ERR_TASKID and TRANS_ERR_CMD_INDX</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCRI</name>
            <description>CQ Command response index</description>
            <addressOffset>0x1D8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CMD_RESP_INDX</name>
                <description>Last Command Response index
This field stores the index of the last received command
response. Controller updates the value every time a
command response is received.</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCRA</name>
            <description>CQ Command response argument register</description>
            <addressOffset>0x1DC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CMD_RESP_ARG</name>
                <description>Last Command Response argument
This field stores the argument of the last received command
response. Controller updates the value every time a
command response is received.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MSHC_VER_ID_R</name>
            <description>MSHC version</description>
            <addressOffset>0x500</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x3137302A</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MSHC_VER_ID</name>
                <description>Current release number
This field indicates the Synopsys DesignWare Cores
DWC_mshc/DWC_mshc_lite current release number that is
read by an application.
For example, release number '1.60a' is represented in
ASCII as 0x313630. Lower 8 bits read from this register can
be ignored by the application.
An application reading this register in conjunction with the
MSHC_VER_TYPE_R register, gathers details of the current
release.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MSHC_VER_TYPE_R</name>
            <description>MSHC version type</description>
            <addressOffset>0x504</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x67612A2A</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MSHC_VER_TYPE</name>
                <description>Current release type
This field indicates the Synopsys DesignWare Cores
DWC_mshc/DWC_mshc_lite current release type that is
read by an application.
For example, release type is 'ga' is represented in ASCII as
0x6761. Lower 16 bits read from this register can be ignored
by the application.
An application reading this register in conjunction with the
MSHC_VER_ID_R register, gathers details of the current
release.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MSHC_CTRL_R</name>
            <description>MSHC Control register</description>
            <addressOffset>0x508</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0x11</resetMask>
            <fields>
              <field>
                <name>CMD_CONFLICT_CHECK</name>
                <description>Command conflict check
This bit enables command conflict check.
Note: DWC_mshc controller monitors the CMD line
whenever a command is issued and checks whether the
value driven on sd_cmd_out matches the value on
sd_cmd_in at next subsequent edge of cclk_tx to determine
command conflict error. This bit is cleared only if the feed
back delay (including IO Pad delay) is more than
(t_card_clk_period - t_setup), where t_setup is the setup
time of a flop in DWC_mshc. The I/O pad delay is consistent
across CMD and DATA lines, and it is within the value:
(2*t_card_clk_period - t_setup)
Values:
- 0x0 (DISABLE_CMD_CONFLICT_CHK): Disable
command conflict check
- 0x1 (CMD_CONFLICT_CHK_LAT1): Check for command
conflict after 1 card clock cycle</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SW_CG_DIS</name>
                <description>Internal clock gating disable control
This bit must be used to disable IP's internal clock gating
when required. when disabled clocks are not gated. Clocks
to the core (except hclk) must be stopped when
programming this bit.
Values:
- 0x0 (ENABLE): Internal clock gates are active and clock
gating is controlled internally
- 0x1 (DISABLE): Internal clock gating is disabled, clocks
are not gated internally</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MBIU_CTRL_R</name>
            <description>MBIU Control register</description>
            <addressOffset>0x510</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>UNDEFL_INCR_EN</name>
                <description>Undefined INCR Burst
Controls generation of undefined length INCR transfer on
Master interface.
Values:
- 0x0 (FALSE): Undefined INCR type burst is the least
preferred burst on AHB Master I/F
- 0x1 (TRUE): Undefined INCR type burst is the most
preferred burst on AHB Master I/F</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURST_INCR4_EN</name>
                <description>INCR4 Burst
Controls generation of INCR4 transfers on Master interface.
Values:
- 0x0 (FALSE): AHB INCR4 burst type is not generated on
Master I/F
- 0x1 (TRUE): AHB INCR4 burst type can be generated on
Master I/F</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURST_INCR8_EN</name>
                <description>INCR8 Burst
Controls generation of INCR8 transfers on Master interface.
Values:
- 0x0 (FALSE): AHB INCR8 burst type is not generated on
Master I/F
- 0x1 (TRUE): AHB INCR8 burst type can be generated on
Master I/F</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURST_INCR16_EN</name>
                <description>INCR16 Burst
Controls generation of INCR16 transfers on Master
interface.
Values:
- 0x0 (FALSE): AHB INCR16 burst type is not generated on
Master I/F
- 0x1 (TRUE): AHB INCR16 burst type can be generated
on Master I/F</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EMMC_CTRL_R</name>
            <description>eMMC Control register</description>
            <addressOffset>0x52C</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0xC</resetValue>
            <resetMask>0x60F</resetMask>
            <fields>
              <field>
                <name>CARD_IS_EMMC</name>
                <description>eMMC Card present
This bit indicates the type of card connected. An application
program this bit based on the card connected to SDHC.
Values:
- 0x1 (EMMC_CARD): Card connected to SDHC is an
eMMC card
- 0x0 (NON_EMMC_CARD): Card connected to SDHC is
a non-eMMC card</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE_DATA_CRC_CHK</name>
                <description>Disable Data CRC Check
This bit controls masking of CRC16 error for Card Write in
eMMC mode. This is useful in bus testing (CMD19) for an
eMMC device. In bus testing, an eMMC card does not send
CRC status for a block, which may generate CRC error. This
CRC error can be masked using this bit during bus testing.
Values:
- 0x1 (DISABLE): DATA CRC check is disabled
- 0x0 (ENABLE): DATA CRC check is enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EMMC_RST_N</name>
                <description>EMMC Device Reset signal control.
This register field controls the card_emmc_reset_n output of SDHC
Values:
- 0x1 (RST_DEASSERT): Reset to eMMC device is
deasserted
- 0x0 (RST_ASSERT): Reset to eMMC device asserted
(active low)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EMMC_RST_N_OE</name>
                <description>Output Enable (OE) control for EMMC Device Reset signal (card_emmc_reset_n).
Values:
- 0x1 (ENABLE): OE for card_emmc_reset_n is 1
- 0x0 (DISABLE): OE for card_emmc_reset_n is 0</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CQE_ALGO_SEL</name>
                <description>Scheduler algorithm selected for execution
This bit selects the Algorithm used for selecting one of the
many ready tasks for execution.
Values:
- 0x0 (PRI_REORDER_PLUS_FCFS): Priority based
reordering with FCFS to resolve equal priority tasks
- 0x1 (FCFS_ONLY): First come First serve, in the order of
DBR rings</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CQE_PREFETCH_DISABLE</name>
                <description>Enable or Disable CQE's PREFETCH feature
This field allows Software to disable CQE's data prefetch
feature when set to 1.
Values:
- 0x0 (PREFETCH_ENABLE): CQE can Prefetch data for
sucessive WRITE transfers and pipeline sucessive READ
transfers
- 0x1 (PREFETCH_DISABLE): Prefetch for WRITE and
Pipeline for READ are disabled</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BOOT_CTRL_R</name>
            <description>eMMC Boot Control register</description>
            <addressOffset>0x52E</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF181</resetMask>
            <fields>
              <field>
                <name>MAN_BOOT_EN</name>
                <description>Mandatory Boot Enable
This bit is used to initiate the mandatory boot operation. The
application sets this bit along with VALIDATE_BOOT bit.
Writing 0 is ignored. The SDHC clears this bit after the
boot transfer is completed or terminated.
Values:
- 0x1 (MAN_BOOT_EN): Mandatory boot enable
- 0x0 (MAN_BOOT_DIS): Mandatory boot disable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALIDATE_BOOT</name>
                <description>Validate Mandatory Boot Enable bit
This bit is used to validate the MAN_BOOT_EN bit.
Values:
- 0x1 (TRUE): Validate Mandatory boot enable bit
- 0x0 (FALSE): Ignore Mandatory boot Enable bit</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>BOOT_ACK_ENABLE</name>
                <description>Boot Acknowledge Enable
When this bit set, SDHC checks for boot acknowledge
start pattern of 0-1-0 during boot operation. This bit is
applicable for both mandatory and alternate boot mode.
Values:
- 0x1 (TRUE): Boot Ack enable
- 0x0 (FALSE): Boot Ack disable</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BOOT_TOUT_CNT</name>
                <description>N/A</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GP_IN_R</name>
            <description>General Purpose Input register</description>
            <addressOffset>0x530</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>GP_IN</name>
                <description>It reflects the value of gp_in ports.
NOT USED - ALWAYS READS 0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GP_OUT_R</name>
            <description>General Purpose Output register</description>
            <addressOffset>0x534</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CARD_DETECT_EN</name>
                <description>0: Force card_detect_n input to 0
1:  Normal card_detect_n operation allowing card detection from a device pin</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_MECH_WRITE_PROT_EN</name>
                <description>card_mech_write_prot, despite its name, is an active low signal (per the SD Host Controller Standard spec it is officially called SDWP#).  Consider that in the following:
0: Force card_mech_write_prot input to 0 internally; this forces write protection to be active
1: Allow card_mech_write_prot to work normally per the device's pin state</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LED_CTRL_OE</name>
                <description>Active high output enable for the LED output signal (led_ctrl) controlled through HOST_CTRL1_R.LED_CTRL:
0: disable OE associated with the led_ctrl output
1: enable OE associated with the led_ctrl output</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_CLOCK_OE</name>
                <description>Active high output enable for the card clock output (clk_card) which is gated by CLK_CTRL_R.SD_CLK_EN:
0: disable OE to the clk_card output
1: enable OE to the clk_card output</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_IF_PWR_EN_OE</name>
                <description>Active high output enable for the card interface power enable output (card_if_pwr_en) controlled through PWR_CTRL_R.SD_BUS_PWR_VDD1:
0: disable OE to the card_if_pwr_en output
1: enable OE to the card_if_pwr_en output</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_VOLT_SEL_OE</name>
                <description>Active high output enable for the IO voltage selection signal (io_volt_sel) controlled through HOST_CTRL_2.SIGNALING_EN:
0: disable OE to the io_volt_sel output
1: enable OE to the io_volt_sel output</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_CLOCK_OUT_DLY</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_CLOCK_IN_DLY</name>
                <description>Delay CARD_CLOCK input internally to optimally sample CMD/DAT; set according to interface mode:
00: SD Default Speed, SD SDR12, eMMC Legacy
01: SD SDR25, SD SDR50
10: SD High Speed, eMMC High Speed SDR
11: SD DDR50, eMMC DDR</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>ETH0</name>
      <description>Ethernet Interface</description>
      <headerStructName>ETH</headerStructName>
      <baseAddress>0x40480000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>MXETH Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FF07</resetMask>
          <fields>
            <field>
              <name>ETH_MODE</name>
              <description>Set ethernet mode. The speed of 10M/100M/1G is selected by programming network_config after IP is enabled.
The field also specifies the clock source of internal tx_clk and rx_clk domain.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MII</name>
                  <description>MII mode (10/100MHz speed is determined by network_config[0]).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GMII</name>
                  <description>GMII mode (network_config[10] must be set to enable 1G operation).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RGMII</name>
                  <description>RGMII mode (10M/100M/1G speed is determined by network_config[10] and network_config[0]).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RMII</name>
                  <description>RMII mode (10M/100M speed is determined by network_config[0]).</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REFCLK_SRC_SEL</name>
              <description>Select the source for ref_clk.
0: Ref_clk comes from REF_CLK_IN input port (HSIO).
1: Ref_clk comes from REF_CLK_INT_IN input port (PLL).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFCLK_DIV</name>
              <description>Specify the ref_clk divider. Integer division by (1+REFCLK_DIV). Allows for integer divisions in the range [1, 256].</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>MXETH enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>MXETH Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>PFC_NEGOTIATE</name>
              <description>Identifies that PFC priority based pause flow control 
has been negotiated.
0  - No PFC priority based pause frames have yet 
been received, flow control is being handled using 
classic 802.3 pause frames.
1  - At least one PFC priority based pause frames 
has been received. All subsequent 802.3 pause 
frames will be dropped.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PFC_PAUSED</name>
              <description>Each bit corresponds to a priority indicated within the PFC priority based pause frame.
Each bit is set when a PFC priority based pause frame has been received, and the associated priority pause time quantum is non-zero. Each bit is cleared when the associated pause time identified by the received pause time quantum has elapsed.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NETWORK_CONTROL</name>
          <description>The network control register contains general MAC control functions for both receiver and transmitter.</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Loopback - controls the loopback output pin.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK_LOCAL</name>
              <description>Loopback local - asserts the loopback_local signal to the system clock generator. Also connects txd to rxd, tx_en to rx_dv and forces full duplex mode. Bit 11 of the network configuration register must be set low to disable TBI mode when in internal loopback. rx_clk and tx_clk may malfunction as the GEM is switched into and out of internal loopback. It is important that receive and transmit circuits have already been disabled when making the switch into and out of internal loopback. Local loopback functionality is optional and may not be supported by some instantiations of the GEM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_RECEIVE</name>
              <description>Receive enable - when set, it enables the GEM to receive data. When reset frame reception will stop immediately and the receive pipeline will be cleared. The receive queue pointer register is unaffected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT</name>
              <description>Transmit enable - when set, it enables the GEM transmitter to send data. When reset transmission will stop immediately, the transmit pipeline and control registers will be cleared and the transmit queue pointer register will reset to point to the start of the transmit descriptor list.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAN_PORT_EN</name>
              <description>Management port enable - set to one to enable the management port. When zero forces mdio to high impedance state and mdc low.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR_ALL_STATS_REGS</name>
              <description>Clear statistics registers - this bit is write only. Writing a one clears the statistics registers. Self clearing register.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INC_ALL_STATS_REGS</name>
              <description>Incremental statistics registers - this bit is write only. Writing a one increments all the statistics registers by one for test purposes. Self clearing register.</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>STATS_WRITE_EN</name>
              <description>Write enable for statistics registers - setting this bit to one means the statistics registers can be written for functional test purposes.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BACK_PRESSURE</name>
              <description>Back pressure if set in 10M or 100M half duplex mode will force collisions on all received frames. Ignored in gigabit half duplex mode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_START_PCLK</name>
              <description>Start transmission - writing one to this bit starts transmission.</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_HALT_PCLK</name>
              <description>Transmit halt - writing one to this bit halts transmission as soon as any ongoing frame transmission ends.</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_PAUSE_FRAME_REQ</name>
              <description>Transmit pause frame - writing one to this bit causes a pause frame to be transmitted. Self clearing register.</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_PAUSE_FRAME_ZERO</name>
              <description>Transmit zero quantum pause frame - writing one to this bit causes a pause frame with zero quantum to be transmitted.</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>REMOVED_13</name>
              <description>Write ignore, read 0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_14</name>
              <description>Write ignore, read 0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STORE_RX_TS</name>
              <description>Store receive time stamp to memory. Setting this bit to one will cause the CRC of every received frame to be replaced with the value of the nanoseconds field of the 1588 timer that was captured as the receive frame passed the message time stamp point. Set to zero for normal operation.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PFC_ENABLE</name>
              <description>Enable PFC Priority Based Pause Reception capabilities. Setting this bit will enable PFC negotiation and recognition of priority based pause frames.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMIT_PFC_PRIORITY_BASED_PAUSE_FRAME</name>
              <description>Write a one to transmit PFC priority based pause frame. Takes the values stored in the Transmit PFC Pause Register. Self clearing register.</description>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FLUSH_RX_PKT_PCLK</name>
              <description>Flush the next packet from the external RX DPRAM. Writing one to this bit will only have an effect if the DMA is not currently writing a packet already stored in the DPRAM to memory. Self clearing register.</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_LPI_EN</name>
              <description>Enable LPI transmission when set LPI (low power idle) is immediately transmitted. LPI is transmitted even if bit 3 transmit enable is disabled. Setting this bit also sends a pause signal to the transmit datapath.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTP_UNICAST_ENA</name>
              <description>Enable detection of unicast PTP unicast frames.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALT_SGMII_MODE</name>
              <description>Alternative sgmii mode. If asserted with sgmii_mode in the network control register the ACK bit is driven before ability detect during transfer of status information from the PHY to the MAC.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STORE_UDP_OFFSET</name>
              <description>N/A</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT_TSU_PORT_ENABLE</name>
              <description>Write ignore, read 0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ONE_STEP_SYNC_MODE</name>
              <description>1588 One Step Sync Mode. Write 1 to enable. Replace timestamp field in the 1588 header for TX Sync Frames with current TSU timer value.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PFC_CTRL</name>
              <description>'Enable multiple PFC pause quantums, one per pause priority'</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT_RXQ_SEL_EN</name>
              <description>Enable external selection of receive queue. When this bit is high the ext_match1, ext_match2, ext_match3 and ext_match4 inputs will determine which receive queue a frame is routed to. This will be the case regardless of the state of the external address match
enable bit 9 of the network config register. Note that receive frames will be dropped unless they are matched by the internal frame filtering functionality. If the external address match enable bit 9 in the network config register is set frames may be matched by an
external address match filter as long as one of the ext_match1, ext_match2, ext_match3 and ext_match4 inputs is asserted early enough. When set ext_rxq_sel_en takes precedence over the existing screener functionality. This bit is only relevant if priority
queuing is configured.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSS_CORRECTION_FIELD</name>
              <description>1588 One Step Correction Field Update. Set this bit
high to enable updating the correction field of PTP
1588 version 2 sync frames by adding current TSU
timer value.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_MII_ON_RGMII</name>
              <description>If the RGMII interface being used set this bit high to
configure the interface for MII operation.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TWO_PT_FIVE_GIG</name>
              <description>2.5G operation selected - setting this bit high drives
the speed_mode[3] top level output pin high and also
adjusts the link timer in the PCS auto-negotiation block
to ensure it delivers 10ms for 2500BASE-X and 1.6ms
in SGMII mode, and also ensures int_moderation
counts 800ns periods with the speeded up MAC
clocks.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IFG_EATS_QAV_CREDIT</name>
              <description>Setting this bit high modifies the CBS algorithm so the
IFG/IPG associated with a transmit frame counts
towards its 802.1Qav credit.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT_RXQ_RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NETWORK_CONFIG</name>
          <description>The network configuration register contains functions for setting the mode of operation for the Gigabit Ethernet MAC.</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPEED</name>
              <description>Speed - set to logic one to indicate 100Mbps operation, logic zero for 10Mbps.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_DUPLEX</name>
              <description>Full duplex - if set to logic one, the transmit block ignores the state of collision and carrier sense and allows receive while transmitting. Also controls the half_duplex pin.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISCARD_NON_VLAN_FRAMES</name>
              <description>Discard non-VLAN frames - when set only VLAN tagged frames will be passed to the address matching logic.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>JUMBO_FRAMES</name>
              <description>Jumbo frames - set to one to enable jumbo frames up to `gem_jumbo_max_length bytes to be accepted. The default length is 10,240 bytes.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COPY_ALL_FRAMES</name>
              <description>Copy all frames - when set to logic one, all valid frames will be accepted.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NO_BROADCAST</name>
              <description>No broadcast - when set to logic one, frames addressed to the broadcast address of all ones will not be accepted.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MULTICAST_HASH_ENABLE</name>
              <description>Multicast hash enable - when set, multicast frames will be accepted when the 6 bit hash function of the destination address points to a bit that is set in the hash register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNICAST_HASH_ENABLE</name>
              <description>Unicast hash enable - when set, unicast frames will be accepted when the 6 bit hash function of the destination address points to a bit that is set in the hash register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVE_1536_BYTE_FRAMES</name>
              <description>Receive 1536 byte frames - setting this bit means the GEM will accept frames up to 1536 bytes in length. Normally the GEM would reject any frame above 1518 bytes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTERNAL_ADDRESS_MATCH_ENABLE</name>
              <description>External address match enable - when set the external address match interface can be used to copy frames to memory.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GIGABIT_MODE_ENABLE</name>
              <description>Gigabit mode enable - setting this bit configures the GEM for 1000 Mbps operation.
 0: 10/100 operation using MII interface
 1: Gigabit operation using GMI interface</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCS_SELECT</name>
              <description>PCS select - selects between MII/GMII and TBI</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_TEST</name>
              <description>Retry test - must be set to zero for normal operation. If set to one the backoff between collisions will always be one slot time. Setting this bit to one helps test the too many retries condition. Also used in the pause frame tests to reduce the pause counter's decrement time from 512 bit times, to every rx_clk cycle.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSE_ENABLE</name>
              <description>Pause enable - when set, transmission will pause if a non zero 802.3 classic pause frame is received and PFC has not been negotiated.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVE_BUFFER_OFFSET</name>
              <description>Receive buffer offset - indicates the number of bytes by which the received data is offset from the start of the receive buffer.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LENGTH_FIELD_ERROR_FRAME_DISCARD</name>
              <description>Length field error frame discard - setting this bit causes frames with a measured length shorter than the extracted length field (as indicated by bytes 13 and 14 in a non-VLAN tagged frame) to be discarded. This only applies to frames with a length field less than 0x0600.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FCS_REMOVE</name>
              <description>FCS remove - setting this bit will cause received frames to be written to memory without their frame check sequence (last 4 bytes). The frame length indicated will be reduced by four bytes in this mode.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDC_CLOCK_DIVISION</name>
              <description>MDC clock division - set according to pclk speed. These three bits determine the number pclk will be divided by to generate MDC. For conformance with the 802.3 specification, MDC must not exceed 2.5 MHz (MDC is only active during MDIO read and write operations). The reset value for this can be changed by defining a new value for gem_mdc_clock_div in gem_defs.v
 000: divide pclk by 8 (pclk up to 20 MHz)
 001: divide pclk by 16 (pclk up to 40 MHz)
 010: divide pclk by 32 (pclk up to 80 MHz)
 011: divide pclk by 48 (pclk up to 120MHz)
 100: divide pclk by 64 (pclk up to 160 MHz)
 101: divide pclk by 96 (pclk up to 240 MHz)
 110: divide pclk by 128 (pclk up to 320 MHz)
 111: divide pclk by 224 (pclk up to 540 MHz). 
Note. The reset value of this field is equal to the gem_mdc_clock_div define, which is user configurable.</description>
              <bitRange>[20:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_BUS_WIDTH</name>
              <description>Data bus width - set according to AMBA (AXI/AHB) or external FIFO data bus width. The reset value for this can be changed by defining a new value for gem_dma_bus_width_def in gem_defs. Only valid bus widths may be written if the system is configured to a maximum width less than 128-bits. 
 00: 32 bit data bus width 01: 64 bit AMBA (AXI/AHB) data bus width 
 10: 128 bit AMBA (AXI/AHB) data bus width
 11: 128 bit AMBA (AXI/AHB) data bus width. 
Note. The reset value of this field is equal to the gem_dma_bus_width_def define, which is user configurable.
Note: 
For AXI_MASTER_PRESENT=1, MXETH only supports 64b DMA data bus width, so must set it 1.
For AXI_MASTER_PRESENT=0, MXETH only supports 32b DMA data bus width, so must set it 0.</description>
              <bitRange>[22:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_COPY_OF_PAUSE_FRAMES</name>
              <description>Disable copy of pause frames - set to one to prevent pause frames being copied to memory. When set, neither control frames with type id 8808, nor pause frames with destination address 010000c28001 are copied to memory, this functionality was enhanced in release 1p09 (mxeth uses 1p09). Note that valid pause frames received will still increment pause statistics and pause the transmission of frames as required.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVE_CHECKSUM_OFFLOAD_ENABLE</name>
              <description>Receive checksum offload enable - when set, the receive checksum engine is enabled. Frames with bad IP, TCP or UDP checksums are discarded.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_HALF_DUPLEX_RX</name>
              <description>Enable frames to be received in half-duplex mode while transmitting.
Must set '0', MXETH only supports full-duplex mode.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_RX_FCS</name>
              <description>Ignore RX FCS - when set frames with FCS/CRC errors will not be rejected. FCS error statistics will still be collected for frames with bad FCS and FCS status will be recorded in frame's DMA descriptor. For normal operation this bit must be set to zero.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGMII_MODE_ENABLE</name>
              <description>SGMII mode enable - changes behaviour of the auto-negotiation advertisement and link partner ability registers to meet the requirements of SGMII and reduces the duration of the link timer from 10 ms to 1.6 ms.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPG_STRETCH_ENABLE</name>
              <description>IPG stretch enable - when set the transmit IPG can be increased above 96 bit times depending on the previous frame length using the IPG stretch register.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NSP_CHANGE</name>
              <description>Receive bad preamble. When set frames with non-standard preamble are not rejected.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_IPG_RX_ER</name>
              <description>Ignore IPG rx_er. When set rx_er has no effect on the GEMs operation when rx_dv is low. Set this when using the RGMII wrapper in half-duplex mode.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NETWORK_STATUS</name>
          <description>The network status register returns status information with respect to the PHY management interface.</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x6</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PCS_LINK_STATE</name>
              <description>Returns status of PCS link state. If auto-negotiation is disabled this returns the synchronisation status. If auto-negotiation is enabled it is set in the LINK_OK state as long as a compatible duplex mode is resolved.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MDIO_IN</name>
              <description>Returns status of the mdio_in pin.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAN_DONE</name>
              <description>The PHY management logic is idle (i.e. has completed).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAC_FULL_DUPLEX</name>
              <description>PCS auto-negotiation duplex resolution. Set to one if the resolution function determines that both devices are capable of full duplex operation. If zero half-duplex operation is possible as long as bit 0 (PCS link state) is also one.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_5_4</name>
              <description>N/A</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PFC_NEGOTIATE_PCLK</name>
              <description>Set when PFC Priority Based Pause has been negotiated.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LPI_INDICATE_PCLK</name>
              <description>LPI Indication - Low power idle has been detected on receive. This bit is set when LPI is detected and reset when normal idle is detected. An interrupt is generated when the state of this bit changes.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_IO_REGISTER</name>
          <description>Not presents. Access to the register will return AHB error.</description>
          <addressOffset>0x100C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSVD_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CONFIG</name>
          <description>DMA Configuration Register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180704</resetValue>
          <resetMask>0x77FF3FFF</resetMask>
          <fields>
            <field>
              <name>AMBA_BURST_LENGTH</name>
              <description>Selects the burst length to use on the AMBA (AHB/AXI) when transferring frame data. Not used for DMA management operations and only used where space and data size allow and respecting AXI/AHB burst boundary rules. One-hot priority encoding enforced automatically on register writes as follows, where x represents don't care:
 1xxxx: Attempt to use bursts of up to 16.
 01xxx: Attempt to use bursts of up to 8.
 001xx: Attempt to use bursts of up to 4.
 0001x: Always use SINGLE bursts.
 00001: Always use SINGLE bursts.
 00000: Attempt to use bursts of up to 256.
Note: MXETH only supports burst length up to 16.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDR_DATA_SPLITTING_EN</name>
              <description>Enable header data Splitting. When set, receive frames will be forwarded to main memory using a minimum of two DMA data buffers. The first X data buffers will contain the frame header, consisting of the Ethernet,VLAN,(IPv4 or IPv6),(TCP or UDP). X= (frame header size divided by rx_buf_size as defined in bits 23:16 of this register). The last Y data buffers will contain the frame payload. Y= (frame payload size divided by rx_buf_size). Note that for non VLAN/IP/TCP/UDP frames, the header will always be 14 bytes. When this feature is disabled, the frame is forwarded to main memory in blocks of rx_buf_size.
Note: For AXI_MASTER_PRESENT=0 i.e. AHB master support, this feature cannot be set.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENDIAN_SWAP_MANAGEMENT</name>
              <description>endian swap mode enable for management descriptor accesses. When set, selects swapped endianism for AMBA (AXI/AHB) transfers. When clear, selects little endian mode. Note, the default value of this bit equals to `gem_endian_swap_def, which is design time configuration.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENDIAN_SWAP_PACKET</name>
              <description>endian swap mode enable for packet data accesses. When set, selects swapped endianism for AMBA (AXI/AHB) transfers. When clear, selects little endian mode. Note, the default value of this bit equals to `gem_endian_swap_def, which is design time configuration.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PBUF_SIZE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PBUF_SIZE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PBUF_TCP_EN</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INFINITE_LAST_DBUF_SIZE_EN</name>
              <description>Forces the DMA to consider the data buffer pointed to by last descriptor in the descriptor list to be of infinite size.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERROR_REPORT</name>
              <description>When the bit is set, bit 16 of the receive buffer descriptor will represent FCS/CRC error (only if frames with FCS are copied to memory as enabled by bit 26 in the network config register). When this bit is clear, bit 16 of the receive buffer descriptor will represent the Canonical format indicator (CFI) bit as extracted from the receive frame (if the receive buffer descriptor is pointing to the last data buffer of the receive frame and the received frame was VLAN tagged).</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_BUF_SIZE</name>
              <description>DMA receive buffer size in external AMBA (AXI/AHB) system memory. The value defined by these bits determines the size of buffer to use in main system memory when writing received data. The value is defined in multiples of 64 bytes.
 0x01 corresponds to buffers of 64 bytes
 0x02 corresponds to 128 bytes etc. 
For example:
 0x02: 128 byte.
 0x18: 1536 byte (1*max length frame/buffer)
 0xA0: 10240 byte (1*10K jumbo frame/buffer) 
Note that this value should never be written as zero. 
Note. The reset value of this field is equal to the gem_rx_buffer_length_def define, which is user configurable.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DISCARD_ON_ERR</name>
              <description>Auto Discard RX pkts during lack of resource. When set, the GEM DMA will automatically discard receive packets from the receiver packet buffer memory when no AMBA (AXI/AHB) resource is available. When low, then received packets will remain to be stored in the SRAM based packet buffer until AMBA (AXI/AHB) buffer resource next becomes available. A write to this bit is ignored if the DMA is not configured in the packet buffer full store and forward mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_MAX_AMBA_BURST_RX</name>
              <description>Force max length bursts on RX. Force the RX DMA to always issue max length bursts on EOP(end of packet) or EOB(end of buffer)transfers, even if there is less than max burst real packet data required to write. Any extra bytes of pad data is set to 0x00. Does not apply on bursts that break 1k boundary rule.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_MAX_AMBA_BURST_TX</name>
              <description>Force max length bursts on TX. Force the TX DMA to always issue max length bursts on EOP(end of packet) or EOB(end of buffer) transfers as defined by bits 4:0 of this register, even when there is less that max burst data bytes to read. Residual data read is ignored. Does not apply on bursts that break 1k boundary rule.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_BD_EXTENDED_MODE_EN</name>
              <description>Enable RX extended BD mode. See RX BD control register definition for description of feature.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BD_EXTENDED_MODE_EN</name>
              <description>Enable TX extended BD mode. See TX BD control register definition for description of feature.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_ADDR_BUS_WIDTH_1</name>
              <description>DMA address bus width. 0 = 32b, 1 = 64b. MXETH only supports 32b DMA address bus width, so must set it 0.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRANSMIT_STATUS</name>
          <description>This register, when read, provides details of the status of a transmit. Once read, individual bits may be cleared by writing 1 to them. It is not possible to set a bit to 1 by writing to the register.</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>USED_BIT_READ</name>
              <description>Used bit read - set when a transmit buffer descriptor is read with its used bit set. Cleared by writing a one to this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLLISION_OCCURRED</name>
              <description>Collision occurred - set by the assertion of collision. Cleared by writing a one to this bit. When operating in 10/100 mode, this status indicates either a collision or a late collision. In gigabit mode, this status is not set for a late collision.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_LIMIT_EXCEEDED</name>
              <description>Retry limit exceeded - cleared by writing a one to this bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMIT_GO</name>
              <description>Transmit go - if high transmit is active. When using the exposed FIFO interface, this bit represents bit 3 of the network control register. When using the DMA interface this bit represents the tx_go variable as specified in the transmit buffer description.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AMBA_ERROR123</name>
              <description>Transmit frame corruption due to AMBA (AXI/AHB) errors. Set if an error occurs whilst midway through reading transmit frame from external memory including RRESP or BRESP errors and buffers exhausted mid frame (if the buffers run out during transmission of a frame then transmission stops, FCS shall be bad and tx_er asserted). Also set in DMA packet buffer mode if single frame is too large for configured packet buffer memory size. Cleared by writing a one to this bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMIT_COMPLETE123</name>
              <description>Transmit complete - set when a frame has been transmitted. Cleared by writing a one to this bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMIT_UNDER_RUN123</name>
              <description>Transmit under run - this bit is set if the transmitter was forced to terminate a frame that it had already began transmitting due to further data being unavailable. This bit is set if a transmitter status write back has not completed when another status write back is attempted. When using the DMA interface configured for packet buffer mode, this bit will never be set. Cleared by writing a 1.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_COLLISION_OCCURRED</name>
              <description>Late collision occurred - only set if the condition occurs in gigabit mode, as retry is not attempted. Cleared by writing a one to this bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_NOT_OK123</name>
              <description>bresp/hresp not OK - set when the DMA block sees bresp/hresp not OK. Cleared by writing a one to this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RECEIVE_Q_PTR</name>
          <description>This register holds the start address of the receive buffer queue (receive buffers descriptor list). The receive buffer queue base address must be initialized before receive is enabled through bit 2 of the network control register. Once reception is enabled, any write to the receive buffer queue base address register is ignored. Reading this register returns the location of the descriptor currently being accessed. This value increments as buffers are used. Software should not use this register for determining where to remove received frames from the queue as it constantly changes as new frames are received. Software should instead work its way through the buffer descriptor queue checking the used bits. In terms of AMBA (AXI) operation, the receive descriptors are read from memory using a single 32bit AXI access. When the datapath is configured at 64bit, the receive descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is written to using a single 64bit AXI access.</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFD</resetMask>
          <fields>
            <field>
              <name>DMA_RX_DIS_Q</name>
              <description>Disable queue if set to 1. This can be used to reduce the number of active queues and should only be changed while receive is not enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_Q_PTR</name>
              <description>Receive buffer queue base address - written with the address of the start of the receive queue.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRANSMIT_Q_PTR</name>
          <description>This register holds the start address of the transmit buffer queue (transmit buffers descriptor list). The transmit buffer queue base address register must be initialized before transmit is started through bit 9 of the network control register. Once transmission has started, any write to the transmit buffer queue base address register is illegal and therefore ignored. Note that due to clock boundary synchronization, it takes a maximum of four pclk cycles from the writing of the transmit start bit before the transmitter is active. Writing to the transmit buffer queue base address register during this time may produce unpredictable results. Reading this register returns the location of the descriptor currently being accessed. Because the DMA can store data for multiple frames at once, this may not necessarily be pointing to the current frame being transmitted. In terms of AMBA AXI operation, the transmit descriptors are written to memory using a single 32bit AHB access. When the datapath is configured as 64bit, the transmit descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from memory using a single AXI access.</description>
          <addressOffset>0x101C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFD</resetMask>
          <fields>
            <field>
              <name>DMA_TX_DIS_Q</name>
              <description>Disable queue if set to 1. This can be used to reduce the number of active queues and should only be changed while transmit is not enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_Q_PTR</name>
              <description>Transmit buffer queue base address - written with the address of the start of the transmit queue.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RECEIVE_STATUS</name>
          <description>This register, when read provides details of the status of a receive. Once read, individual bits may be cleared by writing 1 to them. It is not possible to set a bit to 1 by writing to the register.</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>BUFFER_NOT_AVAILABLE</name>
              <description>Buffer not available - an attempt was made to get a new buffer and the pointer indicated that it was owned by the processor. The DMA will reread the pointer each time an end of frame is received until a valid pointer is found. This bit is set following each descriptor read attempt that fails, even if consecutive pointers are unsuccessful and software has in the mean time cleared the status flag. Cleared by writing a one to this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_RECEIVED</name>
              <description>Frame received - one or more frames have been received and placed in memory. Cleared by writing a one to this bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVE_OVERRUN123</name>
              <description>Receive overrun - this bit is set if either the gem_dma RX FIFO or external RX FIFO were unable to store the receive frame due to a FIFO overflow, or if the receive status, reported by the gem_rx module to the gem_dma was not taken at end of frame. This bit is also set in DMA packet buffer mode if the packet buffer overflows. For DMA operation the buffer will be recovered if an overrun occurs. This bit is cleared by writing a one to it.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_NOT_OK1234</name>
              <description>bresp not OK - set when the DMA block sees bresp/hresp not OK. Cleared by writing a one to this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STATUS</name>
          <description>If not configured for priority queueing, the GEM generates a single interrupt. This register indicates the source of this interrupt. The corresponding bit in the mask register must be clear for a bit to be set. If any bit is set in this register the ethernet_int signal will be asserted. For test purposes each bit can be set or reset by writing to the interrupt mask register. The default configuration is shown below whereby all bits are reset to zero on read. Changing the validity of the `gem_irq_read_clear define will instead require a one to be written to the appropriate bit in order to clear it. In this mode reading has no affect on the status of the bit.</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFEFF</resetMask>
          <fields>
            <field>
              <name>MANAGEMENT_FRAME_SENT</name>
              <description>Management frame sent - the PHY maintenance register has completed its operation. Cleared on read.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVE_COMPLETE</name>
              <description>Receive complete - a frame has been stored in memory. Cleared on read.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_USED_BIT_READ</name>
              <description>RX used bit read - set when a receive buffer descriptor is read with its used bit set. Cleared on read.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_USED_BIT_READ</name>
              <description>TX used bit read - set when a transmit buffer descriptor is read with its used bit set. Cleared on read.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMIT_UNDER_RUN</name>
              <description>Transmit under run - this interrupt is set if the transmitter was forced to terminate a frame that it has already began transmitting due to further data being unavailable. If an under run occurs, the transmitter will force bad crc and tx_er high. This interrupt is set if a transmitter status write back has not completed when another status write back is attempted. When using the DMA interface configured for internal FIFO mode, this interrupt is also set when the transmit DMA has written the SOP data into the FIFO and either the AHB bus was not granted in time for further data, or because an AHB/AXI error response was returned by the connected slave, or because a used bit was read. When using the DMA interface configured for packet buffer mode, this bit will never be set. When using the external FIFO interface, this interrupt is also set when the tx_r_underflow input was asserted during a frame transfer. Cleared on read.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION</name>
              <description>Retry limit exceeded or late collision - transmit error. Late collision will only cause this status bit to be set in gigabit mode (as a retry is not attempted). Cleared on read.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AMBA_ERROR</name>
              <description>Transmit frame corruption due to AMBA (AXI/AHB) error. Set if an error occurs whilst midway through reading transmit frame from external system memory, including HRESP (AHB), RRESP or BRESP(AXI) errors and buffers exhausted mid frame (if the buffers run out during transmission of a frame then transmission stops, FCS shall be bad and tx_er asserted). Also set in DMA packet buffer mode if single frame is too large for configured packet buffer memory size. Cleared on a read.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMIT_COMPLETE</name>
              <description>Transmit complete - set when a frame has been transmitted. Cleared on read.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>REMOVED_9</name>
              <description>Write ignore, read 0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RECEIVE_OVERRUN</name>
              <description>Receive overrun - set when the receive overrun status bit gets set. Cleared on read.</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESP_NOT_OK</name>
              <description>bresp not OK - set when the DMA block sees bresp not OK. Cleared on read.</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PAUSE_FRAME_WITH_NON_ZERO_PAUSE_QUANTUM_RECEIVED</name>
              <description>Pause frame with non-zero pause quantum received - indicates a valid pause has been received that has a non-zero pause quantum field. Cleared on read.</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PAUSE_TIME_ELAPSED</name>
              <description>Pause Time elapsed. set when either the pause time register at address 0x38 decrements to zero, or when a valid pause frame is received with a zero pause quantum field. Cleared on read.</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PAUSE_FRAME_TRANSMITTED</name>
              <description>Pause frame transmitted - indicates a pause frame has been successfully transmitted after being initiated from the network control register or from the tx_pause control pin. Cleared on read.</description>
              <bitRange>[14:14]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>REMOVED_15</name>
              <description>Write ignore, read 0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_16</name>
              <description>Write ignore, read 0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_17</name>
              <description>Write ignore, read 0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_DELAY_REQ_FRAME_RECEIVED</name>
              <description>PTP delay_req frame received indicates a PTP delay_req frame has been received. Cleared on read.</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PTP_SYNC_FRAME_RECEIVED</name>
              <description>PTP sync frame received indicates a PTP sync frame has been received. Cleared on read.</description>
              <bitRange>[19:19]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PTP_DELAY_REQ_FRAME_TRANSMITTED</name>
              <description>PTP delay_req frame transmitted indicates a PTP delay_req frame has been transmitted. Cleared on read.</description>
              <bitRange>[20:20]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PTP_SYNC_FRAME_TRANSMITTED</name>
              <description>PTP sync frame transmitted indicates a PTP sync frame has been transmitted. Cleared on read.</description>
              <bitRange>[21:21]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PTP_PDELAY_REQ_FRAME_RECEIVED</name>
              <description>PTP pdelay_req frame received indicates a PTP pdelay_req frame has been received. Cleared on read.</description>
              <bitRange>[22:22]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PTP_PDELAY_RESP_FRAME_RECEIVED</name>
              <description>PTP pdelay_resp frame received indicates a PTP pdelay_resp frame has been received. Cleared on read.</description>
              <bitRange>[23:23]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PTP_PDELAY_REQ_FRAME_TRANSMITTED</name>
              <description>PTP pdelay_req frame transmitted indicates a PTP pdelay_req frame has been transmitted. Cleared on read.</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PTP_PDELAY_RESP_FRAME_TRANSMITTED</name>
              <description>PTP pdelay_resp frame transmitted indicates a PTP pdelay_resp frame has been transmitted. Cleared on read.</description>
              <bitRange>[25:25]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TSU_SECONDS_REGISTER_INCREMENT</name>
              <description>TSU seconds register increment indicates the register has incremented. Cleared on read.</description>
              <bitRange>[26:26]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RECEIVE_LPI_INDICATION_STATUS_BIT_CHANGE</name>
              <description>Receive LPI indication status bit change</description>
              <bitRange>[27:27]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>REMOVED_28</name>
              <description>Write ignore, read 0</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TSU_TIMER_COMPARISON_INTERRUPT</name>
              <description>TSU timer comparison interrupt. Indicates when TSU timer count value is equal to programmed value.</description>
              <bitRange>[29:29]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ENABLE</name>
          <description>At reset all interrupts are disabled. Writing a one to the relevant bit location enables the required interrupt. This register is write only and when read will return zero.</description>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE_MANAGEMENT_DONE_INTERRUPT</name>
              <description>Enable management done interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RECEIVE_COMPLETE_INTERRUPT</name>
              <description>Enable receive complete interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RECEIVE_USED_BIT_READ_INTERRUPT</name>
              <description>Enable receive used bit read interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT_USED_BIT_READ_INTERRUPT</name>
              <description>Enable transmit used bit read interrupt</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT_BUFFER_UNDER_RUN_INTERRUPT</name>
              <description>Enable transmit buffer under run interrupt</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_INTERRUPT</name>
              <description>Enable retry limit exceeded or late collision interrupt</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT_FRAME_CORRUPTION_DUE_TO_AMBA_ERROR_INTERRUPT</name>
              <description>Enable transmit frame corruption due to AMBA (AXI/AHB) error interrupt</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT_COMPLETE_INTERRUPT</name>
              <description>Enable transmit complete interrupt</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_8</name>
              <description>Not used</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_9</name>
              <description>Not used</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RECEIVE_OVERRUN_INTERRUPT</name>
              <description>Enable receive overrun interrupt</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RESP_NOT_OK_INTERRUPT</name>
              <description>Enable bresp not OK interrupt</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PAUSE_FRAME_WITH_NON_ZERO_PAUSE_QUANTUM_INTERRUPT</name>
              <description>Enable pause frame with non-zero pause quantum interrupt</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PAUSE_TIME_ZERO_INTERRUPT</name>
              <description>Enable pause time zero interrupt</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PAUSE_FRAME_TRANSMITTED_INTERRUPT</name>
              <description>Enable pause frame transmitted interrupt</description>
              <bitRange>[14:14]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_15</name>
              <description>Not used</description>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_16</name>
              <description>Not used</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_17</name>
              <description>Not used</description>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PTP_DELAY_REQ_FRAME_RECEIVED</name>
              <description>Enable PTP delay_req frame received</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PTP_SYNC_FRAME_RECEIVED</name>
              <description>Enable PTP sync frame received</description>
              <bitRange>[19:19]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PTP_DELAY_REQ_FRAME_TRANSMITTED</name>
              <description>Enable PTP delay_req frame transmitted</description>
              <bitRange>[20:20]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PTP_SYNC_FRAME_TRANSMITTED</name>
              <description>Enable PTP sync frame transmitted</description>
              <bitRange>[21:21]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PTP_PDELAY_REQ_FRAME_RECEIVED</name>
              <description>Enable PTP pdelay_req frame received</description>
              <bitRange>[22:22]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PTP_PDELAY_RESP_FRAME_RECEIVED</name>
              <description>Enable PTP pdelay_resp frame received</description>
              <bitRange>[23:23]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PTP_PDELAY_REQ_FRAME_TRANSMITTED</name>
              <description>Enable PTP pdelay_req frame transmitted</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_PTP_PDELAY_RESP_FRAME_TRANSMITTED</name>
              <description>Enable PTP pdelay_resp frame transmitted</description>
              <bitRange>[25:25]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TSU_SECONDS_REGISTER_INCREMENT</name>
              <description>Enable TSU seconds register increment</description>
              <bitRange>[26:26]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RX_LPI_INDICATION_INTERRUPT</name>
              <description>Enable RX LPI indication interrupt</description>
              <bitRange>[27:27]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_28</name>
              <description>Not used</description>
              <bitRange>[28:28]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TSU_TIMER_COMPARISON_INTERRUPT</name>
              <description>Enable TSU timer comparison interrupt.</description>
              <bitRange>[29:29]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_DISABLE</name>
          <description>Writing a 1 to the relevant bit location disables that particular interrupt. This register is write only and when read will return zero.</description>
          <addressOffset>0x102C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DISABLE_MANAGEMENT_DONE_INTERRUPT</name>
              <description>'Disable management done interrupt'</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RECEIVE_COMPLETE_INTERRUPT</name>
              <description>'Disable receive complete interrupt'</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RECEIVE_USED_BIT_READ_INTERRUPT</name>
              <description>'Disable receive used bit read interrupt'</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TRANSMIT_USED_BIT_READ_INTERRUPT</name>
              <description>'Disable transmit used bit read interrupt'</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TRANSMIT_BUFFER_UNDER_RUN_INTERRUPT</name>
              <description>'Disable transmit buffer under run interrupt'</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_INTERRUPT</name>
              <description>'Disable retry limit exceeded or late collision interrupt'</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TRANSMIT_FRAME_CORRUPTION_DUE_TO_AMBA_ERROR_INTERRUPT</name>
              <description>'Disable transmit frame corruption due to AMBA (AHB/AXI) error interrupt'</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TRANSMIT_COMPLETE_INTERRUPT</name>
              <description>'Disable transmit complete interrupt'</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_8</name>
              <description>Not used</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_9</name>
              <description>Not used</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RECEIVE_OVERRUN_INTERRUPT</name>
              <description>'Disable receive overrun interrupt'</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RESP_NOT_OK_INTERRUPT</name>
              <description>'Disable bresp/hresp not OK interrupt'</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PAUSE_FRAME_WITH_NON_ZERO_PAUSE_QUANTUM_INTERRUPT</name>
              <description>'Disable pause frame with non-zero pause quantum interrupt'</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PAUSE_TIME_ZERO_INTERRUPT</name>
              <description>'Disable pause time zero interrupt'</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PAUSE_FRAME_TRANSMITTED_INTERRUPT</name>
              <description>'Disable pause frame transmitted interrupt'</description>
              <bitRange>[14:14]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_15</name>
              <description>Not used</description>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_16</name>
              <description>Not used</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_17</name>
              <description>Not used</description>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PTP_DELAY_REQ_FRAME_RECEIVED</name>
              <description>'Disable PTP delay_req frame received'</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PTP_SYNC_FRAME_RECEIVED</name>
              <description>'Disable PTP sync frame received'</description>
              <bitRange>[19:19]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PTP_DELAY_REQ_FRAME_TRANSMITTED</name>
              <description>'Disable PTP delay_req frame transmitted '</description>
              <bitRange>[20:20]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PTP_SYNC_FRAME_TRANSMITTED</name>
              <description>'Disable PTP sync frame transmitted '</description>
              <bitRange>[21:21]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PTP_PDELAY_REQ_FRAME_RECEIVED</name>
              <description>'Disable PTP pdelay_req frame received'</description>
              <bitRange>[22:22]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PTP_PDELAY_RESP_FRAME_RECEIVED</name>
              <description>'Disable PTP pdelay_resp frame received'</description>
              <bitRange>[23:23]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PTP_PDELAY_REQ_FRAME_TRANSMITTED</name>
              <description>'Disable PTP pdelay_req frame transmitted'</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_PTP_PDELAY_RESP_FRAME_TRANSMITTED</name>
              <description>'Disable PTP pdelay_resp frame transmitted'</description>
              <bitRange>[25:25]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TSU_SECONDS_REGISTER_INCREMENT</name>
              <description>'Disable TSU seconds register increment'</description>
              <bitRange>[26:26]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RX_LPI_INDICATION_INTERRUPT</name>
              <description>'Disable RX LPI indication interrupt'</description>
              <bitRange>[27:27]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNUSED_28</name>
              <description>Not used</description>
              <bitRange>[28:28]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TSU_TIMER_COMPARISON_INTERRUPT</name>
              <description>'Disable TSU timer comparison interrupt.'</description>
              <bitRange>[29:29]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RSVD_30_30</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_31_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MASK</name>
          <description>The interrupt mask register is a read only register indicating which interrupts are masked. All bits are set at reset and can be reset individually by writing to the interrupt enable register or set individually by writing to the interrupt disable register. Having separate address locations for enable and disable saves the need for performing a read modify write when updating the interrupt mask register. For test purposes there is a write-only function to this register that allows the bits in the interrupt status register to be set or cleared, regardless of the state of the mask register.</description>
          <addressOffset>0x1030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3FFFFFFF</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MANAGEMENT_DONE_INTERRUPT_MASK</name>
              <description>management done interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RECEIVE_COMPLETE_INTERRUPT_MASK</name>
              <description>receive complete interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RECEIVE_USED_BIT_READ_INTERRUPT_MASK</name>
              <description>receive used bit read interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANSMIT_USED_BIT_READ_INTERRUPT_MASK</name>
              <description>transmit used bit read interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANSMIT_BUFFER_UNDER_RUN_INTERRUPT_MASK</name>
              <description>transmit buffer under run interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_MASK</name>
              <description>A read of this register returns the value of the retry limit exceeded or late collision (gigabit mode only) interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AMBA_ERROR_INTERRUPT_MASK</name>
              <description>transmit frame corruption due to AMBA (AXI) error interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANSMIT_COMPLETE_INTERRUPT_MASK</name>
              <description>transmit complete interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNUSED_8</name>
              <description>Not used</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNUSED_9</name>
              <description>Not used</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RECEIVE_OVERRUN_INTERRUPT_MASK</name>
              <description>receive overrun interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_NOT_OK_INTERRUPT_MASK</name>
              <description>bresp not OK interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PAUSE_FRAME_WITH_NON_ZERO_PAUSE_QUANTUM_INTERRUPT_MASK</name>
              <description>pause frame with non-zero pause quantum interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PAUSE_TIME_ZERO_INTERRUPT_MASK</name>
              <description>pause time zero interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PAUSE_FRAME_TRANSMITTED_INTERRUPT_MASK</name>
              <description>pause frame transmitted interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNUSED_15</name>
              <description>Not used</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNUSED_16</name>
              <description>Not used</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNUSED_17</name>
              <description>Not used</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_DELAY_REQ_FRAME_RECEIVED_MASK</name>
              <description>A read of this register returns the value of the PTP delay_req frame received mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_SYNC_FRAME_RECEIVED_MASK</name>
              <description>A read of this register returns the value of the PTP sync frame received mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_DELAY_REQ_FRAME_TRANSMITTED_MASK</name>
              <description>A read of this register returns the value of the PTP delay_req frame transmitted mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_SYNC_FRAME_TRANSMITTED_MASK</name>
              <description>A read of this register returns the value of the PTP sync frame transmitted mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_PDELAY_REQ_FRAME_RECEIVED_MASK</name>
              <description>A read of this register returns the value of the PTP pdelay_req frame received mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_PDELAY_RESP_FRAME_RECEIVED_MASK</name>
              <description>A read of this register returns the value of the PTP pdelay_resp frame received mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_PDELAY_REQ_FRAME_TRANSMITTED_MASK</name>
              <description>A read of this register returns the value of the PTP pdelay_req frame transmitted mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_PDELAY_RESP_FRAME_TRANSMITTED_MASK</name>
              <description>A read of this register returns the value of the PTP pdelay_resp frame transmitted mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TSU_SECONDS_REGISTER_INCREMENT_MASK</name>
              <description>A read of this register returns the value of the TSU seconds register increment mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_LPI_INDICATION_MASK</name>
              <description>A read of this register returns the value of the RX LPI indication mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNUSED_28</name>
              <description>unused</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TSU_TIMER_COMPARISON_MASK</name>
              <description>Enable TSU timer comparison interrupt mask.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_MANAGEMENT</name>
          <description>The PHY maintenance register is implemented as a shift register. Writing to the register starts a shift operation which is signalled as complete when bit-2 is set in the network status register. It takes about 2000 pclk cycles to complete, when MDC is set for pclk divide by 32 in the network configuration register. An interrupt is generated upon completion. During this time, the MSB of the register is output on the MDIO pin and the LSB updated from the MDIO pin with each MDC cycle. This causes transmission of a PHY management frame on MDIO. See Section 22.2.4.5 of the IEEE 802.3 standard. Reading during the shift operation will return the current contents of the shift register. At the end of management operation, the bits will have shifted back to their original locations. For a read operation, the data bits will be updated with data read from the PHY. It is important to write the correct values to the register to ensure a valid PHY management frame is produced. The MDIO interface can read IEEE 802.3 clause 45 PHYs as well as clause 22 PHYs. To read clause 45 PHYs, bit 30 should be written with a 0 rather than a 1. For a description of MDC generation, see Network Configuration Register.</description>
          <addressOffset>0x1034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_WRITE_READ_DATA</name>
              <description>For a write operation this is written with the data to be written to the PHY. After a read operation this contains the data read from the PHY.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE10</name>
              <description>Must be written with 10.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGISTER_ADDRESS</name>
              <description>Register address - specifies the register in the PHY to access.</description>
              <bitRange>[22:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_ADDRESS</name>
              <description>PHY address.</description>
              <bitRange>[27:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPERATION</name>
              <description>Operation. For a Clause 45 frame: 00 is an addr, 01 is a write, 10 is a post read increment, 11 is a read frame. For a Clause 22 frame: 10 is a read, 01 is a write.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE1</name>
              <description>Must be written to 1 for a valid Clause 22 frame and to 0 for a valid Clause 45 frame.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE0</name>
              <description>Must be written with 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PAUSE_TIME</name>
          <description>Received Pause Quantum Register</description>
          <addressOffset>0x1038</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>QUANTUM</name>
              <description>Received pause quantum - stores the current value of the received pause quantum register which is decremented every 512 bit times.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_PAUSE_QUANTUM</name>
          <description>Transmit Pause Quantum Register</description>
          <addressOffset>0x103C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUANTUM</name>
              <description>Transmit pause quantum - written with the pause quantum value for pause frame transmission.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QUANTUM_P1</name>
              <description>Transmit pause quantum - written with the pause quantum value for pause frame transmission of priority 1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PBUF_TXCUTTHRU</name>
          <description>Partial store and forward is only applicable when using the DMA configured in SRAM based packet buffer mode. It is also not available when using multi buffer frames. TX Partial Store and Forward</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1FF</resetValue>
          <resetMask>0x800001FF</resetMask>
          <fields>
            <field>
              <name>DMA_TX_CUTTHRU_THRESHOLD</name>
              <description>Watermark value. This value must be &gt;= 0x9. The reset value depends on the value of the configuration option `gem_tx_pbuf_addr, which is defined in the verilog defs configuration file. The value chosen for the generation of the userguide was `gem_tx_pbuf_addr = 9</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_CUTTHRU</name>
              <description>Enable TX partial store and forward operation</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PBUF_RXCUTTHRU</name>
          <description>RX Partial Store and Forward</description>
          <addressOffset>0x1044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>DMA_RX_CUTTHRU_THRESHOLD</name>
              <description>Watermark value. The reset value depends on the value of the configuration option `gem_rx_pbuf_addr, which is defined in the verilog defs configuration file. The value chosen for the generation of the userguide was `gem_rx_pbuf_addr = 8.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_CUTTHRU</name>
              <description>Enable RX partial store and forward operation</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JUMBO_MAX_LENGTH</name>
          <description>Maximum Jumbo Frame Size.</description>
          <addressOffset>0x1048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x600</resetValue>
          <resetMask>0x3FFF</resetMask>
          <fields>
            <field>
              <name>JUMBO_MAX_LENGTH</name>
              <description>Maximum Jumbo Frame Size - resets to the gem_jumbo_max_length define value.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTERNAL_FIFO_INTERFACE</name>
          <description>Not presents.</description>
          <addressOffset>0x104C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXI_MAX_PIPELINE</name>
          <description>Used to set the maximum amount of outstanding transactions on the AXI bus between AR / R channels and AW / W channels. Cannot be more than the depth of the configured AXI pipeline FIFO (defined in verilog defs.v)</description>
          <addressOffset>0x1054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x1FFFF</resetMask>
          <fields>
            <field>
              <name>AR2R_MAX_PIPELINE</name>
              <description>Defines the maximum number of outstanding AXI read requests that can be issued by the DMA via the AR channel.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AW2W_MAX_PIPELINE</name>
              <description>Defines the maximum number of outstanding AXI write requests that can be issued by the DMA via the AW channel.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USE_AW2B_FILL</name>
              <description>For the write issuing capability as defined in bits 15:8 of this register, select whether the max number of transactions operates between the AW to W AXI channel or the AW to B channel. Set to 0 to operate between the AW and W channels. Set to 1 to operate between the AW and B channels.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RSC_CONTROL</name>
          <description>Not presents. Access to the register will return AHB error.</description>
          <addressOffset>0x1058</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MODERATION</name>
          <description>Used to moderate the number of transmit and receive complete interrupts issued. With interrupt moderation enabled receive and transmit interrupts are not generated immediately a frame is transmitted or received. Instead when a receive or transmit event occurs a timer is started and the interrupt is asserted after it times out. This limits the frequency with which the CPU receives interrupts. When interrupt moderation is enabled interrupt status bit one is always used for receive and bit 7 is always used for transmit even when priority queuing is enabled. With interrupt moderation 800ns periods are counted. GEM determines what constitutes an 800ns period by looking at the tbi (bit 11), gigabit bit (10) and speed (bit 0) bits in the network configuration register and counting tx_clk cycles. Bit 0 needs to be set to 1 for 100M operation.</description>
          <addressOffset>0x105C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>RX_INT_MODERATION</name>
              <description>Count of 800ns periods before bit 1 is set in the interrupt status register after a frame is received. A non-zero value indicates receive interrupt moderation will be performed.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INT_MODERATION</name>
              <description>Count of 800ns periods before bit 7 is set in the interrupt status register after a frame is transmitted. A non-zero value indicates transmit interrupt moderation will be performed.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_WAKE_TIME</name>
          <description>Used to pause transmission after deassertion of tx_lpi_en. Each unit in this register corresponds to 64ns in gigabit mode, 320ns in 100M mode and 3200ns at 10M. After tx_lpi_en is deasserted transmission will pause for the set time.</description>
          <addressOffset>0x1060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SYS_WAKE_TIME</name>
              <description>Count of 64ns, 320ns or 3200ns intervals before transmission starts after deassertion of tx_lpi_en (each interval is equivalent to eight tx_clk periods and so varies with data rate).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_BOTTOM</name>
          <description>The unicast hash enable and the multicast hash enable bits in the network configuration register enable the reception of hash matched frames. Hash Register Bottom (31 to 0 bits)</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_HASH_B</name>
              <description>The first 32 bits of the hash address register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_TOP</name>
          <description>Hash Register Top (63 to 32 bits)</description>
          <addressOffset>0x1084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_HASH_T</name>
              <description>The remaining 32 bits of the hash address register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD1_BOTTOM</name>
          <description>The addresses stored in the specific address registers are deactivated at reset or when their corresponding specific address register bottom is written. They are activated when specific address register top is written.</description>
          <addressOffset>0x1088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_ADD1_B</name>
              <description>'Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.'</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD1_TOP</name>
          <description>Specific Address Top</description>
          <addressOffset>0x108C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_TOP</name>
              <description>Specific address 1. The most significant bits of the destination/source address that is to be compared, that is bits 47:32.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_TYPE</name>
              <description>This control bit selects whether this filter should be comparing the MAC source address or the MAC destination address of the received Ethernet frame. When set to zero, the filter is a destination address filter. When set to one, the filter is a source address filter. Specific address 1. The most significant bits of the destination address, that is bits 47:32.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD2_BOTTOM</name>
          <description>The addresses stored in the specific address registers are deactivated at reset or when their corresponding specific address register bottom is written. They are activated when specific address register top is written.</description>
          <addressOffset>0x1090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_BOTTOM</name>
              <description>Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD2_TOP</name>
          <description>Specific Address Top</description>
          <addressOffset>0x1094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F01FFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_TOP</name>
              <description>Specific address 1. The most significant bits of the destination/source address that is to be compared, that is bits 47:32.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_TYPE</name>
              <description>This control bit selects whether this filter should be comparing the MAC source address or the MAC destination address of the received Ethernet frame. When set to zero, the filter is a destination address filter. When set to one, the filter is a source address filter. Specific address 1. The most significant bits of the destination address, that is bits 47:32.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_BYTE_MASK</name>
              <description>When high, the associated byte of the specific address will not be compared. Bit 24 controls whether the first byte received should be compared. Bit 29 controls whether the last byte received should be compared.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD3_BOTTOM</name>
          <description>The addresses stored in the specific address registers are deactivated at reset or when their corresponding specific address register bottom is written. They are activated when specific address register top is written.</description>
          <addressOffset>0x1098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_BOTTOM</name>
              <description>Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD3_TOP</name>
          <description>Specific Address Top</description>
          <addressOffset>0x109C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F01FFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_TOP</name>
              <description>Specific address 1. The most significant bits of the destination/source address that is to be compared, that is bits 47:32.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_TYPE</name>
              <description>This control bit selects whether this filter should be comparing the MAC source address or the MAC destination address of the received Ethernet frame. When set to zero, the filter is a destination address filter. When set to one, the filter is a source address filter. Specific address 1. The most significant bits of the destination address, that is bits 47:32.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_BYTE_MASK</name>
              <description>When high, the associated byte of the specific address will not be compared. Bit 24 controls whether the first byte received should be compared. Bit 29 controls whether the last byte received should be compared.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD4_BOTTOM</name>
          <description>The addresses stored in the specific address registers are deactivated at reset or when their corresponding specific address register bottom is written. They are activated when specific address register top is written.</description>
          <addressOffset>0x10A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_BOTTOM</name>
              <description>Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD4_TOP</name>
          <description>Specific Address Top</description>
          <addressOffset>0x10A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F01FFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_TOP</name>
              <description>Specific address 1. The most significant bits of the destination/source address that is to be compared, that is bits 47:32.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_TYPE</name>
              <description>This control bit selects whether this filter should be comparing the MAC source address or the MAC destination address of the received Ethernet frame. When set to zero, the filter is a destination address filter. When set to one, the filter is a source address filter. Specific address 1. The most significant bits of the destination address, that is bits 47:32.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_BYTE_MASK</name>
              <description>When high, the associated byte of the specific address will not be compared. Bit 24 controls whether the first byte received should be compared. Bit 29 controls whether the last byte received should be compared.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_TYPE1</name>
          <description>Type ID Match 1</description>
          <addressOffset>0x10A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Type ID match 1. For use in comparisons with received frames type ID/length field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_COPY</name>
              <description>Enable copying of type ID match 1 matched frames.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_TYPE2</name>
          <description>Type ID Match 2</description>
          <addressOffset>0x10AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Type ID match 2. For use in comparisons with received frames type ID/length field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_COPY</name>
              <description>Enable copying of type ID match 2 matched frames.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_TYPE3</name>
          <description>Type ID Match 3</description>
          <addressOffset>0x10B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Type ID match 3. For use in comparisons with received frames type ID/length field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_COPY</name>
              <description>Enable copying of type ID match 3 matched frames.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_TYPE4</name>
          <description>Type ID Match 4</description>
          <addressOffset>0x10B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Type ID match 4. For use in comparisons with received frames type ID/length field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_COPY</name>
              <description>Enable copying of type ID match 4 matched frames.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WOL_REGISTER</name>
          <description>Wake on LAN Register. Presents in design, but feature is not supported.</description>
          <addressOffset>0x10B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Wake on LAN ARP request IP address. Written to define the least significant 16 bits of the target IP address that is matched to generate a Wake on LAN event. A value of zero will not generate an event, even if this is matched by the received frame.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WOL_MASK_0</name>
              <description>Wake on LAN magic packet event enable. When set magic packet events will cause the wol output to be asserted.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WOL_MASK_1</name>
              <description>Wake on LAN ARP request event enable. When set ARP request events will cause the wol output to be asserted.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WOL_MASK_2</name>
              <description>Wake on LAN specific address register 1 event enable. When set specific address 1 events will cause the wol output to be asserted.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WOL_MASK_3</name>
              <description>Wake on LAN multicast hash event enable. When set multicast hash events will cause the wol output to be asserted.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STRETCH_RATIO</name>
          <description>IPG stretch register</description>
          <addressOffset>0x10BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>IPG_STRETCH</name>
              <description>IPG Stretch. Bits 7:0 are multiplied with the previously transmitted frame length (including preamble) bits 15:8 +1 divide the frame length. If the resulting number is greater than 96 and bit 28 is set in the network configuration register then the resulting number is used for the transmit inter-packet-gap. 1 is added to bits 15:8 to prevent a divide by zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STACKED_VLAN</name>
          <description>Stacked VLAN Register</description>
          <addressOffset>0x10C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>User defined VLAN_TYPE field. When Stacked VLAN is enabled, the first VLAN tag in a received frame will only be accepted if the VLAN type field is equal to this user defined VLAN_TYPE OR equal to the standard VLAN type (0x8100). Note that the second VLAN tag of a Stacked VLAN packet will only be matched correctly if its VLAN_TYPE field equals 0x8100.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_PROCESSING</name>
              <description>Enable stacked VLAN processing mode</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_PFC_PAUSE</name>
          <description>Transmit PFC Pause Register</description>
          <addressOffset>0x10C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VECTOR_ENABLE</name>
              <description>Priority Vector Enable. If bit 17 of the network control register is written with a one then the priority enable vector of the PFC priority based pause frame will be set equal to the value stored in this register [7:0].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTOR</name>
              <description>Priority Vector Pause Size. If bit 17 of the network control register is written with a one then for each entry equal to zero in the Transmit PFC Pause Register[15:8], the PFC pause frame's pause quantum field associated with that entry will be taken from the transmit pause quantum register. For each entry equal to one in the Transmit PFC Pause Register [15:8], the pause quantum associated with that entry will be zero.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MASK_ADD1_BOTTOM</name>
          <description>Specific Address Mask 1 Bottom (31 to 0 bits)</description>
          <addressOffset>0x10C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_MASK_BOTTOM</name>
              <description>Specific Address Mask. Setting a bit to one masks the corresponding bit in the specific address 1 register (31 to 0 bits)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MASK_ADD1_TOP</name>
          <description>Specific Address Mask 1 Top (47 to 32 bits)</description>
          <addressOffset>0x10CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_MASK_TOP</name>
              <description>Specific Address Mask. Setting a bit to one masks the corresponding bit in the specific address 1 register (47 to 32 bits).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_ADDR_OR_MASK</name>
          <description>Receive DMA Data Buffer Address Mask</description>
          <addressOffset>0x10D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF000000F</resetMask>
          <fields>
            <field>
              <name>MASK_ENABLE</name>
              <description>Data Buffer Address Mask Enable. These bits are associated directly with bits[31:28].When bit 0 is set, the AXI/AHB address bit 28 used for accessing the receive data buffers will be forced to the value stored in bit 28 of this register. When bit 1 is set, the AXI/AHB address bit 29 used for accessing the receive data buffers will be forced to the value stored in bit 29 of this register. When bit 2 is set, the AXI/AHB address bit 30 used for accessing the receive data buffers will be forced to the value stored in bit 30 of this register. When bit 3 is set, the AXI/AHB address bit 31 used for accessing the receive data buffers will be forced to the value stored in bit 31 of this register. When these bits are clear, the associated value stored in bits 31:28 have no effect on the AXI/AHB address used for receive data buffer accesses. Any changes to this register will be ignored while the DMA is currently processing a receive packet. It will only affect the next full packet to be written to external memory.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_VALUE_DA</name>
              <description>Data Buffer Address Mask Value. Values used to force bits 31:28 of the receive data buffer AHB address to a particular value when the associated enable bits stored in this register [3:0] are set. Any changes to this register will be ignored while the DMA is currently processing a receive packet. It will only affect the next full packet to be written to external system memory.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_PTP_UNICAST</name>
          <description>PTP RX unicast IP destination address</description>
          <addressOffset>0x10D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_UNICAST</name>
              <description>Unicast IP destination address. Used for detection of PTP frames on receive path.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_PTP_UNICAST</name>
          <description>PTP TX unicast IP destination address</description>
          <addressOffset>0x10D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS_UNICAST</name>
              <description>Unicast IP destination address. Used for detection of PTP frames on transmit path.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_NSEC_CMP</name>
          <description>TSU timer comparison value nanoseconds</description>
          <addressOffset>0x10DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARISON_NSEC</name>
              <description>TSU timer comparison value (ns). Value is compared to the bits[45:24] of the TSU timer count value (upper 22 bits of nanosecond value).</description>
              <bitRange>[21:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_SEC_CMP</name>
          <description>TSU timer comparison value seconds (31 to 0 bits)</description>
          <addressOffset>0x10E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARISON_SEC</name>
              <description>TSU timer comparison value (s). Value is compared to seconds value bits [31:0] of the TSU timer count value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_MSB_SEC_CMP</name>
          <description>TSU timer comparison value seconds (47 to 32 bits)</description>
          <addressOffset>0x10E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARISON_MSB_SEC</name>
              <description>TSU timer comparison value (s). Value is compared to the top 16 bits (most significant 16-bits {47:32] of seconds value) of the TSU timer count value.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PTP_TX_MSB_SEC</name>
          <description>PTP Event Frame Transmitted Seconds Register (47 to 32 bits)</description>
          <addressOffset>0x10E8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_SECONDS</name>
              <description>PTP Event Frame TX Seconds. The register is updated with the value that the 1588 timer seconds register held when the SFD of a PTP transmit primary event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP sync or delay_req frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PTP_RX_MSB_SEC</name>
          <description>PTP Event Frame Received Seconds Register (47 to 32 bits)</description>
          <addressOffset>0x10EC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_SECONDS</name>
              <description>PTP Event Frame TX Seconds. The register is updated with the value that the 1588 timer seconds register held when the SFD of a PTP receive primary event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP sync or delay_req frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PEER_TX_MSB_SEC</name>
          <description>PTP Peer Event Frame Transmitted Seconds Register (47 to 32 bits)</description>
          <addressOffset>0x10F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_SECONDS</name>
              <description>PTP Peer Event Frame TX Seconds. The register is updated with the value that the 1588 timer seconds register held when the SFD of a PTP transmit peer event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP pdelay_req or pdelay_resp frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PEER_RX_MSB_SEC</name>
          <description>PTP Peer Event Frame Received Seconds Register (47 to 32 bits)</description>
          <addressOffset>0x10F4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_SECONDS</name>
              <description>PTP Peer Event Frame RX Seconds. The register is updated with the value that the 1588 timer seconds register held when the SFD of a PTP receive peer event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP pdelay_req or pdelay_resp frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPRAM_FILL_DBG</name>
          <description>The fill levels for the TX &amp; RX packet buffers can be read using this register, including the fill level for each queue in the TX direction.</description>
          <addressOffset>0x10F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF00F1</resetMask>
          <fields>
            <field>
              <name>DMA_TX_RX_FILL_LEVEL_SELECT</name>
              <description>TX/RX Fill Level select - report the fill level for the TX or RX packet buffer.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_Q_FILL_LEVEL_SELECT</name>
              <description>TX queue fill level select - select what TX queue to report fill levels for.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_RX_FILL_LEVEL</name>
              <description>Fill Level - TX or RX packet buffer fill level, selected by the tx_q_fill_level_select and tx_rx_fill_level_select registers. Read this register to determine the fill level.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REVISION_REG</name>
          <description>This register indicates a Cadence module identification number and module revision. The value of this register is read only as defined by `gem_revision_reg_value</description>
          <addressOffset>0x10FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x70109</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MODULE_REVISION</name>
              <description>Module revision - fixed value specific to the revision of the design which is incremented for each non-fix release of the IP.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MODULE_IDENTIFICATION_NUMBER</name>
              <description>Module identification number - for the GEM, this value is fixed.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIX_NUMBER</name>
              <description>Fix number - incremented for fix releases.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OCTETS_TXED_BOTTOM</name>
          <description>Octets Transmitted lower bits (31 to 0 bits)</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_BOTTOM</name>
              <description>Transmitted octets in frame without errors [31:0]. The number of octets transmitted in valid frames of any type. This counter is 48-bits, and is read through two registers. This count does not include octets from automatically generated pause frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OCTETS_TXED_TOP</name>
          <description>Octets Transmitted higher bits (47 to 32 bits)</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_TOP</name>
              <description>Transmitted octets in frame without errors [47:32]. The number of octets transmitted in valid frames of any type. This counter is 48-bits, and is read through two registers. This count does not include octets from automatically generated pause frames.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_TXED_OK</name>
          <description>Frames Transmitted</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_OK</name>
              <description>Frames transmitted without error. A 32 bit register counting the number of frames successfully transmitted, i.e. no under run and not too many retries. Excludes pause frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BROADCAST_TXED</name>
          <description>Broadcast Frames Transmitted</description>
          <addressOffset>0x110C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_BROADCAST</name>
              <description>Broadcast frames transmitted without error. A 32 bit register counting the number of broadcast frames successfully transmitted without error, i.e. no under run and not too many retries. Excludes pause frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MULTICAST_TXED</name>
          <description>Multicast Frames Transmitted</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_MULTICAST</name>
              <description>Multicast frames transmitted without error. A 32 bit register counting the number of multicast frames successfully transmitted without error, i.e. no under run and not too many retries. Excludes pause frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PAUSE_FRAMES_TXED</name>
          <description>Pause Frames Transmitted</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_PAUSE</name>
              <description>Transmitted pause frames - a 16 bit register counting the number of pause frames transmitted. Only pause frames triggered by the register interface or through the external pause pins are counted as pause frames. Pause frames received through the external FIFO interface are counted in the frames transmitted counter.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_TXED_64</name>
          <description>64 Byte Frames Transmitted</description>
          <addressOffset>0x1118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_64</name>
              <description>64 byte frames transmitted without error. A 32 bit register counting the number of 64 byte frames successfully transmitted without error, i.e. no under run and not too many retries. Excludes pause frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_TXED_65</name>
          <description>65 to 127 Byte Frames Transmitted</description>
          <addressOffset>0x111C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_65</name>
              <description>65 to127 byte frames transmitted without error. A 32 bit register counting the number of 65 to127 byte frames successfully transmitted without error, i.e. no under run and not too many retries.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_TXED_128</name>
          <description>128 to 255 Byte Frames Transmitted</description>
          <addressOffset>0x1120</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_128</name>
              <description>128 to 255 byte frames transmitted without error. A 32 bit register counting the number of 128 to 255 byte frames successfully transmitted without error, i.e. no under run and not too many retries.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_TXED_256</name>
          <description>256 to 511 Byte Frames Transmitted</description>
          <addressOffset>0x1124</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_256</name>
              <description>256 to 511 byte frames transmitted without error. A 32 bit register counting the number of 256 to 511 byte frames successfully transmitted without error, i.e. no under run and not too many retries.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_TXED_512</name>
          <description>512 to 1023 Byte Frames Transmitted</description>
          <addressOffset>0x1128</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_512</name>
              <description>512 to 1023 byte frames transmitted without error. A 32 bit register counting the number of 512 to 1023 byte frames successfully transmitted without error, i.e. no under run and not too many retries.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_TXED_1024</name>
          <description>1024 to 1518 Byte Frames Transmitted</description>
          <addressOffset>0x112C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_1024</name>
              <description>1024 to 1518 byte frames transmitted without error. A 32 bit register counting the number of 1024 to 1518 byte frames successfully transmitted without error, i.e. no under run and not too many retries.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_TXED_1519</name>
          <description>Greater Than 1518 Byte Frames Transmitted</description>
          <addressOffset>0x1130</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_1519</name>
              <description>Greater than 1518 byte frames transmitted without error. A 32 bit register counting the number of 1518 or above byte frames successfully transmitted without error, i.e. no under run and not too many retries.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_UNDERRUNS</name>
          <description>Transmit Under Runs</description>
          <addressOffset>0x1134</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_UN</name>
              <description>Transmit under runs - a 10 bit register counting the number of frames not transmitted due to a transmit under run. If this register is incremented then no other statistics register is incremented.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SINGLE_COLLISIONS</name>
          <description>Single Collision Frames. Presents in design but not support.</description>
          <addressOffset>0x1138</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF</resetMask>
          <fields>
            <field>
              <name>COUNT14</name>
              <description>Single collision frames - an 18 bit register counting the number of frames experiencing a single collision before being successfully transmitted, i.e. no under run.</description>
              <bitRange>[17:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MULTIPLE_COLLISIONS</name>
          <description>Multiple Collision Frames. Presents in design but not support.</description>
          <addressOffset>0x113C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF</resetMask>
          <fields>
            <field>
              <name>COUNT15</name>
              <description>Multiple collision frames - an 18 bit register counting the number of frames experiencing between two and fifteen collisions prior to being successfully transmitted, i.e. no under run and not too many retries.</description>
              <bitRange>[17:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXCESSIVE_COLLISIONS</name>
          <description>Excessive Collisions.  Presents in design but not support.</description>
          <addressOffset>0x1140</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT16</name>
              <description>Excessive collisions - a 10 bit register counting the number of frames that failed to be transmitted because they experienced 16 collisions.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATE_COLLISIONS</name>
          <description>Late Collisions.  Presents in design but not support.</description>
          <addressOffset>0x1144</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT17</name>
              <description>Late collisions - a 10 bit register counting the number of late collision occurring after the slot time (512 bits) has expired. In 10/100 mode, late collisions are counted twice i.e. both as a collision and a late collision. In gigabit mode, a late collision causes the transmission to be aborted, thus the single and multi collision registers are not updated.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEFERRED_FRAMES</name>
          <description>Deferred Transmission Frames.  Presents in design but not support.</description>
          <addressOffset>0x1148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF</resetMask>
          <fields>
            <field>
              <name>COUNT18</name>
              <description>Deferred transmission frames - an 18 bit register counting the number of frames experiencing deferral due to carrier sense being active on their first attempt at transmission. Frames involved in any collision are not counted nor are frames that experienced a transmit under run.</description>
              <bitRange>[17:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRS_ERRORS</name>
          <description>Carrier Sense Errors.  Presents in design but not support.</description>
          <addressOffset>0x114C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT19</name>
              <description>Carrier sense errors - a 10 bit register counting the number of frames transmitted where carrier sense was not seen during transmission or where carrier sense was deasserted after being asserted in a transmit frame without collision (no under run). Only incremented in half duplex mode. The only effect of a carrier sense error is to increment this register. The behaviour of the other statistics registers is unaffected by the detection of a carrier sense error.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OCTETS_RXED_BOTTOM</name>
          <description>Octets Received (31 to 0 bits)</description>
          <addressOffset>0x1150</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_BOTTOM</name>
              <description>Received octets in frame without errors [31:0]. The number of octets received in valid frames of any type. This counter is 48-bits and is read through two registers. This count does not include octets from pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OCTETS_RXED_TOP</name>
          <description>Octets Received (47 to 32 bits)</description>
          <addressOffset>0x1154</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_TOP</name>
              <description>Received octets in frame without errors [47:32]. The number of octets received in valid frames of any type. This counter is 48-bits and is read through two registers. This count does not include octets from pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_RXED_OK</name>
          <description>Frames Received</description>
          <addressOffset>0x1158</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_OK</name>
              <description>Frames received without error. A 32 bit register counting the number of frames successfully received. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BROADCAST_RXED</name>
          <description>Broadcast Frames Received</description>
          <addressOffset>0x115C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_BROADCAST</name>
              <description>Broadcast frames received without error. A 32 bit register counting the number of broadcast frames successfully received without error. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MULTICAST_RXED</name>
          <description>Multicast Frames Received</description>
          <addressOffset>0x1160</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_MULTICAST</name>
              <description>Multicast frames received without error. A 32 bit register counting the number of multicast frames successfully received without error. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PAUSE_FRAMES_RXED</name>
          <description>Pause Frames Received</description>
          <addressOffset>0x1164</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_PAUSE</name>
              <description>Received pause frames - a 16 bit register counting the number of pause frames received without error.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_RXED_64</name>
          <description>64 Byte Frames Received</description>
          <addressOffset>0x1168</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_64</name>
              <description>64 byte frames received without error. A 32 bit register counting the number of 64 byte frames successfully received without error. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_RXED_65</name>
          <description>65 to 127 Byte Frames Received</description>
          <addressOffset>0x116C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_65</name>
              <description>65 to 127 byte frames received without error. A 32 bit register counting the number of 65 to 127 byte frames successfully received without error. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_RXED_128</name>
          <description>128 to 255 Byte Frames Received</description>
          <addressOffset>0x1170</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_128</name>
              <description>128 to 255 byte frames received without error. A 32 bit register counting the number of 128 to 255 byte frames successfully received without error. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_RXED_256</name>
          <description>256 to 511 Byte Frames Received</description>
          <addressOffset>0x1174</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_256</name>
              <description>256 to 511 byte frames received without error. A 32 bit register counting the number of 256 to 511 byte frames successfully transmitted without error. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_RXED_512</name>
          <description>512 to 1023 Byte Frames Received</description>
          <addressOffset>0x1178</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_512</name>
              <description>512 to 1023 byte frames received without error. A 32 bit register counting the number of 512 to 1023 byte frames successfully received without error. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_RXED_1024</name>
          <description>1024 to 1518 Byte Frames Received</description>
          <addressOffset>0x117C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_1024</name>
              <description>1024 to 1518 byte frames received without error. A 32 bit register counting the number of 1024 to 1518 byte frames successfully received without error. Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAMES_RXED_1519</name>
          <description>1519 to maximum Byte Frames Received</description>
          <addressOffset>0x1180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_1519</name>
              <description>1519 to maximum byte frames received without error. A 32 bit register counting the number of 1519 byte or above frames successfully received without error. Maximum frame size is determined by the network configuration register bit 8 (1536 maximum frame size) or bit 3 (jumbo frame size). Excludes pause frames, and is only incremented if the frame is successfully filtered.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNDERSIZE_FRAMES</name>
          <description>Undersized Frames Received</description>
          <addressOffset>0x1184</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_UNDERSIZE</name>
              <description>Undersize frames received - a 10 bit register counting the number of frames received less than 64 bytes in length (10/100 mode or gigabit mode, full duplex) that do not have either a CRC error or an alignment error. In gigabit mode, half duplex, this register counts either frames not conforming to the minimum slot time of 512 bytes or frames not conforming to the minimum frame size once bursting is active.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXCESSIVE_RX_LENGTH</name>
          <description>Oversize Frames Received</description>
          <addressOffset>0x1188</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_OVERSIZE</name>
              <description>Oversize frames received - a 10 bit register counting the number of frames received exceeding 1518 bytes (1536 bytes if bit 8 is set in network configuration register, 10,240 bytes if bit 3 is set in the network configuration register) in length but do not have either a CRC error, an alignment error nor a receive symbol error.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_JABBERS</name>
          <description>Jabbers Received</description>
          <addressOffset>0x118C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_JABBERS</name>
              <description>Jabbers received - a 10 bit register counting the number of frames received exceeding 1518 bytes (1536 if bit 8 set in network configuration register, 10,240 bytes if bit 3 is set in the network configuration register) in length and have either a CRC error, an alignment error or a receive symbol error.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FCS_ERRORS</name>
          <description>Frame Check Sequence Errors</description>
          <addressOffset>0x1190</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_FCS_ERR</name>
              <description>Frame check sequence errors - a 10 bit register counting frames that are an integral number of bytes, have bad CRC and are between 64 and 1518 bytes in length (1536 if bit 8 set in network configuration register, 10,240 bytes if bit 3 is set in the network configuration register). This register is also incremented if a symbol error is detected and the frame is of valid length and has an integral number of bytes. This register is incremented for a frame with bad FCS, regardless of whether it is copied to memory due to ignore FCS mode being enabled in bit 26 of the network configuration register.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_LENGTH_ERRORS</name>
          <description>Length Field Frame Errors</description>
          <addressOffset>0x1194</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_LENGTH_ERR</name>
              <description>Length field frame errors - this 10-bit register counts the number of frames received that have a measured length shorter than that extracted from the length field (bytes 13 and 14). This condition is only counted if the value of the length field is less than 0x0600, the frame is not of excessive length and checking is enabled through bit 16 of the network configuration register.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_SYMBOL_ERRORS</name>
          <description>Receive Symbol Errors</description>
          <addressOffset>0x1198</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_SYMBOL_ERR</name>
              <description>Receive symbol errors - a 10-bit register counting the number of frames that had rx_er asserted during reception. For 10/100 mode symbol errors are counted regardless of frame length checks. For gigabit mode the frame must satisfy slot time requirements in order to count a symbol error. Additionally, in gigabit half duplex mode, carrier extension errors are also recorded. Receive symbol errors will also be counted as an FCS or alignment error if the frame is between 64 and 1518 bytes (1536 bytes if bit 8 is set in the network configuration register, 10240 bytes if bit 3 is set in the network configuration register). If the frame is larger it will be recorded as a jabber error.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALIGNMENT_ERRORS</name>
          <description>Alignment Errors</description>
          <addressOffset>0x119C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_ALIGNMENT_ERROR</name>
              <description>Alignment errors - a 10 bit register counting frames that are not an integral number of bytes long and have bad CRC when their length is truncated to an integral number of bytes and are between 64 and 1518 bytes in length (1536 if bit 8 set in network configuration register, 10,240 bytes if bit 3 is set in the network configuration register). This register is also incremented if a symbol error is detected and the frame is of valid length and does not have an integral number of bytes.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_RESOURCE_ERRORS</name>
          <description>Receive Resource Errors</description>
          <addressOffset>0x11A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_RESOURCE_ERR</name>
              <description>Receive resource errors - an 18 bit register counting the number of frames that were successfully received by the MAC (correct address matched frame and adequate slot time) but could not be copied to memory because no receive buffer was available. This occurs when the GEM reads a buffer descriptor with its ownership (or used) bit set.</description>
              <bitRange>[17:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_OVERRUNS</name>
          <description>Receive Overruns</description>
          <addressOffset>0x11A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>COUNT_OVERRUN</name>
              <description>Receive overruns - a 10 bit register counting the number of frames that are address recognized but were not copied to memory due to a receive overrun.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_IP_CK_ERRORS</name>
          <description>IP Header Checksum Errors</description>
          <addressOffset>0x11A8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNT_IPCK_ERR</name>
              <description>IP header checksum errors - an 8-bit register counting the number of frames discarded due to an incorrect IP header checksum, but are between 64 and 1518 bytes (1536 bytes if bit 8 is set in the network configuration register or 10240 bytes if bit 3 is in the network configuration register) and do not have a CRC error, an alignment error, nor a symbol error.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_TCP_CK_ERRORS</name>
          <description>TCP Checksum Errors</description>
          <addressOffset>0x11AC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNT_TCPCK_ERR</name>
              <description>TCP checksum errors - an 8-bit register counting the number of frames discarded due to an incorrect TCP checksum, but are between 64 and 1518 bytes (1536 bytes if bit 8 is set in the network configuration register or 10240 bytes if bit 3 is in the network configuration register) and do not have a CRC error, an alignment error, nor a symbol error.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_UDP_CK_ERRORS</name>
          <description>UDP Checksum Errors</description>
          <addressOffset>0x11B0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNT_UDPCK_ERR</name>
              <description>UDP checksum errors - an 8-bit register counting the number of frames discarded due to an incorrect UDP checksum, but are between 64 and 1518 bytes (1536 bytes if bit 8 is set in the network configuration register or 10240 bytes if bit 3 is in the network configuration register) and do not have a CRC error, an alignment error, nor a symbol error.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUTO_FLUSHED_PKTS</name>
          <description>Receive DMA Flushed Packets</description>
          <addressOffset>0x11B4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_FLUSHED</name>
              <description>Flushed RX packets counter. A 16 bit register counting the number of frames that have been flushed from the receive SRAM based packet buffer due to one of the following reasons .1. When partial store and forward mode is enabled or bit 24 of the DMA configuration register is enabled, a packet is received while there is no AMBA (AXI/AHB) resource. 2. When partial store and forward mode is enabled and an AMBA (AXI/AHB) error is encountered while writing the packet data to external memory. When bit 18 of the network control register(software action to flush a packet from the head of the PBUF queue) is pulsed and the GEM DMA is not currently busy.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_TIMER_INCR_SUB_NSEC</name>
          <description>1588 Timer Increment Register sub nsec</description>
          <addressOffset>0x11BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FFFF</resetMask>
          <fields>
            <field>
              <name>SUB_NS_INCR</name>
              <description>These are the most significant bits [23:8] of the sub-ns value by which the 1588 timer will be incremented each clock cycle. 24 bits of sub nanosecond precision gives resolution of approximately 5.86E-17 seconds (16 bits gives 15.2 femtoseconds).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUB_NS_INCR_LSB</name>
              <description>These are the least significant bits [7:0] of the sub-ns value by which the 1588 timer will be incremented each clock cycle.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_TIMER_MSB_SEC</name>
          <description>1588 Timer Seconds Register (47 to 32 bits)</description>
          <addressOffset>0x11C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_MSB_SEC</name>
              <description>TSU timer value (s). Most significant 16 bits of seconds timer count. The register is writeable. The 48-bit counter increments by one when the 1588 nanoseconds counter counts to one second. It may also be incremented or decremented when the timer adjust register is written (if decremented from zero the 48-bit combined count would roll back to 0xFFFFFFFFFFFF). Note: The value of this register is used only when the lower 32 bit register is written to. This is to ensure a single update of the 48 bit seconds value</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_STROBE_MSB_SEC</name>
          <description>1588 Timer Sync Strobe Seconds Register (47 to 32 bits)</description>
          <addressOffset>0x11C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>STROBE_MSB_SEC</name>
              <description>1588 Timer Sync Strobe Seconds. The most significant 16-bit value of the Timer Seconds register captured when gem_tsu_ms and gem_tsu_inc_ctrl are zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_STROBE_SEC</name>
          <description>1588 Timer Sync Strobe Seconds Register (31 to 0 bits)</description>
          <addressOffset>0x11C8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STROBE_SEC</name>
              <description>1588 Timer Sync Strobe Seconds. The lowest significant 32-bit value of the Timer Seconds register captured when gem_tsu_ms and gem_tsu_inc_ctrl are zero.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_STROBE_NSEC</name>
          <description>1588 Timer Sync Strobe Nanoseconds Register</description>
          <addressOffset>0x11CC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>STROBE_NSEC</name>
              <description>1588 Timer Sync Strobe Nanoseconds. The value of the Timer Nanoseconds register captured when gem_tsu_ms and gem_tsu_inc_ctrl are zero.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_TIMER_SEC</name>
          <description>1588 Timer Seconds Register (31 to 0 bits)</description>
          <addressOffset>0x11D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_SEC</name>
              <description>1588 Timer Seconds Register. TSU timer value (s). Least significant 32 bits of seconds timer count. This register is writeable. The 48-bit counter increments by one when the 1588 nanoseconds counter counts to one second. It may also be incremented or decremented when the timer adjust register is written (if decremented from zero the 48-bit combined count would roll back to 0xFFFFFFFFFFFF).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_TIMER_NSEC</name>
          <description>1588 Timer Nanoseconds Register</description>
          <addressOffset>0x11D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_NSEC</name>
              <description>Timer count in nanoseconds. This register is writeable. It can also be adjusted by writes to the 1588 timer adjust register. It increments by the value of the 1588 timer increment register each clock cycle (if this register is close to zero and a write to the timer adjust register causes a decrement the seconds register will be decremented if necessary and the nanoseconds register will roll back to 9999999xx(decimal)).</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_TIMER_ADJUST</name>
          <description>This register is used to adjust the value of the timer in the TSU. It allows an integral number of nanoseconds to be added or subtracted from the timer in a one-off operation. This register returns all zeroes when read.</description>
          <addressOffset>0x11D8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCREMENT_VALUE</name>
              <description>Timer increment value. The number of nanoseconds to increment or decrement the 1588 timer nanoseconds register. If necessary the 1588 seconds register will be incremented or decremented.</description>
              <bitRange>[29:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ADD_SUBTRACT</name>
              <description>Write as one to subtract from the 1588 timer. Write as zero to add to it.</description>
              <bitRange>[31:31]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_TIMER_INCR</name>
          <description>1588 Timer Increment Register</description>
          <addressOffset>0x11DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>NS_INCREMENT</name>
              <description>A count of nanoseconds by which the 1588 timer nanoseconds register will be incremented each clock cycle. These are the most significant 8 bits of the 32 bit timer_increment counter. The tsu_timer_incr_sub_nsec register holds the least significant 24 bits of the increment.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALT_NS_INCR</name>
              <description>Alternative nanoseconds count. Alternative count of nanoseconds by which the 1588 timer nanoseconds register will be incremented each clock cycle.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_INCS</name>
              <description>Number of incs before alt inc. The number of increments after which the alternative increment is used.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PTP_TX_SEC</name>
          <description>PTP Event Frame Transmitted Seconds Register (31 to 0 bits)</description>
          <addressOffset>0x11E0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_PTP_SEC</name>
              <description>PTP Event Frame Transmitted Seconds. The register is updated with the value that the 1588 timer seconds register held when the SFD of a PTP transmit primary event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP sync or delay_req frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PTP_TX_NSEC</name>
          <description>PTP Event Frame Transmitted Nanoseconds Register</description>
          <addressOffset>0x11E4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_PTP_NSEC</name>
              <description>PTP Event Frame Transmitted Nanoseconds. The register is updated with the value that the 1588 timer nanoseconds register held when the SFD of a PTP transmit primary event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP sync or delay_req frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PTP_RX_SEC</name>
          <description>PTP Event Frame Received Seconds Register (31 to 0 bits)</description>
          <addressOffset>0x11E8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_PTP_SEC</name>
              <description>PTP Event Frame Received Seconds. The register is updated with the value that the 1588 timer seconds register held when the SFD of a PTP receive primary event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP sync or delay_req frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PTP_RX_NSEC</name>
          <description>PTP Event Frame Received Nanoseconds Register</description>
          <addressOffset>0x11EC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_PTP_NSEC</name>
              <description>PTP Event Frame Received Nanoseconds. The register is updated with the value that the 1588 timer nanoseconds register held when the SFD of a PTP receive primary event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP sync or delay_req frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PEER_TX_SEC</name>
          <description>PTP Peer Event Frame Transmitted Seconds Register (31 to 0 bits)</description>
          <addressOffset>0x11F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_PEER_SEC</name>
              <description>PTP Peer Event Frame Received Seconds. The register is updated with the value that the 1588 timer seconds register held when the SFD of a PTP transmit peer event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP pdelay_req or pdelay_resp frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PEER_TX_NSEC</name>
          <description>PTP Peer Event Frame Transmitted Nanoseconds Register</description>
          <addressOffset>0x11F4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_PEER_NSEC</name>
              <description>PTP Peer Event Frame Transmitted Nanoseconds. The register is updated with the value that the 1588 timer nanoseconds register held when the SFD of a PTP transmit peer event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP pdelay_req or pdelay_resp frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PEER_RX_SEC</name>
          <description>PTP Peer Event Frame Received Seconds Register (31 to 0 bits)</description>
          <addressOffset>0x11F8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_PEER_SEC</name>
              <description>PTP Peer Event Frame Received Seconds. The register is updated with the value that the 1588 timer seconds register held when the SFD of a PTP receive peer event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP pdelay_req or pdelay_resp frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSU_PEER_RX_NSEC</name>
          <description>PTP Peer Event Frame Received Nanoseconds Register</description>
          <addressOffset>0x11FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_PEER_NSEC</name>
              <description>PTP Peer Event Frame Received Nanoseconds. The register is updated with the value that the 1588 timer nanoseconds register held when the SFD of a PTP receive peer event crosses the MII interface. The actual update occurs when the GEM recognizes the frame as a PTP pdelay_req or pdelay_resp frame. An interrupt is issued when the register is updated.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCS_CONTROL</name>
          <description>Not presents. Access to the register returns AHB error.</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCS_STATUS</name>
          <description>Not presents. Access to the register returns AHB error.</description>
          <addressOffset>0x1204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCS_AN_ADV</name>
          <description>Not presents. Access to the register returns AHB error.</description>
          <addressOffset>0x1210</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCS_AN_LP_BASE</name>
          <description>Not presents. Access to the register returns AHB error.</description>
          <addressOffset>0x1214</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCS_AN_EXP</name>
          <description>Not presents. Access to the register returns AHB error.</description>
          <addressOffset>0x1218</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCS_AN_NP_TX</name>
          <description>Not presents. Access to the register returns AHB error.</description>
          <addressOffset>0x121C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCS_AN_LP_NP</name>
          <description>Not presents. Access to the register returns AHB error.</description>
          <addressOffset>0x1220</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCS_AN_EXT_STATUS</name>
          <description>Not presents. Access to the register returns AHB error.</description>
          <addressOffset>0x123C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_PAUSE_QUANTUM1</name>
          <description>Transmit Pause Quantum Register 1</description>
          <addressOffset>0x1260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUANTUM_P2</name>
              <description>Transmit pause quantum - written with the pause quantum value for pause frame transmission of priority 2.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QUANTUM_P3</name>
              <description>Transmit pause quantum - written with the pause quantum value for pause frame transmission of priority 3.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_PAUSE_QUANTUM2</name>
          <description>Transmit Pause Quantum Register 2</description>
          <addressOffset>0x1264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUANTUM_P4</name>
              <description>Transmit pause quantum - written with the pause quantum value for pause frame transmission of priority 4.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QUANTUM_P5</name>
              <description>Transmit pause quantum - written with the pause quantum value for pause frame transmission of priority 5.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_PAUSE_QUANTUM3</name>
          <description>Transmit Pause Quantum Register 3</description>
          <addressOffset>0x1268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUANTUM_P6</name>
              <description>Transmit pause quantum - written with the pause quantum value for pause frame transmission of priority 6.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QUANTUM_P7</name>
              <description>Transmit pause quantum - written with the pause quantum value for pause frame transmission of priority 7.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_LPI</name>
          <description>Received LPI transitions</description>
          <addressOffset>0x1270</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_LPI</name>
              <description>Count of RX LPI transitions. A count of the number of times there is a transition from receiving normal idle to receiving low power idle. Cleared on read.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_LPI_TIME</name>
          <description>Received LPI time</description>
          <addressOffset>0x1274</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPI_TIME</name>
              <description>Time in LPI. This register increments once every 16 pclk cycles when the LPI indication bit 20 is set in the receive configuration register. Cleared on read.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_LPI</name>
          <description>Transmit LPI transitions</description>
          <addressOffset>0x1278</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_LPI</name>
              <description>Count of LPI transmissions. A count of the number of times the enable LPI transmission bit 20 goes from low to high in the transmit control register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_LPI_TIME</name>
          <description>Transmit LPI time</description>
          <addressOffset>0x127C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPI_TIME</name>
              <description>Time in LPI. This register increments once every 16 pclk cycles when the enable LPI transmission bit 20 is set in the transmit control register. Cleared on read.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG1</name>
          <description>The GEM_GXL(3PIP) has many parameterisation options to configure the IP during compilation stage. This is achieved using Verilog define compiler directives in an include file called mxeth_defs.v.</description>
          <addressOffset>0x1280</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x508503</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NO_PCS</name>
              <description>Takes the value of the `gem_no_pcs DEFINE</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXCLUDE_QBV</name>
              <description>Takes the value of the `gem_exclude_qbv DEFINE</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_2</name>
              <description>N/A</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT_LOOPBACK</name>
              <description>Takes the value of the `gem_int_loopback DEFINE</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_5</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXT_FIFO_INTERFACE</name>
              <description>Takes the value of the `gem_ext_fifo_interface DEFINE</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_8</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USER_IO</name>
              <description>Takes the value of the `gem_user_io DEFINE</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USER_OUT_WIDTH</name>
              <description>Takes the value of the `gem_user_out_width DEFINE if `gem_user_io is set.
If 'gem_user_io is not set, the value is 0x01</description>
              <bitRange>[14:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USER_IN_WIDTH</name>
              <description>Takes the value of the `gem_user_in_width DEFINE `gem_user_io.
If 'gem_user_io is not set, the value is 0x01</description>
              <bitRange>[19:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_20</name>
              <description>N/A</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NO_STATS</name>
              <description>Takes the value of the `gem_no_stats DEFINE</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NO_SNAPSHOT</name>
              <description>Takes the value of the `gem_no_snapshot DEFINE</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ_READ_CLEAR</name>
              <description>Takes the value of the `gem_irq_read_clear DEFINE</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXCLUDE_CBS</name>
              <description>Takes the value of the `gem_exclude_cbs DEFINE</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_BUS_WIDTH</name>
              <description>Takes the value of bits 7:5 of the `gem_dma_bus_width DEFINE. So if the define is set to decimal 64 this will return binary 010.</description>
              <bitRange>[27:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_CACHE_VALUE</name>
              <description>Takes the value of the `gem_axi_cache_value DEFINE</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG2</name>
          <description>Design Configuration Register 2</description>
          <addressOffset>0x1284</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xA6310600</resetValue>
          <resetMask>0xFFFF3FFF</resetMask>
          <fields>
            <field>
              <name>JUMBO_MAX_LENGTH</name>
              <description>Takes the value of the `gem_jumbo_max_length DEFINE</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HPROT_VALUE</name>
              <description>Takes the value of the `gem_hprot_value DEFINE</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PKT_BUFFER</name>
              <description>Takes the value of the `gem_rx_pkt_buffer DEFINE</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PKT_BUFFER</name>
              <description>Takes the value of the `gem_tx_pkt_buffer DEFINE</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PBUF_ADDR</name>
              <description>Takes the value of the `gem_rx_pbuf_addr DEFINE</description>
              <bitRange>[25:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_ADDR</name>
              <description>Takes the value of the `gem_tx_pbuf_addr DEFINE</description>
              <bitRange>[29:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI</name>
              <description>Takes the value of the `gem_axi DEFINE</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPRAM</name>
              <description>Takes the value of the `gem_spram DEFINE</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG3</name>
          <description>Design Configuration Register 3</description>
          <addressOffset>0x1288</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4000000</resetValue>
          <resetMask>0x3F000000</resetMask>
          <fields>
            <field>
              <name>NUM_SPEC_ADD_FILTERS</name>
              <description>Takes the value of the `num_spec_add_filters DEFINE</description>
              <bitRange>[29:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG4</name>
          <description>Design Configuration Register 4</description>
          <addressOffset>0x128C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSVD_31_0</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG5</name>
          <description>Design Configuration Register 5</description>
          <addressOffset>0x1290</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x518E3744</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_FIFO_CNT_WIDTH</name>
              <description>Takes the value of the `gem_rx_fifo_cnt_width DEFINE</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FIFO_CNT_WIDTH</name>
              <description>Takes the value of the `gem_tx_fifo_cnt_width DEFINE</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TSU</name>
              <description>Takes the value of the `gem_tsu DEFINE</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_IDENT</name>
              <description>Takes the value of the `gem_phy_ident DEFINE</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_BUS_WIDTH_DEF</name>
              <description>Takes the value of the `gem_dma_bus_width_def DEFINE</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MDC_CLOCK_DIV</name>
              <description>Takes the value of the `gem_mdc_clock_div DEFINE</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENDIAN_SWAP_DEF</name>
              <description>Takes the value of the `gem_endian_swap_def DEFINE</description>
              <bitRange>[16:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PBUF_SIZE_DEF</name>
              <description>Takes the value of the `gem_rx_pbuf_size_def DEFINE</description>
              <bitRange>[18:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_SIZE_DEF</name>
              <description>Takes the value of the `gem_tx_pbuf_size_def DEFINE</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_BUFFER_LENGTH_DEF</name>
              <description>Takes the value of the `gem_rx_buffer_length_def DEFINE</description>
              <bitRange>[27:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TSU_CLK</name>
              <description>Takes the value of the `gem_tsu_clk DEFINE</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_PROT_VALUE</name>
              <description>Takes the value of the `gem_axi_prot_value DEFINE</description>
              <bitRange>[31:29]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG6</name>
          <description>Design Configuration Register 6</description>
          <addressOffset>0x1294</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3020006</resetValue>
          <resetMask>0xFFFFFFE</resetMask>
          <fields>
            <field>
              <name>DMA_PRIORITY_QUEUE1</name>
              <description>Takes the value of the `dma_priority_queue1 DEFINE</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE2</name>
              <description>Takes the value of the `dma_priority_queue2 DEFINE</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE3</name>
              <description>Takes the value of the `dma_priority_queue3 DEFINE</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE4</name>
              <description>Takes the value of the `dma_priority_queue4 DEFINE</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE5</name>
              <description>Takes the value of the `dma_priority_queue5 DEFINE</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE6</name>
              <description>Takes the value of the `dma_priority_queue6 DEFINE</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE7</name>
              <description>Takes the value of the `dma_priority_queue7 DEFINE</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE8</name>
              <description>Takes the value of the `dma_priority_queue8 DEFINE</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE9</name>
              <description>Takes the value of the `dma_priority_queue9 DEFINE</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE10</name>
              <description>Takes the value of the `dma_priority_queue10 DEFINE</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE11</name>
              <description>Takes the value of the `dma_priority_queue11 DEFINE</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE12</name>
              <description>Takes the value of the `dma_priority_queue12 DEFINE</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE13</name>
              <description>Takes the value of the `dma_priority_queue13 DEFINE</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE14</name>
              <description>Takes the value of the `dma_priority_queue14 DEFINE</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_PRIORITY_QUEUE15</name>
              <description>Takes the value of the `dma_priority_queue15 DEFINE</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_QUEUE_SEGMENT_SIZE</name>
              <description>Takes the value of the `gem_tx_pbuf_queue_segment_size DEFINE</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXT_TSU_TIMER</name>
              <description>Takes the value of the `gem_ext_tsu_timer DEFINE</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_ADD_FIFO_IF</name>
              <description>Takes the value of the `gem_tx_add_fifo_if DEFINE</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_IF_SOFT_SELECT</name>
              <description>Takes the value of the `gem_host_if_soft_select DEFINE</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_ADDR_WIDTH_IS_64B</name>
              <description>Takes the value of the `gem_dma_addr_width_is_64b DEFINE</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PFC_MULTI_QUANTUM</name>
              <description>Takes the value of the `gem_pfc_multi_quantum DEFINE</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PBUF_CUTTHRU</name>
              <description>Takes the value of the `gem_pbuf_cutthru DEFINE</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PBUF_RSC</name>
              <description>Takes the value of the `gem_pbuf_rsc DEFINE</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PBUF_LSO</name>
              <description>Takes the value of the `gem_pbuf_lso DEFINE</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG7</name>
          <description>Design Configuration Register 7</description>
          <addressOffset>0x1298</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>X_PBUF_NUM_SEGMENTS_Q0</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q0 DEFINE</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>X_PBUF_NUM_SEGMENTS_Q1</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q1 DEFINE</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>X_PBUF_NUM_SEGMENTS_Q2</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q2 DEFINE</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>X_PBUF_NUM_SEGMENTS_Q3</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q3 DEFINE</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>X_PBUF_NUM_SEGMENTS_Q4</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q4 DEFINE</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>X_PBUF_NUM_SEGMENTS_Q5</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q5 DEFINE</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>X_PBUF_NUM_SEGMENTS_Q6</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q6 DEFINE</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>X_PBUF_NUM_SEGMENTS_Q7</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q7 DEFINE</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG8</name>
          <description>Design Configuration Register 8</description>
          <addressOffset>0x129C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x10100820</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_SCR2_COMPARE_REGS</name>
              <description>Takes the value of the `num_scr2_compare_regs DEFINE</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_SCR2_ETHTYPE_REGS</name>
              <description>Takes the value of the `num_scr2_ethtype_regs DEFINE</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_TYPE2_SCREENERS</name>
              <description>Takes the value of the `num_type2_screeners DEFINE</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_TYPE1_SCREENERS</name>
              <description>Takes the value of the `num_type1_screeners DEFINE</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG9</name>
          <description>Design Configuration Register 9</description>
          <addressOffset>0x12A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PBUF_NUM_SEGMENTS_Q8</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q8 DEFINE</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_NUM_SEGMENTS_Q9</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q9 DEFINE</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_NUM_SEGMENTS_Q10</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q10 DEFINE</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_NUM_SEGMENTS_Q11</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q11 DEFINE</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_NUM_SEGMENTS_Q12</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q12 DEFINE</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_NUM_SEGMENTS_Q13</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q13 DEFINE</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_NUM_SEGMENTS_Q14</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q14 DEFINE</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_NUM_SEGMENTS_Q15</name>
              <description>Takes the value of the `gem_tx_pbuf_num_segments_q15 DEFINE</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DESIGNCFG_DEBUG10</name>
          <description>Design Configuration Register 10</description>
          <addressOffset>0x12A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4411111</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AXI_RX_DESCR_WR_BUFF_BITS</name>
              <description>Takes the value of the `gem_axi_rx_descr_wr_buff_bits DEFINE</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_TX_DESCR_WR_BUFF_BITS</name>
              <description>Takes the value of the `gem_axi_tx_descr_wr_buff_bits DEFINE</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_RX_DESCR_RD_BUFF_BITS</name>
              <description>Takes the value of the `gem_axi_rx_descr_rd_buff_bits DEFINE</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_TX_DESCR_RD_BUFF_BITS</name>
              <description>Takes the value of the `gem_axi_tx_descr_rd_buff_bits DEFINE</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_ACCESS_PIPELINE_BITS</name>
              <description>Takes the value of the `gem_axi_access_pipeline_bits DEFINE</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PBUF_DATA</name>
              <description>Takes the value of the `gem_rx_pbuf_data DEFINE. 1 - The RX DPRAM has a datawidth of 32bits. 2 - The RX DPRAM has a datawidth of 64bits. 4 - RX The DPRAM has a datawidth of 128bits</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PBUF_DATA</name>
              <description>Takes the value of the `gem_tx_pbuf_data DEFINE. 1 - The TX DPRAM has a datawidth of 32bits. 2 - The TX DPRAM has a datawidth of 64bits. 4 - The TX DPRAM has a datawidth of 128bits</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMAC_BUS_WIDTH</name>
              <description>Takes the value of the `gem_emac_bus_width DEFINE. 1 - The MAC has a datawidth of 32bits. 2 - The MAC has a datawidth of 64bits. 4 - The MAC has a datawidth of 128bits</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD5_BOTTOM</name>
          <description>Specific address registers 5 ~ 36 doesn't present. Access to the register returns AHB error.</description>
          <addressOffset>0x1300</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSVD_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD5_TOP</name>
          <description>Specific address registers 5 ~ 36 doesn't present. Access to the register returns AHB error.</description>
          <addressOffset>0x1304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSVD_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD36_BOTTOM</name>
          <description>Not presents.</description>
          <addressOffset>0x13F8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSVD_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPEC_ADD36_TOP</name>
          <description>Not presents.</description>
          <addressOffset>0x13FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSVD_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q1_STATUS</name>
          <description>Priority queue Interrupt Status Register</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8E6</resetMask>
          <fields>
            <field>
              <name>RECEIVE_COMPLETE</name>
              <description>Receive complete</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_USED_BIT_READ</name>
              <description>RX used bit read</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION</name>
              <description>Retry limit exceeded or late collision</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AMBA_ERROR</name>
              <description>Transmit frame corruption due to AMBA (AXI/AHB) error set if an error occurs whilst midway through reading transmit frame from the external memory, including HRESP (AHB), RRESP and BRESP errors (AXI) and buffers exhausted mid frame</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANSMIT_COMPLETE</name>
              <description>Transmit complete</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_NOT_OK</name>
              <description>bresp not OK</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q2_STATUS</name>
          <description>Priority queue Interrupt Status Register</description>
          <addressOffset>0x1404</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8E6</resetMask>
          <fields>
            <field>
              <name>RECEIVE_COMPLETE</name>
              <description>Receive complete</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_USED_BIT_READ</name>
              <description>RX used bit read</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION</name>
              <description>Retry limit exceeded or late collision</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AMBA_ERROR</name>
              <description>Transmit frame corruption due to AMBA (AXI/AHB) error set if an error occurs whilst midway through reading transmit frame from the external memory, including HRESP(AHB), RRESP and BRESP errors (AXI) and buffers exhausted mid frame</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANSMIT_COMPLETE</name>
              <description>Transmit complete</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_NOT_OK</name>
              <description>bresp not OK</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q3_STATUS</name>
          <description>int_q3_status to int_q15_status doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x1408</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q15_STATUS</name>
          <description>Not presents.</description>
          <addressOffset>0x1438</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRANSMIT_Q1_PTR</name>
          <description>This register holds the start address of the transmit buffer queue (transmit buffers descriptor list). The transmit buffer queue base address register must be initialized before transmit is started through bit 9 of the network control register. Once transmission has started, any write to the transmit buffer queue base address register is illegal and therefore ignored. Note that due to clock boundary synchronization, it takes a maximum of four pclk cycles from the writing of the transmit start bit before the transmitter is active. Writing to the transmit buffer queue base address register during this time may produce unpredictable results. Reading this register returns the location of the descriptor currently being accessed. Because the DMA can store data for multiple frames at once, this may not necessarily be pointing to the current frame being transmitted. In terms of AMBA AXI operation, the transmit descriptors are written to memory using a single 32bit AHB access. When the datapath is configured as 64bit , the transmit descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from memory using a single AXI access.</description>
          <addressOffset>0x1440</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFD</resetMask>
          <fields>
            <field>
              <name>DMA_TX_DIS_Q</name>
              <description>Disable queue if set to 1. This can be used to reduce the number of active queues and should only be changed while transmit is not enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_Q_PTR</name>
              <description>This register holds the start address of the transmit buffer queue (transmit buffers
descriptor list). The transmit buffer queue base address register must be initialized before
transmit is started through bit 9 of the network control register. Once transmission has
started, any write to the transmit buffer queue base address register is illegal and
therefore ignored. Note that due to clock boundary synchronization, it takes a maximum
of four pclk cycles from the writing of the transmit start bit before the transmitter is active.
Writing to the transmit buffer queue base address register during this time may produce
unpredictable results. Reading this register returns the location of the descriptor currently
being accessed. Because the DMA can store data for multiple frames at once, this may
not necessarily be pointing to the current frame being transmitted. In terms of AMBA
AHB/AXI operation, the transmit descriptors are written to memory using a single 32bit
AHB access. When the datapath is configured as 64bit or 128bit, the transmit descriptors
should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from
memory using a single AHB/AXI access. For 32bit datapaths, the descriptors should be
aligned at 32-bit boundaries and the descriptors are read from memory using two
individual 32-bit non sequential accesses.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRANSMIT_Q2_PTR</name>
          <description>This register holds the start address of the transmit buffer queue (transmit buffers descriptor list). The transmit buffer queue base address register must be initialized before transmit is started through bit 9 of the network control register. Once transmission has started, any write to the transmit buffer queue base address register is illegal and therefore ignored. Note that due to clock boundary synchronization, it takes a maximum of four pclk cycles from the writing of the transmit start bit before the transmitter is active. Writing to the transmit buffer queue base address register during this time may produce unpredictable results. Reading this register returns the location of the descriptor currently being accessed. Because the DMA can store data for multiple frames at once, this may not necessarily be pointing to the current frame being transmitted. In terms of AMBA AXI operation, the transmit descriptors are written to memory using a single 32bit AHB access. When the datapath is configured as 64bit , the transmit descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from memory using a single AXI access.</description>
          <addressOffset>0x1444</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFD</resetMask>
          <fields>
            <field>
              <name>DMA_TX_DIS_Q</name>
              <description>Disable queue if set to 1. This can be used to reduce the number of active queues and should only be changed while transmit is not enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_Q_PTR</name>
              <description>This register holds the start address of the transmit buffer queue (transmit buffers
descriptor list). The transmit buffer queue base address register must be initialized before
transmit is started through bit 9 of the network control register. Once transmission has
started, any write to the transmit buffer queue base address register is illegal and
therefore ignored. Note that due to clock boundary synchronization, it takes a maximum
of four pclk cycles from the writing of the transmit start bit before the transmitter is active.
Writing to the transmit buffer queue base address register during this time may produce
unpredictable results. Reading this register returns the location of the descriptor currently
being accessed. Because the DMA can store data for multiple frames at once, this may
not necessarily be pointing to the current frame being transmitted. In terms of AMBA
AHB/AXI operation, the transmit descriptors are written to memory using a single 32bit
AHB access. When the datapath is configured as 64bit or 128bit, the transmit descriptors
should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from
memory using a single AHB/AXI access. For 32bit datapaths, the descriptors should be
aligned at 32-bit boundaries and the descriptors are read from memory using two
individual 32-bit non sequential accesses</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRANSMIT_Q3_PTR</name>
          <description>transmit_q3_ptr to transmit_q15_ptr doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x1448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Disable queue if set to 1. This can be used to reduce the number of active queues and should only be changed while transmit is not enabled.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRANSMIT_Q15_PTR</name>
          <description>Not presents.</description>
          <addressOffset>0x1478</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RECEIVE_Q1_PTR</name>
          <description>This register holds the start address of the transmit buffer queue (transmit buffers descriptor list). The transmit buffer queue base address register must be initialized before transmit is started through bit 9 of the network control register. Once transmission has started, any write to the transmit buffer queue base address register is illegal and therefore ignored. Note that due to clock boundary synchronization, it takes a maximum of four pclk cycles from the writing of the transmit start bit before the transmitter is active. Writing to the transmit buffer queue base address register during this time may produce unpredictable results. Reading this register returns the location of the descriptor currently being accessed. Because the DMA can store data for multiple frames at once, this may not necessarily be pointing to the current frame being transmitted. In terms of AMBA AXI operation, the transmit descriptors are written to memory using a single 32bit AHB access. When the datapath is configured as 64bit , the transmit descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from memory using a single AXI access.</description>
          <addressOffset>0x1480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFD</resetMask>
          <fields>
            <field>
              <name>DMA_RX_DIS_Q</name>
              <description>Disable queue if set to 1. This can be used to reduce the number of active queues and should only be changed while receive is not enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_Q_PTR</name>
              <description>Receive buffer queue base address - written with the address of the start of the receive queue.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RECEIVE_Q2_PTR</name>
          <description>This register holds the start address of the transmit buffer queue (transmit buffers descriptor list). The transmit buffer queue base address register must be initialized before transmit is started through bit 9 of the network control register. Once transmission has started, any write to the transmit buffer queue base address register is illegal and therefore ignored. Note that due to clock boundary synchronization, it takes a maximum of four pclk cycles from the writing of the transmit start bit before the transmitter is active. Writing to the transmit buffer queue base address register during this time may produce unpredictable results. Reading this register returns the location of the descriptor currently being accessed. Because the DMA can store data for multiple frames at once, this may not necessarily be pointing to the current frame being transmitted. In terms of AMBA AXI operation, the transmit descriptors are written to memory using a single 32bit AHB access. When the datapath is configured as 64bit , the transmit descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from memory using a single AXI access.</description>
          <addressOffset>0x1484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFD</resetMask>
          <fields>
            <field>
              <name>DMA_RX_DIS_Q</name>
              <description>Disable queue if set to 1. This can be used to reduce the number of active queues and should only be changed while receive is not enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_Q_PTR</name>
              <description>Receive buffer queue base address - written with the address of the start of the receive queue.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RECEIVE_Q3_PTR</name>
          <description>Not presents.  Start address register doesn't present for queue3 ~ queue7.</description>
          <addressOffset>0x1488</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RECEIVE_Q7_PTR</name>
          <description>Not presents.</description>
          <addressOffset>0x1498</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RXBUF_SIZE_Q1</name>
          <description>Receive Buffer queue 1 Size</description>
          <addressOffset>0x14A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x18</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DMA_RX_Q_BUF_SIZE</name>
              <description>DMA receive buffer size in system memory. The value defined by these bits determines the size of buffer to use in main system memory when writing received data. The value is defined in multiples of 64 bytes.
 0x01 corresponds to buffers of 64 bytes.
 0x02 corresponds to 128 bytes etc. 
For example:
 0x02: 128 byte
 0x18: 1536 byte (1*max length frame/buffer)
 0xA0: 10240 byte (1*10K jumbo frame/buffer) 
Note that this value should never be written as zero. Note. The reset value of this field is equal to the gem_rx_buffer_length_def define, which is user configurable.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RXBUF_SIZE_Q2</name>
          <description>Receive Buffer queue 2 Size</description>
          <addressOffset>0x14A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x18</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DMA_RX_Q_BUF_SIZE</name>
              <description>DMA receive buffer size in system memory. The value defined by these bits determines the size of buffer to use in main system memory when writing received data. The value is defined in multiples of 64 bytes.
 0x01 corresponds to buffers of 64 bytes.
 0x02 corresponds to 128 bytes etc. 
For example:
 0x02: 128 byte
 0x18: 1536 byte (1*max length frame/buffer)
 0xA0: 10240 byte (1*10K jumbo frame/buffer) 
Note that this value should never be written as zero. Note. The reset value of this field is equal to the gem_rx_buffer_length_def define, which is user configurable.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RXBUF_SIZE_Q3</name>
          <description>dma_rxbuf_size_q3 to dma_rxbuf_size_q7 doesn't present.</description>
          <addressOffset>0x14A8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>DMA receive buffer size in system memory. The value defined by these bits determines the size of buffer to use in main system memory when writing received data. The value is defined in multiples of 64 bytes.
 0x01 corresponds to buffers of 64 bytes.
 0x02 corresponds to 128 bytes etc. 
For example:
 0x02: 128 byte
 0x18: 1536 byte (1*max length frame/buffer)
 0xA0: 10240 byte (1*10K jumbo frame/buffer) 
Note that this value should never be written as zero. Note. The reset value of this field is equal to the gem_rx_buffer_length_def define, which is user configurable.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RXBUF_SIZE_Q7</name>
          <description>Not presents.</description>
          <addressOffset>0x14B8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CBS_CONTROL</name>
          <description>The IdleSlope value is defined as the rate of change of credit when a packet is waiting to be sent. This must not exceed the portTransmitRate which is dependent on the speed of operation, eg, portTranmsitRate. 1Gb/s = 32'h07735940 (125 Mbytes/s), 100Mb/sec = 32'h017D7840 (25 Mnibbles/s), 10Mb/sec = 32'h002625A0 (2.5 Mnibbles/s). If 50 percent of bandwidth was to be allocated to a particular queue in 1Gb/sec mode then the IdleSlope value for that queue would be calculated as 32'h07735940/2. Note that Credit-Based Shaping should be disabled prior to updating the IdleSlope values. As another example, for a 1722 audio packet with a payload of 6 samples per channel, the packet size would be 7 (preamble) + 1 (SFD) + 50 (packet header) + 6x4x2(payload) + 4 (CRC) = 110 bytes. For a rate of 8000 packets per second, the desired rate would 110 x 8000 bytes per second, so the programmed idleSlope value would be 880000 for a 1Gb/s connection, or 1760000 for a 100Mb/s or 10Mbs connection. See Figure 6.3 in the IEEE 1722 standard. In practice, the actual transmission rate will be vary slightly from that calculated. In this case, the idleSlope value should be recalibrated based on the variance between the measured and expected rate, and in this case very accurate transmission rates can be achieved.</description>
          <addressOffset>0x14BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CBS_ENABLE_QUEUE_A</name>
              <description>Enable Credit-Based Shaping on the highest priority queue (queue A). Write 1 to enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBS_ENABLE_QUEUE_B</name>
              <description>Enable Credit-Based shaping on the 2nd highest priority queue (queue B). Write 1 to enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CBS_IDLESLOPE_Q_A</name>
          <description>queue A is the highest priority queue. This would be queue 8 in an 8 queue configuration.</description>
          <addressOffset>0x14C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLESLOPE_A</name>
              <description>IdleSlope value for queue A in bytes/sec for gigabit operation and nibbles/sec for 10/100 operation</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CBS_IDLESLOPE_Q_B</name>
          <description>queue B is the 2nd highest priority queue. This would be queue 7 in an 8 queue configuration.</description>
          <addressOffset>0x14C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLESLOPE_B</name>
              <description>IdleSlope value for queue B in bytes/sec for gigabit operation and nibbles/sec for 10/100 operation</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPPER_TX_Q_BASE_ADDR</name>
          <description>Upper 32 bits of transmit buffer descriptor queue base address.</description>
          <addressOffset>0x14C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UPPER_TX_Q_BASE_ADDR</name>
              <description>Upper 32 bits of transmit buffer descriptor queue base address. Used when 64 bit addressing is enabled. (In releases earlier to 1p06f2 this register also affected the receive descriptor queue.)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_BD_CONTROL</name>
          <description>TX BD control register</description>
          <addressOffset>0x14CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30</resetMask>
          <fields>
            <field>
              <name>TX_BD_TS_MODE</name>
              <description>TX Descriptor Timestamp Insertion mode, 00: TS insertion disable, 01: TS inserted for PTP Event Frames only, 10: TS inserted for All PTP Frames only, 11: TS insertion for All Frames</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_BD_CONTROL</name>
          <description>RX BD control register</description>
          <addressOffset>0x14D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30</resetMask>
          <fields>
            <field>
              <name>RX_BD_TS_MODE</name>
              <description>RX Descriptor Timestamp Insertion mode, 00: TS insertion disable, 01: TS inserted for PTP Event Frames only, 10: TS inserted for All PTP Frames only, 11: TS insertion for All Frames</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPPER_RX_Q_BASE_ADDR</name>
          <description>Upper 32 bits of receive buffer descriptor queue base address.</description>
          <addressOffset>0x14D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UPPER_RX_Q_BASE_ADDR</name>
              <description>Upper 32 bits of receive buffer descriptor queue base address. Used when 64 bit addressing is enabled.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HIDDEN_REG0</name>
          <description>Hidden registers defined in edma_defs.v '`define gem_cbs_port_tx_rate_10m   12'h4e0   // 10M Port TX Rate *** HIDDEN Register ***'. Default value of cbs related hidden registers (0x14E0~0x14E8) are depicted in cbs_control register.</description>
          <addressOffset>0x14E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2625A0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIDDEN0_FIELD</name>
              <description>default value is defined per description of register cbs_control.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HIDDEN_REG1</name>
          <description>Hidden registers defined in edma_defs.v '`define gem_cbs_port_tx_rate_100m  12'h4e4   // 100M Port TX Rate *** HIDDEN Register ***'</description>
          <addressOffset>0x14E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x17D7840</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIDDEN1_FIELD</name>
              <description>default value is defined per description of register cbs_control.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HIDDEN_REG2</name>
          <description>Hidden registers defined in edma_defs.v '`define gem_cbs_port_tx_rate_1g    12'h4e8       // 1G Port TX Rate *** HIDDEN Register ***'</description>
          <addressOffset>0x14E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7735940</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIDDEN2_FIELD</name>
              <description>default value is defined per description of register cbs_control.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HIDDEN_REG3</name>
          <description>Hidden registers defined in edma_defs.v '`define gem_wd_counter 12'h4ec    // *** HIDDEN Register ***'.</description>
          <addressOffset>0x14EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>HIDDEN3_FIELD</name>
              <description>default value is defined per description of register cbs_control.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HIDDEN_REG4</name>
          <description>Hidden registers defined in edma_defs.v '`define gem_axi_tx_full_threshold0 12'h4f8   // AXI full threshold setting *** HIDDEN Register ***'. Note. When using AXI mode with a single port ram ( gem_spram == 1) mode and a 32b dma bus width ( gem_dma_bus_width == 32 or bits 22 to 21 of the network_config register are set to 0) the AXI hidden registers (0x14F8 and 0x14FC) need to be updated (these registers are used for fine tuning AXI dma bursts and normally should not be touched).</description>
          <addressOffset>0x14F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x60008</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>HIDDEN4_FIELD_L</name>
              <description>The valid bits is defined by `gem_tx_pbuf_addr.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIDDEN4_FIELD_H</name>
              <description>The valid bits is defined by `gem_tx_pbuf_addr.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HIDDEN_REG5</name>
          <description>Hidden registers defined in edma_defs.v '`define gem_axi_tx_full_threshold1 12'h4fc   // AXI full threshold setting *** HIDDEN Register ***'.</description>
          <addressOffset>0x14FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>HIDDEN5_FIELD_L</name>
              <description>The valid bits is defined by `gem_tx_pbuf_addr.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIDDEN5_FIELD_H</name>
              <description>The valid bits is defined by `gem_tx_pbuf_addr.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_0</name>
          <description>Screening type 1 registers are used to allocate up to 16 priority queues to received frames based on certain IP or UDP fields of incoming frames. Firstly, when DS/TC match enable is set (bit 28), the DS (Differentiated Services) field of the received IPv4 header or TCfield (traffic class) of IPv6 headers are matched against bits 11 to 4. Secondly, when UDP port match enable is set (bit 29), the UDP Destination Port of the received UDP frame is matched against bits 27 to 12. Both UDP and DS/TC matching can be enabled simultaneously or individually. If a match is successful, then the queue value programmed in bits 2 to 0 is allocated to the frame. The required number of Type 1 screening registers is configured in the gem defines file. Up to 16 type 1 screening registers have been allocated APB address space between 0x500 and 0x53C.</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_1</name>
          <description>screening type 1 register 1, same as screening_type_1_register_0</description>
          <addressOffset>0x1504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_2</name>
          <description>screening type 1 register 2, same as screening_type_1_register_0</description>
          <addressOffset>0x1508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_3</name>
          <description>screening type 1 register 3, same as screening_type_1_register_0</description>
          <addressOffset>0x150C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_4</name>
          <description>screening type 1 register 4, same as screening_type_1_register_0</description>
          <addressOffset>0x1510</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_5</name>
          <description>screening type 1 register 5, same as screening_type_1_register_0</description>
          <addressOffset>0x1514</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_6</name>
          <description>screening type 1 register 6, same as screening_type_1_register_0</description>
          <addressOffset>0x1518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_7</name>
          <description>screening type 1 register 7, same as screening_type_1_register_0</description>
          <addressOffset>0x151C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_8</name>
          <description>screening type 1 register 8, same as screening_type_1_register_0</description>
          <addressOffset>0x1520</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_9</name>
          <description>screening type 1 register 9, same as screening_type_1_register_0</description>
          <addressOffset>0x1524</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_10</name>
          <description>screening type 1 register 10, same as screening_type_1_register_0</description>
          <addressOffset>0x1528</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_11</name>
          <description>screening type 1 register 11, same as screening_type_1_register_0</description>
          <addressOffset>0x152C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_12</name>
          <description>screening type 1 register 12, same as screening_type_1_register_0</description>
          <addressOffset>0x1530</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_13</name>
          <description>screening type 1 register 13, same as screening_type_1_register_0</description>
          <addressOffset>0x1534</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_14</name>
          <description>screening type 1 register 14, same as screening_type_1_register_0</description>
          <addressOffset>0x1538</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_1_REGISTER_15</name>
          <description>screening type 1 register 15, same as screening_type_1_register_0</description>
          <addressOffset>0x153C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>Queue Number (0 to 15)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_MATCH</name>
              <description>DS/TC Match</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH</name>
              <description>UDP Port Match</description>
              <bitRange>[27:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTC_ENABLE</name>
              <description>DS/TC Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDP_PORT_MATCH_ENABLE</name>
              <description>UDP port match enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_0</name>
          <description>Screener Type 2 match registers operate independently of screener type 1 registers and offer additional match capabilities, extending the capabilities into vendor specific protocols.</description>
          <addressOffset>0x1540</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_1</name>
          <description>screening type 2 register 1, same as screening_type_2_register_0</description>
          <addressOffset>0x1544</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_2</name>
          <description>screening type 2 register 2, same as screening_type_2_register_0</description>
          <addressOffset>0x1548</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_3</name>
          <description>screening type 2 register 3, same as screening_type_2_register_0</description>
          <addressOffset>0x154C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_4</name>
          <description>screening type 2 register 4, same as screening_type_2_register_0</description>
          <addressOffset>0x1550</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_5</name>
          <description>screening type 2 register 5, same as screening_type_2_register_0</description>
          <addressOffset>0x1554</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_6</name>
          <description>screening type 2 register 6, same as screening_type_2_register_0</description>
          <addressOffset>0x1558</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_7</name>
          <description>screening type 2 register 7, same as screening_type_2_register_0</description>
          <addressOffset>0x155C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_8</name>
          <description>screening type 2 register 8, same as screening_type_2_register_0</description>
          <addressOffset>0x1560</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_9</name>
          <description>screening type 2 register 9, same as screening_type_2_register_0</description>
          <addressOffset>0x1564</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_10</name>
          <description>screening type 2 register 10, same as screening_type_2_register_0</description>
          <addressOffset>0x1568</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_11</name>
          <description>screening type 2 register 11, same as screening_type_2_register_0</description>
          <addressOffset>0x156C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_12</name>
          <description>screening type 2 register 12, same as screening_type_2_register_0</description>
          <addressOffset>0x1570</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_13</name>
          <description>screening type 2 register 13, same as screening_type_2_register_0</description>
          <addressOffset>0x1574</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_14</name>
          <description>screening type 2 register 14, same as screening_type_2_register_0</description>
          <addressOffset>0x1578</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_REGISTER_15</name>
          <description>screening type 2 register 15, same as screening_type_2_register_0</description>
          <addressOffset>0x157C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QUEUE_NUMBER</name>
              <description>'Queue Number (0 to 15)'</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_PRIORITY</name>
              <description>'VLAN Priority'</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_ENABLE</name>
              <description>'VLAN Enable'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INDEX</name>
              <description>'Index to screener type 2 EtherType register'</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHERTYPE_ENABLE</name>
              <description>'EtherType Enable'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A</name>
              <description>'Compare A - Index to screener type 2 Compare register '</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_A_ENABLE</name>
              <description>'Compare A Enable'</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B</name>
              <description>'Compare B - Index to screener type 2 Compare register'</description>
              <bitRange>[23:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_B_ENABLE</name>
              <description>'Compare B Enable'</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C</name>
              <description>'Compare C - Index to screener type 2 Compare register'</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_C_ENABLE</name>
              <description>'Compare C Enable'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_SCHED_CTRL</name>
          <description>This register controls the transmit scheduling algorithm the user can select for each active transmit queue. By default all queues are initialized to fixed priority, with the top indexed queue having overall priority</description>
          <addressOffset>0x1580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SCHED_Q0</name>
              <description>'Queue 0 selection.
 00 : Fixed Priority
 01 : CBS Enabled only valid for top two enabled queues and if CBS capability selected.
 10 : DWRR Enabled
 11 : ETS Enabled'</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SCHED_Q1</name>
              <description>'Queue 1 selection.
 00 : Fixed Priority
 01 : CBS Enabled only valid for top two enabled queues and if CBS capability selected.
 10 : DWRR Enabled
 11 : ETS Enabled'</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SCHED_Q2</name>
              <description>'Queue 2 selection.
 00 : Fixed Priority
 01 : CBS Enabled only valid for top two enabled queues and if CBS capability selected.
 10 : DWRR Enabled
 11 : ETS Enabled</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SCHED_Q3</name>
              <description>Write ignore, read 0</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_31_8</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BW_RATE_LIMIT_Q0TO3</name>
          <description>This register holds the DWRR weighting value or the ETS bandwidth percentage value used by the transmit scheduler for queues 0 to 3.</description>
          <addressOffset>0x1590</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DWRR_ETS_WEIGHT_Q0</name>
              <description>'DWRR Weighting / ETS Bandwidth Allocation for queue 0'</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DWRR_ETS_WEIGHT_Q1</name>
              <description>'DWRR Weighting / ETS Bandwidth Allocation for queue 1'</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DWRR_ETS_WEIGHT_Q2</name>
              <description>'DWRR Weighting / ETS Bandwidth Allocation for queue 2'</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DWRR_ETS_WEIGHT_Q3</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BW_RATE_LIMIT_Q4TO7</name>
          <description>Not presents. MXETH has only 3 queues.  Access to the register returns AHB error.</description>
          <addressOffset>0x1594</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>'DWRR Weighting / ETS Bandwidth Allocation for queue 0'</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BW_RATE_LIMIT_Q8TO11</name>
          <description>Not presents. MXETH has only 3 queues.  Access to the register returns AHB error.</description>
          <addressOffset>0x1598</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BW_RATE_LIMIT_Q12TO15</name>
          <description>Not presents. MXETH has only 3 queues.  Access to the register returns AHB error.</description>
          <addressOffset>0x159C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_Q_SEG_ALLOC_Q0TO7</name>
          <description>This register allows the user to distribute the Transmit SRAM used by the DMA across the priority queues, for queues 0 to 7. The SRAM itself is split into a number of evenly sized segments (this is defined in the verilog configuration defs file - for the configuration used to generate this register description, the total number of segments was set to '16'). Those segments can then be freely distributed across the active queues, in powers of 2. I.e. a value of 0 would mean 1 segment has been allocated to the queue. A value of 1 would mean 2 segments, a value of 2 means 4 segments and so on. The reset values of these registers are defined in the configuration defs file.</description>
          <addressOffset>0x15A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEGMENT_ALLOC_Q0</name>
              <description>Number of segments allocated to q0. This should be entered as a log 2, for example entering a value of 2 would grant 4 segments. A maximum of 32 segments can be granted. The default value is determined by `gem_tx_pbuf_num_segments_q0</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_3_3</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SEGMENT_ALLOC_Q1</name>
              <description>Number of segments allocated to q1. This should be entered as a log 2, for example entering a value of 2 would grant 4 segments. A maximum of 32 segments can be granted</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_7_7</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SEGMENT_ALLOC_Q2</name>
              <description>Number of segments allocated to q2. This should be entered as a log 2, for example entering a value of 2 would grant 4 segments. A maximum of 32 segments can be granted</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_11_11</name>
              <description>Write ignore, read 0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_14_12</name>
              <description>Write ignore, read 0</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_15_15</name>
              <description>Write ignore, read 0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_18_16</name>
              <description>Write ignore, read 0</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_19_19</name>
              <description>Write ignore, read 0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_22_20</name>
              <description>Write ignore, read 0</description>
              <bitRange>[22:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_23</name>
              <description>Write ignore, read 0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_26_24</name>
              <description>Write ignore, read 0</description>
              <bitRange>[26:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_27_27</name>
              <description>Write ignore, read 0</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REMOVED_30_28</name>
              <description>Write ignore, read 0</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSVD_31_31</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_Q_SEG_ALLOC_Q8TO15</name>
          <description>Not presents.  Access to the register returns AHB error.</description>
          <addressOffset>0x15A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RECEIVE_Q8_PTR</name>
          <description>receive_q8_ptr to receive_q15_ptr doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x15C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RECEIVE_Q15_PTR</name>
          <description>Not presents.</description>
          <addressOffset>0x15DC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RXBUF_SIZE_Q8</name>
          <description>dma_rxbuf_size_q8 to dma_rxbuf_size_q15 doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x15E0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RXBUF_SIZE_Q15</name>
          <description>Not presents.</description>
          <addressOffset>0x15FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q1_ENABLE</name>
          <description>At reset all interrupts are disabled. Writing a one to the relevant bit location enables the required interrupt. This register is write only and when read will return zero.</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8E6</resetMask>
          <fields>
            <field>
              <name>ENABLE_RECEIVE_COMPLETE_INTERRUPT</name>
              <description>Enable Receive complete interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RX_USED_BIT_READ_INTERRUPT</name>
              <description>Enable RX used bit read interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_INTERRUPT</name>
              <description>Enable Retry limit exceeded or late collision interrupt</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT_FRAME_CORRUPTION_DUE_TO_AMBA_ERROR_INTERRUPT</name>
              <description>Enable Transmit frame corruption due to AMBA (AXI/AHB) error interrupt</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT_COMPLETE_INTERRUPT</name>
              <description>Enable Transmit complete interrupt</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RESP_NOT_OK_INTERRUPT</name>
              <description>Enable bresp not OK interrupt</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q2_ENABLE</name>
          <description>At reset all interrupts are disabled. Writing a one to the relevant bit location enables the required interrupt. This register is write only and when read will return zero.</description>
          <addressOffset>0x1604</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8E6</resetMask>
          <fields>
            <field>
              <name>ENABLE_RECEIVE_COMPLETE_INTERRUPT</name>
              <description>Enable Receive complete interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RX_USED_BIT_READ_INTERRUPT</name>
              <description>Enable RX used bit read interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_INTERRUPT</name>
              <description>Enable Retry limit exceeded or late collision interrupt</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT_FRAME_CORRUPTION_DUE_TO_AMBA_ERROR_INTERRUPT</name>
              <description>Enable Transmit frame corruption due to AMBA (AXI/AHB) error interrupt</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_TRANSMIT_COMPLETE_INTERRUPT</name>
              <description>Enable Transmit complete interrupt</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENABLE_RESP_NOT_OK_INTERRUPT</name>
              <description>Enable bresp not OK interrupt</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q3_ENABLE</name>
          <description>int_q3_enable to int_q7_enable doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x1608</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q7_ENABLE</name>
          <description>Not presents.</description>
          <addressOffset>0x1618</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q1_DISABLE</name>
          <description>Writing a 1 to the relevant bit location disables that particular interrupt. This register is write only and when read will return zero.</description>
          <addressOffset>0x1620</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8E6</resetMask>
          <fields>
            <field>
              <name>DISABLE_RECEIVE_COMPLETE_INTERRUPT</name>
              <description>Disable Receive complete interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RX_USED_BIT_READ_INTERRUPT</name>
              <description>Disable RX used bit read interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_INTERRUPT</name>
              <description>Disable Retry limit exceeded or late collision interrupt</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TRANSMIT_FRAME_CORRUPTION_DUE_TO_AMBA_ERROR_INTERRUPT</name>
              <description>Disable Transmit frame corruption due to AMBA (AXI/AHB) error interrupt</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TRANSMIT_COMPLETE_INTERRUPT</name>
              <description>Disable Transmit complete interrupt</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RESP_NOT_OK_INTERRUPT</name>
              <description>Disable bresp not OK interrupt</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q2_DISABLE</name>
          <description>Writing a 1 to the relevant bit location disables that particular interrupt. This register is write only and when read will return zero.</description>
          <addressOffset>0x1624</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8E6</resetMask>
          <fields>
            <field>
              <name>DISABLE_RECEIVE_COMPLETE_INTERRUPT</name>
              <description>Disable Receive complete interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RX_USED_BIT_READ_INTERRUPT</name>
              <description>Disable RX used bit read interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_INTERRUPT</name>
              <description>Disable Retry limit exceeded or late collision interrupt</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TRANSMIT_FRAME_CORRUPTION_DUE_TO_AMBA_ERROR_INTERRUPT</name>
              <description>Disable Transmit frame corruption due to AMBA (AXI/AHB) error interrupt</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_TRANSMIT_COMPLETE_INTERRUPT</name>
              <description>Disable Transmit complete interrupt</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DISABLE_RESP_NOT_OK_INTERRUPT</name>
              <description>Disable bresp not OK interrupt</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q3_DISABLE</name>
          <description>int_q3_disable to int_q7_disable doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x1628</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q7_DISABLE</name>
          <description>Not presents.</description>
          <addressOffset>0x1638</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q1_MASK</name>
          <description>The interrupt mask register is a read only register indicating which interrupts are masked. All bits are set at reset and can be reset individually by writing to the interrupt enable register or set individually by writing to the interrupt disable register. Having separate address locations for enable and disable saves the need for performing a read modify write when updating the interrupt mask register. For test purposes there is a write-only function to this register that allows the bits in the interrupt status register to be set or cleared, regardless of the state of the mask register.</description>
          <addressOffset>0x1640</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x8E6</resetValue>
          <resetMask>0x8E6</resetMask>
          <fields>
            <field>
              <name>RECEIVE_COMPLETE_INTERRUPT_MASK</name>
              <description>receive complete interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_USED_INTERRUPT_MASK</name>
              <description>A read of this register returns the value of the RX Used interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_INTERRUPT_MASK</name>
              <description>retry limit exceeded or late collision interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AMBA_ERROR_INTERRUPT_MASK</name>
              <description>A read of this register returns the value of the AMBA (AXI/AHB) error interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANSMIT_COMPLETE_INTERRUPT_MASK</name>
              <description>transmit complete interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_NOT_OK_INTERRUPT_MASK</name>
              <description>bresp not OK interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q2_MASK</name>
          <description>The interrupt mask register is a read only register indicating which interrupts are masked. All bits are set at reset and can be reset individually by writing to the interrupt enable register or set individually by writing to the interrupt disable register. Having separate address locations for enable and disable saves the need for performing a read modify write when updating the interrupt mask register. For test purposes there is a write-only function to this register that allows the bits in the interrupt status register to be set or cleared, regardless of the state of the mask register.</description>
          <addressOffset>0x1644</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x8E6</resetValue>
          <resetMask>0x8E6</resetMask>
          <fields>
            <field>
              <name>RECEIVE_COMPLETE_INTERRUPT_MASK</name>
              <description>receive complete interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_USED_INTERRUPT_MASK</name>
              <description>A read of this register returns the value of the RX Used interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RETRY_LIMIT_EXCEEDED_OR_LATE_COLLISION_INTERRUPT_MASK</name>
              <description>retry limit exceeded or late collision interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AMBA_ERROR_INTERRUPT_MASK</name>
              <description>A read of this register returns the value of the AMBA (AXI/AHB) error interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANSMIT_COMPLETE_INTERRUPT_MASK</name>
              <description>transmit complete interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_NOT_OK_INTERRUPT_MASK</name>
              <description>bresp not OK interrupt mask.
 0: Interrupt is enabled.
 1: Interrupt is disabled. 
A write to this register directly affects the state of the corresponding bit in the interrupt status register, causing an interrupt to be generated if a 1 is written.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q3_MASK</name>
          <description>int_q3_mask to int_q7_mask doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x1648</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q7_MASK</name>
          <description>Not presents.</description>
          <addressOffset>0x1658</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q8_ENABLE</name>
          <description>int_q8_enable to int_q15_enable doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x1660</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q15_ENABLE</name>
          <description>Not presents.</description>
          <addressOffset>0x167C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q8_DISABLE</name>
          <description>int_q8_disable to int_q15_disable doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x1680</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q15_DISABLE</name>
          <description>Not presents.</description>
          <addressOffset>0x169C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q8_MASK</name>
          <description>int_q8_mask to int_q15_mask doesn't present.  Access to the register returns AHB error.</description>
          <addressOffset>0x16A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_Q15_MASK</name>
          <description>Not presents.</description>
          <addressOffset>0x16BC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMOVED_31_0</name>
              <description>Write ignore, read 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_ETHERTYPE_REG_0</name>
          <description>Ethertype Register</description>
          <addressOffset>0x16E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARE_VALUE</name>
              <description>'EtherType compare value'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_16</name>
              <description>N/A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_ETHERTYPE_REG_1</name>
          <description>Ethertype Register</description>
          <addressOffset>0x16E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARE_VALUE</name>
              <description>'EtherType compare value'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_16</name>
              <description>N/A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_ETHERTYPE_REG_2</name>
          <description>Ethertype Register</description>
          <addressOffset>0x16E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARE_VALUE</name>
              <description>'EtherType compare value'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_16</name>
              <description>N/A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_ETHERTYPE_REG_3</name>
          <description>Ethertype Register</description>
          <addressOffset>0x16EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARE_VALUE</name>
              <description>'EtherType compare value'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_16</name>
              <description>N/A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_ETHERTYPE_REG_4</name>
          <description>Ethertype Register</description>
          <addressOffset>0x16F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARE_VALUE</name>
              <description>'EtherType compare value'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_16</name>
              <description>N/A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_ETHERTYPE_REG_5</name>
          <description>Ethertype Register</description>
          <addressOffset>0x16F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARE_VALUE</name>
              <description>'EtherType compare value'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_16</name>
              <description>N/A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_ETHERTYPE_REG_6</name>
          <description>Ethertype Register</description>
          <addressOffset>0x16F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARE_VALUE</name>
              <description>'EtherType compare value'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_16</name>
              <description>N/A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCREENING_TYPE_2_ETHERTYPE_REG_7</name>
          <description>Ethertype Register</description>
          <addressOffset>0x16FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPARE_VALUE</name>
              <description>'EtherType compare value'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_16</name>
              <description>N/A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_0_WORD_0</name>
          <description>'Compare A, B and C fields of the screener type 2 match register are pointers to a pool of up to 32 compare registers. If enabled the compare is true if the data at the OFFSET into the frame, ANDed with the MASK Value if the mask is enabled, is equal to the COMPARE Value. Either a 16 bit comparison or a 32 bit comparison is done. This selection is made via the associated compare word1 register bit 9. If a 16 bit comparison is selected, then a 16 bit mask is also available to the user to select which bits should be compared. If the 32 bit compare option is selected, then no mask is available. The byte at the OFFSET number of bytes from the index start is compared thru bits 7 to 0 of the configured VALUE. The byte at the OFFSET number of bytes + 1 from the index start is compared thru bits 15 to 8 of the configured VALUE and so on. The OFFSET can be configured to be from 0 to 127 bytes from either the start of the frame, the byte following the therType field (last EtherType in the header if the frame is VLAN tagged), the byte following the IP header (IPv4 or IPv6) or from the byte following the start of the TCP/UDP header. The required number of Type 2 screening registers up to a maximum of 32 is configurable in the gem defines file and have been allocated APB address space between 0x700 and 0x7fc. Note. when using RX Partial Store and Forward mode and priority queues, the frame offset must be less than the Partial Store and Forward watermark. If the offset is higher than the watermark value it's not possible to identify the priority queue before the frame is sent to the AMBA interface, and an incorrect priority queue may be used. '</description>
          <addressOffset>0x1700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_0_WORD_1</name>
          <description>'Type2 Compare Word 1'</description>
          <addressOffset>0x1704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_1_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_1_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x170C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_2_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_2_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1714</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_3_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1718</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_3_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x171C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_4_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1720</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_4_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1724</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_5_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1728</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_5_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x172C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_6_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1730</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_6_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1734</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_7_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1738</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_7_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x173C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_8_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1740</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_8_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1744</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_9_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1748</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_9_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x174C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_10_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1750</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_10_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1754</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_11_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1758</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_11_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x175C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_12_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1760</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_12_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1764</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_13_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1768</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_13_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x176C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_14_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1770</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_14_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1774</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_15_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1778</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_15_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x177C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_16_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1780</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_16_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1784</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_17_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1788</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_17_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x178C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_18_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1790</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_18_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x1794</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_19_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x1798</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_19_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x179C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_20_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_20_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_21_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_21_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_22_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_22_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_23_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_23_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_24_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_24_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_25_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_25_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_26_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_26_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_27_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_27_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_28_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_28_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_29_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_29_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_30_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_30_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_31_WORD_0</name>
          <description>same as type2_compare_0_word_0</description>
          <addressOffset>0x17F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_VALUE</name>
              <description>These bits can be either a 2 byte mask field or an additional 2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [7:0] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [15:8] is compared against the byte in the received frame from the selected offset+1. 
If bit 9 of the associated compare_word1 register is clear, these bits become a direct 2-byte mask for the 2-byte compare register in bits [31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_VALUE_TYPE2</name>
              <description>2 byte Compare Value. 
If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TYPE2_COMPARE_31_WORD_1</name>
          <description>same as type2_compare_0_word_1</description>
          <addressOffset>0x17FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_VALUE</name>
              <description>'Offset value in bytes'</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_OFFSET</name>
              <description>'Compare byte offset.
00 : Offset from beginning of the frame.
01 : Offset from byte after Ether Type.
10 : Offset from byte following end of IP header.
11 : Offset from byte following end of TCP/UDP header'

If bit 9 of the associated compare_word1 register is set, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+2 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+3. 
If bit 9 of the associated compare_word1 register is clear, then the byte stored in bits [23:16] is compared against the byte in the received frame from the selected offset+0 and the byte stored in bits [31:24] is compared against the byte in the received frame from the selected offset+1.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MASK</name>
              <description>'This bit is used to control whether the compare register word_0 contains a 4-byte compare value, or a 2-byte compare value with a 2-byte mask value.
1 - 4-byte compare value
0 - 2-byte compare, 2-byte mask '</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_31_10</name>
              <description>N/A</description>
              <bitRange>[31:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LIN0</name>
      <description>LIN</description>
      <headerStructName>LIN</headerStructName>
      <baseAddress>0x40500000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ERROR_CTL</name>
          <description>Error control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80EF001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which HW  injected channel transmitter errors applies.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SYNC_ERROR</name>
              <description>The synchronization field is changed from 0x55 to 0x00.

At the receiver, this should result in INTR.RX_HEADER_SYNC_ERROR activation.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SYNC_STOP_ERROR</name>
              <description>The synchronization field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_HEADER_SYNC_ERROR or INTR.RX_HEADER_FRAME_ERROR activation.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PARITY_ERROR</name>
              <description>In LIN mode, the PID parity bit P[1] is inverted from !(ID[5] ^ ID[4] ^ ID[3] ^ ID[1]) to (ID[5] ^ ID[4] ^ ID[3] ^ ID[1]).

At the receiver, this should result in INTR.RX_HEADER_PARITY_ERROR activation.

In UART mode, a data field's parity bit is inverted.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PID_STOP_ERROR</name>
              <description>The PID field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_HEADER_FRAME_ERROR activation.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_STOP_ERROR</name>
              <description>The data field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_RESPONSE_FRAME_ERROR activation.

Note: Used in UART mode.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CHECKSUM_ERROR</name>
              <description>The checksum field is inverted.

At the receiver, this should result in INTR.RX_RESPONSE_CHECKSUM_ERROR activation.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CHECKSUM_STOP_ERROR</name>
              <description>The checksum field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_RESPONSE_FRAME_ERROR activation.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Error injection enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST_CTL</name>
          <description>Test control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8001001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which test applies. The channel IO signals of channel indices CH_IDX and CH_NR-1 are connected as specified by MODE. CH_IDX should be in the range [0, CH_NR-2], as channel index CH_NR-1 is always involved in test and cannot be connected to itself. The test mode allows BOTH of the two connected channels to be tested.

Note: this testing functionality simplifies SW development, but may also be used in the field to verify correct channel functionality.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Test mode:
'0': Partial disconnect from IOSS. This mode's isolation allows for device test without relying on an external LIN transceiver. The IOSS 'tx' IO cell can be used to observe messages outside of the device.
- tx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS lin_tx_in[CH_IDX].
- rx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS lin_tx_in[CH_IDX].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- lin_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].

'1': Full disconnect from IOSS (the IOSS/HSIOM should disconnect 'tx_out' from the 'tx' IO cell). This mode's isolation allows for device test without effecting an operational LIN cluster.
- tx_in[CH_IDX] = lin_tx_out[CH_IDX].
- tx_in[CH_NR-1] = lin_tx_out[CH_IDX].
- rx_in[CH_IDX] = lin_tx_out[CH_IDX].
- rx_in[CH_NR-1] = lin_tx_out[CH_IDX].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- lin_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Test enable:
'0': Disabled. Functional mode.
- tx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS lin_tx_in[CH_NR-1].
- rx_in[CH_IDX] = IOSS lin_rx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS lin_rx_in[CH_NR-1].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX].
- lin_tx_out[CH_NR-1] = tx_out[CH_NR-1].
'1': Enabled. Test mode, specific test mode is specified by MODE.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>LIN channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CTL0</name>
            <description>Control 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x400C0101</resetValue>
            <resetMask>0xF91F0313</resetMask>
            <fields>
              <field>
                <name>STOP_BITS</name>
                <description>STOP bit periods:
'0': 1/2 bit period.
'1': 1 bit period.
'2': 1 1/2 bit period.
'3': 2 bit periods.


In LIN mode, this field should be set to '1' (the default value) . 

In UART mode, this field can be programmed as desired.

Note: receiver STOP bit frame errors can only be detected if the number of STOP bit periods is 1 or more bit period.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_EN</name>
                <description>LIN transceiver auto enable:
'0': Disabled.
'1': Enabled. The TX_RX_STATUS.EN_OUT field is controlled by HW.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BREAK_DELIMITER_LENGTH</name>
                <description>In LIN mode, this field specifies the break delimiter length:
(used in header transmission, not used in header reception).
'0': 1 bit period.
'1': 2 bit periods (default value).
'2': 3 bit periods.
'3': 4 bit periods.

In UART mode, this field specifies the data field size:
'0': 5 bit data field.
'1': 6 bit data field.
'2': 7 bit data field.
'3': 8 bit data field.
When the data field size is less than 8 bits, the most significant (unused) bits of the DATAx.DATAy[7:0] fields should be set to '0' for the transmitter.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BREAK_WAKEUP_LENGTH</name>
                <description>Break/wakeup length (minus 1) in bit periods:
'0': 1 bit period.
...
'10': 11 bit periods (break length for slave nodes)
...
'12': 13 bit periods (break length for master nodes)
...
'30': 31 bit periods.
'31': Illegal (should NOT be used!!!)

This field is used for transmission/reception of BOTH break and wakeup signals. Note that these functions are mutually exclusive:
- When CMD.TX_HEADER is '1', the field specifies the transmitted break field.
- When CMD.TX_WAKEUP is '1', the field specifies the transmitted wakeup field.
- When CMD.RX_HEADER is '1', the field specifies the to be received break field.
- Otherwise, the field specifies the to be received wakeup field.

Per the standard, the master wakeup duration is between 250 us and 5 ms. To support uncalibrated slaves, a slave has a detection threshold of 150 us (3 bit periods at 20 kbps). After transmission of a break or wakeup signal, the INTR.TX_BREAK_WAKEUP_DONE interrupt cause is activated. After reception of a wakeup signal, the INTR.RX_BREAK_WAKEUP_DONE interrupt cause is activated.

To specify longer wakeup signals in terms of absolute time (us/ms rather than bit periods), the associated PERI clock divider value can be (temporarily) increased to make the LIN bit period longer.

Note: entering bus sleep mode is achieved with the 'go-to-sleep' command.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Mode of operation:
'0': LIN mode.
'1': UART mode.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>LIN</name>
                    <description>LIN mode.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>UART</name>
                    <description>UART mode.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIT_ERROR_IGNORE</name>
                <description>Specifies behavior on a detected bit error during header or response transmission:
'0': Message transfer is aborted.
'1': Message transfer is NOT aborted.

Note: this field does NOT effect the reporting of the bit error through INTR/STATUS.TX_HEADER/RESPONSE_BIT_ERROR; i.e. bit errors are always reported.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PARITY</name>
                <description>Parity mode:
'0': Even parity: even number of '1' bits (including parity).
'1': Odd parity.

Note: Used in UART mode only.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PARITY_EN</name>
                <description>Parity generation enable:
'0': Disabled. No parity bit is transferred.
'1': Enabled. The parity bit is transferred after the last (most significant) data field bit.

Note: Used in UART mode only.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>RX filter (for 'lin_rx_in'):
'0': No filter.
'1': Median 3 (default value) operates on the last three 'lin_rx_in' values. The sequences '000', '001', '010' and '100' result in a filtered value '0'. The sequences '111', '110', '101' and '011' result in a filtered value '1'.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. If a channel is disabled, all non-retained MMIO registers (e.g. the TX_RX_STATUS, and INTR registers) have their fields reset to their default value.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTL1</name>
            <description>Control 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3000000</resetMask>
            <fields>
              <field>
                <name>DATA_NR</name>
                <description>Number of data fields (minus 1) in the response (not including the checksum):
'0': 1 data field.
'1': 2 data fields.
...
'7': 8 data fields.

Note: master and slave nodes need to agree upon the number of data fields before message transfer.
In RX_RESPONSE case, When PID (header) is received, firmware has the time of one response data byte, to modify CTL1.DATA_NR.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECKSUM_ENHANCED</name>
                <description>Checksum mode:
'0': Classic mode. PID field is NOT included in the checksum calculation.
'1': Enhanced mode. PID field is included in the checksum calculation. This mode requires special attention when the master node transmits the header and a (different) slave node transmits the response: the slave node will use the calculated partial checksum over the received PID field as a starting point for the calculation over the to be transmitted data fields.

Note: If the frame identifier ID[5:0] is 0x3c or 0x3d, the classic mode will ALWAYS be used for transmission and assumed for reception, independent of the CHECKSUM_ENHANCED value.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAME_TIMEOUT</name>
                <description>Specifies the maximum allowed length (timeout value) for a frame, frame header or frame response in bit periods. The LIN specification prescribes to set the maximum length to 1.4x the nominal length (Theader_max = 1.4 x Theader_nom and Tresponse_max = 1.4 x Tresponse_nom). The nominal header length Theader_nom is 34 bit periods and the nominal response length Tresponse_nom is 10 * (data_nr + 1) bit periods (data_nr is the number of data fields) 

Note: the LIN specification specifies the following: 'Tools and tests shall check the Tframe_max (= Theader_max + Tresponse_max). Nodes shall not check this time. The receiving node of the frame shall accept the frame up to the next frame slot (i.e. next break field), even if it is longer then Tframe_max).'</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAME_TIMEOUT_SEL</name>
                <description>Specifies the frame timeout mode:
'0': No timeout functionality (default value).
'1': Frame mode: detects timeout from the start of break field to checksum field STOP bits (inclusive). The minimum FRAME_TIMEOUT value is 34+20 bit periods (header and a response with 1 data field).
'2': Frame header mode: detects timeout from the start of break field to PID field STOP bits (inclusive). The minimum FRAME_TIMEOUT value is 34 bit periods (header).
'3': Frame response mode: detects timeout from the PID field STOP bits (exclusive) to checksum field STOP bits (the response space is included in the frame response). The minimum FRAME_TIMEOUT value is 20 bit periods (response with 1 data field).</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F03333F</resetMask>
            <fields>
              <field>
                <name>DATA_IDX</name>
                <description>Number of transferred data and checksum fields in the response (also acts as an index/address into response data field and checksum field registers (DATA0, DATA1, PID_CHECKSUM)) :
'0': No data fields transferred.
'1': Data field 1 transferred.
...
'7': Data fields 1, 2, 3, ... and 7 transferred.
'8':  Data fields 1, 2, 3, ... and 8 transferred.
'9': Data fields 1, 2, 3, ..., 8 and checksum field transferred.
'10'-'15': Unused.

Set to '0' on the start of a TX_HEADER or RX_HEADER command.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HEADER_RESPONSE</name>
                <description>Frame header / response identifier (only valid when TX_BUSY or RX_BUSY is '1'):
'0': Frame header being transferred.
'1': Frame response being transferred.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DATA0_FRAME_ERROR</name>
                <description>Frame response, first data field frame error. HW sets this field to '1'  when the received STOP bits of the first response data field have an unexpected value (only after a RX_HEADER command), and this data byte is 0x00. HW clears this field to '0' at the falling edge of SYNC start bit (after INTR.RX_HEADER_BREAK_WAKEUP_DONE). This field is used together with INTR.RX_RESPONSE_FRAME_ERROR to distinguish 'no response', 'error response' and 'correct response' scenarios.

Note: The ongoing message transfer is NOT aborted.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_BUSY</name>
                <description>Transmitter busy.
- Set to '1' on the start of the following commands: TX_HEADER, TX_RESPONSE, TX_WAKEUP.
- Set to '0' on successful completion of previous commands or when an error is detected.
   In 'TX_HEADER, RX_RESPONSE' case, set to '0' at the start bit falling edge in the first response data byte, after header transmission</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BUSY</name>
                <description>Receiver busy.
- Set to '1' on the start of the following commands: RX_HEADER, RX_RESPONSE.
   in RX_HEADER case, set at Break filed rising edge.
   in RX_RESPONSE case, set at the start bit falling edge in the first response data byte.

- Set to '0' on successful completion of previous commands or when an error is detected.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_DONE</name>
                <description>Transmitter done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following command sequences (if CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble):
- TX_HEADER.
- TX_HEADER, TX_RESPONSE.
- RX_HEADER, TX_RESPONSE.
- TX_WAKEUP.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DONE</name>
                <description>Receiver done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following command sequences (if CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble):
- RX_HEADER, RX_RESPONSE.
- TX_HEADER, RX_RESPONSE.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Copy of INTR.TX_HEADER_BIT_ERROR.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Copy of INTR.TX_RESPONSE_BIT_ERROR.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Copy of INTR.RX_HEADER_FRAME_ERROR.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Copy of INTR.RX_HEADER_SYNC_ERROR.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Copy of INTR.RX_HEADER_PARITY_ERROR.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Copy of INTR.RX_RESPONSE_FRAME_ERROR.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Copy of INTR.RX_RESPONSE_CHECKSUM_ERROR.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD</name>
            <description>Command</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x307</resetMask>
            <fields>
              <field>
                <name>TX_HEADER</name>
                <description>SW sets this field to '1' to transmit a header. HW sets this field to '0' on successful completion of ANY of the following legal command sequences (also set to '0' when an error is detected):
- TX_HEADER
- TX_HEADER, TX_RESPONSE.
- TX_HEADER, RX_RESPONSE.
- RX_HEADER, TX_RESPONSE.
- RX_HEADER, RX_RESPONSE.
- TX_WAKEUP.

The header is transmitted when the PID field STOP bits are transmitted (INTR.TX_HEADER_DONE).

HW sets this field to '1', when the 'tr_cmd_tx_header' input trigger is activated. This allows for time triggered LIN message transfer. HW driven time triggered transfer eliminates the jitter that is typically associated with SW driven transfer.

In UART mode, a single data field (DATA0.DATA1) is transmitted.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE</name>
                <description>SW sets this field to '1' to transmit a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).

The response is transmitted when the checksum field STOP bits are transmitted (INTR.TX_RESPONSE_DONE).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP</name>
                <description>SW sets this field to '1' to transmit a wakeup signal. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).

The command generates CTL.BREAK_WAKEUP_LENGTH bit periods in the dominant state (low/'0') and transitions to the recessive state (high/'1') (INTR.TX_WAKEUP_DONE).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER</name>
                <description>SW sets this field to '1' to receive a header. HW sets this field to '0' on successful completion of the ANY of the legal command sequences (NOT set to '0' when an error is detected in LIN mode).

The header is received when the PID field STOP bits are received (INTR.RX_HEADER_DONE).

Typically, a slave node SW sets both RX_HEADER and RX_RESPONSE to '1', anticipating a transfer of a response from the master node to this slave node. After receipt of the header PID field (INTR.RX_HEADER_PID_DONE is activated), the slave node may decide to set TX_RESPONSE to '1' (which has a higher priority than RX_RESPONSE) to transmit a response.

the Break detection is performed regardless of CMD.RX_HEADER.
INTR.RX_BREAK_WAKEUP_DONE will trigger at LIN_RX rising edge, when the low pulse meet CTL0.BREAK_WAKEUP_LENGTH. when Break is detected, HW check CMD.RX_HEADER before entering SYNC byte processing state. when RX_HEADER is cleared, SW has at least 11 bit times to set RX_HEADER again, before next Break is detected (RX_BREAK_WAKEUP_DONE). in this case, there is no gap, Break will never be missed.


In UART mode, a single data field in received (in DATA0.DATA1). HW set this field to '0' when the data field is received, or when an error is detected.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE</name>
                <description>SW sets this field to '1' to receive a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (NOT set to '0' when an error is detected).

The response is received when the checksum field STOP bits are received (INTR.RX_RESPONSE_DONE).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_RX_STATUS</name>
            <description>TX/RX status</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x5000000</resetValue>
            <resetMask>0x5000000</resetMask>
            <fields>
              <field>
                <name>SYNC_COUNTER</name>
                <description>Synchronization counter in LIN channel clock periods. After the receipt of a synchronization field, this fields reflects the duration of the synchronization field. Ideally, SYNC_COUNTER = 8*16 = 128 (the synchronization fields consists of eight bit period of 16 LIN channel clock periods each).
- If SYNC_COUNTER is less than 128, the LIN channel clock is too slow and the PERI/PCLK divider value should be decreased.
- If SYNC_COUNTER is greater than 128, the LIN channel clock is too fast and the PERI/PCLK divider value should be increased.

The biggest master-slave clock discrepancy occurs when the master is slow and the slave is fast or vice versa. At a 0.5 percent master inaccuracy and a 14 percent slave inaccuracy, this results in the extreme synchronization values of (.86 * 128) / 1.005 = 109.5 and (1.14 *128) / 0.995 = 146.6. We add a little margin for a valid range of [106, 152].

Note: Only slave nodes with imprecise clocks require clock resynchronization. Master and slave nodes with precise clocks do NOT require clock resynchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_IN</name>
                <description>LIN transmitter input ('tx_in', 'lin_tx_in' in functional mode). TX_IN and RX_IN can be used to determine a wakeup source. Note that wakeup source detection relies on the external transceiver functionality.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_IN</name>
                <description>LIN receiver input ('rx_in', 'lin_rx_in' in functional mode).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_OUT</name>
                <description>LIN transmitter output ('tx_out', 'lin_tx_out').</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EN_OUT</name>
                <description>LIN transceiver enable ('en_out', 'lin_en_out'). This field controls the enable (or low active sleep enable) of the external transceiver:
'0': Disabled.
'1': Enabled.

If CTL.AUTO_EN is '0', SW controls this field to enable the external transceiver. If CTL.AUTO_EN is '1', HW controls this field to enable the external transceiver:
- Before a legal command sequence, HW sets this field to '1', if it is '0'. The start of the command sequence is effectively postponed by a 4-bit period preamble.
- After a legal command sequence, HW clears this field to '0'. The end of the command sequence is effectively postponed by a 4-bit period postamble.

Note: external transceivers require a 'power up' or 'power down' period of 1 or 2 bit periods, so a 4-bit period suffices for all known transceivers.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PID_CHECKSUM</name>
            <description>PID and checksum</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PID</name>
                <description>Header protected identifier (PID). 
- Bits 5 down to 0: frame identifier ID[5:0].
Frame identifier 0x3c is for a 'master request' frame, 0x3d is for a 'slave response' frame, 0x3e and 0x3f are for future LIN enhancements. Frame identifier ID[5:4] is optionally used for length control; i.e. specifies the number of response data fields.
- Bits 1 down to 0: parity bits P[1] and P[0].
  - P[1] = ! (ID[5] ^ ID[4] ^ ID[3] ^ ID[1])
  - P[0] = (ID[4] ^ ID[2] ^ ID[1] ^ ID[0])

Transmission: To be transmitted PID field. SW needs to calculate the PID field parity bits P[1] and P[0].

Reception: Received PID field. Slave node SW uses the PID field to determine how to handle the response for a received frame header: TX_RESPONSE or  RX_RESPONSE.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECKSUM</name>
                <description>Checksum.

Transmission: HW calculated checksum (SW does not need to calculate the checksum) over the transmitted PID field (optional per CTL.CHECKSUM_ENHANCED) and data fields.

Reception: Received checksum. Note that in case of a RX_CHECKSUM_ERROR, SW can use the received PID field and the  received data fields to calculate the correct checksum value.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>Response data 0</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA1</name>
                <description>Data field 1. 

Transmission: To be transmitted data field. SW provides data field.

Reception: Received data field. SW uses the data field.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Data field 2.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Data field 3.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Data field 4.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>Response data 1</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA5</name>
                <description>Data field 5.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Data field 6.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Data field 7.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA8</name>
                <description>Data field 8.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (break field, synchronization field and PID field) is transmitted (the CMD.TX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the frame header transfer.
- When not followed by a response command, this field is set to '1' after completion of the frame header transfer. If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: used in UART mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (data fields and checksum field) is transmitted (the CMD.TX_RESPONSE is completed). If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a wakeup signal is transmitted (per CTL.BREAK_WAKEUP_LENGTH). This cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (break field, synchronization field and PID field) is received (the CMD.RX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the frame header transfer.
- When not followed by a response command, this field is set to '1' after completion of the frame header transfer. If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: used in UART mode.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (data fields and checksum field) is received (the CMD.RX_RESPONSE is completed). If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: activation implies that RX_RESPONSE_FRAME_ERROR and RX_RESPONSE_CHECKSUM_ERROR are not activated during response reception</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a break or wakeup signal is received (per CTL.BREAK_WAKEUP_LENGTH). This cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.

The break or wakeup detection is always enabled, regardless of CMD register setting.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>HW sets this field to '1', when a synchronization field is received (including trailing STOP bits).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>HW sets this field to '1', when isolated '0' or '1' 'in_rx_in' values are observed or when during sampling the last three 'lin_rx_in' values do NOT all have the same value. This mismatch is an indication of noise on the LIN line.

Note: The ongoing frame transfer is NOT aborted.

Note: Used in UART mode.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>HW sets this field to '1', when a frame, frame header or frame response timeout is detected (per CTL.FRAME_TIMEOUT_SEL).

Note: The ongoing frame transfer is NOT aborted.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'lin_tx_out' value does NOT match a received 'lin_rx_in' value (during header transmission). This specific test allows for delay through the external transceiver. This mismatch is an indication of bus collisions on the LIN line.

The match is performed for the Wakeup, Break, SYNC and the PID fields (for the START bit, data Byte and STOP bit).

Note: When CTL.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_HEADER_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

Note: Used in UART mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'lin_tx_out' value does NOT match a received 'lin_rx_in' value (during response transmission).

The match is performed for the data fields and the checksum field (for the START bit, data Byte and STOP bit).

Note: When CTL.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the received START or STOP bits have an unexpected value (during header reception).

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

Note: Used in UART mode.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>HW sets this field to '1', when the received synchronization field is not received within the synchronization counter range [106, 152] (see TX_RX_STATUS.SYNC_COUNTER). 

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_SYNC_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>HW sets this field to '1', when the received PID field has a parity error. 

Note: The ongoing message transfer is aborted (INTR.RX_PID_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

+G119 HW sets this field to '1', when the received data field has a parity error (when CTL0.PARITY_EN is '1').</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the received START or STOP bits have an unexpected value (during response reception). HW does NOT use this field for the STOP bits of the first data field after a RX_HEADER command, if the received data byte is 0x00. (STATUS.RX_DATA0_FRAME_ERROR is used instead).

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>HW sets this field to '1', when the calculated checksum over the received PID and data fields is not the same as the received checksum. 

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CANFD0</name>
      <description>CAN Controller</description>
      <headerStructName>CANFD</headerStructName>
      <baseAddress>0x40520000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>512</dimIncrement>
          <name>CH[%s]</name>
          <description>FIFO wrapper around M_TTCAN 3PIP, to enable DMA</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <name>M_TTCAN</name>
            <description>TTCAN 3PIP, includes FD</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CREL</name>
              <description>Core Release Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x32380609</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DAY</name>
                  <description>Time Stamp Day
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MON</name>
                  <description>Time Stamp Month
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>YEAR</name>
                  <description>Time Stamp Year
One digit, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SUBSTEP</name>
                  <description>Sub-step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STEP</name>
                  <description>Step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REL</name>
                  <description>Core Release
One digit, BCD-coded.</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENDN</name>
              <description>Endian Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x87654321</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ETV</name>
                  <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DBTP</name>
              <description>Data Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xA33</resetValue>
              <resetMask>0x9F1FFF</resetMask>
              <fields>
                <field>
                  <name>DSJW</name>
                  <description>Data (Re)Synchronization Jump Width
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG2</name>
                  <description>Data time segment after sample point
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG1</name>
                  <description>Data time segment before sample point
0x00-0x1F Valid values are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBRP</name>
                  <description>Data Bit Rate Prescaler
0x00-0x1F The value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDC</name>
                  <description>Transmitter Delay Compensation
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TEST</name>
              <description>Test Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>TAM</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Multiplexer Control
Controls output pin m_ttcan_ascm in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_ascm controlled by FSE
1= Level at pin m_ttcan_ascm = '1'</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TAT</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Transmit Control
Controls output pin m_ttcan_asct in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_asct controlled by FSE
1= Level at pin m_ttcan_asct = '1'</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAM</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Multiplexer Control
Monitors level at output pin m_ttcan_ascm.
0= Output pin m_ttcan_ascm = '0'
1= Output pin m_ttcan_ascm = '1'</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAT</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Transmit Control
Monitors level at output pin m_ttcan_asct.
0= Output pin m_ttcan_asct = '0'</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBCK</name>
                  <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled (see Section 3.1.9, Test Modes)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX</name>
                  <description>Control of Transmit Pin
00 Reset value, m_ttcan_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_ttcan_tx
10 Dominant ('0') level at pin m_ttcan_tx
11 Recessive ('1') at pin m_ttcan_tx</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX</name>
                  <description>Receive Pin
Monitors the actual value of pin m_ttcan_rx
0= The CAN bus is dominant (m_ttcan_rx = '0')
1= The CAN bus is recessive (m_ttcan_rx = '1')</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RWD</name>
              <description>RAM Watchdog</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WDC</name>
                  <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of '00' the counter is
disabled.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDV</name>
                  <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CCCR</name>
              <description>CC Control Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xF3FF</resetMask>
              <fields>
                <field>
                  <name>INIT</name>
                  <description>Initialization
0= Normal Operation
1= Initialization is started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CCE</name>
                  <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = '1')</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ASM</name>
                  <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSA</name>
                  <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_TTCAN may be set in power down by stopping m_ttcan_hclk and m_ttcan_cclk</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSR</name>
                  <description>Clock Stop Request, not supported by M_TTCAN use CTL.STOP_REQ at the group level instead.
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after
all pending transfer requests have been completed and the CAN bus reached idle.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MON_</name>
                  <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAR</name>
                  <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEST</name>
                  <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FDOE</name>
                  <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BRSE</name>
                  <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PXHD</name>
                  <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFBI</name>
                  <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXP</name>
                  <description>Transmit Pause
If this bit is set, the M_TTCAN pauses for two CAN bit times before starting the next transmission
after itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NISO</name>
                  <description>Non ISO Operation
If this bit is set, the M_TTCAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0 addressing the non-ISO CAN FD</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NBTP</name>
              <description>Nominal Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6000A03</resetValue>
              <resetMask>0xFFFFFF7F</resetMask>
              <fields>
                <field>
                  <name>NTSEG2</name>
                  <description>Nominal Time segment after sample point
0x01-0x7F Valid values are 1 to 127. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NTSEG1</name>
                  <description>Nominal Time segment before sample point
0x01-0xFF Valid values are 1 to 255. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NBRP</name>
                  <description>Nominal Bit Rate Prescaler
0x000-0x1FFThe value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[24:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NSJW</name>
                  <description>Nominal (Re)Synchronization Jump Width
0x00-0x7F Valid values are 0 to 127. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[31:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCC</name>
              <description>Timestamp Counter Configuration</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0003</resetMask>
              <fields>
                <field>
                  <name>TSS</name>
                  <description>Timestamp Select, should always be set to external timestamp counter
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as '00'</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCP</name>
                  <description>Timestamp Counter Prescaler (still used for TOCC)
0x0-0xF Configures the timestamp and timeout counters time unit in multiples of CAN bit times
[1...16]. The actual interpretation by the hardware of this value is such that one more
than the value programmed here is used.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCV</name>
              <description>Timestamp Counter Value</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TSC</name>
                  <description>Timestamp Counter, not used for M_TTCAN
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).
When TSCC.TSS = '01', the Timestamp Counter is incremented in multiples of CAN bit times
[1...16] depending on the configuration of TSCC.TCP. A wrap around sets interrupt flag IR.TSW.
Write access resets the counter to zero. When TSCC.TSS = '10', TSC reflects the external
Timestamp Counter value. A write access has no impact.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCC</name>
              <description>Timeout Counter Configuration</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF0000</resetValue>
              <resetMask>0xFFFF0007</resetMask>
              <fields>
                <field>
                  <name>ETOC</name>
                  <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOS</name>
                  <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured
by TOCC.TOP and continues down-counting. When the Timeout Counter is controlled by one of the
FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting
is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOP</name>
                  <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCV</name>
              <description>Timeout Counter Value</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TOC</name>
                  <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [1...16] depending on the
configuration of TSCC.TCP. When decremented to zero, interrupt flag IR.TOO is set and the
Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ECR</name>
              <description>Error Counter Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TEC</name>
                  <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REC</name>
                  <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RP</name>
                  <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CEL</name>
                  <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the Transmit Error Counter
or the Receive Error Counter to be incremented. It is reset by read access to CEL. The counter stops
at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PSR</name>
              <description>Protocol Status Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x707</resetValue>
              <resetMask>0x7F7FFF</resetMask>
              <fields>
                <field>
                  <name>LEC</name>
                  <description>Last Error Code,
Set on Read0
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0'
when a message has been transferred (reception or transmission) without error.

0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_TTCAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus
 value was dominant. 
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or
overload flag), the device wanted to send a dominant level (data or identifier bit logical value
0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set
each time a sequence of 11 recessive bits has been monitored. This enables the CPU to
monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming
message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to '7'.
When the LEC shows the value '7', no CAN bus event was detected since the last CPU read
access to the Protocol Status Register.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ACT</name>
                  <description>Activity
Monitors the module's CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP</name>
                  <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EW</name>
                  <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BO</name>
                  <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DLEC</name>
                  <description>Data Phase Last Error Code
, Set on Read
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set. Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with its BRS flag set has been transferred (reception or transmission) without error.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESI</name>
                  <description>ESI flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RBRS</name>
                  <description>BRS flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RFDF</name>
                  <description>Received a CAN FD Message
, Reset on Read
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PXE</name>
                  <description>Protocol Exception Event
, Reset on Read
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TDCV</name>
                  <description>Transmitter Delay Compensation Value
0x00-0x7F Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO. The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TDCR</name>
              <description>Transmitter Delay Compensation Register</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F</resetMask>
              <fields>
                <field>
                  <name>TDCF</name>
                  <description>Transmitter Delay Compensation Filter Window Length
0x00-0x7F Defines the minimum value for the SSP position, dominant edges on m_ttcan_rx
that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than
TDCO. Valid values are 0 to 127 mtq</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDCO</name>
                  <description>Transmitter Delay Compensation Offset
0x00-0x7F Offset value defining the distance between the measured delay from m_ttcan_tx to
m_ttcan_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IR</name>
              <description>Interrupt Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0N</name>
                  <description>N/A</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0W</name>
                  <description>N/A</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0F</name>
                  <description>N/A</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0L_</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1N</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1W</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1F</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1L_</name>
                  <description>N/A</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPM</name>
                  <description>N/A</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TC</name>
                  <description>N/A</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCF</name>
                  <description>N/A</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFE</name>
                  <description>N/A</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFN</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFW</name>
                  <description>N/A</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFF</name>
                  <description>N/A</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFL_</name>
                  <description>N/A</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSW</name>
                  <description>N/A</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAF</name>
                  <description>N/A</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOO</name>
                  <description>N/A</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRX</name>
                  <description>N/A</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEC</name>
                  <description>Bit Error Corrected
This bit always reads as 0.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEU</name>
                  <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. The flag is set in the folloiwng cases.
- M_TTCAN detects uncorrectable ECC error from Message RAM when ECC is enabled and ECC error injection is disabled.
- M_TTCAN reads from an out of range Message RAM address.
Message RAM bit error sets CCCR.INIT to '1'. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELO</name>
                  <description>N/A</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_</name>
                  <description>N/A</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EW_</name>
                  <description>N/A</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BO_</name>
                  <description>N/A</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDI</name>
                  <description>N/A</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEA</name>
                  <description>N/A</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PED</name>
                  <description>N/A</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARA</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NE</name>
                  <description>Rx FIFO 0 New Message Interrupt Enable
 
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WE</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FE</name>
                  <description>Rx FIFO 0 Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LE</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NE</name>
                  <description>Rx FIFO 1 New Message Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WE</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FE</name>
                  <description>Rx FIFO 1 Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LE</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPME</name>
                  <description>High Priority Message Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCE</name>
                  <description>Transmission Completed Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFE</name>
                  <description>Transmission Cancellation Finished Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEE</name>
                  <description>Tx FIFO Empty Interrupt Enable
0= Interrupt Disabled
1= Interrupt EnabledTx FIFO Empty Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNE</name>
                  <description>Tx Event FIDO New Entry Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWE</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFE</name>
                  <description>Tx Event FIFO Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLE</name>
                  <description>Tx Event FIFO Event Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWE</name>
                  <description>Timestamp Wraparound Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFE</name>
                  <description>Message RAM Access Failure Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOE</name>
                  <description>Timeout Occurred Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXE</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECE</name>
                  <description>Bit Error Corrected Interrupt Enable (not used in M_TTCAN)
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUE</name>
                  <description>Bit Error Uncorrected Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOE</name>
                  <description>Error Logging Overflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPE</name>
                  <description>Error Passive Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWE</name>
                  <description>Warning Status Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOE</name>
                  <description>Bus_Off Status Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIE</name>
                  <description>Watchdog Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAE</name>
                  <description>Protocol Error in Arbitration Phase Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDE</name>
                  <description>Protocol Error in Data Phase Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAE</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILS</name>
              <description>Interrupt Line Select</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NL</name>
                  <description>Rx FIFO 0 New Message Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WL</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FL</name>
                  <description>Rx FIFO 0 Full Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LL</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NL</name>
                  <description>Rx FIFO 1 New Message Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WL</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FL</name>
                  <description>Rx FIFO 1 Full Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LL</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPML</name>
                  <description>High Priority Message Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCL</name>
                  <description>Transmission Completed Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFL</name>
                  <description>Transmission Cancellation Finished Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEL</name>
                  <description>Tx FIFO Empty Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNL</name>
                  <description>Tx Event FIFO New Entry Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWL</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFL</name>
                  <description>Tx Event FIFO Full Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLL</name>
                  <description>Tx Event FIFO Event Lost Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWL</name>
                  <description>Timestamp Wraparound Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFL</name>
                  <description>Message RAM Access Failure Interrupt Select  
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOL</name>
                  <description>Timeout Occurred Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXL</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECL</name>
                  <description>Bit Error Corrected Interrupt Select  (not used in M_TTCAN) 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUL</name>
                  <description>Bit Error Uncorrected Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOL</name>
                  <description>Error Logging Overflow Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPL</name>
                  <description>Error Passive Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWL</name>
                  <description>Warning Status Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOL</name>
                  <description>Bus_Off Status Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIL</name>
                  <description>Watchdog Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAL</name>
                  <description>Protocol Error in Arbitration Phase Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDL</name>
                  <description>Protocol Error in Data Phase Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAL</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILE</name>
              <description>Interrupt Line Enable</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>EINT0</name>
                  <description>Enable Interrupt Line 0
0= Interrupt line m_ttcan_int0 disabled
1= Interrupt line m_ttcan_int0 enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EINT1</name>
                  <description>Enable Interrupt Line 1
0= Interrupt line m_ttcan_int1 disabled
1= Interrupt line m_ttcan_int1 enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GFC</name>
              <description>Global Filter Configuration</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>RRFE</name>
                  <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RRFS</name>
                  <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFE</name>
                  <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFS</name>
                  <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SIDFC</name>
              <description>Standard ID Filter Configuration</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFC</resetMask>
              <fields>
                <field>
                  <name>FLSSA</name>
                  <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSS</name>
                  <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
128= Values greater than 128 are interpreted as 128</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDFC</name>
              <description>Extended ID Filter Configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>FLESA</name>
                  <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSE</name>
                  <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDAM</name>
              <description>Extended ID AND Mask</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1FFFFFFF</resetValue>
              <resetMask>0x1FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EIDM</name>
                  <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message
ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all
bits set to one the mask is not active.</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HPMS</name>
              <description>High Priority Message Status</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BIDX</name>
                  <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = '1'.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSI</name>
                  <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIDX</name>
                  <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLST</name>
                  <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT1</name>
              <description>New Data 1</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT2</name>
              <description>New Data 2</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0C</name>
              <description>Rx FIFO 0 Configuration</description>
              <addressOffset>0xA0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F0SA</name>
                  <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0S</name>
                  <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0WM</name>
                  <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0OM</name>
                  <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0S</name>
              <description>Rx FIFO 0 Status</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F0FL</name>
                  <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0GI</name>
                  <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.
This field is updated by the software writing to RXF0A.F0AI.
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0PI</name>
                  <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF0L</name>
                  <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0A</name>
              <description>Rx FIFO 0 Acknowledge</description>
              <addressOffset>0xA8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F0AI</name>
                  <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the
 buffer index of the last element read from Rx FIFO 0 to F0AI. This will set the Rx FIFO 0 Get Index
 RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXBC</name>
              <description>Rx Buffer Configuration</description>
              <addressOffset>0xAC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFC</resetMask>
              <fields>
                <field>
                  <name>RBSA</name>
                  <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).
Also used to reference debug messages A,B,C.</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1C</name>
              <description>Rx FIFO 1 Configuration</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F1SA</name>
                  <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1S</name>
                  <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1WM</name>
                  <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1OM</name>
                  <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1S</name>
              <description>Rx FIFO 1 Status</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F1FL</name>
                  <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1GI</name>
                  <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.
This field is updated by the software writing to RXF1A.F1AI.
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1PI</name>
                  <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF1L</name>
                  <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DMS</name>
                  <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1A</name>
              <description>Rx FIFO 1 Acknowledge</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F1AI</name>
                  <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the
 buffer index of the last element read from Rx FIFO 1 to F1AI. This will set the Rx FIFO 1 Get Index
 RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXESC</name>
              <description>Rx Buffer / FIFO Element Size Configuration</description>
              <addressOffset>0xBC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777</resetMask>
              <fields>
                <field>
                  <name>F0DS</name>
                  <description>Rx FIFO 0 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1DS</name>
                  <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RBDS</name>
                  <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBC</name>
              <description>Tx Buffer Configuration</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>TBSA</name>
                  <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NDTB</name>
                  <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQS</name>
                  <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQM</name>
                  <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXFQS</name>
              <description>Tx FIFO/Queue Status</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F1F3F</resetMask>
              <fields>
                <field>
                  <name>TFFL</name>
                  <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when
Tx Queue operation is configured (TXBC.TFQM = '1')</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFGI</name>
                  <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
TXBC.TFQM = '1').</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQPI</name>
                  <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQF</name>
                  <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXESC</name>
              <description>Tx Buffer Element Size Configuration</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TBDS</name>
                  <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBRP</name>
              <description>Tx Buffer Request Pending</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TRP</name>
                  <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.
The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set,
a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register
TXBRP. In case a transmission has already been started when a cancellation is requested, this is
done at the end of the transmission, regardless whether the transmission was successful or not. The
cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signaled via TXBCF
after successful transmission together with the corresponding TXBTO bit
when the transmission has not yet been started at the point of cancellation
when the transmission has been aborted due to lost arbitration
when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The
corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBAR</name>
              <description>Tx Buffer Add Request</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>AR</name>
                  <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a '1' will set the corresponding Add Request
bit; writing a '0' has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan
process has completed.
0= No transmission request added
1= Transmission requested added</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCR</name>
              <description>Tx Buffer Cancellation Request</description>
              <addressOffset>0xD4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CR</name>
                  <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a '1' will set the corresponding
Cancellation Request bit; writing a '0' has no impact. This enables the Host to set cancellation
requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx
Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTO</name>
              <description>Tx Buffer Transmission Occurred</description>
              <addressOffset>0xD8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TO</name>
                  <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding
TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission
is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCF</name>
              <description>Tx Buffer Cancellation Finished</description>
              <addressOffset>0xDC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CF</name>
                  <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding
TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding
TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a
new transmission is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTIE</name>
              <description>Tx Buffer Transmission Interrupt Enable</description>
              <addressOffset>0xE0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIE</name>
                  <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCIE</name>
              <description>Tx Buffer Cancellation Finished Interrupt Enable</description>
              <addressOffset>0xE4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CFIE</name>
                  <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFC</name>
              <description>Tx Event FIFO Configuration</description>
              <addressOffset>0xF0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>EFSA</name>
                  <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFS</name>
                  <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS-1</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFWM</name>
                  <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
32= Watermark interrupt disabled</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFS</name>
              <description>Tx Event FIFO Status</description>
              <addressOffset>0xF4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F1F3F</resetMask>
              <fields>
                <field>
                  <name>EFFL</name>
                  <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFGI</name>
                  <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.
This field is updated by the software writing to TXEFA.EFAI.
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFPI</name>
                  <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFF</name>
                  <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TEFL</name>
                  <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFA</name>
              <description>Tx Event FIFO Acknowledge</description>
              <addressOffset>0xF8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>EFAI</name>
                  <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write
the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMC</name>
              <description>TT Trigger Memory Configuration</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>TMSA</name>
                  <description>Trigger Memory Start Address
Start address of Trigger Memory in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TME</name>
                  <description>Trigger Memory Elements
0= No Trigger Memory
1-64= Number of Trigger Memory elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTRMC</name>
              <description>TT Reference Message Configuration</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xDFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RID</name>
                  <description>Reference Identifier
Identifier transmitted with reference message and used for reference message filtering. Standard or
extended reference identifier depending on bit XTD. A standard identifier has to be written to
ID[28:18].</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>XTD</name>
                  <description>Extended Identifier
0= 11-bit standard identifier
1= 29-bit extended identifier</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RMPS</name>
                  <description>Reference Message Payload Select
Ignored in case of time slaves.
0= Reference message has no additional payload
1= The following elements are taken from Tx Buffer 0:
Message Marker MM, Event FIFO Control EFC, Data Length Code DLC, Data Bytes DB
Level 1: bytes 2-8, Level 0,2: bytes 5-8)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCF</name>
              <description>TT Operation Configuration</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x7FFFFFB</resetMask>
              <fields>
                <field>
                  <name>OM</name>
                  <description>Operation Mode
00= Event-driven CAN communication, default
01= TTCAN level 1
10= TTCAN level 2
11= TTCAN level 0</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN</name>
                  <description>Gap Enable
0= Strictly time-triggered operation
1= External event-synchronized time-triggered operation</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TM</name>
                  <description>Time Master
0= Time Master function disabled
1= Potential Time Master</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDSDL</name>
                  <description>LD of Synchronization Deviation Limit
The Synchronization Deviation Limit SDL is configured by its dual logarithm LDSDL with SDL =
2(LDSDL + 5). It should not exceed the clock tolerance given by the CAN bit timing configuration.
0x0-7 LD of Synchronization Deviation Limit (SDL &lt;= 32...4096)</description>
                  <bitRange>[7:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IRTO</name>
                  <description>Initial Reference Trigger Offset
0x00-7F Positive offset, range from 0 to 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EECS</name>
                  <description>Enable External Clock Synchronization
If enabled, TUR configuration (TURCF.NCL only) may be updated during TTCAN operation.
0= External clock synchronization in TTCAN Level 0,2 disabled
1= External clock synchronization in TTCAN Level 0,2 enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL</name>
                  <description>Application Watchdog Limit
The application watchdog can be disabled by programming AWL to 0x00.
0x00-FF Maximum time after which the application has to serve the application watchdog.
The application watchdog is incremented once each 256 NTUs.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGTF</name>
                  <description>Enable Global Time Filtering
0= Global time filtering in TTCAN Level 0,2 is disabled
1= Global time filtering in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECC</name>
                  <description>Enable Clock Calibration
0= Automatic clock calibration in TTCAN Level 0,2 is disabled
1= Automatic clock calibration in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EVTP</name>
                  <description>Event Trigger Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTMLM</name>
              <description>TT Matrix Limits</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFF0FFF</resetMask>
              <fields>
                <field>
                  <name>CCM</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSS</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXEW</name>
                  <description>Tx Enable Window
0x0-F Length of Tx enable window, 1-16 NTU cycles</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENTT</name>
                  <description>Expected Number of Tx Triggers
0x000-FFF Expected number of Tx Triggers in one Matrix Cycle</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURCF</name>
              <description>TUR Configuration</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000000</resetValue>
              <resetMask>0xBFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>NCL</name>
                  <description>Numerator Configuration Low
Write access to the TUR Numerator Configuration Low is only possible during configuration with
TURCF.ELT = '0' or if TTOCF.EECS (external clock synchronization enabled) is set. When a new
value for NCL is written outside TT Configuration Mode, the new value takes effect when
TTOST.WECS is cleared to '0'. NCL is locked TTOST.WECS is '1'.
0x0000-FFFF Numerator Configuration Low</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC</name>
                  <description>Denominator Configuration
0x0000 Illegal value
0x0001-3FFF Denominator Configuration</description>
                  <bitRange>[29:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELT</name>
                  <description>Enable Local Time
0= Local time is stopped, default
1= Local time is enabled</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCN</name>
              <description>TT Operation Control</description>
              <addressOffset>0x114</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFFF</resetMask>
              <fields>
                <field>
                  <name>SGT</name>
                  <description>Set Global time
Writing a '1' to SGT sets TTOST.WGDT if the node is the actual Time Master. SGT is reset after one
Host clock period. The global time preset takes effect when the node transmits the next reference
message with the Master_Ref_Mark modified by the preset value written to TTGTP.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECS</name>
                  <description>External Clock Synchronization
Writing a '1' to ECS sets TTOST.WECS if the node is the actual Time Master. ECS is reset after one
Host clock period. The external clock synchronization takes effect at the start of the next basic cycle.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWP</name>
                  <description>Stop Watch Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWS</name>
                  <description>Stop Watch Source
00= Stop Watch disabled
01= Actual value of cycle time is copied to TTCPT.SWV
10= Actual value of local time is copied to TTCPT.SWV
11= Actual value of global time is copied to TTCPT.SWV</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTIE</name>
                  <description>Register Time Mark Interrupt Pulse Enable
Register time mark interrupts are configured by register TTTMK. A register time mark interrupt pulse
with the length of one NTU is generated when the time referenced by TTOCN.TMC (cycle, local, or
global) equals TTTMK.TM, independent of the synchronization state.
0= Register Time Mark Interrupt output m_ttcan_rtp disabled
1= Register Time Mark Interrupt output m_ttcan_rtp enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMC</name>
                  <description>Register Time Mark Compare
00= No Register Time Mark Interrupt generated
01= Register Time Mark Interrupt if Time Mark = cycle time
10= Register Time Mark Interrupt if Time Mark = local time
11= Register Time Mark Interrupt if Time Mark = global time</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTIE</name>
                  <description>Trigger Time Mark Interrupt Pulse Enable
External time mark events are configured by trigger memory element TMEX (see Section 2.4.7). A
trigger time mark interrupt pulse is generated when the trigger memory element becomes active,
and the M_TTCAN is in synchronization state In_Schedule or In_Gap.
0= Trigger Time Mark Interrupt output m_ttcan_tmp disabled
1= Trigger Time Mark Interrupt output m_ttcan_tmp enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GCS</name>
                  <description>Gap Control Select
0= Gap control independent from m_ttcan_evt
1= Gap control by input pin m_ttcan_evt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FGP</name>
                  <description>Finish Gap
Set by the CPU, reset by each reference message
0= No reference message requested
1= Application requested start of reference message</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMG</name>
                  <description>Time Mark Gap
0= Reset by each reference message
1= Next reference message started when Register Time Mark interrupt TTIR.RTMI is activated</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NIG</name>
                  <description>Next is Gap
This bit can only be set when the M_TTCAN is the actual Time Master and when it is configured for
external event-synchronized time-triggered operation (TTOCF.GEN = '1')
0= No action, reset by reception of any reference message
1= Transmit next reference message with Next_is_Gap = '1'</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ESCN</name>
                  <description>External Synchronization Control
If enabled the M_TTCAN synchronizes its cycle time phase to an external event signaled by a rising
edge at pin m_ttcan_evt (see Section 4.11).
0= External synchronization disabled
1= External synchronization enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKC</name>
                  <description>TT Operation Control Register Locked
Set by a write access to register TTOCN. Reset when the updated configuration has been
synchronized into the CAN clock domain.
0= Write access to TTOCN enabled
1= Write access to TTOCN locked</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTGTP</name>
              <description>TT Global Time Preset</description>
              <addressOffset>0x118</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TP</name>
                  <description>N/A</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTP</name>
                  <description>Cycle Time Target Phase
CTP is write-protected while TTOCN.ESCN or TTOST.SPL are set (see Section 4.11).
0x0000-FFFF Defines target value of cycle time when a rising edge of m_ttcan_evt is expected</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMK</name>
              <description>TT Time Mark</description>
              <addressOffset>0x11C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x807FFFFF</resetMask>
              <fields>
                <field>
                  <name>TM_</name>
                  <description>Time Mark
0x0000-FFFF Time Mark</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TICC</name>
                  <description>Time Mark Cycle Code
Cycle count for which the time mark is valid.
0b000000x valid for all cycles
0b000001c valid every second cycle at cycle count mod2 = c
0b00001cc valid every fourth cycle at cycle count mod4 = cc
0b0001ccc valid every eighth cycle at cycle count mod8 = ccc
0b001cccc valid every sixteenth cycle at cycle count mod16 = cccc
0b01ccccc valid every thirty-second cycle at cycle count mod32 = ccccc
0b1cccccc valid every sixty-fourth cycle at cycle count mod64 = cccccc</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKM</name>
                  <description>TT Time Mark Register Locked
Always set by a write access to registers TTOCN. Set by write access to register TTTMK when
TTOCN.TMC != '00'. Reset when the registers have been synchronized into the CAN clock domain.
0= Write access to TTTMK enabled
1= Write access to TTTMK locked</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIR</name>
              <description>TT Interrupt Register</description>
              <addressOffset>0x120</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBC</name>
                  <description>Start of Basic Cycle
0= No Basic Cycle started since bit has been reset
1= Basic Cycle started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMC</name>
                  <description>Start of Matrix Cycle
0= No Matrix Cycle started since bit has been reset
1= Matrix Cycle started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSM_</name>
                  <description>Change of Synchronization Mode
0= No change in master to slave relation or schedule synchronization
1= Master to slave relation or schedule synchronization changed,
also set when TTOST.SPL is reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOG</name>
                  <description>Start of Gap
0= No reference message seen with Next_is_Gap bit set
1= Reference message with Next_is_Gap bit set becomes valid</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMI</name>
                  <description>Register Time Mark Interrupt
Set when time referenced by TTOCN.TMC (cycle, local, or global) equals TTTMK.TM, independent
of the synchronization state.
0= Time mark not reached
1= Time mark reached</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMI</name>
                  <description>Trigger Time Mark Event Internal
Internal time mark events are configured by trigger memory element TMIN (see Section 2.4.7). Set
when the trigger memory element becomes active, and the M_TTCAN is in synchronization state
In_Gap or In_Schedule.
0= Time mark not reached
1= Time mark reached (Level 0: cycle time TTOCF.IRTO * 0x200)</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWE</name>
                  <description>Stop Watch Event
0= No rising/falling edge at stop watch trigger pin m_ttcan_swt detected
1= Rising/falling edge at stop watch trigger pin m_ttcan_swt detected</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTW</name>
                  <description>Global Time Wrap
0= No global time wrap occurred
1= Global time wrap from 0xFFFF to 0x0000 occurred</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTD</name>
                  <description>Global Time Discontinuity
0= No discontinuity of global time
1= Discontinuity of global time</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTE</name>
                  <description>Global Time Error
Synchronization deviation SD exceeds limit specified by TTOCF.LDSDL, TTCAN Level 0,2 only.
0= Synchronization deviation within limit
1= Synchronization deviation exceeded limit</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXU</name>
                  <description>Tx Count Underflow
0= Number of Tx Trigger as expected
1= Less Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXO</name>
                  <description>Tx Count Overflow
0= Number of Tx Trigger as expected
1= More Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1</name>
                  <description>Scheduling Error 1
0= No scheduling error 1
1= Scheduling error 1 occurred</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2</name>
                  <description>Scheduling Error 2
0= No scheduling error 2
1= Scheduling error 2 occurred</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELC</name>
                  <description>Error Level Changed
Not set when error level changed during initialization.
0= No change in error level
1= Error level changed</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWT</name>
                  <description>Initialization Watch Trigger
The initialization is restarted by resetting IWT.
0= No missing reference message during system startup
1= No system startup due to missing reference message</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WT</name>
                  <description>Watch Trigger
0= No missing reference message
1= Missing reference message (Level 0: cycle time 0xFF00)</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AW</name>
                  <description>Application Watchdog
0= Application watchdog served in time
1= Application watchdog not served in time</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CER</name>
                  <description>Configuration Error
Trigger out of order.
0= No error found in trigger list
1= Error found in trigger list</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIE</name>
              <description>TT Interrupt Enable</description>
              <addressOffset>0x124</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCE</name>
                  <description>Start of Basic Cycle Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCE</name>
                  <description>Start of Matrix Cycle Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSME</name>
                  <description>Change of Synchronization Mode Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGE</name>
                  <description>Start of Gap Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIE</name>
                  <description>Register Time Mark Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIE</name>
                  <description>Trigger Time Mark Event Internal Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEE</name>
                  <description>Stop Watch Event Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWE</name>
                  <description>Global Time Wrap Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDE</name>
                  <description>Global Time Discontinuity Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEE</name>
                  <description>Global Time Error Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUE</name>
                  <description>Tx Count Underflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOE</name>
                  <description>Tx Count Overflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1E</name>
                  <description>Scheduling Error 1 Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2E</name>
                  <description>Scheduling Error 2 Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCE</name>
                  <description>Change Error Level Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTE</name>
                  <description>Initialization Watch Trigger Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTE</name>
                  <description>Watch Trigger Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWE_</name>
                  <description>Application Watchdog Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERE</name>
                  <description>Configuration Error Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTILS</name>
              <description>TT Interrupt Line Select</description>
              <addressOffset>0x128</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCL</name>
                  <description>Start of Basic Cycle Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCL</name>
                  <description>Start of Matrix Cycle Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSML</name>
                  <description>Change of Synchronization Mode Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGL</name>
                  <description>Start of Gap Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIL</name>
                  <description>Register Time Mark Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIL</name>
                  <description>Trigger Time Mark Event Internal Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEL</name>
                  <description>Stop Watch Event Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWL</name>
                  <description>Global Time Wrap Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDL</name>
                  <description>Global Time Discontinuity Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEL</name>
                  <description>Global Time Error Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUL</name>
                  <description>Tx Count Underflow Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOL</name>
                  <description>Tx Count Overflow Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1L</name>
                  <description>Scheduling Error 1 Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2L</name>
                  <description>Scheduling Error 2 Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCL</name>
                  <description>Change Error Level Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTL</name>
                  <description>Initialization Watch Trigger Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTL</name>
                  <description>Watch Trigger Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL_</name>
                  <description>Application Watchdog Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERL</name>
                  <description>Configuration Error Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOST</name>
              <description>TT Operation Status</description>
              <addressOffset>0x12C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x80</resetValue>
              <resetMask>0xFFC0FFFF</resetMask>
              <fields>
                <field>
                  <name>EL</name>
                  <description>Error Level
00= Severity 0 - No Error
01= Severity 1 - Warning
10= Severity 2 - Error
11= Severity 3 - Severe Error</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master State
00= Master_Off, no master properties relevant
01= Operating as Time Slave
10= Operating as Backup Time Master
11= Operating as current Time Master</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SYS</name>
                  <description>Synchronization State
00= Out of Synchronization
01= Synchronizing to TTCAN communication
10= Schedule suspended by Gap (In_Gap)
11= Synchronized to schedule (In_Schedule)</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QGTP</name>
                  <description>Quality of Global Time Phase
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '0'.
0= Global time not valid
1= Global time in phase with Time Master</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QCS</name>
                  <description>Quality of Clock Speed
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '1'.
0= Local clock speed not synchronized to Time Master clock speed
1= Synchronization Deviation &lt;= SDL</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RTO</name>
                  <description>Reference Trigger Offset
The Reference Trigger Offset value is a signed integer with a range from -127 (0x81) to 127 (0x7F).
There is no notification when the lower limit of -127 is reached. In case the M_TTCAN becomes
Time Master (MS[1:0] = '11'), the reset of RTO is delayed due to synchronization between Host and
CAN clock domain. For time slaves the value configured by TTOCF.IRTO is read.
0x00-FF Actual Reference Trigger offset value</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WGTD</name>
                  <description>Wait for Global Time Discontinuity
0= No global time preset pending
1= Node waits for the global time preset to take effect. The bit is reset when the node has transmitted
a reference message with Disc_Bit = '1' or after it received a reference message.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GFI</name>
                  <description>Gap Finished Indicator
Set when the CPU writes TTOCN.FGP, or by a time mark interrupt if TMG = '1', or via input pin
m_ttcan_evt if TTOCN.GCS = '1'. Not set by Ref_Trigger_Gap or when Gap is finished by another
node sending a reference message.
0= Reset at the end of each reference message
1= Gap finished by M_TTCAN</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TMP</name>
                  <description>Time Master Priority
0x0-7 Priority of actual Time Master</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GSI</name>
                  <description>Gap Started Indicator
0= No Gap in schedule, reset by each reference message and for all time slaves
1= Gap time after Basic Cycle has started</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WFE</name>
                  <description>Wait for Event
0= No Gap announced, reset by a reference message with Next_is_Gap = '0'
1= Reference message with Next_is_Gap = '1' received</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AWE</name>
                  <description>Application Watchdog Event
The application watchdog is served by reading TTOST. When the watchdog is not served in time,
bit AWE is set, all TTCAN communication is stopped, and the M_TTCAN is set into Bus Monitoring
Mode.
0= Application Watchdog served in time
1= Failed to serve Application Watchdog in time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WECS</name>
                  <description>Wait for External Clock Synchronization
0= No external clock synchronization pending
1= Node waits for external clock synchronization to take effect. The bit is reset at the start of the
next basic cycle.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPL</name>
                  <description>Schedule Phase Lock
The bit is valid only when external synchronization is enabled (TTOCN.ESCN = '1'). In this case it
signals that the difference between cycle time configured by TTGTP.CTP and the cycle time at the
rising edge at pin m_ttcan_evt is less or equal 9 NTU (see Section 4.11).
0= Phase outside range
1= Phase inside range</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURNA</name>
              <description>TUR Numerator Actual</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x3FFFF</resetMask>
              <fields>
                <field>
                  <name>NAV</name>
                  <description>N/A</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTLGT</name>
              <description>TT Local &amp; Global Time</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LT</name>
                  <description>Local Time
Non-fractional part of local time, incremented once each local NTU (see Section 4.5).
0x0000-FFFF Local time value of TTCAN node</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GT</name>
                  <description>Global Time
Non-fractional part of the sum of the node's local time and its local offset (see Section 4.5).
0x0000-FFFF Global time value of TTCAN network</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCTC</name>
              <description>TT Cycle Time &amp; Count</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x3F0000</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>CT</name>
                  <description>Cycle Time
Non-fractional part of the difference of the node's local time and Ref_Mark (see Section 4.5).
0x0000-FFFF Cycle time value of TTCAN Basic Cycle</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC</name>
                  <description>Cycle Count
0x00-3F Number of actual Basic Cycle in the System Matrix</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCPT</name>
              <description>TT Capture Time</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF003F</resetMask>
              <fields>
                <field>
                  <name>CCV</name>
                  <description>Cycle Count Value
Cycle count value captured together with SWV.
0x00-3F Captured cycle count value</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWV</name>
                  <description>Stop Watch Value
On a rising/falling edge (as configured via TTOCN.SWP) at the Stop Watch Trigger pin m_ttcan_swt, when TTOCN.SWS is != '00' and TTIR.SWE is '0', the actual time value as selected
by TTOCN.SWS (cycle, local, global) is copied to SWV and TTIR.SWE will be set to '1'. Capturing of the next stop watch value is enabled by resetting TTIR.SWE.
0x0000-FFFF Captured Stop Watch value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCSM</name>
              <description>TT Cycle Sync Mark</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CSM</name>
                  <description>Cycle Sync Mark
The Cycle Sync Mark is measured</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>RXFTOP_CTL</name>
            <description>Receive FIFO Top control</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>F0TPE</name>
                <description>FIFO 0 Top Pointer Enable. 
This enables the FIFO top pointer logic to set the FIFO Top Address (FnTA) and message word counter.
This logic is also disabled when the IP is being reconfigured (CCCR.CCE=1).
When this logic is disabled a Read from RXFTOP0_DATA is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>F1TPE</name>
                <description>FIFO 1 Top Pointer Enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_STAT</name>
            <description>Receive FIFO 0 Top Status</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F0TA</name>
                <description>Current FIFO 0 Top Address.
This is a pointer to the next word in the message buffer defined by the FIFO Start Address (FnSA), Get Index (FnGI), the FIFO message size (FnDS) and the message word counter (FnMWC)
FnTA = FnSA + FnGI * msg_size[FnDS] + FnMWC</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_DATA</name>
            <description>Receive FIFO 0 Top Data</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F0TD</name>
                <description>When enabled (F0TPE=1) read data from MRAM at location FnTA. This register can have a read side effect if the following conditions are met:
- M_TTCAN not being reconfigured (CCCR.CCE=0)
- FIFO Top Pointer logic is enabled (FnTPE=1)
- FIFO is not empty (FnFL!=0)
The read side effect is as follows:
- if FnMWC pointed to the last word of the message (as indicated by FnDS) then the corresponding message index (FnGI) is automatically acknowledge by a write to FnAI
- FnMWC is incremented (or restarted if FnMWC pointed to the last word of the message)
- the FIFO top address FnTA is incremented (with FIFO wrap around) 
When this logic is disabled (F0TPE=0) a Read from this register returns undefined data.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_STAT</name>
            <description>Receive FIFO 1 Top Status</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F1TA</name>
                <description>See F0TA description</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_DATA</name>
            <description>Receive FIFO 1 Top Data</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F1TD</name>
                <description>See F0TD description</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CTL</name>
          <description>Global CAN control register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>STOP_REQ</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_OFF</name>
              <description>MRAM off
0= Default MRAM on (with MRAM retained in DeepSleep).
1= Switch MRAM off (not retained) to save power. Before setting this bit all the CAN channels have to be powered down using the STOP_REQ/ACK bits.
When the MRAM is off any access attempt to it is considered an address error (as if MRAM_SIZE=0).
After switching the MRAM on again software needs to allow for a certain power up time before MRAM can be used, i.e. before STOP_REQ can be de-asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register.

MRAM_OFF should be set to 0 prior to transitioning to Hibernate mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Global CAN status register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STOP_ACK</name>
              <description>Clock Stop Acknowledge for each TTCAN IP.
These bits are directly driven by m_ttcan_clkstop_ack of each TTCAN IP.
When this bit is set the corresponding TTCAN IP clocks will be gated off, except HCLK will enabled for each AHB write</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_CAUSE</name>
          <description>Consolidated interrupt0 cause register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT0</name>
              <description>Show pending m_ttcan_int0 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_CAUSE</name>
          <description>Consolidated interrupt1 cause register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT1</name>
              <description>Show pending m_ttcan_int1 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTL</name>
          <description>Time Stamp control register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Time Stamp counter prescale value. 
When enabled divide the Host clock (HCLK) by PRESCALE+1 to create Time Stamp clock ticks.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Counter enable bit
0 = Count disabled. Stop counting up and keep the counter value
1 = Count enabled. Start counting up from the current value</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CNT</name>
          <description>Time Stamp counter value</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>The counter value of the Time Stamp Counter.
When enabled this counter will count Time Stamp clock ticks from the pre-scaler.
When written this counter and the pre-scaler will reset to 0 (write data is ignored).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10000</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC for CANFD SRAM
When disabled also all error injection functionality is disabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_ERR_INJ</name>
          <description>ECC error injection</description>
          <addressOffset>0x1084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFC</resetValue>
          <resetMask>0x7F10FFFC</resetMask>
          <fields>
            <field>
              <name>ERR_ADDR</name>
              <description>Specifies the address of the word where an error will be injected on write or an non-correctable error will be suppressed.
When the ERR_EN bit is set an error parity (ERR_PAR) is injected when any write, from bus or a CAN channel, is done to this address.
When the ERR_EN bit is set and the access address matches ERR_ADDR then a non-correctable ECC error or an Address error will NOT result in a bus error or CAN channel shutdown.
Note that error reporting to the fault structure cannot be suppressed.</description>
              <bitRange>[15:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_EN</name>
              <description>Enable error injection (ECC_EN must be 1).
When this bit is set the error parity (ERR_PAR) will be used when an AHB write is done to the ERR_ADDR address.
When the error word is read a single or double error will be reported to the fault structure just like for a real ECC error (even if this bit is no longer set).
When this bit is set (and ECC_EN=1) a non-correctable error (ECC or address error) for the ERR_ADDR will not be reported back to the CAN channel or  AHB bus.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_PAR</name>
              <description>ECC Parity bits to use for ECC error injection at address ERR_ADDR.</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CANFD0">
      <name>CANFD1</name>
      <baseAddress>0x40540000</baseAddress>
    </peripheral>
    <peripheral>
      <name>TCPWM0</name>
      <description>Timer/Counter/PWM</description>
      <headerStructName>TCPWM</headerStructName>
      <baseAddress>0x40580000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>3</dim>
          <dimIncrement>32768</dimIncrement>
          <name>GRP[%s]</name>
          <description>Group of counters</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <dim>63</dim>
            <dimIncrement>128</dimIncrement>
            <name>CNT[%s]</name>
            <description>Timer/Counter/PWM Counter Module</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CTRL</name>
              <description>Counter control register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF0</resetValue>
              <resetMask>0xC73737FF</resetMask>
              <fields>
                <field>
                  <name>AUTO_RELOAD_CC0</name>
                  <description>Specifies switching of the CC0 and buffered CC0 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 0 event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_CC1</name>
                  <description>Specifies switching of the CC1 and buffered CC1 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 1 event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_PERIOD</name>
                  <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM and PWM_DT modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.

In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to select the index / wrap-around capture function.
'0': Captures on index (reload) event. The counter value is copied to the PERIOD register on an index (reload) event.
'1': Captures when COUNTER equals 0 or 0xffff. The counter value is copied to the PERIOD register when COUNTER equals 0 or 0xffff.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_LINE_SEL</name>
                  <description>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values. This field has a function in PWM and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting up
'1': compare match 0 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting down
'1': compare match 0 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting up
'1': compare match 1 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting down
'1': compare match 1 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_IMM_KILL</name>
                  <description>Specifies whether the kill event immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals or with the next module clock ('active count' pre-scaled 'clk_counter').
'0': synchronous kill activation. Deactivates the 'dt_line_out' and 'dt_line_compl_out' signals with the next module clock ('active count' pre-scaled 'clk_counter').
'1': immediate kill activation. Immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_STOP_ON_KILL</name>
                  <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_SYNC_KILL</name>
                  <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_DISABLE_MODE</name>
                  <description>Specifies the behavior of the PWM outputs 'line_out' and 'line_compl_out' while the TCPWM counter is disabled (CTL.ENABLED='0') or stopped.

Note: The output signal of this selection can be further modified by the immediate kill logic and line_out polarity settings (CTRL.QUAD_ENCODING_MODE).</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The behavior is the same is in previous mxtcpwm (version 1).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RETAIN</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM.
When the counter is disabled or stopped upon a stop event the PWM outputs are retained (keep their previous levels). 
While the counter is disabled or stopped the PWM outputs can be changed via LINE_SEL (when parameter GRP_SMC_PRESENT = 1).</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>L</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM. 
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '0' and the PWM output 'line_compl_out' is driven as a fixed '1'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM. 
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '1' and the PWM output 'line_compl_out' is driven as a fixed '0'.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UP_DOWN_MODE</name>
                  <description>Determines counter direction.

In QUAD mode this field acts as QUAD_RANGE_MODE field selecting between different counter range, reload value and compare / capture behavior.</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>COUNT_UP</name>
                      <description>Count up (to PERIOD). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. A terminal count event is generated when the counter changes from a state in which COUNTER equals PERIOD.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_DOWN</name>
                      <description>Count down (to '0'). An underflow event is generated when  the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN1</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN2</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0' AND when the counter changes from a state in which COUNTER equals PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ONE_SHOT</name>
                  <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>QUAD_ENCODING_MODE</name>
                  <description>In QUAD mode this field selects the quadrature encoding mode (X1/X2/X4) or the Up / Down rotary counting mode.
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUAD_ENCODING_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUAD_ENCODING_MODE[1].</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>X1</name>
                      <description>X1 encoding (QUAD mode)
This encoding is identical with an up / down counting functionality of the following way: Rising edges of input phiA increment or decrement the counter depending on the state of input phiB (direction input).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X2</name>
                      <description>X2 encoding (QUAD mode)</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X4</name>
                      <description>X4 encoding (QUAD mode)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UP_DOWN</name>
                      <description>Up / Down rotary counting mode. Input phiA increments the counter, input phiB decrements the counter. The trigger edge detection settings apply.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MODE</name>
                  <description>Counter mode.</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TIMER</name>
                      <description>Timer mode</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CAPTURE</name>
                      <description>Capture mode</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>QUAD</name>
                      <description>Quadrature mode</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>Pulse width modulation (PWM) mode</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_DT</name>
                      <description>PWM with deadtime insertion mode</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_PR</name>
                      <description>Pseudo random pulse width modulation</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SR</name>
                      <description>Shift register mode.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DBG_FREEZE_EN</name>
                  <description>Specifies the counter behavior in debug mode.
'0': The counter operation continues in debug mode.
'1': The counter operation freezes in debug mode.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Counter enable.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_IN_SEL, TR_IN_EDGE_SEL, TR_PWM_CTRL and TR_OUT_SEL register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_out0' and tr_out1').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STATUS</name>
              <description>Counter status register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x20</resetValue>
              <resetMask>0xFFFF8FF1</resetMask>
              <fields>
                <field>
                  <name>DOWN</name>
                  <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE0</name>
                  <description>Indicates the actual level of the selected capture 0 trigger.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_COUNT</name>
                  <description>Indicates the actual level of the selected count trigger.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_RELOAD</name>
                  <description>Indicates the actual level of the selected reload trigger.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_STOP</name>
                  <description>Indicates the actual level of the selected stop trigger.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_START</name>
                  <description>Indicates the actual level of the selected start trigger.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE1</name>
                  <description>Indicates the actual level of the selected capture 1 trigger.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_OUT</name>
                  <description>Indicates the actual level of the PWM line output signal.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_COMPL_OUT</name>
                  <description>Indicates the actual level of the complementary PWM line output signal.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RUNNING</name>
                  <description>When '0', the counter is NOT running. When '1', the counter is running. 

This field is used to indicate that the counter is running after a start/reload event and that the counter is stopped after a stop event.
When a running counter operation is paused in debug state (see CTRL.DBG_PAUSE) then the RUNNING bit is still '1'.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_L</name>
                  <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion (8bit dead time counter or low byte of 16-bit dead time counter). 
In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_H</name>
                  <description>High byte of 16-bit dead time counter. In PWM_DT mode, this counter is used for dead time insertion.
In all other modes, this field has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8bit wide and the only the field DT_CNT_L is used as dead time counter.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>COUNTER</name>
              <description>Counter count register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COUNTER</name>
                  <description>16-bit / 32-bit counter value. It is advised to not write to this field when the counter is running.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0</name>
              <description>Counter compare/capture 0 register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0_BUFF</name>
              <description>Counter buffered compare/capture 0 register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC register.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1</name>
              <description>Counter compare/capture 1 register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1_BUFF</name>
              <description>Counter buffered compare/capture 1 register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC1 register.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD</name>
              <description>Counter period register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD_BUFF</name>
              <description>Counter buffered period register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Additional buffer for counter PERIOD register.

In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit represents a tap of the shift register which can be feed back to the MSB via an XOR tree. 
Examples for GRP_CNT_WIDTH = 16: 
- Maximum length 16bit LFSR
  - polynomial x^16 + x^14 + x^13 + x^11 + 1
  - taps 0,2,3,5 -&gt; PERIOD = 0x002d
  - period is 2^16-1 = 65535 cycles
- Maximum length 8bit LFSR: 
  - polynomial x^8 + x^6 + x^5 + x^4 + 1
  - taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)
  - period is 2^8-1 = 255 cycles

In SR mode PERIOD_BUFF defines which tap of the shift register generates the PWM output signals. For a delay of n cycles (from capture event to PWM output) the bit CNT_WIDTH-n should be set to '1'. For a shift register function only one tap should be use, i.e. a one-hot value must be written to PERIOD_BUFF. If multiple bits in PERIOD_BUFF are set then the taps are XOR combined.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL</name>
              <description>Counter line selection register</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_out'. Default setting is the PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM and PWM_PR modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_out polarity setting (CTRL.QUAD_ENCODING_MODE[0]).</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_compl_out'. Default setting is the inverted PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM and PWM_PR modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_compl_out polarity setting (CTRL.QUAD_ENCODING_MODE[1]).</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_compl_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_compl_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL_BUFF</name>
              <description>Counter buffered line selection register</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Buffer for LINE_SEL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM and PWM_PR modes only.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Buffer for LINE_SEL.COMPL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_COMPL_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM and PWM_PR modes only.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DT</name>
              <description>Counter PWM dead time register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DT_LINE_OUT_L</name>
                  <description>In PWM_DT mode, this field is used to determine the low byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain. 
In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.

Note: This field determines the low byte of the 16-bit dead time before activating 'line_out' when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by this DT_LINE_OUT_L field is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_OUT_H</name>
                  <description>In PWM_DT mode, this field is used to determine the high byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain.
In all other modes, this field  has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_COMPL_OUT</name>
                  <description>In PWM_DT mode, this field is used to determine the dead time before activating the complementary PWM line output signal 'line_compl_out': amount of dead time cycles in the counter clock domain. 
In all other modes, this field  has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_CMD</name>
              <description>Counter trigger command register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3D</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0</name>
                  <description>SW capture 0 trigger. When written with '1', a capture 0 trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.ENABLED, the field is immediately set to '0'.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD</name>
                  <description>SW reload trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP</name>
                  <description>SW stop trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>START</name>
                  <description>SW start trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1</name>
                  <description>SW capture 1 trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL0</name>
              <description>Counter input trigger selection register 0</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_SEL</name>
                  <description>Selects one of the up to 256 input triggers as a capture0 trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. If existing, the one-to-one trigger inputs 'tr_one_cnt_in' (different to each counter) are selected by setting 2 and above. The settings above are used for the general purpose trigger inputs 'tr_all_cnt_in' connected to all counters selected.
In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COUNT_SEL</name>
                  <description>Selects one of the 256 input triggers as a count trigger. 
In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.

Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the counter is externally triggered ( COUNT_SEL &gt; 1), an external trigger will be required for each TR_CMD to execute. For example, a write to TR_CMD.START will not start the counter until the trigger selected by COUNT_SEL asserts. The next trigger will increment the counter since the counter is now running. This goes for all TR_CMD fields.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD_SEL</name>
                  <description>Selects one of the 256 input triggers as a reload trigger. 
In QUAD mode, this is the index or revolution pulse. In these modes, it will update the counter with 0x8000 (counter midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP_SEL</name>
                  <description>Selects one of the 256 input triggers as a stop trigger. 
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL1</name>
              <description>Counter input trigger selection register 1</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>START_SEL</name>
                  <description>Selects one of the 256 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1_SEL</name>
                  <description>Selects one of the 256 input triggers as a capture 1 trigger.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_EDGE_SEL</name>
              <description>Counter input trigger edge selection register</description>
              <addressOffset>0x4C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFF</resetValue>
              <resetMask>0xFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_EDGE</name>
                  <description>A capture 0 event will copy the counter value into the CC0 register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COUNT_EDGE</name>
                  <description>A counter event will increase or decrease the counter by '1'.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>RELOAD_EDGE</name>
                  <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>STOP_EDGE</name>
                  <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>START_EDGE</name>
                  <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CAPTURE1_EDGE</name>
                  <description>A capture 1 event will copy the counter value into the CC1 register.</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_PWM_CTRL</name>
              <description>Counter trigger PWM control register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFF</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>CC0_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 0 event (COUNTER equals CC0 register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC0 register should be set to '0'. For a 100 percent duty cycle, the counter CC0 register should be set to larger than the counter PERIOD register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OVERFLOW_MODE</name>
                  <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UNDERFLOW_MODE</name>
                  <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CC1_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 1 event (COUNTER equals CC1 register) on the 'line_out' output signals.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_OUT_SEL</name>
              <description>Counter output trigger selection register</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT0</name>
                  <description>Selects one of the internal events to generate the output trigger 0. Default setting selects the terminal count event.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event (default selection)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OUT1</name>
                  <description>Selects one of the internal events to generate the output trigger 1. Default setting selects the compare match 0 event.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event (default selection)</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR</name>
              <description>Interrupt request register</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Counter matches CC0 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Counter matches CC1 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_SET</name>
              <description>Interrupt set request register</description>
              <addressOffset>0x74</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASK</name>
              <description>Interrupt mask register</description>
              <addressOffset>0x78</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASKED</name>
              <description>Interrupt masked request register</description>
              <addressOffset>0x7C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40600000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300400F</resetValue>
          <resetMask>0x9303D70F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
'0': Internally clocked mode 
'1': Externally clocked mode 

In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.

The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.

Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>This field specifies the clocking for the SCB block
'0': Internally clocked mode 
'1': externally clocked mode
 In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 

Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1').
In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not separated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_WIDTH</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>8-bit FIFO data elements. 
This mode provides the biggest amount of FIFO entries, but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>16-bit FIFO data elements. 
TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 15].</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>32-bit FIFO data elements. 
This mode provides the smallest amount of FIFO entries, but TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH can be in a range of [0, 31].</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EC_ACCESS</name>
              <description>EC_ACCESS is used to enable I2CS_EC or SPIS_EC access to internal EZ memory.
1: enable clk_scb
0: disable clk_scb

Before going to deepsleep this field should be set to 1. 
when waking up from DeepSleep power mode, and PLL is locked (clk_scb is at expected frequency), this filed should be set to 0.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
Generally when this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).

Specific to SPI master case,  when SCB is idle,  below registers can be changed without disabling SCB block,
      TX_CTRL
      TX_FIFO_CTRL
      RX_CTRL
      RX_FIFO_CTRL
      SPI_CTRL.SSEL,</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when slave mode is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000010</resetValue>
          <resetMask>0x8F017F3F</resetMask>
          <fields>
            <field>
              <name>SSEL_CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily separated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always separated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (
for Motorola as determined by CPOL and CPHA, 
for Texas Instruments on the falling edge of SCLK and 
for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_SETUP_DEL</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_HOLD_DEL</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_INTER_FRAME_DEL</name>
              <description>N/A</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': No local loopback
'1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconductors submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>Selects one of the four incoming/outgoing SPI slave select signals:
- 0: Slave 0, SSEL[0].
- 1: Slave 1, SSEL[1].
- 2: Slave 2, SSEL[2].
- 3: Slave 3, SSEL[3].
SCB block should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TX_CTRL</name>
          <description>SPI transmitter control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0').</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RX_CTRL</name>
          <description>SPI receiver control</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x130</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0').</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). 
0: Loopback is not enabled
1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0x10F3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of half bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period. 

Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. 
When '0', received data is sent to the RX FIFO. 
When '1', received data is dropped and lost. 
Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behavior when an error is detected in a start or stop period. 
When '0', received data is sent to the RX FIFO.
 When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_LEVEL</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least significant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal:
'0': RTS is active low; 
'1': RTS is active high; 

During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal
'0': CTS is active low ; 
'1': CTS is active high;</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal by the UART transmitter:
'0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.

in slave mode, this field is used to define number of clk_scb cycles for tSU-DAT timing (from ACK/NACK/data ready, to SCL rising edge (released from I2C slave clock stretching))</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>This field is used during an address match or general call address in internally clocked mode 
Only used when:
 - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
       1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
       2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>Only used when:
- non EZ mode
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
When '0', no loopback
When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x35</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2CS_IC_BUSY</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Enable for 50ns glitch filter on SDA input
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Enable for 50ns glitch filter on SCL input
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x1011F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 31]. For I2C the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

The open drain mode is supported for:
- UART mode, 'uart_tx' IO cell.
- SPI mode, 'spi_miso' IO cell.

not applicable to I2C mode, 'i2c_scl' and 'i2c_sda' IO cells. (I2C SCL/SDA always work in open-drain mode)</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is transmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x31F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 31]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptibility to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR  (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.

When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read silent</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when CTRL.EC_AM_MODE is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when CTRL.EC_AM_MODE is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode. 
(Note: This bit may be set unintentionally, even if the FIFO is not empty. 
Workaround: Ignore the bit when the clock frequency of the AHB bus is greater than 3x the internal frequency of SCB and the FIFO is not empty)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40610000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x40620000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB3</name>
      <baseAddress>0x40630000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB4</name>
      <baseAddress>0x40640000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB5</name>
      <baseAddress>0x40650000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB6</name>
      <baseAddress>0x40660000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB7</name>
      <baseAddress>0x40670000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB8</name>
      <baseAddress>0x40680000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB9</name>
      <baseAddress>0x40690000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB10</name>
      <baseAddress>0x406A0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>I2S0</name>
      <description>I2S registers</description>
      <headerStructName>I2S</headerStructName>
      <baseAddress>0x40800000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>TX_ENABLED</name>
              <description>Enables the I2S TX component:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ENABLED</name>
              <description>Enables the I2S RX component:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCK_CTL</name>
          <description>Clock control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000</resetValue>
          <resetMask>0x1313F</resetMask>
          <fields>
            <field>
              <name>CLOCK_DIV</name>
              <description>Frequency divisor for generating I2S clock frequency.
The selected clock with CLOCK_SEL is divided by this. 
'0': Bypass
'1': 2 x
'2': 3 x
'3': 4 x
...
'62': 63 x
'63': 64 x</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SEL</name>
              <description>Selects clock to be used by I2S:
'0': Internal clock ('clk_audio_i2s')
'1': External clock ('clk_i2s_if')</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLK_DIV</name>
              <description>Selects clock divider for MCLK_OUT.
CTL.TX_ENABLED=1 or CTL.RX_ENABLED=1 and and CLOCK_CTL.CLOCK_SEL=0 to enable the clock.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV1</name>
                  <description>Divide clk_audio_i2s by 1 (Bypass)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV2</name>
                  <description>Divide clk_audio_i2s by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV4</name>
                  <description>Divide clk_audio_i2s by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV8</name>
                  <description>Divide clk-audio_i2s by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MCLK_EN</name>
              <description>Enable MCLK - enables MCLK divider operation
Upon assertion allows MCLK Divider to begin operation.
Upon de-assertion, i.e. 1-0 transition, allows MCLK divider to reach the all 0s state (reset state) then freezes the divider.  This permits a controlled power-on/power-off sequence that may be used prior to going to DeepSleep/IP Disable and avoids glitching the MCLK.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCK_STAT</name>
          <description>Clock Status</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>MCLK_DIV_OFF</name>
              <description>MCLK Divider OFF
0: Indicates MCLK Divider not a reset state
1: Indicates MCLK Divider at reset state. This is ONLY set when IP is enabled (CTL.RX_ENABLED=1 or CTL.TX_ENABLED=1), CLOCK_CTL.MCLK_EN=0, and MCLK_DIV reaches it's reset state.

The intent is that this bit indicates successful shutdown of the MCLK_DIVIDER after CLOCK_CTL.MCLK_EN transitions from 1 to 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10101</resetMask>
          <fields>
            <field>
              <name>TX_START</name>
              <description>Transmitter enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PAUSE</name>
              <description>Pause enable:
'0': Disabled (TX FIFO data is sent over I2S).
'1': Enabled ('0' data is sent over I2S, instead of TX FIFO data).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_START</name>
              <description>Receiver enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>TX_REQ_EN</name>
              <description>Trigger output ('tr_i2s_tx_req') enable for requests of DMA transfer in transmission
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_REQ_EN</name>
              <description>Trigger output ('tr_i2s_rx_req') enable for requests of DMA transfer in reception
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTL</name>
          <description>Transmitter control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x440510</resetValue>
          <resetMask>0x37737F8</resetMask>
          <fields>
            <field>
              <name>B_CLOCK_INV</name>
              <description>Serial data transmission is advanced by 0.5 SCK cycles. This bit is valid only in TX slave mode.
When set to '1', the serial data will be transmitted 0.5 SCK cycles earlier than when set to '0'. 

1) TX_CTL.SCKI_POL=0 and TX_CTL.B_CLOCK_INV=0: Serial data will be transmitted off the SCK falling edge
2) TX_CTL.SCKI_POL=0 and TX_CTL.B_CLOCK_INV=1: Serial data will be transmitted off the SCK rising edge that is 0.5 SCK cycles before the SCK falling edge in 1)
3) TX_CTL.SCKI_POL=1 and TX_CTL.B_CLOCK_INV=0: Serial data will be transmitted off the SCK rising edge
4) TX_CTL.SCKI_POL=1 and TX_CTL.B_CLOCK_INV=1: Serial data will be transmitted off the SCK falling edge that is 0.5 SCK cycles before the SCK rising edge in 3)

(Note that this is only the appearance w.r.t. SCK edge, the actual timing is generated by an internal clock that runs 8x the SCK frequency). The word sync (TX_WS) signal is not affected by this bit setting. 
Note: When Master mode, must be '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALLING_EDGE_TX</name>
                  <description>SDO transmitted at SCK falling edge when TX_CTL.SCKI_POL=0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING_EDGE_TX</name>
                  <description>SDO transmitted at SCK rising edge when TX_CTL.SCKI_POL=0</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_NR</name>
              <description>Specifies number of channels per frame:

Note: only '2channels' is supported during Left Justfied or I2S mode. Hence software must set '1' to this field in the modes.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CH_NUM1</name>
                  <description>1 channel</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM2</name>
                  <description>2 channels</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM3</name>
                  <description>3 channels</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM4</name>
                  <description>4 channels</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM5</name>
                  <description>5 channels</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM6</name>
                  <description>6 channels</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM7</name>
                  <description>7 channels</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM8</name>
                  <description>8 channels</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MS</name>
              <description>Set interface in master or slave mode:</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLAVE</name>
                  <description>Slave</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASTER</name>
                  <description>Master</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_MODE</name>
              <description>Select I2S, left-justified or TDM:</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEFT_JUSTIFIED</name>
                  <description>Left Justified</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S</name>
                  <description>I2S mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_A</name>
                  <description>TDM mode A, the 1st Channel align to WSO 
Rising Edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_B</name>
                  <description>TDM mode B, the 1st Channel align to WSO
Rising edge with1 SCK Delay</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WS_PULSE</name>
              <description>Set WS pulse width in TDM mode:

Note: When not TDM mode, must be '1'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCK_PERIOD</name>
                  <description>Pulse width is 1 SCK period</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_LENGTH</name>
                  <description>Pulse width is 1 channel length</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVHDATA</name>
              <description>Set overhead value:
'0': Set to '0'
'1': Set to '1'</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WD_EN</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_LEN</name>
              <description>Channel length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- When TDM mode, must be 32-bit length to this field.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WORD_LEN</name>
              <description>Word length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- Don't configure this field as beyond Channel length.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCKO_POL</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKI_POL</name>
              <description>N/A</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_WATCHDOG</name>
          <description>Transmitter watchdog</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WD_COUNTER</name>
              <description>Start value of the TX watchdog. With the reset value of 0x0000:0000 the counter is disabled. This is clocked by the AHB-Lite system clock 'clk_sys'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTL</name>
          <description>Receiver control</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x440510</resetValue>
          <resetMask>0x3F727F8</resetMask>
          <fields>
            <field>
              <name>B_CLOCK_INV</name>
              <description>Serial data capture is delayed by 0.5 SCK cycles. This bit is valid only in RX master mode.
When set to '1', the serial data will be captured 0.5 SCK cycles later than when set to '0'.

1) RX_CTL.SCKO_POL=0 and RX_CTL.B_CLOCK_INV=0: Serial data will be captured by the SCK rising edge
2) RX_CTL.SCKO_POL=0 and RX_CTL.B_CLOCK_INV=1: Serial data will be captured by the SCK falling edge that is 0.5 SCK cycles after the SCK rising edge in 1)
3) RX_CTL.SCKO_POL=1 and RX_CTL.B_CLOCK_INV=0: Serial data will be captured by the SCK falling edge
4) RX_CTL.SCKO_POL=1 and RX_CTL.B_CLOCK_INV=1: Serial data will be captured by the SCK rising edge that is 0.5 SCK cycles after the SCK falling edge in 3)

(Note that this is only the appearance w.r.t. SCK edge, the actual capture timing is derived from an internal clock that runs 8x the SCK frequency). The word sync (RX_WS) signal is not affected by this bit setting. 
Note: When Slave mode, must be '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RISING_EDGE_RX</name>
                  <description>SDI received at SCK rising edge when RX_CTL.SCKO_POL=0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING_EDGE_RX</name>
                  <description>SDI received at SCK falling edge when RX_CTL.SCKO_POL=0</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_NR</name>
              <description>Specifies number of channels per frame:

Note: only '2channels' is supported during Left Justfied or I2S mode. Hence software must set '1' to this field in the modes.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CH_NUM1</name>
                  <description>1 channel</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM2</name>
                  <description>2 channels</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM3</name>
                  <description>3 channels</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM4</name>
                  <description>4 channels</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM5</name>
                  <description>5 channels</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM6</name>
                  <description>6 channels</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM7</name>
                  <description>7 channels</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM8</name>
                  <description>8 channels</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MS</name>
              <description>Set interface in master or slave mode:</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLAVE</name>
                  <description>Slave</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASTER</name>
                  <description>Master</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_MODE</name>
              <description>Select I2S, left-justified or TDM:</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEFT_JUSTIFIED</name>
                  <description>Left Justified</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S</name>
                  <description>I2S mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_A</name>
                  <description>TDM mode A, the 1st Channel align to WSO 
Rising Edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_B</name>
                  <description>TDM mode B, the 1st Channel align to WSO
Rising edge with1 SCK Delay</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WS_PULSE</name>
              <description>Set WS pulse width in TDM mode:
Note: When not TDM mode, must be '1'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCK_PERIOD</name>
                  <description>Pulse width is 1 SCK period</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_LENGTH</name>
                  <description>Pulse width is 1 channel length</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WD_EN</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_LEN</name>
              <description>Channel length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- When TDM mode, must be 32-bit length to this field.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WORD_LEN</name>
              <description>Word length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- Don't configure this field as beyond Channel length.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIT_EXTENSION</name>
              <description>N/A</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKO_POL</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKI_POL</name>
              <description>N/A</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_WATCHDOG</name>
          <description>Receiver watchdog</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WD_COUNTER</name>
              <description>Start value of the RX watchdog. With the reset value of 0x0000:0000 the counter is disabled. This is clocked by the AHB-Lite system clock 'clk_sys'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTL</name>
          <description>TX FIFO control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the TX FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the TX FIFO and TX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the TX FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer. This field is used only for debugging purposes.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>TX FIFO status</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of entries in the TX FIFO. The field value is in the range [0, 256].</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>TX FIFO read pointer: FIFO location from which a data frame is read by the hardware.This field is used only for debugging purposes.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>TX FIFO write pointer: FIFO location at which a new data frame is written by the host. This field is used only for debugging purposes.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>TX FIFO write</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data written into the TX FIFO. Behavior is similar to that of a PUSH operation. 
Note: Don't access to this register while TX_FIFO_CTL.CLEAR is '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTL</name>
          <description>RX FIFO control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated.
Note: software can configure up to 253 in I2S mode or Left Justified (RX_CTL.I2S_MODE = '0' or '1'). In TDM mode (RX_CTL.I2S_MODE = '2' or '3'), it can configure up to [256 - (RX_CTL.CH_NR+2)].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the RX FIFO and RX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the RX FIFO have no effect. Freeze will not advance the RX FIFO write pointer. This field is used only for debugging purposee.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>RX FIFO status</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of entries in the RX FIFO. The field value is in the range [0, 256].</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>RX FIFO read pointer: FIFO location from which a data frame is read by the host. This field is used only for debugging purposes.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>RX FIFO write pointer: FIFO location at which a new data frame is written by the hardware. This field is used only for debugging purposes.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>RX FIFO read</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the RX FIFO. Reading a data frame will remove the data frame from the RX FIFO; i.e. behavior is similar to that of a POP operation. 
Notes: 
 - Don't access to this register while RX_FIFO_CTL.CLEAR is '1'. 
 - Two stored data may be not valid after CMD.RX_START is set '1'. Therefore we recommend software discard those data.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>RX FIFO silent read</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the RX FIFO. Reading a data frame will NOT remove the data frame from the RX FIFO; i.e. behavior is similar to that of a PEEK operation. This field is used only for debugging purposes.
Notes: 
 - Don't access to this register while RX_FIFO_CTL.CLEAR is '1'. 
 - Two stored data may be not valid after CMD.RX_START is set '1'. Therefore we recommend software discard those data.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TRIGGER_LEVEL in TX_FIFO_CTRL.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>TX FIFO is not full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and TX_EMPTY is '1'.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Triggers (sets to '1') when the Tx watchdog event occurs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in RX_FIFO_CTRL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>RX FIFO is not empty.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>RX FIFO is full.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Triggers (sets to '1') when the Rx watchdog event occurs.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S1</name>
      <baseAddress>0x40801000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S2</name>
      <baseAddress>0x40802000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PASS0</name>
      <description>Programmable Analog Subsystem for S40E</description>
      <headerStructName>PASS</headerStructName>
      <baseAddress>0x40900000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>1048576</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>3</dim>
          <dimIncrement>4096</dimIncrement>
          <name>SAR[%s]</name>
          <description>SAR ADC with Sequencer for S40E</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Analog control register.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xE00007FF</resetMask>
            <fields>
              <field>
                <name>PWRUP_TIME</name>
                <description>Number cycles to wait to power up after IDLE_PWRDWN.
Check the STATUS.PWRUP_BUSY flag to see if the delay is still in progress.
The power up delay is 1 us.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IDLE_PWRDWN</name>
                <description>When idle automatically power down the analog.
After an automatic power down a new trigger will power up the analog, however it will take PWRUP_TIME cycles before the first acquisition can be started. Note that re-arbitration happens at that time, i.e. the trigger that caused the power up may not get handled first.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MSB_STRETCH</name>
                <description>When set use 2 cycles for the Most Significant Bit (MSB)
- 0: Use 1 clock cycle for MSB
- 1: Use 2 clock cycles for MSB</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HALF_LSB</name>
                <description>When set take an extra cycle to convert the half LSB and add it to 12-bit result for Missing Code Recovery
This bit should always be set to '1'
- 0: disable half LSB conversion (not recommended)
- 1: enable half LSB conversion</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SARMUX_EN</name>
                <description>Enable the SARMUX (only valid if ENABLED=1)
- 0: SARMUX disabled (put analog in power down)
- 1: SARMUX enabled.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADC_EN</name>
                <description>Enable the SAR ADC and SAR sequencer (only valid if ENABLED=1)
- 0: SARADC and SARSEQ are disabled (put SARADC analog in power down and stop clocks), also clears all pending triggers.
- 1: SAR ADC and SARSEQ are enabled.
To enable ADC0 to borrow SARMUX1-3 the corresponding ADC_EN must  be set to 0.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>- 0: SAR IP disabled (put analog in power down and stop clocks), also clears all pending triggers.
- 1: SAR IP enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DIAG_CTL</name>
            <description>Diagnostic Reference control register.</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>DIAG_SEL</name>
                <description>Select Diagnostic Reference function</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>VREFL</name>
                    <description>DiagOut = VrefL</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH_1DIV8</name>
                    <description>DiagOut = VrefH * 1/8</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH_2DIV8</name>
                    <description>DiagOut = VrefH * 2/8</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH_3DIV8</name>
                    <description>DiagOut = VrefH * 3/8</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH_4DIV8</name>
                    <description>DiagOut = VrefH * 4/8</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH_5DIV8</name>
                    <description>DiagOut = VrefH * 5/8</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH_6DIV8</name>
                    <description>DiagOut = VrefH * 6/8</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH_7DIV8</name>
                    <description>DiagOut = VrefH * 7/8</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH</name>
                    <description>DiagOut = VrefH</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFX</name>
                    <description>DiagOut = VrefX = VrefH * 199/200</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VBG</name>
                    <description>DiagOut = Vbg from SRSS</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VIN1</name>
                    <description>DiagOut = Vin1</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VIN2</name>
                    <description>DiagOut = Vin2</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VIN3</name>
                    <description>DiagOut = Vin3</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>I_SOURCE</name>
                    <description>DiagOut = Isource (10uA)</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>I_SINK</name>
                    <description>DiagOut = Isink (10uA)</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIAG_EN</name>
                <description>Diagnostic Reference enable (only valid if ENABLED=1)
- 0: Diagnostic Reference disabled (powered down resistor ladder and current mirrors, DiagOut = Vssa).
- 1: Diagnostic Reference enabled, output signal select according to DIAG_SEL (note also EPASS_MMIO.PASS_CTL.REFBUF_EN must be set).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PRECOND_CTL</name>
            <description>Preconditioning control register.</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>PRECOND_TIME</name>
                <description>Number ADC clock cycles that Preconditioning is done before the sample window starts. If OVERLAP_EN=0 there will be 1 additional break before make cycle between preconditioning and sampling.
Note that the minimum value is 1 (0 gives the same result as 1).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CAL</name>
            <description>Current analog calibration values</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F00FF</resetMask>
            <fields>
              <field>
                <name>AOFFSET</name>
                <description>Analog offset correction</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGAIN</name>
                <description>Analog gain correction</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DIG_CAL</name>
            <description>Current digital calibration values</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F0FFF</resetMask>
            <fields>
              <field>
                <name>DOFFSET</name>
                <description>Digital offset correction
Subtract DOFFSET from ADC output.</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DGAIN</name>
                <description>Digital gain correction.
Signed value to correct +/- 30 codes for the maximum input voltage.
Corrected = (D - DOFFSET) + ( (D - DOFFSET) * DGAIN + 0x800) / 0x1000</description>
                <bitRange>[21:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CAL_ALT</name>
            <description>Alternate analog calibration values</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F00FF</resetMask>
            <fields>
              <field>
                <name>AOFFSET</name>
                <description>See corresponding ANA_CAL field</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGAIN</name>
                <description>See corresponding ANA_CAL field</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DIG_CAL_ALT</name>
            <description>Alternate digital calibration values</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F0FFF</resetMask>
            <fields>
              <field>
                <name>DOFFSET</name>
                <description>See corresponding DIG_CAL field</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DGAIN</name>
                <description>See corresponding DIG_CAL field</description>
                <bitRange>[21:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_UPD_CMD</name>
            <description>Calibration update command</description>
            <addressOffset>0x98</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>UPDATE</name>
                <description>Calibration update command: coherently copy values from alternate calibration regs to current calibration regs.
Software sets this bit when the alternate calibration values have been set with the new values. Hardware will do the calibration update as soon as the ADC is idle or a 'continuous' triggered group completes. This ensures that all acquisitions within a group scan (even if preempted) are done with the same calibration values.
This bit is cleared at the same time the calibration update is done. By clearing this bit software can cancel a requested update.
Note: if the ADC is always busy with acquisitions for non continuously triggered groups/channels then the calibration update will remain pending forever. In such a case the software can either  do a non coherent update by writing directly to the current calibration registers, or software can force the ADC to idle by disabling some or all channels.
Software can check/poll this bit to see if the calibration update has taken effect.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_PEND</name>
            <description>Trigger pending status</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TR_PEND</name>
                <description>Trigger Pending. 
Hardware will set this bit if a hardware trigger is received.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WORK_VALID</name>
            <description>Channel working data register 'valid' bits</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WORK_VALID</name>
                <description>If set the corresponding WORK register is valid, i.e. was already acquired during the current group scan. If this bit is low then either the channel is not enabled, not yet acquired or it is used as a pulse detect channel.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WORK_RANGE</name>
            <description>Range detected</description>
            <addressOffset>0x184</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RANGE</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WORK_RANGE_HI</name>
            <description>Range detect above Hi flag</description>
            <addressOffset>0x188</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ABOVE_HI</name>
                <description>Out of range was detected and the value was above the Hi threshold</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WORK_PULSE</name>
            <description>Pulse detected</description>
            <addressOffset>0x18C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PULSE</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESULT_VALID</name>
            <description>Channel result data register 'valid' bits</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESULT_VALID</name>
                <description>If set the corresponding RESULT register is valid, i.e. was acquired during the preceding group scan. If this bit is low, after a group scan completed, then either the channel is not enabled or is used as a pulse  detect channel.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESULT_RANGE_HI</name>
            <description>Channel Range above Hi flags</description>
            <addressOffset>0x1A4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ABOVE_HI</name>
                <description>Out of range was detected and the value was above the Hi threshold</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Current status of internal SAR registers (mostly for debug)</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xE000371F</resetMask>
            <fields>
              <field>
                <name>CUR_CHAN</name>
                <description>current channel being acquired, only valid if BUSY.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CUR_PRIO</name>
                <description>priority of current group/channel, only valid if BUSY.</description>
                <bitRange>[10:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CUR_PREEMPT_TYPE</name>
                <description>Preempting type of current group/channel, only valid if BUSY.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DBG_FREEZE</name>
                <description>If high then the SAR is prevented from starting a new acquisition, see DBG_FREEZE_EN.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PWRUP_BUSY</name>
                <description>If high then the SAR is waiting for PWRUP_TIME due to IDLE_PWRDWN</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>If high then the SAR is busy with a conversion.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AVG_STAT</name>
            <description>Current averaging status (for debug)</description>
            <addressOffset>0x204</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF0FFFFF</resetMask>
            <fields>
              <field>
                <name>CUR_AVG_ACCU</name>
                <description>the current value of the averaging accumulator</description>
                <bitRange>[19:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CUR_AVG_CNT</name>
                <description>the current value of the averaging counter. Note that the value shown is updated after the sample window and therefore runs ahead of the accumulator update.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>32</dim>
            <dimIncrement>64</dimIncrement>
            <name>CH[%s]</name>
            <description>Channel structure</description>
            <addressOffset>0x00000800</addressOffset>
            <register>
              <name>TR_CTL</name>
              <description>Trigger control.</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x800</resetValue>
              <resetMask>0x80000B77</resetMask>
              <fields>
                <field>
                  <name>SEL</name>
                  <description>Trigger select</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OFF</name>
                      <description>Use for channels in group, except the first channel</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TCPWM</name>
                      <description>Trigger from corresponding TCPWM channel</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GENERIC0</name>
                      <description>Generic trigger input 0</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GENERIC1</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GENERIC2</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GENERIC3</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GENERIC4</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CONTINUOUS</name>
                      <description>Always triggered (also called idle), can only be used for at most 1 channel</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>PRIO</name>
                  <description>Channel priority:
'0': highest priority.
'1'
...
'6'
'7': lowest priority.

Channels with the same priority constitute a priority level. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority level with pending channels is identified. Second, within this priority level, round robin arbitration is applied. Round robin arbitration (within a priority level) gives the highest priority to the lower channel indices (within the priority level).</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PREEMPT_TYPE</name>
                  <description>Preemption type allow for this group</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>ABORT_CANCEL</name>
                      <description>Abort ongoing acquisition, do not return
Clear pending trigger for aborted group and set Cancelled interrupt.
Also 'Abort' whenever this group (do not pend the trigger) is not immediately scheduled for acquisition after a new trigger arrives. ...</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ABORT_RESTART</name>
                      <description>Abort ongoing acquisition, up on return Restart group from first channel.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ABORT_RESUME</name>
                      <description>Abort ongoing acquisition, up on return Resume group from aborted channel
If averaging, discard averaging results so far and restart averaging.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FINISH_RESUME</name>
                      <description>Complete ongoing acquisition (including averaging), up on return Resume group from next channel</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>GROUP_END</name>
                  <description>0: continue group with next channel
1: last channel of a group.

Note that for the channel with the highest index (SAR_CH_NR) this always needs to be set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DONE_LEVEL</name>
                  <description>select level or pulse for 'tr_ch_done' trigger output 
Also see POST_CTL.TR_DONE_GRP_VIO</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>PULSE</name>
                      <description>tr_ch_done generates a 2 cycle pulse (clk_sys), no need to read the result to clear (also no ch_overflow detection)</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LEVEL</name>
                      <description>tr_ch_done  is a level output until the result register is read (typical for DW usage, this also enables ch_overflow detection when DW is too slow)</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>SAMPLE_CTL</name>
              <description>Sample control.</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>PIN_ADDR</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PORT_ADDR</name>
                  <description>Select the physical port. This field is only valid for ADC0.
ADC0 can control and connect to the SARMUX of the neighboring ADC1-3. This requires the corresponding ADC to be off while the SARMUX is left on.
When ADC0 controls another SARMUX it uses the PIN_ADDR, EXT_MUX_EN/SEL of this channel to control the other SARMUX.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SARMUX0</name>
                      <description>ADC uses it's own SARMUX</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SARMUX1</name>
                      <description>ADC0 uses SARMUX1 (only valid for ADC0, undefined result if used for ADC1-3)</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SARMUX2</name>
                      <description>ADC0 uses SARMUX2 (only valid for ADC0, undefined result if used for ADC1-3)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SARMUX3</name>
                      <description>ADC0 uses SARMUX3 (only valid for ADC0, undefined result if used for ADC1-3)</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>EXT_MUX_SEL</name>
                  <description>External analog mux select.
This bit setting is related to EXT_MUX[x]_y on pin assignment.
 0x0: Select EXT_MUX[x]_0 pin
 0x1: Select EXT_MUX[x]_1 pin</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EXT_MUX_EN</name>
                  <description>External analog mux enable.
This enable can  be used as enable (chip select) for the external analog mux (this enable is not used as enable for the GPIO output driver).
This enable also prevents unnecessary toggle activity on the select signals of the external analog mux. When this enable is low EXT_MUX_SEL value will be ignored and the previous value will be maintained.  
Note that an external analog mux can only be used in combination with a pin input, i.e. PIN_ADDR&lt;32 or Vmotor. If an internal signal is selected this enable should be 0.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PRECOND_MODE</name>
                  <description>Select preconditioning mode.
Preconditioning (dis)charges the SAR sample capacitor to the selected reference voltage for PRECOND_TIME (global) cycles, a break before make cycle will be inserted before sampling starts (SAMPLE_TIME).</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OFF</name>
                      <description>No preconditioning</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>VREFL</name>
                      <description>Discharge to VREFL</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>VREFH</name>
                      <description>Charge to VREFH</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIAG</name>
                      <description>Connect the Diagnostic reference output during preconditioning. The Diagnostic reference should be configured to output a reference voltage.
Note: this selection is mutual exclusive with using the Diagnostic reference to supply an ibias current for OVERLAP.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OVERLAP_DIAG</name>
                  <description>Select Overlap mode or SARMUX Diagnostics, in both cases the Diagnostic reference is used.
With Overlap the Diagnostic reference typically sources or sinks a small current which is connected at the same time as the analog signal being sampled.
For SARMUX Diagnostics the Diagnostic reference should provide a reference voltage which is selected at the SARMUX input instead of the normal analog signal being sampled.</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OFF</name>
                      <description>No overlap or SARMUX Diagnostics</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HALF</name>
                      <description>Sample the selected analog input for 2 SAMPLE_TIME periods. During the first period use overlap sampling, i.e. connect both the analog input and Diagnostic reference. During second period only connect the analog input.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FULL</name>
                      <description>Like normal sample the selected analog input for a single SAMPLE_TIME period but use overlap sampling, i.e. connect both the analog input and Diagnostic reference.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MUX_DIAG</name>
                      <description>Select Diagnostic reference instead of analog signal at the input of the SARMUX. This enables a functional safety check of the SARMUX analog connections.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>SAMPLE_TIME</name>
                  <description>Sample time (aperture) in ADC clock cycles. Minimum is 1 (0 gives the same result as 1), minimum time needed for proper settling is at least 412ns, i.e.11 clock cycles at the max frequency of 26.7MHz.</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ALT_CAL</name>
                  <description>Use alternate calibration values instead of the current calibration values.
This allows the firmware to allocate one or more channels to quietly re-calibrate the ADC in the background of regular processing.
0 = use regular calibration values (ANA/DIG_CAL)
1 = use alternate calibration values (ANA/DIG_CAL_ALT)
Note: typically calibration measurements select VrefL (PIN_ADDR=62) or VrefH (PIN_ADDR=63)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>POST_CTL</name>
              <description>Post processing control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>POST_PROC</name>
                  <description>Post processing</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NONE</name>
                      <description>No postprocessing</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AVG</name>
                      <description>Averaging</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AVG_RANGE</name>
                      <description>Averaging followed by Range detect</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE</name>
                      <description>Range detect</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_PULSE</name>
                      <description>Range detect followed by pulse detect</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD0</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD1</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD2</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>LEFT_ALIGN</name>
                  <description>Left or right align data in result[15:0]. 
0: the data is right aligned in result[11:0], with sign extension to 16 bits if enabled
1: the data is left aligned in result[15:4] with the lower nibble 0. Caveat if the result was more than 12 bits (e.g. after averaging) then the bits above 12 will be discarded.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SIGN_EXT</name>
                  <description>Output data is sign extended</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>UNSIGNED</name>
                      <description>Default: result data is unsigned (zero extended if needed)</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIGNED</name>
                      <description>Result data is signed (sign extended if needed)</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>AVG_CNT</name>
                  <description>Either averaging count (minus 1) or Pulse positive reload value

Averaging Count for channels that have averaging enabled. A channel will be sampled (AVG_CNT+1) = [1..256] times.
The signal will be acquired back to back  (1st order accumulate and dump filter), the average result is calculated and stored and then the next enabled channel is sampled.
If more than 16 sample are taken (AVG_CNT&gt;=16) then AVG_SHIFT must be set so that the result after shifting fits in 16 bits

Pulse detect positive reload value PULSE_POS_RL[7:0]</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SHIFT_R</name>
                  <description>Either Shift Right (no pulse detection) or Pulse negative reload value (if pulse detection is enabled)

Shift right SHIFT_R[3:0] = [0..12]: the result (typically after averaging) is shifted right as specified here. Software has to make sure that the result fits in less than 16 bits. 
Any value &gt;12 will be treated as 12, bit [4] is always ignored. This can also be used to fit the 12-bit result in 8 bits.

Pulse detect negative reload value PULSE_NEG_RL[4:0]</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RANGE_MODE</name>
                  <description>Range detect mode</description>
                  <bitRange>[23:22]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BELOW_LO</name>
                      <description>Below Low threshold (result &lt; Lo)</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INSIDE_RANGE</name>
                      <description>Inside range (Lo &lt;= result &lt; Hi)</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ABOVE_HI</name>
                      <description>Above high threshold (Hi &lt;= result)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>OUTSIDE_RANGE</name>
                      <description>Outside range (result &lt; Lo || Hi &lt;= result)</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>TR_DONE_GRP_VIO</name>
                  <description>Select tr_sar_ch_done mode for last channel of a group, ignored for all other channels
Also see TR_CTL.DONE_LEVEL</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DONE</name>
                      <description>Default: tr_sar_ch_done is set when the group is done</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GRP_RANGE_VIO</name>
                      <description>tr_sar_ch_done  is only set if any of the channels in the group has a Range Violation. This mode is ignored if this is not the last channel in the group.
Note that if none of the channels in the group have Range detection enabled then the trigger will never get set.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>RANGE_CTL</name>
              <description>Range thresholds</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>RANGE_LO</name>
                  <description>Range detect low threshold (Lo)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RANGE_HI</name>
                  <description>Range detect high threshold (Hi)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR</name>
              <description>Interrupt request register.</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x707</resetMask>
              <fields>
                <field>
                  <name>GRP_DONE</name>
                  <description>Done Interrupt: hardware sets this interrupt for the last channel of a group if the group scan is done. Write with '1' to clear bit.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GRP_CANCELLED</name>
                  <description>Cancelled Interrupt: hardware sets this interrupt for the last channel of a group if the group scan was preempted and CANCELLED. Note that it is possible that also the GRP_DONE interrupt is set. If that is the case one or more new triggers were detected while the group was already busy, i.e. triggers are too fast.   Write with '1' to clear bit.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GRP_OVERFLOW</name>
                  <description>Overflow Interrupt: hardware sets this interrupt for the last channel of a group if the group scan is done and the Done interrupt is already (still) pending. Write with '1' to clear bit.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_RANGE</name>
                  <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. This interrupt is mutual exclusive with Pulse detect interrupt. Write with '1' to clear bit.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_PULSE</name>
                  <description>Pulse detect Interrupt: hardware sets this interrupt for each channel if the positive pulse counter reaches zero. This interrupt is mutual exclusive with Range detect interrupt. Write with '1' to clear bit.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_OVERFLOW</name>
                  <description>Channel overflow Interrupt: hardware sets this interrupt for each channel if a new Pulse or Range interrupt is detected while the interrupt is still pending or when DW did not acknowledge data pickup. Write with '1' to clear bit.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_SET</name>
              <description>Interrupt set request register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x707</resetMask>
              <fields>
                <field>
                  <name>GRP_DONE_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GRP_CANCELLED_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GRP_OVERFLOW_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_RANGE_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_PULSE_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_OVERFLOW_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASK</name>
              <description>Interrupt mask register.</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x707</resetMask>
              <fields>
                <field>
                  <name>GRP_DONE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GRP_CANCELLED_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GRP_OVERFLOW_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_RANGE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_PULSE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_OVERFLOW_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASKED</name>
              <description>Interrupt masked request register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x707</resetMask>
              <fields>
                <field>
                  <name>GRP_DONE_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GRP_CANCELLED_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GRP_OVERFLOW_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CH_RANGE_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CH_PULSE_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CH_OVERFLOW_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>WORK</name>
              <description>Working data register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0000000</resetMask>
              <fields>
                <field>
                  <name>WORK</name>
                  <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ABOVE_HI_MIR</name>
                  <description>mirror bit of the corresponding ABOVE_HI bit</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RANGE_MIR</name>
                  <description>mirror bit of corresponding bit in WORK_RANGE register</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PULSE_MIR</name>
                  <description>mirror bit of corresponding bit in WORK_PULSE register</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID_MIR</name>
                  <description>mirror bit of corresponding bit in WORK_VALID register</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RESULT</name>
              <description>Result data register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0000000</resetMask>
              <fields>
                <field>
                  <name>RESULT</name>
                  <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ABOVE_HI_MIR</name>
                  <description>mirror bit of the corresponding ABOVE_HI bit</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RANGE_INTR_MIR</name>
                  <description>mirror bit of INTR.CH_RANGE bit</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PULSE_INTR_MIR</name>
                  <description>mirror bit of INTR.CH_PULSE bit</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID_MIR</name>
                  <description>mirror bit of the corresponding bit in RESULT_VALID register</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GRP_STAT</name>
              <description>Group status register</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x10707</resetMask>
              <fields>
                <field>
                  <name>GRP_COMPLETE</name>
                  <description>Group acquisition complete. 
This is a copy of the INTR.GRP_DONE bit.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GRP_CANCELLED</name>
                  <description>Group Cancelled. 
This is a copy of the INTR.GRP_CANCELLED bit.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GRP_OVERFLOW</name>
                  <description>Group Overflow. 
This is a copy of the INTR.GRP_OVERFLOW bit.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CH_RANGE_COMPLETE</name>
                  <description>Channel Range complete. 
This is a copy of the INTR.CH_RANGE bit.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CH_PULSE_COMPLETE</name>
                  <description>Channel Pulse complete. 
This is a copy of the INTR.CH_PULSE bit.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CH_OVERFLOW</name>
                  <description>Channel Overflow. 
This is a copy of the INTR.CH_OVERFLOW bit.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GRP_BUSY</name>
                  <description>Group acquisition busy. 
This is a copy of the TR_PENDING bit of the first channel of the group.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENABLE</name>
              <description>Enable register</description>
              <addressOffset>0x38</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>CHAN_EN</name>
                  <description>Channel enable. 
- 0: the corresponding channel is disabled. Corresponding trigger will be reset immediately.
- 1: the corresponding channel is enabled.

Note: To disable a group either stop the trigger first or begin with disabling the lowest channel first. To enable a group either start with enabling the last channel first and the first channel last, or start the trigger after all channels are enabled. If these rules are not followed the result is undefined.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_CMD</name>
              <description>Software triggers</description>
              <addressOffset>0x3C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>START</name>
                  <description>Software start trigger. When written with '1', a start trigger is generated which sets the corresponding TR_PEND bit (only if the channel is enabled). A read always returns a 0.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>EPASS_MMIO</name>
          <description>PASS top-level MMIO (Generic Triggers)</description>
          <addressOffset>0x000F0000</addressOffset>
          <register>
            <name>PASS_CTL</name>
            <description>PASS control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0600033</resetMask>
            <fields>
              <field>
                <name>SUPPLY_MON_EN_A</name>
                <description>Supply monitor enable for AMUXBUS_A (amuxbus_a_mon)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUPPLY_MON_LVL_A</name>
                <description>Supply monitor level select for AMUXBUS_A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>VRL</name>
                    <description>amuxbus_a_mon = VRL</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VRH</name>
                    <description>amuxbus_a_mon = VRH</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUPPLY_MON_EN_B</name>
                <description>Supply monitor enable for AMUXBUS_B (amuxbus_b_mon)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUPPLY_MON_LVL_B</name>
                <description>Supply monitor level select for AMUXBUS_B</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>VRL</name>
                    <description>amuxbus_b_mon = VRL</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VRH</name>
                    <description>amuxbus_b_mon = VRH</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REFBUF_MODE</name>
                <description>Reference mode.
The reference needs to be present when using TEMP sensor or diagnostic reference (in addition to SAR.DIAG_CTL.DIAG_EN). 
Note that setting this mode is not required for the ADC operation itself.</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>No reference</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ON</name>
                    <description>Reference = buffered Vbg from SRSS</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>undefined</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BYPASS</name>
                    <description>Reference = unbuffered Vbg from SRSS</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Debug pause enable, 1 per ADC.
When set a high tr_debug_freeze trigger will prevent the scheduler from starting acquisitions on a new channel. Note that averaging for an already started channel will be completed.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>SAR_TR_IN_SEL[%s]</name>
            <description>per SAR generic input trigger select</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x43210</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>IN0_SEL</name>
                <description>Select generic trigger for SAR generic trigger input 0</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN1_SEL</name>
                <description>Select generic trigger for SAR generic trigger input 1</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN2_SEL</name>
                <description>Select generic trigger for SAR generic trigger input 2</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN3_SEL</name>
                <description>Select generic trigger for SAR generic trigger input 3</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN4_SEL</name>
                <description>Select generic trigger for SAR generic trigger input 4</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>SAR_TR_OUT_SEL[%s]</name>
            <description>per SAR generic output trigger select</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x3F3F</resetMask>
            <fields>
              <field>
                <name>OUT0_SEL</name>
                <description>Select SAR output trigger for generic trigger output 0
0-31: selects a tr_sar_ch_done trigger
32-63: selects a tr_sar_ch_rangvio trigger</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1_SEL</name>
                <description>Select SAR output trigger for generic trigger output 1</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TEST_CTL</name>
            <description>Test control bits</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x137D</resetMask>
            <fields>
              <field>
                <name>TS_CAL_CUR_IN</name>
                <description>External current input switch control, for Temperature Sensor Calibration</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TS_CAL_VB_OUT</name>
                <description>Voltage Base switch control, for Temperature Sensor Calibration</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TS_CAL_VE_OUT</name>
                <description>Voltage Emitter switch control, for Temperature Sensor Calibration</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TS_CAL_DIODE_EN</name>
                <description>Diode Enable, disconnect or connect the base and collector terminal of the BJT</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TS_CAL_DIODE_PNP_EN</name>
                <description>Enable signal for PNP transistor. This transistor will be used only during calibration for accurate estimation of chip temp.
0 = Turn PNP off
1 = Configure PNP as a diode (short base and collector)</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TS_CAL_VI_SEL</name>
                <description>Select current or voltage output on 'v_temp' pin, for Temperature Sensor Calibration</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CURRENT</name>
                    <description>Current is selected</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VOLTAGE</name>
                    <description>Voltage is selected</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS_CAL_CUR_SEL</name>
                <description>Select the current going into the BJT, for Temperature Sensor Calibration</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>I_1U</name>
                    <description>Select 1 uA</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>I_2U</name>
                    <description>Select 2 uA</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>I_5U</name>
                    <description>Select 5 uA</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>I_10U</name>
                    <description>Select 10 uA</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS_CAL_SPARE</name>
                <description>Spare</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
  </peripherals>
</device>