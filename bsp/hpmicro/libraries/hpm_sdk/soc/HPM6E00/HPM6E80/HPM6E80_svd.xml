<?xml version="1.0" encoding="UTF-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>HPMICRO</vendor>
  <name>HPM6E80</name>
  <series>HPM6E00</series>
  <version>1.0</version>
  <description>HPM6E00 device</description>
  <licenseText>
    /*
 * Copyright (c) 2021-2024 HPMicro
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

  </licenseText>
  <cpu>
    <name>other</name>
    <revision>r0p0</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>7</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>

  <!-- Default Properties -->
  <addressUnitBits>8</addressUnitBits> <!-- byte addressable memory -->
  <width>32</width> <!-- bus width is 32 bits -->
  <size>32</size>          <!-- this is the default size (number of bits) of all peripherals and register that do not define "size" themselves -->
  <access>read-write</access>  <!-- default access permission for all subsequent registers -->
  <resetValue>0x0</resetValue>  <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>  <!-- by default all 32Bits of the registers are used -->

  <!-- peripherals -->
  <peripherals>
    <peripheral>
      <name>FGPIO</name>
      <description>FGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x300000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x900</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>DI[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO input value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INPUT</name>
                <description>GPIO input bus value, each bit represents a bus bit
0: low level presents on chip pin
1: high level presents on chip pin</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>DO[%s]</name>
          <description>no description available</description>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO output value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO output set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO output clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO output toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>OE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO direction value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO direction set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO direction clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO direction toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>IF[%s]</name>
          <description>no description available</description>
          <addressOffset>0x300</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt flag value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_FLAG</name>
                <description>GPIO interrupt flag, write 1 to clear this flag
0: no irq
1: irq pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>IE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt enable value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt enable set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt enable clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt enable toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>PL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x500</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt polarity value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt polarity set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt polarity clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt polarity toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>TP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt type value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt type set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt type clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt type toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>AS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x700</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt asynchronous value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt asynchronous set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt asynchronous clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt asynchronous toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,gpiov,gpiow,gpiox,gpioy,gpioz</dimIndex>
          <name>PD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x800</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO dual edge interrupt enable value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>IRQ_DUAL</name>
                <description>GPIO dual edge interrupt enable
0: single edge interrupt
1: dual edge interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO dual edge interrupt enable set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>IRQ_DUAL</name>
                <description>GPIO dual edge interrupt enable set
0: keep original edge interrupt type
1: dual edge interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO dual edge interrupt enable clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>IRQ_DUAL</name>
                <description>GPIO dual edge interrupt enable clear
0: keep original edge interrupt type
1: single edge interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO dual edge interrupt enable toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>IRQ_DUAL</name>
                <description>GPIO dual edge interrupt enable toggle
0: keep original edge interrupt type
1: change original edge interrupt type to another one.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>GPIO0</name>
      <description>GPIO0</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf00d0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>GPIO1</name>
      <description>GPIO1</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf00d4000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>PGPIO</name>
      <description>PGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf411c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>BGPIO</name>
      <description>BGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf4214000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PLIC</name>
      <description>PLIC</description>
      <groupName>PLIC</groupName>
      <baseAddress>0xe4000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x202000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>feature</name>
          <description>Feature enable register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>VECTORED</name>
              <description>Vector mode enable
0: Disabled
1: Enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPT</name>
              <description>Preemptive priority interrupt enable
0: Disabled
1: Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>127</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PRIORITY1,PRIORITY2,PRIORITY3,PRIORITY4,PRIORITY5,PRIORITY6,PRIORITY7,PRIORITY8,PRIORITY9,PRIORITY10,PRIORITY11,PRIORITY12,PRIORITY13,PRIORITY14,PRIORITY15,PRIORITY16,PRIORITY17,PRIORITY18,PRIORITY19,PRIORITY20,PRIORITY21,PRIORITY22,PRIORITY23,PRIORITY24,PRIORITY25,PRIORITY26,PRIORITY27,PRIORITY28,PRIORITY29,PRIORITY30,PRIORITY31,PRIORITY32,PRIORITY33,PRIORITY34,PRIORITY35,PRIORITY36,PRIORITY37,PRIORITY38,PRIORITY39,PRIORITY40,PRIORITY41,PRIORITY42,PRIORITY43,PRIORITY44,PRIORITY45,PRIORITY46,PRIORITY47,PRIORITY48,PRIORITY49,PRIORITY50,PRIORITY51,PRIORITY52,PRIORITY53,PRIORITY54,PRIORITY55,PRIORITY56,PRIORITY57,PRIORITY58,PRIORITY59,PRIORITY60,PRIORITY61,PRIORITY62,PRIORITY63,PRIORITY64,PRIORITY65,PRIORITY66,PRIORITY67,PRIORITY68,PRIORITY69,PRIORITY70,PRIORITY71,PRIORITY72,PRIORITY73,PRIORITY74,PRIORITY75,PRIORITY76,PRIORITY77,PRIORITY78,PRIORITY79,PRIORITY80,PRIORITY81,PRIORITY82,PRIORITY83,PRIORITY84,PRIORITY85,PRIORITY86,PRIORITY87,PRIORITY88,PRIORITY89,PRIORITY90,PRIORITY91,PRIORITY92,PRIORITY93,PRIORITY94,PRIORITY95,PRIORITY96,PRIORITY97,PRIORITY98,PRIORITY99,PRIORITY100,PRIORITY101,PRIORITY102,PRIORITY103,PRIORITY104,PRIORITY105,PRIORITY106,PRIORITY107,PRIORITY108,PRIORITY109,PRIORITY110,PRIORITY111,PRIORITY112,PRIORITY113,PRIORITY114,PRIORITY115,PRIORITY116,PRIORITY117,PRIORITY118,PRIORITY119,PRIORITY120,PRIORITY121,PRIORITY122,PRIORITY123,PRIORITY124,PRIORITY125,PRIORITY126,PRIORITY127</dimIndex>
          <name>PRIORITY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIORITY</name>
              <description>Interrupt source priority. The valid range of this field is 0-7.
0: Never interrupt
1-7: Interrupt source priority. The larger the value, the higher the priority.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PENDING0,PENDING1,PENDING2,PENDING3</dimIndex>
          <name>PENDING[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>The interrupt pending status of inpterrupt sources. Every interrupt source occupies 1 bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TRIGGER0,TRIGGER1,TRIGGER2,TRIGGER3</dimIndex>
          <name>TRIGGER[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>The interrupt trigger type of interrupt sources. Every interrupt source occupies 1 bit.
0: Level-triggered interrupt
1: Edge-triggered interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NUMBER</name>
          <description>Number of supported interrupt sources and targets</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_TARGET</name>
              <description>The number of supported targets</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_INTERRUPT</name>
              <description>The number of supported interrupt sources</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INFO</name>
          <description>Version and the maximum priority</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_PRIORITY</name>
              <description>The maximum priority supported</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION</name>
              <description>The version of the PLIC design</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>target0,target1</dimIndex>
          <name>TARGETINT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2000</addressOffset>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>INTEN0,INTEN1,INTEN2,INTEN3</dimIndex>
            <name>INTEN[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INTERRUPT</name>
                <description>The interrupt enable bit for interrupt. Every interrupt source occupies 1 bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x1000</dimIncrement>
          <dimIndex>target0,target1</dimIndex>
          <name>TARGETCONFIG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200000</addressOffset>
          <register>
            <name>THRESHOLD</name>
            <description>Target0 priority threshold</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>THRESHOLD</name>
                <description>Interrupt priority threshold.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLAIM</name>
            <description>Target claim and complete</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>INTERRUPT_ID</name>
                <description>On reads, indicating the interrupt source that has being claimed. On writes, indicating the interrupt source that has been handled (completed).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PPS</name>
            <description>Preempted priority stack</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIORITY_PREEMPTED</name>
                <description>Each bit indicates if the corresponding priority level has been preempted by a higher-priority interrupt.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MCHTMR</name>
      <description>MCHTMR</description>
      <groupName>MCHTMR</groupName>
      <baseAddress>0xe6000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MTIME</name>
          <description>Machine Time</description>
          <addressOffset>0x0</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000020210</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTIME</name>
              <description>Machine time</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MTIMECMP</name>
          <description>Machine Time Compare</description>
          <addressOffset>0x8</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000020210</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTIMECMP</name>
              <description>Machine time compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PLICSW</name>
      <description>PLICSW</description>
      <groupName>PLICSW</groupName>
      <baseAddress>0xe6400000</baseAddress>
      <addressBlock>
        <offset>0x1000</offset>
        <size>0x1ff008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PENDING</name>
          <description>Pending status</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000002</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>writing 1 to trigger software interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTEN</name>
          <description>Interrupt enable</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>enable software interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLAIM</name>
          <description>Claim and complete.</description>
          <addressOffset>0x200004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_ID</name>
              <description>On reads, indicating the interrupt source that has being claimed. On writes, indicating the interrupt source that has been handled (completed).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTMR0</name>
      <description>GPTMR0</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>ch0,ch1,ch2,ch3</dimIndex>
          <name>CHANNEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CR</name>
            <description>Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8007FFFF</resetMask>
            <fields>
              <field>
                <name>CNTUPT</name>
                <description>1- update counter to new value as CNTUPTVAL
This bit will be auto cleared after 1 cycle</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CNT_MODE</name>
                <description>0: internal counting mode, timer increase each gptmr clock cycle.
1: external counting mode, timer increase at each input signal posedge, reload/compare feature can still work but change at input signal posedge.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OPMODE</name>
                <description>0:  round mode
1:  one-shot mode, timer will stopped at reload point.user need clear CEN and set it to start timer agian.
NOTE: reload irq will be always set at one-shot mode at end</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MONITOR_SEL</name>
                <description>set to monitor input signal high level time(chan_meas_high)
clr to monitor input signal period(chan_meas_prd)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MONITOR_EN</name>
                <description>set to monitor input signal period or high level time.
When this bit is set, if detected period less than val_0 or more than val_1, will set related irq_sts
* only can be used when trig_mode is selected as measure mode(100)
* the time may not correct after reload, so monitor is disabled after reload point, and enabled again after two continul posedge.
if no posedge after reload for more than val_1, will also assert irq_capt</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNTRST</name>
                <description>1- reset counter</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCFLW</name>
                <description>1- enable this channel to reset counter to reload(RLD) together with its previous channel.
This bit is not valid for channel 0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCIFEN</name>
                <description>1- SYNCI is valid on its falling edge</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCIREN</name>
                <description>1- SYNCI is valid on its rising edge</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CEN</name>
                <description>1- counter enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPINIT</name>
                <description>Output compare initial poliarity
1- The channel output initial level is high
0- The channel output initial level is low
User should set this bit before set CMPEN to 1.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPEN</name>
                <description>1- Enable the channel output compare function. The output signal can be generated per comparator (CMPx) settings.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMASEL</name>
                <description>select one of DMA request:
00- CMP0 flag
01- CMP1 flag
10- Input signal toggle captured
11- RLD flag, counter reload;</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAEN</name>
                <description>1- enable dma</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWSYNCIEN</name>
                <description>1- enable software sync. When this bit is set, counter will reset to RLD when swsynct bit is set</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBGPAUSE</name>
                <description>1- counter will pause if chip is in debug mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPMODE</name>
                <description>This bitfield define the input capture mode
100:  width measure mode, timer will calculate the input signal period and duty cycle
011:  capture at both rising edge and falling edge
010:  capture at falling edge
001:  capture at rising edge
000:  No capture</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>CMP0,CMP1</dimIndex>
            <name>CMP[%s]</name>
            <description>no description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFF0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CMP</name>
                <description>compare value 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RLD</name>
            <description>Reload register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RLD</name>
                <description>reload value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNTUPTVAL</name>
            <description>Counter update value register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTUPTVAL</name>
                <description>counter will be set to this value when software write cntupt bit in CR</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPPOS</name>
            <description>Capture rising edge register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPPOS</name>
                <description>This register contains the counter value captured at input signal rising edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPNEG</name>
            <description>Capture falling edge register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPNEG</name>
                <description>This register contains the counter value captured at input signal falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPPRD</name>
            <description>PWM period measure register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPPRD</name>
                <description>This register contains the input signal period when channel is configured to input capture measure mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPDTY</name>
            <description>PWM duty cycle measure register</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MEAS_HIGH</name>
                <description>This register contains the input signal duty cycle when channel is configured to input capture measure mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNT</name>
            <description>Counter</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>32 bit counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>SR</name>
          <description>Status register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3CMP1F</name>
              <description>channel 3 compare value 1 match flag</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3CMP0F</name>
              <description>channel 3 compare value 1 match flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3CAPF</name>
              <description>channel 3 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3RLDF</name>
              <description>channel 3 counter reload flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CMP1F</name>
              <description>channel 2 compare value 1 match flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CMP0F</name>
              <description>channel 2 compare value 1 match flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CAPF</name>
              <description>channel 2 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2RLDF</name>
              <description>channel 2 counter reload flag</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CMP1F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CMP0F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CAPF</name>
              <description>channel 1 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1RLDF</name>
              <description>channel 1 counter reload flag</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CMP1F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CMP0F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CAPF</name>
              <description>channel 1 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0RLDF</name>
              <description>channel 1 counter reload flag</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQEN</name>
          <description>Interrupt request enable register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3CMP1EN</name>
              <description>1- generate interrupt request when ch3cmp1f flag is set</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3CMP0EN</name>
              <description>1- generate interrupt request when ch3cmp0f flag is set</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3CAPEN</name>
              <description>1- generate interrupt request when ch3capf flag is set</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3RLDEN</name>
              <description>1- generate interrupt request when ch3rldf flag is set</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CMP1EN</name>
              <description>1- generate interrupt request when ch2cmp1f flag is set</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CMP0EN</name>
              <description>1- generate interrupt request when ch2cmp0f flag is set</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CAPEN</name>
              <description>1- generate interrupt request when ch2capf flag is set</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2RLDEN</name>
              <description>1- generate interrupt request when ch2rldf flag is set</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CMP1EN</name>
              <description>1- generate interrupt request when ch1cmp1f flag is set</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CMP0EN</name>
              <description>1- generate interrupt request when ch1cmp0f flag is set</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CAPEN</name>
              <description>1- generate interrupt request when ch1capf flag is set</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1RLDEN</name>
              <description>1- generate interrupt request when ch1rldf flag is set</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CMP1EN</name>
              <description>1- generate interrupt request when ch0cmp1f flag is set</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CMP0EN</name>
              <description>1- generate interrupt request when ch0cmp0f flag is set</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CAPEN</name>
              <description>1- generate interrupt request when ch0capf flag is set</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0RLDEN</name>
              <description>1- generate interrupt request when ch0rldf flag is set</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GCR</name>
          <description>Global control register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>SWSYNCT</name>
              <description>set this bitfield to trigger software counter sync event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR1</name>
      <description>GPTMR1</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0004000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR2</name>
      <description>GPTMR2</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0008000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR3</name>
      <description>GPTMR3</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf000c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR4</name>
      <description>GPTMR4</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0010000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR5</name>
      <description>GPTMR5</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0014000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR6</name>
      <description>GPTMR6</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0018000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR7</name>
      <description>GPTMR7</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf001c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>NTMR0</name>
      <description>NTMR0</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf1410000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>NTMR1</name>
      <description>NTMR1</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf1414000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>PTMR</name>
      <description>PTMR</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf4120000</baseAddress>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART0</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0040000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x3c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IDLE_CFG</name>
          <description>Idle Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FF0BFF</resetMask>
          <fields>
            <field>
              <name>TX_IDLE_COND</name>
              <description>IDLE Detection Condition
0 - Treat as idle if TX pin is logic one
1 - Treat as idle if UART state machine state is idle</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_IDLE_EN</name>
              <description>UART TX Idle Detect Enable
0 - Disable
1 - Enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_IDLE_THR</name>
              <description>Threshold for UART transmit Idle detection (in terms of bits)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEN</name>
              <description>UART receive enable.
0 - hold RX input to high, avoide wrong data input when config pinmux
1 - bypass RX input from PIN
software should set it after config pinmux</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_IDLE_COND</name>
              <description>IDLE Detection Condition
0 - Treat as idle if RX pin is logic one
1 - Treat as idle if UART state machine state is idle</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_IDLE_EN</name>
              <description>UART Idle Detect Enable
0 - Disable
1 - Enable
it should be enabled if enable address match feature</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_IDLE_THR</name>
              <description>Threshold for UART Receive Idle detection (in terms of bits)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDR_CFG</name>
          <description>address match config register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>TXEN_9BIT</name>
              <description>set to use 9bit mode for transmitter,
will set the MSB for the first character as address flag, keep 0 for others.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEN_ADDR_MSB</name>
              <description>set to use MSB as address flag at receiver(actually this is done by software set correct MSB in addr0/addr1).
Clr to use first character as address.
Only needed if enable address match feature</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEN_9BIT</name>
              <description>set to use 9bit mode for receiver, only valid if rxen_addr_msb is set</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>A1_EN</name>
              <description>enable addr1 compare for the first character.
If a1_en OR a0_en, then do not receive data if address not match.
If ~a1_en AND ~a0_en, the receive all data like before.
NOTE: should set idle_tmout_en if enable address match feature</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>A0_EN</name>
              <description>enable addr0 compare for the first character</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR1</name>
              <description>address 1 fileld.
in 9bit mode, this is the full address byte.
For other mode(8/7/6/5bit), MSB should be set for address flag.
If want address==0 to be matched at 8bit mode, should set addr1=0x80</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR0</name>
              <description>address 0 field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IIR2</name>
          <description>Interrupt Identification Register2</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xF80000CF</resetMask>
          <fields>
            <field>
              <name>RXIDLE_FLAG</name>
              <description>UART RX IDLE Flag, assert after rxd high and then rx idle timeout, write one clear
0 - UART RX is busy
1 - UART RX is idle</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXIDLE_FLAG</name>
              <description>UART TX IDLE Flag, assert after txd high and then tx idle timeout, write one clear
0 - UART TX is busy
1 - UART TX is idle</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>address match irq status, assert if either address match(and enabled). Write one clear
NOTE: the address byte may not moved by DMA at this point.
User can wait next addr_match_idle irq for the whole data include address</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADDR_MATCH_IDLE</name>
              <description>address match and idle irq status, assert at rx bus idle if address match event triggered.
Write one clear;</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA_LOST</name>
              <description>assert if data lost before address match status, write one clear;
It will not assert if no address match occurs</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOED</name>
              <description>FIFOs enabled
These two bits are 1 when bit 0 of the FIFO Control
Register (FIFOE) is set to 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRID</name>
              <description>Interrupt ID, see IIR2 for detail decoding</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cfg</name>
          <description>Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOSIZE</name>
              <description>The depth of RXFIFO and TXFIFO
0: 16-byte FIFO
1: 32-byte FIFO
2: 64-byte FIFO
3: 128-byte FIFO</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSCR</name>
          <description>Over Sample Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>OSC</name>
              <description>Over-sample control
The value must be an even number; any odd value
writes to this field will be converted to an even value.
OSC=0: reserved
OSC&lt;=8: The over-sample ratio is 8
8 &lt; OSC&lt; 32: The over sample ratio is OSC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FCRR</name>
          <description>FIFO Control Register config</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x008F0FFF</resetMask>
          <fields>
            <field>
              <name>FIFOT4EN</name>
              <description>set to use new 4bit fifo threshold(TFIFOT4 and RFIFOT4)
clr to use 2bit(TFIFOT and RFIFOT)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIFOT4</name>
              <description>txfifo threshold(0 for 1byte, 0xF for 16bytes), uart will send tx_dma_req when data in fifo is less than threshold.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFIFOT4</name>
              <description>rxfifo threshold(0 for 1byte, 0xF for 16bytes).
Uart will send rx_dma_req if data in fifo reachs the threshold, also will set the rxdata irq if enabled</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFIFOT</name>
              <description>Receiver FIFO trigger level</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIFOT</name>
              <description>Transmitter FIFO trigger level</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAE</name>
              <description>DMA enable
0: Disable
1: Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIFORST</name>
              <description>Transmitter FIFO reset
Write 1 to clear all bytes in the TXFIFO and resets its
counter. The Transmitter Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFIFORST</name>
              <description>Receiver FIFO reset
Write 1 to clear all bytes in the RXFIFO and resets its
counter. The Receiver Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOE</name>
              <description>FIFO enable
Write 1 to enable both the transmitter and receiver
FIFOs.
The FIFOs are reset when the value of this bit toggles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MOTO_CFG</name>
          <description>moto system control register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000FFF0</resetMask>
          <fields>
            <field>
              <name>SWTRG</name>
              <description>software trigger. User should avoid use sw/hw trigger at same time, otherwise result unknown.
Hardware auto reset.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXSTP_BITS</name>
              <description>if TXSTOP_INSERT is enabled, the STOP bits to be inserted between each byte. 0 for 1 bit;  0xFF for 256bits</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HWTRG_EN</name>
              <description>set to enable hardware trigger(trigger from moto is shared by other UART)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRG_MODE</name>
              <description>set to enable trigger mode.
software should push needed data into txbuffer frist, uart will not start transmission at this time.
User should send trigger signal(by hw or sw), uart will send all data in txfifo till  empty
NOTE: the hw_trigger should be pulse signal from trig mux.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRG_CLR_RFIFO</name>
              <description>set to enable the feature that, clear rxfifo at tx trigger(sw or hw), avoid unexpected data in rxfifo.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSTOP_INSERT</name>
              <description>set to insert STOP bits between each tx byte till tx fifo empty.
NOTE: there will be no 1.5/2 STOP bits if enabled this feature, LCR.STB should be set to 0 if this bit is set</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RBR</name>
          <description>Receiver Buffer Register (when DLAB = 0)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive data read port</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>THR</name>
          <description>Transmitter Holding Register (when DLAB = 0)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit data write port</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL</name>
          <description>Divisor Latch LSB (when DLAB = 1)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLL</name>
              <description>Least significant byte of the Divisor Latch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <description>Interrupt Enable Register (when DLAB = 0)</description>
          <alternateGroup>UNION_24</alternateGroup>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF800000F</resetMask>
          <fields>
            <field>
              <name>ERXIDLE</name>
              <description>Enable Receive Idle interrupt
0 - Disable Idle interrupt
1 - Enable Idle interrupt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETXIDLE</name>
              <description>enable transmit idle interrupt</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EADDRM</name>
              <description>enable ADDR_MATCH  interrupt</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EADDRM_IDLE</name>
              <description>enable ADDR_MATCH_IDLE interrupt</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EDATLOST</name>
              <description>enable DATA_LOST interrupt</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMSI</name>
              <description>Enable modem status interrupt
The interrupt asserts when the status of one of the
following occurs:
The status of modem_rin, modem_dcdn,
modem_dsrn or modem_ctsn (If the auto-cts mode is
disabled) has been changed.
If the auto-cts mode is enabled (MCR bit4 (AFE) = 1),
modem_ctsn would be used to control the transmitter.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELSI</name>
              <description>Enable receiver line status interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHEI</name>
              <description>Enable transmitter holding register interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERBI</name>
              <description>Enable received data available interrupt and the
character timeout interrupt
0: Disable
1: Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLM</name>
          <description>Divisor Latch MSB (when DLAB = 1)</description>
          <alternateGroup>UNION_24</alternateGroup>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLM</name>
              <description>Most significant byte of the Divisor Latch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IIR</name>
          <description>Interrupt Identification Register</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x800000CF</resetMask>
          <fields>
            <field>
              <name>RXIDLE_FLAG</name>
              <description>UART IDLE Flag
0 - UART is busy
1 - UART is idle
NOTE: when write one to clear this bit, avoid changging FCR register since it's same address as IIR</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOED</name>
              <description>FIFOs enabled
These two bits are 1 when bit 0 of the FIFO Control
Register (FIFOE) is set to 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRID</name>
              <description>Interrupt ID, see IIR2 for detail decoding</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FCR</name>
          <description>FIFO Control Register</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RFIFOT</name>
              <description>Receiver FIFO trigger level</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFIFOT</name>
              <description>Transmitter FIFO trigger level</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMAE</name>
              <description>DMA enable
0: Disable
1: Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFIFORST</name>
              <description>Transmitter FIFO reset
Write 1 to clear all bytes in the TXFIFO and resets its
counter. The Transmitter Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFIFORST</name>
              <description>Receiver FIFO reset
Write 1 to clear all bytes in the RXFIFO and resets its
counter. The Receiver Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOE</name>
              <description>FIFO enable
Write 1 to enable both the transmitter and receiver
FIFOs.
The FIFOs are reset when the value of this bit toggles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <description>Line Control Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLAB</name>
              <description>Divisor latch access bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BC</name>
              <description>Break control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPS</name>
              <description>Stick parity
1: Parity bit is constant 0 or 1, depending on bit4 (EPS).
0: Disable the sticky bit parity.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPS</name>
              <description>Even parity select
1: Even parity (an even number of logic-1 is in the data
and parity bits)
0: Old parity.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEN</name>
              <description>Parity enable
When this bit is set, a parity bit is generated in
transmitted data before the first STOP bit and the parity
bit would be checked for the received data.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STB</name>
              <description>Number of STOP bits
0: 1 bits
1: The number of STOP bit is based on the WLS setting
When WLS = 0, STOP bit is 1.5 bits
When WLS = 1, 2, 3, STOP bit is 2 bits</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WLS</name>
              <description>Word length setting
0: 5 bits
1: 6 bits
2: 7 bits
3: 8 bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCR</name>
          <description>Modem Control Register (</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000032</resetMask>
          <fields>
            <field>
              <name>AFE</name>
              <description>Auto flow control enable
0: Disable
1: The auto-CTS and auto-RTS setting is based on the
RTS bit setting:
When RTS = 0, auto-CTS only
When RTS = 1, auto-CTS and auto-RTS</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOP</name>
              <description>Enable loopback mode
0: Disable
1: Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS</name>
              <description>Request to send
This bit controls the modem_rtsn output.
0: The modem_rtsn output signal will be driven HIGH
1: The modem_rtsn output signal will be driven LOW</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LSR</name>
          <description>Line Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC01F1FFF</resetMask>
          <fields>
            <field>
              <name>RXIDLE</name>
              <description>rxidle after timeout, clear after rx idle condition not match</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXIDLE</name>
              <description>txidle after timeout, clear after tx idle condition not match</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RFIFO_NUM</name>
              <description>data bytes in rxfifo not read</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFIFO_NUM</name>
              <description>data bytes in txfifo not sent</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERRF</name>
              <description>Error in RXFIFO
In the FIFO mode, this bit is set when there is at least
one parity error, framing error, or line break
associated with data in the RXFIFO. It is cleared when
this register is read and there is no more error for the
rest of data in the RXFIFO.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TEMT</name>
              <description>Transmitter empty
This bit is 1 when the THR (TXFIFO in the FIFO
mode) and the Transmitter Shift Register (TSR) are
both empty. Otherwise, it is zero.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE</name>
              <description>Transmitter Holding Register empty
This bit is 1 when the THR (TXFIFO in the FIFO
mode) is empty. Otherwise, it is zero.
If the THRE interrupt is enabled, an interrupt is
triggered when THRE becomes 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LBREAK</name>
              <description>Line break
This bit is set when the uart_sin input signal was held
LOWfor longer than the time for a full-word
transmission. A full-word transmission is the
transmission of the START, data, parity, and STOP
bits. It is cleared when this register is read.
In the FIFO mode, this bit indicates the line break for
the received data at the top of the RXFIFO.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FE</name>
              <description>Framing error
This bit is set when the received STOP bit is not
HIGH. It is cleared when this register is read.
In the FIFO mode, this bit indicates the framing error
for the received data at the top of the RXFIFO.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PE</name>
              <description>Parity error
This bit is set when the received parity does not match
with the parity selected in the LCR[5:4]. It is cleared
when this register is read.
In the FIFO mode, this bit indicates the parity error
for the received data at the top of the RXFIFO.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OE</name>
              <description>Overrun error
This bit indicates that data in the Receiver Buffer
Register (RBR) is overrun.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DR</name>
              <description>Data ready.
This bit is set when there are incoming received data
in the Receiver Buffer Register (RBR). It is cleared
when all of the received data are read.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSR</name>
          <description>Modem Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>CTS</name>
              <description>Clear to send
0: The modem_ctsn input signal is HIGH.
1: The modem_ctsn input signal is LOW.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCTS</name>
              <description>Delta clear to send
This bit is set when the state of the modem_ctsn input
signal has been changed since the last time this
register is read.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR</name>
          <description>GPR Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>A one-byte storage register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART1</name>
      <description>UART1</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0044000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART2</name>
      <description>UART2</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0048000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART3</name>
      <description>UART3</description>
      <groupName>UART</groupName>
      <baseAddress>0xf004c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART4</name>
      <description>UART4</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0050000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART5</name>
      <description>UART5</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0054000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART6</name>
      <description>UART6</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0058000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART7</name>
      <description>UART7</description>
      <groupName>UART</groupName>
      <baseAddress>0xf005c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART8</name>
      <description>UART8</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0180000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART9</name>
      <description>UART9</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0184000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART10</name>
      <description>UART10</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0188000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART11</name>
      <description>UART11</description>
      <groupName>UART</groupName>
      <baseAddress>0xf018c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART12</name>
      <description>UART12</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0190000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART13</name>
      <description>UART13</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0194000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART14</name>
      <description>UART14</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0198000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART15</name>
      <description>UART15</description>
      <groupName>UART</groupName>
      <baseAddress>0xf019c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>PUART</name>
      <description>PUART</description>
      <groupName>UART</groupName>
      <baseAddress>0xf4124000</baseAddress>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C0</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf0060000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x30</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>Cfg</name>
          <description>Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOSIZE</name>
              <description>FIFO Size:
0: 2 bytes
1: 4 bytes
2: 8 bytes
3: 16 bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntEn</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPL</name>
              <description>Set to enable the Completion Interrupt.
Master: interrupts when a transaction is issued from this master and completed without losing the bus arbitration.
Slave: interrupts when a transaction addressing the controller is completed.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTERECV</name>
              <description>Set to enable the Byte Receive Interrupt.
Interrupts when a byte of data is received
Auto-ACK will be disabled if this interrupt is enabled, that is, the software needs to ACK/NACK the received byte manually.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTETRANS</name>
              <description>Set to enable the Byte Transmit Interrupt.
Interrupts when a byte of data is transmitted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>Set to enable the START Condition Interrupt.
Interrupts when a START condition/repeated START condition is detected.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Set to enable the STOP Condition Interrupt
Interrupts when a STOP condition is detected.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ARBLOSE</name>
              <description>Set to enable the Arbitration Lose Interrupt.
Master: interrupts when the controller loses the bus arbitration
Slave: not available in this mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRHIT</name>
              <description>Set to enable the Address Hit Interrupt.
Master: interrupts when the addressed slave returned an ACK.
Slave: interrupts when the controller is addressed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOHALF</name>
              <description>Set to enable the FIFO Half Interrupt.
Receiver: Interrupts when the FIFO is half-empty, i.e, there is &gt;= 1/2 entries in the FIFO.
Transmitter: Interrupts when the FIFO is half-empty, i.e. there is &lt;= 1/2 entries in the FIFO.
This interrupt depends on the transaction direction; don’t enable this interrupt unless the transfer direction is determined, otherwise unintended interrupts may be triggered.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOFULL</name>
              <description>Set to enable the FIFO Full Interrupt.
Interrupts when the FIFO is full.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOEMPTY</name>
              <description>Set to enabled the FIFO Empty Interrupt
Interrupts when the FIFO is empty.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Status</name>
          <description>Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINESDA</name>
              <description>Indicates the current status of the SDA line on the bus
1: high
0: low</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LINESCL</name>
              <description>Indicates the current status of the SCL line on the bus
1: high
0: low</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GENCALL</name>
              <description>Indicates that the address of the current transaction is a general call address:
1: General call
0: Not general call</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSBUSY</name>
              <description>Indicates that the bus is busy
The bus is busy when a START condition is on bus and it ends when a STOP condition is seen on bus
1: Busy
0: Not busy</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK</name>
              <description>Indicates the type of the last received/transmitted acknowledgement bit:
1: ACK
0: NACK</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMPL</name>
              <description>Transaction Completion
Master: Indicates that a transaction has been issued from this master and completed without losing the bus arbitration
Slave: Indicates that a transaction addressing the controller has been completed. This status bit must be cleared to receive the next transaction; otherwise, the next incoming transaction will be blocked.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BYTERECV</name>
              <description>Indicates that a byte of data has been received.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BYTETRANS</name>
              <description>Indicates that a byte of data has been transmitted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>START</name>
              <description>Indicates that a START Condition or a repeated START condition has been transmitted/received.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Indicates that a STOP Condition has been transmitted/received.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ARBLOSE</name>
              <description>Indicates that the controller has lost the bus arbitration.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADDRHIT</name>
              <description>Master: indicates that a slave has responded to the transaction.
Slave: indicates that a transaction is targeting the controller (including the General Call).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOHALF</name>
              <description>Transmitter: Indicates that the FIFO is half-empty.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFOFULL</name>
              <description>Indicates that the FIFO is full.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFOEMPTY</name>
              <description>Indicates that the FIFO is empty.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Addr</name>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The slave address.
For 7-bit addressing mode, the most significant 3 bits are ignored and only the least-significant 7 bits of Addr are valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Data</name>
          <description>Data Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Write this register to put one byte of data to the FIFO.
Read this register to get one byte of data from the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Ctrl</name>
          <description>Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00905E00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATACNT_HIGH</name>
              <description>Data counts in bytes.
Master: The number of bytes to transmit/receive. 0 means max length. DataCnt will be decreased by one for each byte transmitted/received.
Slave: the meaning of DataCnt depends on the DMA mode:
If DMA is not enabled, DataCnt is the number of bytes transmitted/received from the bus master. It is reset to 0 when the controller is addressed and then increased by one for each byte of data transmitted/received.
If DMA is enabled, DataCnt is the number of bytes to transmit/receive. It will not be reset to 0 when the slave is addressed and it will be decreased by one for each byte of data transmitted/received.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_LEN</name>
              <description>reset clock cycles. the clock high/low time is defined by Setup.T_SCLHi, 50% duty cycle.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_HOLD_SCKIN</name>
              <description>set to hold input clock to high when reset is active</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ON</name>
              <description>set to send reset signals(just toggle clock bus defined by reset_len).
this register is clered when reset is end, can't be cleared by software</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_START</name>
              <description>Enable this bit to send a START condition at the beginning of transaction.
Master mode only.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_ADDR</name>
              <description>Enable this bit to send the address after START condition.
Master mode only.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_DATA</name>
              <description>Enable this bit to send the data after Address phase.
Master mode only.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_STOP</name>
              <description>Enable this bit to send a STOP condition at the end of a transaction.
Master mode only.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIR</name>
              <description>Transaction direction
Master: Set this bit to determine the direction for the next transaction.
0: Transmitter
1: Receiver
Slave: The direction of the last received transaction.
0: Receiver
1: Transmitter</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATACNT</name>
              <description>Data counts in bytes.
Master: The number of bytes to transmit/receive. 0 means max length. DataCnt will be decreased by one for each byte transmitted/received.
Slave: the meaning of DataCnt depends on the DMA mode:
If DMA is not enabled, DataCnt is the number of bytes transmitted/received from the bus master. It is reset to 0 when the controller is addressed and then increased by one for each byte of data transmitted/received.
If DMA is enabled, DataCnt is the number of bytes to transmit/receive. It will not be reset to 0 when the slave is addressed and it will be decreased by one for each byte of data transmitted/received.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cmd</name>
          <description>Command Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>Write this register with the following values to perform the corresponding actions:
0x0: no action
0x1: issue a data transaction (Master only)
0x2: respond with an ACK to the received byte
0x3: respond with a NACK to the received byte
0x4: clear the FIFO
0x5: reset the I2C controller (abort current transaction, set the SDA and SCL line to the open-drain mode, reset the Status Register and the Interrupt Enable Register, and empty the FIFO)
When issuing a data transaction by writing 0x1 to this register, the CMD field stays at 0x1 for the duration of the entire transaction, and it is only cleared to 0x0 after when the transaction has completed or when the controller loses the arbitration.
Note: No transaction will be issued by the controller when all phases (Start, Address, Data and Stop) are disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Setup</name>
          <description>Setup Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x05252100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_SUDAT</name>
              <description>T_SUDAT defines the data setup time before releasing the SCL.
Setup time = (2 * tpclk) + (2 + T_SP + T_SUDAT) * tpclk* (TPM+1)
tpclk = PCLK period
TPM = The multiplier value in Timing Parameter Multiplier Register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SP</name>
              <description>T_SP defines the pulse width of spikes that must be suppressed by the input filter.
Pulse width = T_SP * tpclk* (TPM+1)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HDDAT</name>
              <description>T_HDDAT defines the data hold time after SCL goes LOW
Hold time = (2 * tpclk) + (2 + T_SP + T_HDDAT) * tpclk* (TPM+1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SCLRADIO</name>
              <description>The LOW period of the generated SCL clock is defined by the combination of T_SCLRatio and T_SCLHi values. When T_SCLRatio = 0, the LOW period is equal to HIGH period. When T_SCLRatio = 1, the LOW period is roughly two times of HIGH period.
SCL LOW period = (2 * tpclk) + (2 + T_SP + T_SCLHi * ratio) * tpclk * (TPM+1)
1: ratio = 2
0: ratio = 1
This field is only valid when the controller is in the master mode.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SCLHI</name>
              <description>The HIGH period of generated SCL clock is defined by T_SCLHi.
SCL HIGH period = (2 * tpclk) + (2 + T_SP + T_SCLHi) * tpclk* (TPM+1)
The T_SCLHi value must be greater than T_SP and T_HDDAT values.
This field is only valid when the controller is in the master mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAEN</name>
              <description>Enable the direct memory access mode data transfer.
1: Enable
0: Disable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER</name>
              <description>Configure this device as a master or a slave.
1: Master mode
0: Slave mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRESSING</name>
              <description>I2C addressing mode:
1: 10-bit addressing mode
0: 7-bit addressing mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IICEN</name>
              <description>Enable the I2C controller.
1: Enable
0: Disable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TPM</name>
          <description>I2C Timing Paramater Multiplier</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPM</name>
              <description>A multiplication value for I2C timing parameters. All the timing parameters in the Setup Register are multiplied by (TPM+1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C1</name>
      <description>I2C1</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf0064000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C2</name>
      <description>I2C2</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf0068000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C3</name>
      <description>I2C3</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf006c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C4</name>
      <description>I2C4</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf01a0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C5</name>
      <description>I2C5</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf01a4000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C6</name>
      <description>I2C6</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf01a8000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C7</name>
      <description>I2C7</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf01ac000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI0</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0070000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x7c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>wr_trans_cnt</name>
          <description>Transfer count for write data</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRTRANCNT</name>
              <description>Transfer count for write data
WrTranCnt indicates the number of units of data to be transmitted to the SPI bus from the Data Register. The actual transfer count is (WrTranCnt+1).
WrTranCnt only takes effect when TransMode is 0, 1, 3, 4, 5, 6 or 8.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must be equal to RdTranCnt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rd_trans_cnt</name>
          <description>Transfer count for read data</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDTRANCNT</name>
              <description>Transfer count for read data
RdTranCnt indicates the number of units of data to be received from SPI bus and stored to the Data Register. The actual received count is (RdTranCnt+1).
RdTransCnt only takes effect when TransMode is 0, 2, 3, 4, 5, 6 or 9.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must equal RdTranCnt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TransFmt</name>
          <description>Transfer Format Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00020780</resetValue>
          <resetMask>0xFFFF1F9F</resetMask>
          <fields>
            <field>
              <name>ADDRLEN</name>
              <description>Address length in bytes
0x0: 1 byte
0x1: 2 bytes
0x2: 3 bytes
0x3: 4 bytes</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATALEN</name>
              <description>The length of each data unit in bits
The actual bit number of a data unit is (DataLen + 1)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAMERGE</name>
              <description>Enable Data Merge mode, which does automatic data split on write and data coalescing on read.
This bit only takes effect when DataLen = 0x7. Under Data Merge mode, each write to the Data Register will transmit all fourbytes of the write data; each read from the Data Register will retrieve four bytes of received data as a single word data.
When Data Merge mode is disabled, only the least (DataLen+1) significient bits of the Data Register are valid for read/write operations; no automatic data split/coalescing will be performed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSIBIDIR</name>
              <description>Bi-directional MOSI in regular (single) mode
0x0: MOSI is uni-directional signal in regular mode.
0x1: MOSI is bi-directional signal in regular mode. This bi-directional signal replaces the two</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Transfer data with the least significant bit first
0x0: Most significant bit first
0x1: Least significant bit first</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVMODE</name>
              <description>SPI Master/Slave mode selection
0x0: Master mode
0x1: Slave mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>SPI Clock Polarity
0x0: SCLK is LOW in the idle states
0x1: SCLK is HIGH in the idle states</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>SPI Clock Phase
0x0: Sampling data at odd SCLK edges
0x1: Sampling data at even SCLK edges</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DirectIO</name>
          <description>Direct IO Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00003100</resetValue>
          <resetMask>0x013F3F3F</resetMask>
          <fields>
            <field>
              <name>DIRECTIOEN</name>
              <description>Enable Direct IO
0x0: Disable
0x1: Enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOLD_OE</name>
              <description>Output enable for the SPI Flash hold signal</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WP_OE</name>
              <description>Output enable for the SPI Flash write protect signal</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MISO_OE</name>
              <description>Output enable fo the SPI MISO signal</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSI_OE</name>
              <description>Output enable for the SPI MOSI signal</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_OE</name>
              <description>Output enable for the SPI SCLK signal</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CS_OE</name>
              <description>Output enable for SPI CS (chip select) signal</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOLD_O</name>
              <description>Output value for the SPI Flash hold signal</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WP_O</name>
              <description>Output value for the SPI Flash write protect signal</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MISO_O</name>
              <description>Output value for the SPI MISO signal</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSI_O</name>
              <description>Output value for the SPI MOSI signal</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_O</name>
              <description>Output value for the SPI SCLK signal</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CS_O</name>
              <description>Output value for the SPI CS (chip select) signal</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOLD_I</name>
              <description>Status of the SPI Flash hold signal</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WP_I</name>
              <description>Status of the SPI Flash write protect signal</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MISO_I</name>
              <description>Status of the SPI MISO signal</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MOSI_I</name>
              <description>Status of the SPI MOSI signal</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCLK_I</name>
              <description>Status of the SPI SCLK signal</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CS_I</name>
              <description>Status of the SPI CS (chip select) signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TransCtrl</name>
          <description>Transfer Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLVDATAONLY</name>
              <description>Data-only mode (slave mode only)
0x0: Disable the data-only mode
0x1: Enable the data-only mode
Note: This mode only works in the uni-directional regular (single) mode so MOSIBiDir, DualQuad and TransMode should be set to 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDEN</name>
              <description>SPI command phase enable (Master mode only)
0x0: Disable the command phase
0x1: Enable the command phase</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDREN</name>
              <description>SPI address phase enable (Master mode only)
0x0: Disable the address phase
0x1: Enable the address phase</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRFMT</name>
              <description>SPI address phase format (Master mode only)
0x0: Address phase is the regular (single) mode
0x1: The format of the address phase is the same as the data phase (DualQuad).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMODE</name>
              <description>Transfer mode
The transfer sequence could be
0x0: Write and read at the same time
0x1: Write only
0x2: Read only
0x3: Write, Read
0x4: Read, Write
0x5: Write, Dummy, Read
0x6: Read, Dummy, Write
0x7: None Data (must enable CmdEn or AddrEn in master mode)
0x8: Dummy, Write
0x9: Dummy, Read
0xa~0xf: Reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALQUAD</name>
              <description>SPI data phase format
0x0: Regular (Single) mode
0x1: Dual I/O mode
0x2: Quad I/O mode
0x3: Reserved</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOKENEN</name>
              <description>Token transfer enable (Master mode only)
Append a one-byte special token following the address phase for SPI read transfers. The value of the special token should be selected in TokenValue.
0x0: Disable the one-byte special token
0x1: Enable the one-byte special token</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRTRANCNT</name>
              <description>Transfer count for write data
WrTranCnt indicates the number of units of data to be transmitted to the SPI bus from the Data Register. The actual transfer count is (WrTranCnt+1).
WrTranCnt only takes effect when TransMode is 0, 1, 3, 4, 5, 6 or 8.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must be equal to RdTranCnt.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOKENVALUE</name>
              <description>Token value (Master mode only)
The value of the one-byte special token following the address phase for SPI read transfers.
0x0: token value = 0x00
0x1: token value = 0x69</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DUMMYCNT</name>
              <description>Dummy data count. The actual dummy count is (DummyCnt +1).
The number of dummy cycles on the SPI interface will be (DummyCnt+1)* ((DataLen+1)/SPI IO width)
The Data pins are put into the high impedance during the dummy data phase.
DummyCnt is only used for TransMode 5, 6, 8 and 9, which has dummy data phases.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDTRANCNT</name>
              <description>Transfer count for read data
RdTranCnt indicates the number of units of data to be received from SPI bus and stored to the Data Register. The actual received count is (RdTranCnt+1).
RdTransCnt only takes effect when TransMode is 0, 2, 3, 4, 5, 6 or 9.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must equal RdTranCnt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cmd</name>
          <description>Command Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>SPI Command</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Addr</name>
          <description>Address Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>SPI Address
(Master mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Data</name>
          <description>Data Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data to transmit or the received data
For writes, data is enqueued to the TX FIFO. The least significant byte is always transmitted first. If the TX FIFO is full and the SPIActive bit of the status register is 1, the ready signal hready/pready will be deasserted to insert wait states to the transfer.
For reads, data is read and dequeued from the RX FIFO. The least significant byte is the first received byte. If the RX FIFO is empty and the SPIActive bit of the status register is 1, the ready signal hready/pready will be deasserted to insert wait states to the transfer.
The FIFOs decouple the speed of the SPI transfers and the software鈥檚 generation/consumption of data. When the TX FIFO is empty, SPI transfers will hold until more data is written to the TX FIFO; when the RX FIFO is full, SPI transfers will hold until there is more room in the RX FIFO.
If more data is written to the TX FIFO than the write transfer count (WrTranCnt), the remaining data will stay in the TX FIFO for the next transfer or until the TX FIFO is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Ctrl</name>
          <description>Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFF1F</resetMask>
          <fields>
            <field>
              <name>CS_EN</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHRES</name>
              <description>Transmit (TX) FIFO Threshold
The TXFIFOInt interrupt or DMA request would be issued to replenish the TX FIFO when the TX data count is less than or equal to the TX FIFO threshold.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHRES</name>
              <description>Receive (RX) FIFO Threshold
The RXFIFOInt interrupt or DMA request would be issued for consuming the RX FIFO when the RX data count is more than or equal to the RX FIFO threshold.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMAEN</name>
              <description>TX DMA enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMAEN</name>
              <description>RX DMA enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFORST</name>
              <description>Transmit FIFO reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFORST</name>
              <description>Receive FIFO reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIRST</name>
              <description>SPI reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Status</name>
          <description>Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x33FFFF01</resetMask>
          <fields>
            <field>
              <name>TXNUM_7_6</name>
              <description>Number of valid entries in the Transmit FIFO</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNUM_7_6</name>
              <description>Number of valid entries in the Receive FIFO</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Full flag</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Empty flag</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXNUM_5_0</name>
              <description>Number of valid entries in the Transmit FIFO</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Full flag</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Empty flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNUM_5_0</name>
              <description>Number of valid entries in the Receive FIFO</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SPIACTIVE</name>
              <description>SPI register programming is in progress.
In master mode, SPIActive becomes 1 after the SPI command register is written and becomes 0 after the transfer is finished.
In slave mode, SPIActive becomes 1 after the SPI CS signal is asserted and becomes 0 after the SPI CS signal is deasserted.
Note that due to clock synchronization, it may take at most two spi_clock cycles for SPIActive to change when the corresponding condition happens.
Note this bit stays 0 when Direct IO Control or the memory-mapped interface is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntrEn</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SLVCMDEN</name>
              <description>Enable the Slave Command Interrupt.
Control whether interrupts are triggered whenever slave commands are received.
(Slave mode only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENDINTEN</name>
              <description>Enable the End of SPI Transfer interrupt.
Control whether interrupts are triggered when SPI transfers end.
(In slave mode, end of read status transaction doesn鈥檛 trigger this interrupt.)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFOINTEN</name>
              <description>Enable the SPI Transmit FIFO Threshold interrupt.
Control whether interrupts are triggered when the valid entries are less than or equal to the TX FIFO threshold.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFOINTEN</name>
              <description>Enable the SPI Receive FIFO Threshold interrupt.
Control whether interrupts are triggered when the valid entries are greater than or equal to the RX FIFO threshold.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFOURINTEN</name>
              <description>Enable the SPI Transmit FIFO Underrun interrupt.
Control whether interrupts are triggered when the Transmit FIFO run out of data.
(Slave mode only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFOORINTEN</name>
              <description>Enable the SPI Receive FIFO Overrun interrupt.
Control whether interrupts are triggered when the Receive FIFO overflows.
(Slave mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntrSt</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SLVCMDINT</name>
              <description>Slave Command Interrupt.
This bit is set when Slave Command interrupts occur.
(Slave mode only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ENDINT</name>
              <description>End of SPI Transfer interrupt.
This bit is set when End of SPI Transfer interrupts occur.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFIFOINT</name>
              <description>TX FIFO Threshold interrupt.
This bit is set when TX FIFO Threshold interrupts occur.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXFIFOINT</name>
              <description>RX FIFO Threshold interrupt.
This bit is set when RX FIFO Threshold interrupts occur.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFIFOURINT</name>
              <description>TX FIFO Underrun interrupt.
This bit is set when TX FIFO Underrun interrupts occur.
(Slave mode only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXFIFOORINT</name>
              <description>RX FIFO Overrun interrupt.
This bit is set when RX FIFO Overrun interrupts occur.
(Slave mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Timing</name>
          <description>Interface Timing Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>CS2SCLK</name>
              <description>The minimum time between the edges of SPI CS and the edges of SCLK.
SCLK_period * (CS2SCLK + 1) / 2</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSHT</name>
              <description>The minimum time that SPI CS should stay HIGH.
SCLK_period * (CSHT + 1) / 2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_DIV</name>
              <description>The clock frequency ratio between the clock source and SPI interface SCLK.
SCLK_period = ((SCLK_DIV + 1) * 2) * (Period of the SPI clock source)
The SCLK_DIV value 0xff is a special value which indicates that the SCLK frequency should be the same as the spi_clock frequency.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvSt</name>
          <description>Slave Status Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>UNDERRUN</name>
              <description>Data underrun occurs in the last transaction</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Data overrun occurs in the last transaction</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READY</name>
              <description>Set this bit to indicate that the ATCSPI200 is ready for data transaction.
When an SPI transaction other than slave status-reading command ends, this bit will be cleared to 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USR_STATUS</name>
              <description>User defined status flags</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvDataCnt</name>
          <description>Slave Data Count Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FF03FF</resetMask>
          <fields>
            <field>
              <name>WCNT</name>
              <description>Slave transmitted data count</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RCNT</name>
              <description>Slave received data count</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvDataWCnt</name>
          <description>WCnt</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvDataRCnt</name>
          <description>RCnt</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Config</name>
          <description>Configuration Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00004311</resetValue>
          <resetMask>0x000043FF</resetMask>
          <fields>
            <field>
              <name>SLAVE</name>
              <description>Support for SPI Slave mode</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QUADSPI</name>
              <description>Support for Quad I/O SPI</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DUALSPI</name>
              <description>Support for Dual I/O SPI</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFIFOSIZE</name>
              <description>Depth of TX FIFO
0x0: 2 words
0x1: 4 words
0x2: 8 words
0x3: 16 words
0x4: 32 words
0x5: 64 words
0x6: 128 words</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFIFOSIZE</name>
              <description>Depth of RX FIFO
0x0: 2 words
0x1: 4 words
0x2: 8 words
0x3: 16 words
0x4: 32 words
0x5: 64 words
0x6: 128 words</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI1</name>
      <description>SPI1</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0074000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI2</name>
      <description>SPI2</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0078000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI3</name>
      <description>SPI3</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf007c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI4</name>
      <description>SPI4</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf01b0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI5</name>
      <description>SPI5</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf01b4000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI6</name>
      <description>SPI6</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf01b8000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI7</name>
      <description>SPI7</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf01bc000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description>CRC</description>
      <groupName>CRC</groupName>
      <baseAddress>0xf0080000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x200</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>CHN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>pre_set</name>
            <description>&amp;index0 pre set for crc setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>PRE_SET</name>
                <description>0: no pre set
1: CRC32
2: CRC32-AUTOSAR
3: CRC16-CCITT
4: CRC16-XMODEM
5: CRC16-MODBUS
1: CRC32
2: CRC32-autosar
3: CRC16-ccitt
4: CRC16-xmodem
5: CRC16-modbus
6: crc16_dnp
7: crc16_x25
8: crc16_usb
9: crc16_maxim
10: crc16_ibm
11: crc8_maxim
12: crc8_rohc
13: crc8_itu
14: crc8
15: crc5_usb</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>clr</name>
            <description>chn&amp;index0 clear crc result and setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>CLR</name>
                <description>write 1 to clr crc setting and result for its channel.
always read 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>poly</name>
            <description>chn&amp;index0 poly</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POLY</name>
                <description>poly setting</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>init_data</name>
            <description>chn&amp;index0 init_data</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INIT_DATA</name>
                <description>initial data of CRC</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>xorout</name>
            <description>chn&amp;index0 xorout</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>XOROUT</name>
                <description>XOR for CRC result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>misc_setting</name>
            <description>chn&amp;index0 misc_setting</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0101013F</resetMask>
            <fields>
              <field>
                <name>BYTE_REV</name>
                <description>0: no wrap input byte order
1: wrap input byte order</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_OUT</name>
                <description>0: no wrap output bit order
1: wrap output bit order</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_IN</name>
                <description>0: no wrap input bit order
1: wrap input bit order</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POLY_WIDTH</name>
                <description>crc data length</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>data</name>
            <description>chn&amp;index0 data</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>data for crc</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>result</name>
            <description>chn&amp;index0 result</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESULT</name>
                <description>crc result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TSNS</name>
      <description>TSNS</description>
      <groupName>TSNS</groupName>
      <baseAddress>0xf0090000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>T</name>
          <description>Temperature</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Signed number of temperature in 256 x celsius degree</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TMAX</name>
          <description>Maximum Temperature</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0xFF800000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>maximum temperature ever found</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TMIN</name>
          <description>Minimum Temperature</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x007FFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>minimum temperature ever found</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AGE</name>
          <description>Sample age</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AGE</name>
              <description>age of T register in 24MHz clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>indicate value in T is valid or not
0: not valid
1:valid</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIGGER</name>
              <description>Software trigger for sensing in trigger mode, trigger will be ignored if in sensing or other mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONFIG</name>
          <description>Configuration</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00600300</resetValue>
          <resetMask>0xC3FF0713</resetMask>
          <fields>
            <field>
              <name>IRQ_EN</name>
              <description>Enable interrupt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RST_EN</name>
              <description>Enable reset</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_MIN_EN</name>
              <description>Enable compare for minimum temperature</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_MAX_EN</name>
              <description>Enable compare for maximum temperature</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPEED</name>
              <description>cycles of a progressive step in 24M clock, valid from 24-255, default 96
24: 24 cycle for a step
25: 25 cycle for a step
26: 26 cycle for a step
...
255: 255 cycle for a step</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVERAGE</name>
              <description>Average time, default in 3
0: measure and return
1: twice and average
2: 4 times and average
. . .
7: 128 times and average</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>continuous mode that keep sampling temperature peridically
0: trigger mode
1: continuous mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASYNC</name>
              <description>Acynchronous mode, this mode can work without clock, only available function ios compare to certain ADC value
0: active mode
1: Async mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable temperature
0: disable, temperature sensor is shut down
1: enable. Temperature sensor enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VALIDITY</name>
          <description>Sample validity</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x016E3600</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALIDITY</name>
              <description>time for temperature values to expire in 24M clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLAG</name>
          <description>Temperature flag</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00330001</resetMask>
          <fields>
            <field>
              <name>RECORD_MIN_CLR</name>
              <description>Clear minimum recorder of temerature, write 1 to clear</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RECORD_MAX_CLR</name>
              <description>Clear maximum recorder of temerature, write 1 to clear</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDER_TEMP</name>
              <description>Clear under temperature status, write 1 to clear</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVER_TEMP</name>
              <description>Clear over temperature status, write 1 to clear</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>IRQ flag, write 1 to clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPPER_LIM_IRQ</name>
          <description>Maximum temperature to interrupt</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Maximum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOWER_LIM_IRQ</name>
          <description>Minimum temperature to interrupt</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Minimum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPPER_LIM_RST</name>
          <description>Maximum temperature to reset</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Maximum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOWER_LIM_RST</name>
          <description>Minimum temperature to reset</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Minimum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNC</name>
          <description>Configuration in asynchronous mode</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x010107FF</resetMask>
          <fields>
            <field>
              <name>ASYNC_TYPE</name>
              <description>Compare hotter than or colder than in asynchoronous mode
0: hotter than
1: colder than</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Polarity of internal comparator</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE</name>
              <description>Value of async mode to compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADVAN</name>
          <description>Advance configuration</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03010003</resetMask>
          <fields>
            <field>
              <name>ASYNC_IRQ</name>
              <description>interrupt status of asynchronous mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE_IRQ</name>
              <description>interrupt status of active mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SAMPLING</name>
              <description>temperature sampling is working</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NEG_ONLY</name>
              <description>use negative compare polarity only</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_ONLY</name>
              <description>use positive compare polarity only</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MBX0A</name>
      <description>MBX0A</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <description>Command Registers</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXRESET</name>
              <description>Reset TX Fifo and word.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BARCTL</name>
              <description>Bus Access Response Control, when bit 15:14=
00: no bus error will be generated,      no wait for fifo write when fifo full and  no wait for word/fifo read when word message invalid or fifo empty; or when write to word/fifo message will be ignored.
 01: bus error will be generated when: 1, access invalid address; 2, write to ready only addr; 3, write to fulled fifo or valid message; 4, read from a emptied fifo/word message.
10: no error will be generated, but bus will wait when 1, write to fulled fifo/reg message; 2, read from a emptied fifo/reg message; write to word message will overwrite the existing reg value enven word message are still valid; read from invalid word message will read out last read out message data.happen.
11: reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEIE</name>
              <description>Bus Error Interrupt Enable, will enable the interrupt for any bus  error as described in the SR bit 13 to bit 8.
1, enable the bus access error interrupt.
0, disable the bus access error interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFMAIE</name>
              <description>TX FIFO message available interrupt enable.
1, enable the TX FIFO massage available interrupt.
0, disable the TX FIFO message available interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFMEIE</name>
              <description>TX FIFO message empty interrupt enable.
1, enable the TX FIFO massage empty interrupt.
0, disable the TX FIFO message empty interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMAIE</name>
              <description>RX FIFO message available interrupt enable.
1, enable the RX FIFO massage available interrupt.
0, disable the RX FIFO message available interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMFIE</name>
              <description>RX fifo message full interrupt enable.
1, enable the RX fifo message full interrupt.
0, disable the RX fifo message full interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWMEIE</name>
              <description>TX word message empty interrupt enable.
1, enable the TX word massage empty interrupt.
0, disable the TX word message empty interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWMVIE</name>
              <description>RX word message valid interrupt enable.
1, enable the RX word massage valid interrupt.
0, disable the RX word message valid interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <description>Status Registers</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x000000E2</resetValue>
          <resetMask>0xFFFF3FFF</resetMask>
          <fields>
            <field>
              <name>RFVC</name>
              <description>RX FIFO valid message count</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFEC</name>
              <description>TX FIFO empty message word count</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERRRE</name>
              <description>bus Error for read when rx word message are still invalid, this bit is W1C bit.
1, read from word message when the word message are still invalid will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EWTRF</name>
              <description>bus Error for write when tx word message are still valid, this bit is W1C bit.
1, write to word message when the word message are still valid will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRFE</name>
              <description>bus Error for read when rx fifo empty, this bit is W1C bit.
1, read from a empty rx fifo will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EWTFF</name>
              <description>bus Error for write when tx fifo full, this bit is W1C bit.
1, write to a fulled tx fifo will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EAIVA</name>
              <description>bus Error for Accessing Invalid Address; this bit is W1C bit.
1, read and write to invalid address in the bus of this block, will set this bit.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EW2RO</name>
              <description>bus Error for Write to Read Only address; this bit is W1C bit.
1, write to read only address happened in the bus of this block.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFMA</name>
              <description>TX FIFO Message slot available, the 4x32 TX FIFO message buffer to the other core full, will not trigger any interrupt.
1, TXFIFO message buffer has slot available
0, no slot available (fifo full)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFME</name>
              <description>TX FIFO Message Empty, no any data in the message FIFO buffer from other core, will not trigger any interrupt.message from other core.
1, no any message data in TXFIFO from other core.
0, there are some data in the 4x32 TX FIFO from other core yet.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMA</name>
              <description>RX FIFO Message Available, available data in the 4x32 TX FIFO message buffer to the other core, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, no any data in the 4x32 TXFIFO message buffer.
0, there are some data in the  the 4x32 TXFIFO message buffer already.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RFMF</name>
              <description>RX FIFO Message Full, message from other core; will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, the other core had written 4x32 message in the RXFIFO.
0, no 4x32 RX FIFO message from other core yet.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TWME</name>
              <description>TX word message empty, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, means this core had write word message to TXREG.
0, means no valid word message in the TXREG yet.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RWMV</name>
              <description>RX word message valid, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, the other core had written word message in the RXREG.
0, no valid word message yet in the RXREG.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXREG</name>
          <description>Transmit word message to other core.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXREG</name>
              <description>Transmit word message to other core.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXREG</name>
          <description>Receive word message from other core.</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXREG</name>
              <description>Receive word message from other core.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TXFIFO0</dimIndex>
          <name>TXWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFIFO</name>
              <description>TXFIFO for sending message to other core, FIFO size, 4x32
can write one of the word address to push data to the FIFO;
can also use 4x32 burst write from 0x010 to push 4 words to the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>RXFIFO0</dimIndex>
          <name>RXWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFIFO</name>
              <description>RXFIFO for receiving message from other core, FIFO size, 4x32
can read one of the word address to pop data to the FIFO;
can also use 4x32 burst read from 0x020 to read 4 words from the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX0B</name>
      <description>MBX0B</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a4000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX1A</name>
      <description>MBX1A</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a8000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX1B</name>
      <description>MBX1B</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00ac000</baseAddress>
    </peripheral>
    <peripheral>
      <name>EWDG0</name>
      <description>EWDG0</description>
      <groupName>EWDG</groupName>
      <baseAddress>0xf00b0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL0</name>
          <description>wdog ctrl register 0
Note: Parity check is required once writing to this register. The result should be zero by modular two addition of all bits</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x2FE2F03F</resetMask>
          <fields>
            <field>
              <name>CLK_SEL</name>
              <description>clock select
0：bus clock
1：ext clock</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_VALUE</name>
              <description>clock divider, the clock divider works as 2 ^ div_value for wdt counter</description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIN_EN</name>
              <description>window mode enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIN_LOWER</name>
              <description>Once window mode is opened, the lower counter value to refresh wdt
00: 4/8 overtime value
01: 5/8 of overtime value
10: 6/8 of overtime value
11: 7/8 of overtime value</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG_LOCK</name>
              <description>The register is locked and unlock is needed before re-config registers
Once the lock mechanism takes effect, the CTRL0, CTRL1, timeout int register, timeout rst register, needs unlock before re-config them.
The register update needs to be finished in the required period defined by UPD_OT_TIME register</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OT_SELF_CLEAR</name>
              <description>overtime reset can be self released after 32 function cycles</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_OT_REQ</name>
              <description>If refresh event has to be limited into a period after refresh unlocked.
Note: the refresh overtime counter works in bus clock domain, not in wdt function clock domain. The wdt divider doesn't take effect for refresh counter</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIN_UPPER</name>
              <description>The upper threshold of window value
The window period upper limit is: lower_limit + (overtime_rst_value / 16) * upper_reg_value
If this register value is zero, then no upper level limitation</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_LOCK</name>
              <description>WDT refresh has to be unlocked firstly once refresh lock is enable.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_UNLOCK_MEC</name>
              <description>Unlock refresh mechanism
00: the required unlock password is the same with refresh_psd_register
01: the required unlock password is a ring shift left value of refresh_psd_register
10: the required unlock password is always 16'h55AA, no matter what refresh_psd_register is
11: the required unlock password is a LSFR result of refresh_psd_register, the characteristic polynomial is X^15 + 1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DBG</name>
              <description>WTD enable or not in debug mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_LP</name>
              <description>WDT enable or not in low power mode
2'b00: wdt is halted once in low power mode
2'b01: wdt will work with 1/4 normal clock freq in low power mode
2'b10: wdt will work with 1/2 normal clock freq in low power mode
2'b11: wdt will work with normal clock freq in low power mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL1</name>
          <description>wdog ctrl register 1
Note: Parity check is required once writing to this register. The result should be zero by modular two addition of all bits</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00F300FC</resetMask>
          <fields>
            <field>
              <name>REF_FAIL_RST_EN</name>
              <description>Refresh violation will trigger an reset.
These event will be taken as a refresh violation:
1) Not refresh in the window once window mode is enabled
2) Not unlock refresh firstly if unlock is required
3) Not refresh in the required time after unlock, once refresh unlock overtime is enabled.
4) Not write the required word to refresh wdt.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_FAIL_INT_EN</name>
              <description>Refresh violation will trigger an interrupt</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNL_REF_FAIL_RST_EN</name>
              <description>Refresh unlock fail will trigger a reset</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNL_REF_FAIL_INT_EN</name>
              <description>Refresh unlock fail will trigger a interrupt</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OT_RST_EN</name>
              <description>WDT overtime will generate a reset</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OT_INT_EN</name>
              <description>WDT can generate an interrupt warning before timeout</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTL_VIO_RST_EN</name>
              <description>Ctrl update violation will trigger a reset
The violation event is to try updating the locked register before unlock them</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTL_VIO_INT_EN</name>
              <description>Ctrl update violation will trigger a interrupt</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNL_CTL_FAIL_RST_EN</name>
              <description>Unlock register update failure will trigger a reset</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNL_CTL_FAIL_INT_EN</name>
              <description>Unlock register update failure will trigger a interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_FAIL_RST_EN</name>
              <description>Parity error will trigger a reset
A parity check is required once writing to ctrl0 and ctrl1 register. The result should be zero by modular two addition of all bits</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_FAIL_INT_EN</name>
              <description>Parity error will trigger a interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OT_INT_VAL</name>
          <description>wdog timeout interrupt counter value</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>OT_INT_VAL</name>
              <description>WDT timeout interrupt value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OT_RST_VAL</name>
          <description>wdog timeout reset counter value</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>OT_RST_VAL</name>
              <description>WDT timeout reset value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_REFRESH_REG</name>
          <description>wdog refresh register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_REFRESH_REG</name>
              <description>Write this register by 32'h5A45_524F to refresh wdog
Note: Reading this register can read back wdt real time counter value, while it is only used by debug purpose</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_STATUS</name>
          <description>wdog status register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>PARITY_ERROR</name>
              <description>parity error
Write one to clear the bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OT_RST</name>
              <description>Timeout happens, a reset will happen once enable bit set
This bit can be cleared only by refreshing wdt or reset</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OT_INT</name>
              <description>Timeout happens, a interrupt will happen once enable bit set
This bit can be cleared only by refreshing wdt or reset</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTL_UNL_FAIL</name>
              <description>Unlock ctrl reg update protection fail
Write one to clear the bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTL_VIO</name>
              <description>Violate register update protection mechanism
Write one to clear the bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>REF_UNL_FAIL</name>
              <description>Refresh unlock fail
Write one to clear the bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>REF_VIO</name>
              <description>Refresh fail
Write one to clear the bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG_PROT</name>
          <description>ctrl register protection register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>UPD_OT_TIME</name>
              <description>The period in which register update has to be in after unlock
The required period is less than： 128 * 2 ^ UPD_OT_TIME * bus_clock_cycle</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPD_PSD</name>
              <description>The password of unlocking register update</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REF_PROT</name>
          <description>refresh protection register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>REF_UNL_PSD</name>
              <description>The password to unlock refreshing</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_EN</name>
          <description>Wdog enable</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>WDOG_EN</name>
              <description>Wdog is enabled, the re-written of this register is impacted by enable lock function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REF_TIME</name>
          <description>Refresh period value</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>REFRESH_PERIOD</name>
              <description>The refresh period after refresh unlocked
Note: the refresh overtime counter works in bus clock domain, not in wdt function clock domain. The wdt divider doesn't take effect for refresh counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="EWDG0">
      <name>EWDG1</name>
      <description>EWDG1</description>
      <groupName>EWDG</groupName>
      <baseAddress>0xf00b4000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="EWDG0">
      <name>EWDG2</name>
      <description>EWDG2</description>
      <groupName>EWDG</groupName>
      <baseAddress>0xf00b8000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="EWDG0">
      <name>EWDG3</name>
      <description>EWDG3</description>
      <groupName>EWDG</groupName>
      <baseAddress>0xf00bc000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="EWDG0">
      <name>PEWDG</name>
      <description>PEWDG</description>
      <groupName>EWDG</groupName>
      <baseAddress>0xf4128000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMAMUX</name>
      <description>DMAMUX</description>
      <groupName>DMAMUX</groupName>
      <baseAddress>0xf00c4000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>64</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>HDMA_MUX0,HDMA_MUX1,HDMA_MUX2,HDMA_MUX3,HDMA_MUX4,HDMA_MUX5,HDMA_MUX6,HDMA_MUX7,HDMA_MUX8,HDMA_MUX9,HDMA_MUX10,HDMA_MUX11,HDMA_MUX12,HDMA_MUX13,HDMA_MUX14,HDMA_MUX15,HDMA_MUX16,HDMA_MUX17,HDMA_MUX18,HDMA_MUX19,HDMA_MUX20,HDMA_MUX21,HDMA_MUX22,HDMA_MUX23,HDMA_MUX24,HDMA_MUX25,HDMA_MUX26,HDMA_MUX27,HDMA_MUX28,HDMA_MUX29,HDMA_MUX30,HDMA_MUX31,XDMA_MUX0,XDMA_MUX1,XDMA_MUX2,XDMA_MUX3,XDMA_MUX4,XDMA_MUX5,XDMA_MUX6,XDMA_MUX7,XDMA_MUX8,XDMA_MUX9,XDMA_MUX10,XDMA_MUX11,XDMA_MUX12,XDMA_MUX13,XDMA_MUX14,XDMA_MUX15,XDMA_MUX16,XDMA_MUX17,XDMA_MUX18,XDMA_MUX19,XDMA_MUX20,XDMA_MUX21,XDMA_MUX22,XDMA_MUX23,XDMA_MUX24,XDMA_MUX25,XDMA_MUX26,XDMA_MUX27,XDMA_MUX28,XDMA_MUX29,XDMA_MUX30,XDMA_MUX31</dimIndex>
          <name>MUXCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>DMA Mux Channel Enable
Enables the channel for DMA Mux. The DMA has separate channel enables/disables, which should be
used to disable or reconfigure a DMA channel.
0b - DMA Mux channel is disabled
1b - DMA Mux channel is enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SOURCE</name>
              <description>DMA Channel Source
Specifies which DMA source, if any, is routed to a particular DMA channel. See the "DMA MUX Mapping"</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HDMA</name>
      <description>HDMA</description>
      <groupName>DMAV2</groupName>
      <baseAddress>0xf00c8000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x43c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IDMisc</name>
          <description>ID Misc</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF00</resetMask>
          <fields>
            <field>
              <name>DMASTATE</name>
              <description>DMA state machine
localparam ST_IDLE  = 3'b000;
localparam ST_READ  = 3'b001;
localparam ST_READ_ACK = 3'b010;
localparam ST_WRITE = 3'b011;
localparam ST_WRITE_ACK = 3'b100;
localparam ST_LL  = 3'b101;
localparam ST_END  = 3'b110;
localparam ST_END_WAIT     = 3'b111;</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CURCHAN</name>
              <description>current channel in used</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMACfg</name>
          <description>DMAC Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>CHAINXFR</name>
              <description>Chain transfer
0x0: Chain transfer is not configured
0x1: Chain transfer is configured</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REQSYNC</name>
              <description>DMA request synchronization.
The DMA request synchronization should be configured to avoid signal integrity problems when the request signal is not clocked by the system bus clock,
which the DMA control logic operates in. If the request synchronization is not configured, the request signal is sampled directly without synchronization.
0x0: Request synchronization is not configured
0x1: Request synchronization is configured</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATAWIDTH</name>
              <description>AXI bus data width
0x0: 32 bits
0x1: 64 bits
0x2: 128 bits
0x3: 256 bits</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDRWIDTH</name>
              <description>AXI bus address width
0x18: 24 bits
0x19: 25 bits
...
0x40: 64 bits
Others: Invalid</description>
              <bitOffset>17</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CORENUM</name>
              <description>DMA core number
0x0: 1 core
0x1: 2 cores</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSNUM</name>
              <description>AXI bus interface number
0x0: 1 AXI bus
0x1: 2 AXI busses</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REQNUM</name>
              <description>Request/acknowledge pair number
0x0: 0 pair
0x1: 1 pair
0x2: 2 pairs
...
0x10: 16 pairs</description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFODEPTH</name>
              <description>FIFO depth
0x4: 4 entries
0x8: 8 entries
0x10: 16 entries
0x20: 32 entries
Others: Invalid</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHANNELNUM</name>
              <description>Channel number
0x1: 1 channel
0x2: 2 channels
...
0x8: 8 channels
Others: Invalid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMACtrl</name>
          <description>DMAC Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Software reset control. Write 1 to this bit to reset the DMA core and disable all channels.
Note: The software reset may cause the in-completion of AXI transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ChAbort</name>
          <description>Channel Abort Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHABORT</name>
              <description>Write 1 to bit n to abort channel n. The bits should only be set when the corresponding channels are enabled.
Otherwise, the writes will be ignored for channels that are not enabled. (N: Number of channels)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTHALFSTS</name>
          <description>Harlf Complete Interrupt Status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>half transfer done irq status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTTCSTS</name>
          <description>Trans Complete Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>The terminal count status, one bit per channel. The terminal count status is set when a channel transfer finishes without the abort or error event.
0x0: Channel n has no terminal count status
0x1: Channel n has terminal count status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTABORTSTS</name>
          <description>Abort Interrupt Status Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>The abort status of channel, one bit per channel. The abort status is set when a channel transfer is aborted.
0x0: Channel n has no abort status
0x1: Channel n has abort status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTERRSTS</name>
          <description>Error Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>The error status, one bit per channel. The error status is set when a channel transfer encounters the following error events:
- Bus error
- Unaligned address
- Unaligned transfer width
- Reserved configuration
0x0: Channel n has no error status
0x1: Channel n has error status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ChEN</name>
          <description>Channel Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>Alias of the Enable field of all ChnCtrl registers</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>32</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>ch0,ch1,ch2,ch3,ch4,ch5,ch6,ch7,ch8,ch9,ch10,ch11,ch12,ch13,ch14,ch15,ch16,ch17,ch18,ch19,ch20,ch21,ch22,ch23,ch24,ch25,ch26,ch27,ch28,ch29,ch30,ch31</dimIndex>
          <name>CHCTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x40</addressOffset>
          <register>
            <name>Ctrl</name>
            <description>Channel &amp;index0 Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFF5DF</resetMask>
            <fields>
              <field>
                <name>INFINITELOOP</name>
                <description>set to loop current config infinitely</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HANDSHAKEOPT</name>
                <description>0: one request to transfer one burst
1: one request to transfer all the data defined in ch_tts</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIORITY</name>
                <description>Channel priority level
0x0: Lower priority
0x1: Higher priority</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BURSTOPT</name>
                <description>set to change burst_size definition</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCBURSTSIZE</name>
                <description>Source burst size. This field indicates the number of transfers before DMA channel re-arbitration.
The burst transfer byte number is (SrcBurstSize * SrcWidth).
0x0: 1 transfer
0x1: 2 transfers
0x2: 4 transfers
0x3: 8 transfers
0x4: 16 transfers
0x5: 32 transfers
0x6: 64 transfers
0x7: 128 transfers
0x8: 256 transfers
0x9:512 transfers
0xa: 1024 transfers
0xb - 0xf: Reserved, setting this field with a reserved value triggers the error exception</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCWIDTH</name>
                <description>Source transfer width
0x0: Byte transfer
0x1: Half-word transfer
0x2: Word transfer
0x3: Double word transfer
0x4: Quad word transfer
0x5: Eight word transfer
0x6 - 0x7: Reserved, setting this field with a reserved value triggers the error exception</description>
                <bitOffset>21</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTWIDTH</name>
                <description>Destination transfer width.
Both the total transfer byte number and the burst transfer byte number should be aligned to the destination transfer width;
otherwise the error event will be triggered.
For example, destination transfer width should be set as byte transfer if total transfer byte is not aligned to half-word.
See field SrcBurstSize above for the definition of burst transfer byte number and section 3.2.8 for the definition of the total transfer byte number.
0x0: Byte transfer
0x1: Half-word transfer
0x2: Word transfer
0x3: Double word transfer
0x4: Quad word transfer
0x5: Eight word transfer
0x6 - 0x7: Reserved, setting this field with a reserved value triggers the error exception</description>
                <bitOffset>18</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCMODE</name>
                <description>Source DMA handshake mode
0x0: Normal mode
0x1: Handshake mode
Normal mode is enabled and started by software set Enable bit;
Handshake mode is enabled by software set Enable bit, started by hardware dma request from DMAMUX block</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTMODE</name>
                <description>Destination DMA handshake mode
0x0: Normal mode
0x1: Handshake mode
the difference bewteen Source/Destination handshake mode is:
the dma block will response hardware request after read in Source handshake mode;
the dma block will response hardware request after write in Destination handshake mode;
NOTE: can't set SrcMode and DstMode at same time, otherwise result unknown.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCADDRCTRL</name>
                <description>Source address control
0x0: Increment address
0x1: Decrement address
0x2: Fixed address
0x3: Reserved, setting the field with this value triggers the error exception</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTADDRCTRL</name>
                <description>Destination address control
0x0: Increment address
0x1: Decrement address
0x2: Fixed address
0x3: Reserved, setting the field with this value triggers the error exception</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_FIXBURST</name>
                <description>set to loop current burst, omit setting in src_addr_ctrl</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_FIXBURST</name>
                <description>set to loop current burst, omit setting in dst_addr_ctrl</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWAP_CTL</name>
                <description>00 ：use swap table(if swap table all 0, then act nothing)
01 :   byte swap
10 :   16bit swap
11 :   32bit swap</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTHALFCNTMASK</name>
                <description>Channel half interrupt mask
0x0: Allow the half interrupt to be triggered
0x1: Disable the half interrupt</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTABTMASK</name>
                <description>Channel abort interrupt mask
0x0: Allow the abort interrupt to be triggered
0x1: Disable the abort interrupt</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTERRMASK</name>
                <description>Channel error interrupt mask
0x0: Allow the error interrupt to be triggered
0x1: Disable the error interrupt</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTTCMASK</name>
                <description>Channel terminal count interrupt mask
0x0: Allow the terminal count interrupt to be triggered
0x1: Disable the terminal count interrupt</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Channel enable bit
0x0: Disable
0x1: Enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TranSize</name>
            <description>Channel &amp;index0Transfer Size Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0FFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRANSIZE</name>
                <description>Total transfer size from source. The total number of transferred bytes is (TranSize * SrcWidth). This register is cleared when the DMA transfer is done.
If a channel is enabled with zero total transfer size, the error event will be triggered and the transfer will be terminated.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SrcAddr</name>
            <description>Channel &amp;index0 Source Address Low Part Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SRCADDRL</name>
                <description>Low part of the source starting address. When the transfer completes, the value of {SrcAddrH,SrcAddrL} is updated to the ending address.
This address must be aligned to the source transfer size; otherwise, an error event will be triggered.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ChanReqCtrl</name>
            <description>Channel &amp;index0 DMA Request Control Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x1F1F0000</resetMask>
            <fields>
              <field>
                <name>SRCREQSEL</name>
                <description>Source DMA request select. Select the request/ack handshake pair that the source device is connected to.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTREQSEL</name>
                <description>Destination DMA request select. Select the request/ack handshake pair that the destination device is connected to.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DstAddr</name>
            <description>Channel &amp;index0 Destination Address Low Part Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DSTADDRL</name>
                <description>Low part of the destination starting address. When the transfer completes, the value of {DstAddrH,DstAddrL} is updated to the ending address.
This address must be aligned to the destination transfer size; otherwise the error event will be triggered.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SwapTable</name>
            <description>swap table register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TABLE</name>
                <description>"4bit for one byte, define how to swap, default is no swap.
For HDMA, support up to 4-byte, the register default value is 0x3210"</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LLPointer</name>
            <description>Channel &amp;index0 Linked List Pointer Low Part Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFF8</resetMask>
            <fields>
              <field>
                <name>LLPOINTERL</name>
                <description>Low part of the pointer to the next descriptor. The pointer must be double word aligned.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>29</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="HDMA">
      <name>XDMA</name>
      <description>XDMA</description>
      <groupName>DMAV2</groupName>
      <baseAddress>0xf3100000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PPI</name>
      <description>PPI</description>
      <groupName>PPI</groupName>
      <baseAddress>0xf00cc000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>glb_cfg</name>
          <description>glb_cfg</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>PAD_OUT_REG_ENJ</name>
              <description>0:  register output, one cycle delay;
1:  direct output， no delay but may have timing issue</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFT_RESET</name>
              <description>software reset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pad_cfg</name>
          <description>pad_cfg</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0x0F0FFFFF</resetMask>
          <fields>
            <field>
              <name>CS_IDLE_ST</name>
              <description>cs pin idle state, default high for active low</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DM_PAD_POL</name>
              <description>dm pin polarity</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL_PAD_OE</name>
              <description>the pad output enable signal. 0 for IN; 1 for OUT.
NOTE: for unused pads, set both ctrl_pad_oe and ctrl_pad_pol to 0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL_PAD_POL</name>
              <description>for OUT pad:
0: output the value in cmd
1: output reversed value in cmd
for IN pad, defines the signal active value,  when ctrl_cfg.io_cfg is set,
will wait the active value for ready(generally read or write ready)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>clkpin_cfg</name>
          <description>clkpin_cfg</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F0F23</resetMask>
          <fields>
            <field>
              <name>CYCLE</name>
              <description>there will be a system counter run from 0 to cycle,
clk output will be set to high when counter is clk_high, and low when counter is clk_low.
The output will be system clock if cycle is 0.
All 4 CS share same clock configuration(one clock pin with configured frequency).
different CS can be assert at different  counter value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIGH</name>
              <description>clock high numer</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW</name>
              <description>clock low number</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INVERT</name>
              <description>set to invert clock output</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AON</name>
              <description>0:  use clk_gate in cmd sequence for whether output clock
1: always enable clock output;</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>set to enable clock logic</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tm_cfg</name>
          <description>tm_cfg</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010FFF</resetMask>
          <fields>
            <field>
              <name>TM_EN</name>
              <description>timeout enable.
if enabled, then if each AHB transfer time exceed tm_cfg clock cycles, will assert irq</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TM_CFG</name>
              <description>timeout value, max 20us at 200MHz clock</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts</name>
          <description>irq_sts</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>IRQ_TMOUT_STS</name>
              <description>tiemout interrupt status, write 1 to clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en</name>
          <description>irq_en</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>IRQ_TMOUT_EN</name>
              <description>timeout interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>CS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x40</addressOffset>
          <register>
            <name>cfg0</name>
            <description>cfg0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0FFF0FFF</resetMask>
            <fields>
              <field>
                <name>ADDR_END</name>
                <description>No description available</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ADDR_START</name>
                <description>addr_start and addr_end config the address slot for CS0, use high 12bit,
the minimun slot is 1Mbyte(addr_start==addr_end)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg1</name>
            <description>cfg1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0xFFFF0000</resetValue>
            <resetMask>0xFFFF000F</resetMask>
            <fields>
              <field>
                <name>ADDR_MASK</name>
                <description>the high AHB address will AND with {cs0_mask[15:0], 16'hFFFF},
shift right with addr_shift, then output as real address.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ADDR_SHIFT</name>
                <description>gennerally should be configured according to port size,
0 for 8bit; 1 for 16bit; 2 for 32bit;</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg2</name>
            <description>cfg2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x10F010F7</resetMask>
            <fields>
              <field>
                <name>CS_SYNC_EN</name>
                <description>set to enable CS pin sync with clock counter.
Clr if use async mode(no clk pin), or not care the CS start time with clk pin</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC_CLK_SEL</name>
                <description>CS assert at when clk_div_cnt equal to sync_clk_sel</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>READY_IN_SEL</name>
                <description>0: use two stage sync;
1: use one stage sync</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTER_CMD_DLY</name>
                <description>set to none-zero value, will add delay between each command sequence for burst cmd,
or splited transfer cmd sequence(such as transfer 32bit on 16bit port),
CS will be de-assert during the delay.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SIZE</name>
                <description>00-8bit; 01-16bit; 10-32bit; 11-reserved</description>
                <bitOffset>1</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>CS enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg3</name>
            <description>cfg3</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3F3F3F3F</resetMask>
            <fields>
              <field>
                <name>RCMD_END1</name>
                <description>sequential read cmd end index</description>
                <bitOffset>24</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RCMD_START1</name>
                <description>sequential read cmd start index</description>
                <bitOffset>16</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RCMD_END0</name>
                <description>first read cmd end index</description>
                <bitOffset>8</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RCMD_START0</name>
                <description>first read cmd start index</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg4</name>
            <description>cfg4</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x3F3F3F3F</resetValue>
            <resetMask>0x3F3F3F3F</resetMask>
            <fields>
              <field>
                <name>WCMD_END1</name>
                <description>sequential write cmd end index</description>
                <bitOffset>24</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WCMD_START1</name>
                <description>sequential write cmd start index</description>
                <bitOffset>16</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WCMD_END0</name>
                <description>first write cmd end index</description>
                <bitOffset>8</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WCMD_START0</name>
                <description>first write cmd start index</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>64</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,rsv60,61,62,63</dimIndex>
          <name>CMD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>cmd_cfg</name>
            <description>cmd_cfg</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000300FF</resetMask>
            <fields>
              <field>
                <name>CS_VAL</name>
                <description>cs value in current cmd</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CLK_GATE</name>
                <description>the clock gate enable signal, set to output clock signal</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CYCLE_NUM</name>
                <description>cmd clock cycles</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ad_cfg</name>
            <description>ad_cfg</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>DIR3</name>
                <description>No description available</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AD_SEL3</name>
                <description>No description available</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BYTE_SEL3</name>
                <description>No description available</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR2</name>
                <description>No description available</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AD_SEL2</name>
                <description>No description available</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BYTE_SEL2</name>
                <description>No description available</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR1</name>
                <description>No description available</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AD_SEL1</name>
                <description>No description available</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BYTE_SEL1</name>
                <description>No description available</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR0</name>
                <description>0 for OUT; 1 for IN</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AD_SEL0</name>
                <description>0 for data; 1 for address.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BYTE_SEL0</name>
                <description>select one of the 4 bytes(11 for 31:24,  10 for 23:16, 01 for 15:8, 00 for 7:0)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ctrl_cfg</name>
            <description>ctrl_cfg</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x11111111</resetMask>
            <fields>
              <field>
                <name>IO_CFG7</name>
                <description>No description available</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_CFG6</name>
                <description>No description available</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_CFG5</name>
                <description>No description available</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_CFG4</name>
                <description>No description available</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_CFG3</name>
                <description>No description available</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_CFG2</name>
                <description>No description available</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_CFG1</name>
                <description>No description available</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_CFG0</name>
                <description>for OUT, it defines the output value(0 or 1);
for IN, it defines whether to wait for ready(ready polarity is defined in ctrl_pad_pol)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOM</name>
      <description>GPIOM</description>
      <groupName>GPIOM</groupName>
      <baseAddress>0xf00d8000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,rsv13,gpioy,gpioz</dimIndex>
          <name>ASSIGN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <dim>32</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>PIN00,PIN01,PIN02,PIN03,PIN04,PIN05,PIN06,PIN07,PIN08,PIN09,PIN10,PIN11,PIN12,PIN13,PIN14,PIN15,PIN16,PIN17,PIN18,PIN19,PIN20,PIN21,PIN22,PIN23,PIN24,PIN25,PIN26,PIN27,PIN28,PIN29,PIN30,PIN31</dimIndex>
            <name>PIN[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x80000F03</resetMask>
            <fields>
              <field>
                <name>LOCK</name>
                <description>lock fields in this register, lock can only be cleared by soc reset
0: fields can be changed
1: fields locked to current value, not changeable</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HIDE</name>
                <description>pin value visibility to gpios,
bit0: 1, invisible to soc gpio0; 0: visible to soc gpio0
bit1: 1, invisible to soc gpio1; 0: visible to soc gpio1
bit2: 1, invisible to cpu0 fast gpio; 0: visible to cpu0 fast gpio
bit3: 1, invisible to cpu1 fast gpio; 0: visible to cpu1 fast gpio</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SELECT</name>
                <description>select which gpio controls chip pin,
0: soc gpio0;
1: soc gpio1;
2: cpu0 fastgpio
3: cpu1 fast gpio</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LOBS</name>
      <description>LOBS</description>
      <groupName>LOBS</groupName>
      <baseAddress>0xf00dc000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xfb4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0000001</resetMask>
          <fields>
            <field>
              <name>RUN</name>
              <description>Run control.
0 LOBS disabled. Register programming permitted.
1 LOBS enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STREAMCTRL</name>
          <description>Stream Control Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000027</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>Signal Group Select
0 128bit from one group
1 from 2 groups, 4bit in each group</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_CLEAR</name>
              <description>FIFO Overflow Clear</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>Sample Rate
4 take one every 5
5 take one every 6
6 take one every 7</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BURST</name>
              <description>Burst Cfg
3b011 Incr4
3b101 Incr8
3b111 Incr16</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTACTION</name>
          <description>Pre-trigger Action Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRACE</name>
              <description>Enables trace</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTADDR</name>
          <description>Start Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Start address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDADDR</name>
          <description>End Address Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>End address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTSR</name>
          <description>Current Trigger State Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FINALSTATE</name>
              <description>0 LOBS is still tracing.
1 Indicates that the LOBS has stopped advancing Trigger States and stopped trace.
FINALSTATE can be set by TRIGCTRL.COUNTBRK reaching the final loop count, or by programming NEXTSTATEto zero</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSR</name>
              <description>Reads current Trigger State. This is a one-hot encoded field.
When CTRL.RUN:
0 RAZ.
1 Returns current Trigger State.
If FINALSTATE is 1, then the CTSR field gives the Trigger State when FINALSTATE became 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCVR</name>
          <description>Current Counter Value Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCVR</name>
              <description>Returns the counter value when the CTSR was last read. If the CTSR has never been read, then the value in the CCVR is undefined</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAVR</name>
          <description>Current Action Value Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRACE</name>
              <description>Trace active.
0b0 Trace is not active.
0b1 Trace is active.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOSTATE</name>
          <description>Fifo State Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FULL</name>
              <description>FIFO full</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FIFO empty</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FINALADDR</name>
          <description>Final Address Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Final address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRPSELA</name>
          <description>Group Select Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM2</name>
              <description>Select sample group number2</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM1</name>
              <description>Select sample group number1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRPENA</name>
          <description>Group Enable Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN2</name>
              <description>Enable sample group number2</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN1</name>
              <description>Enable sample group number1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIGSELA1</name>
          <description>Signal Select1 Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM4</name>
              <description>Select sample signal bit number4 in first group</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM3</name>
              <description>Select sample signal bit number3 in first group</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM2</name>
              <description>Select sample signal bit number2 in first group</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM1</name>
              <description>Select sample signal bit number1 in first group</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIGSELA2</name>
          <description>Signal Select2 Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM4</name>
              <description>Select sample signal bit number4 in second group</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM3</name>
              <description>Select sample signal bit number3 in second group</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM2</name>
              <description>Select sample signal bit number2 in second group</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM1</name>
              <description>Select sample signal bit number1 in second group</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIGENA</name>
          <description>Signal Enable Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN2</name>
              <description>Enable sample signal number2</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN1</name>
              <description>Enable sample signal number1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>5</dim>
          <dimIncrement>0x100</dimIncrement>
          <dimIndex>0,1,2,3,4</dimIndex>
          <name>STATE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>SIGSEL</name>
            <description>Signal Select Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Selects Signal Group.
0x1 Selects Signal Group 0.
0x2 Selects Signal Group 1.
0x4 Selects Signal Group 2.
0x8 Selects Signal Group 3.
0x10 Selects Signal Group 4.
0x20 Selects Signal Group 5.
0x40 Selects Signal Group 6.
0x80 Selects Signal Group 7.
0x100 Selects Signal Group 8.
0x200 Selects Signal Group 9.
0x400 Selects Signal Group 10.
0x800 Selects Signal Group 11.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRIGCTRL</name>
            <description>Trigger Control Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFCCF</resetMask>
            <fields>
              <field>
                <name>TRACE</name>
                <description>Trace capture control.
0b10 Trace is captured every ELACLK cycle.
others Reserved.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPSEL</name>
                <description>Comparison mode. Acts as both a counter enable and a select for the comparison mode.
0b0 Disable counters and select Trigger Signal Comparison mode.
0b1 Enable counters and select Trigger Counter Comparison mode.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>COMP</name>
                <description>Trigger Signal Comparison type select.
0b000 Trigger Signal Comparisons disabled. The enabled counters count clocks immediately after the Trigger State has been entered and generate a programmable Output Action and transition to the next Trigger State when the Counter Compare Register count is reached, that is when a Trigger Counter Comparison match occurs.
0b001 Compare type is equal (==).
0b010 Compare type is greater than (&gt;).
0b011 Compare type is greater than or equal (&gt;=).
0b101 Compare type is not equal (!=).
0b110 Compare type is less than (&lt;).
0b111 Compare type is less than or equal (&lt;=).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NEXTSTATE</name>
            <description>Next State Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NEXTSTATE</name>
                <description>Selects the next state to move to after the Trigger Condition has been met in the current state.
0x0 Do not change state. This is the final Trigger State.
0x1 Selects Trigger State 0.
0x2 Selects Trigger State 1.
0x4 Selects Trigger State 2.
0x8 Selects Trigger State 3.
0x10 Selects Trigger State 4.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ACTION</name>
            <description>Action Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRACE</name>
                <description>Trace active.
0b0 Trace disable.
0b1 Trace enable.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTCOMP</name>
            <description>Counter Compare Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>A value that, when reached in the associated up-counter for this Trigger State, causes a Trigger Counter Comparison match to occur.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTMASK</name>
            <description>External Mask Register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>External Mask</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTCOMP</name>
            <description>External Compare Register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>External Compare</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIGMASK</name>
            <description>Signal Mask Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NUM3</name>
                <description>Select compare signal number3</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NUM2</name>
                <description>Select compare signal number2</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NUM1</name>
                <description>Select compare signal number1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NUM0</name>
                <description>Select compare signal number0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COMPEN</name>
            <description>Compare Enable register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Select compare signal number0-3</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIGCOMP0</name>
            <description>Signal Compare Register0</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE0</name>
                <description>Compare golden value for Signal Group signals[31:0].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIGCOMP1</name>
            <description>Signal Compare Register1</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE1</name>
                <description>Compare golden value for Signal Group signals[63:32].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIGCOMP2</name>
            <description>Signal Compare Register2</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE2</name>
                <description>Compare golden value for Signal Group signals[95:64].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIGCOMP3</name>
            <description>Signal Compare Register3</description>
            <addressOffset>0x8c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE3</name>
                <description>Compare golden value for Signal Group signals[127:96].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>LAR</name>
          <description>Lock Access Register</description>
          <addressOffset>0xfb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Lock Access Value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC0</name>
      <description>ADC0</description>
      <groupName>ADC16</groupName>
      <baseAddress>0xf0100000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1464</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>12</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>trg0a,trg0b,trg0c,trg1a,trg1b,trg1c,trg2a,trg2b,trg2c,trg3a,trg3b,trg3c</dimIndex>
          <name>CONFIG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF3F3F7F</resetMask>
          <fields>
            <field>
              <name>TRIG_LEN</name>
              <description>length for current trigger, can up to 4 conversions for one trigger, from 0 to 3</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>INTEN3</name>
              <description>interrupt enable for 4th conversion</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN3</name>
              <description>channel number for 4th conversion</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN2</name>
              <description>interrupt enable for 3rd conversion</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN2</name>
              <description>channel number for 3rd conversion</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN1</name>
              <description>interrupt enable for 2nd conversion</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN1</name>
              <description>channel number for 2nd conversion</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE_EN</name>
              <description>preemption queue enable control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN0</name>
              <description>interrupt enable for 1st conversion</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN0</name>
              <description>channel number for 1st conversion</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trg_dma_addr</name>
          <description>No description available</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>TRG_DMA_ADDR</name>
              <description>buffer start address for trigger queue, 192byte total, 16 bytes for each trigger (4 bytes for each conversion)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trg_sw_sta</name>
          <description>No description available</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>TRG_SW_STA</name>
              <description>SW trigger start bit, HW will clear it after all conversions(up to 4) finished. SW should make sure it's 0 before set it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_INDEX</name>
              <description>which trigger for the SW trigger
0 for trig0a, 1 for trig0b…
3 for trig1a, …11 for trig3c</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>BUS_RESULT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>set after conversion finished if wait_dis is set, cleared after software read.
The first time read with 0 will trigger one new conversion.
If SW read other channel when one channel conversion is in progress, it will not trigger new conversion at other channel, and will get old result with valid 0, also with read_cflct interrupt status bit set.
the result may not realtime if software read once and wait  long time to read again</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT</name>
              <description>read this register will trigger one adc conversion.
If wait_dis bit is set, SW will get the latest conversion result(not current one) with valid bit is 0, SW need polling valid bit till it's set to get current result
If wait_dis bit is 0, SW can get the current conversion result with holding the bus, valid bit is always set at this mode. this is not recommended if channel sample time is too long</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>buf_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>BUS_MODE_EN</name>
              <description>bus mode enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAIT_DIS</name>
              <description>set to disable read waiting, get result immediately but maybe not current conversion result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000F1F</resetMask>
          <fields>
            <field>
              <name>CYCLE</name>
              <description>current dma write cycle bit</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEQ_LEN</name>
              <description>sequence queue length, 0 for one, 0xF for 16</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESTART_EN</name>
              <description>if set together with cont_en, HW will continue process the whole queue after trigger once.
If cont_en is 0, this bit is not used</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONT_EN</name>
              <description>if set, HW will continue process the queue till end(seq_len) after trigger once</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_TRIG</name>
              <description>SW trigger, pulse signal, cleared by HW one cycle later</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SW_TRIG_EN</name>
              <description>set to enable SW trigger</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HW_TRIG_EN</name>
              <description>set to enable external HW trigger, only trigger on posedge</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_dma_addr</name>
          <description>No description available</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>TAR_ADDR</name>
              <description>dma target address, should be 4-byte aligned</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_wr_addr</name>
          <description>No description available</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>SEQ_WR_POINTER</name>
              <description>HW update this field after each dma write, it indicate the next dma write pointer.
dma write address is (tar_addr+seq_wr_pointer)*4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_dma_cfg</name>
          <description>No description available</description>
          <addressOffset>0x80c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF3FFF</resetMask>
          <fields>
            <field>
              <name>STOP_POS</name>
              <description>if stop_en is set, SW is responsible to update this field to the next read point, HW should not write data to this point since it's not read out by SW yet</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RST</name>
              <description>set this bit will reset HW dma write pointer to seq_dma_addr, and set HW cycle bit to 1. dma is halted if this bit is set.
SW should clear all cycle bit in buffer to 0 before clear dma_rst</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_EN</name>
              <description>set to stop dma if reach the stop_pos</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_LEN</name>
              <description>dma buffer length, after write to (tar_addr[31:2]+buf_len)*4, the next dma address will be tar_addr[31:2]*4
0 for 4byte;
0xFFF for 16kbyte.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>cfg0,cfg1,cfg2,cfg3,cfg4,cfg5,cfg6,cfg7,cfg8,cfg9,cfg10,cfg11,cfg12,cfg13,cfg14,cfg15</dimIndex>
          <name>SEQ_QUE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SEQ_INT_EN</name>
              <description>interrupt enable for current conversion</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN_NUM_4_0</name>
              <description>channel number for current conversion</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_high_cfg</name>
          <description>No description available</description>
          <addressOffset>0x850</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>STOP_POS_HIGH</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_LEN_HIGH</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>PRD_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0xc00</addressOffset>
          <register>
            <name>prd_cfg</name>
            <description>No description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00001FFF</resetMask>
            <fields>
              <field>
                <name>PRESCALE</name>
                <description>0: 1xclock, 1: 2x, 2: 4x, 3: 8x,…,15: 32768x,…,31: 2Gx</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRD</name>
                <description>conver period, with prescale.
Set to 0 means disable current channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>prd_thshd_cfg</name>
            <description>No description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>THSHDH</name>
                <description>threshold high, assert interrupt(if enabled) if result exceed high or low.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THSHDL</name>
                <description>threshold low</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>prd_result</name>
            <description>No description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CHAN_RESULT</name>
                <description>adc convert result, update after each valid conversion.
it may be updated period according to config, also may be updated due to other queue convert the same channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>SAMPLE_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_CLOCK_NUMBER_SHIFT</name>
              <description>shift for sample clock number</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_CLOCK_NUMBER</name>
              <description>sample clock number, base on clock_period, default one period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>conv_cfg1</name>
          <description>No description available</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>CONVERT_CLOCK_NUMBER</name>
              <description>convert clock numbers, set to 21 (0x15) for 16bit mode, which means convert need 21 adc clock cycles(based on clock after divider);
user can use small value to get faster conversion, but less accuracy, need to config cov_end_cnt at adc16_config1 also.
Ex: use 200MHz bus clock for adc, set sample_clock_number to 4, sample_clock_number_shift to 0, covert_clk_number to 21 for 16bit mode, clock_divder to 3, then each ADC conversion(plus sample) need 25 cycles(50MHz).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_DIVIDER</name>
              <description>clock_period, N half clock cycle per half adc cycle
0 for same adc_clk and bus_clk,
1 for 1:2,
2 for 1:3,
...
15 for 1:16
Note: set to 2 can genenerate 66.7MHz adc_clk at 200MHz bus_clk</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xA0000001</resetMask>
          <fields>
            <field>
              <name>SEL_SYNC_AHB</name>
              <description>set to 1 will enable sync AHB bus, to get better bus performance.
Adc_clk must to be set to same as bus clock at this mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_AHB_EN</name>
              <description>set to 1 to enable ADC DMA to write data to soc memory bus, for trig queue and seq queue;</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT3_REALTIME</name>
              <description>set to enable trg queue stop other queues</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_sts</name>
          <description>No description available</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF0FFFF</resetMask>
          <fields>
            <field>
              <name>TRIG_CMPT</name>
              <description>interrupt for one trigger conversion complete if enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_CFLCT</name>
              <description>read conflict interrupt, set if wait_dis is set, one conversion is in progress, SW read another channel</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_SW_CFLCT</name>
              <description>sequence queue conflict interrupt, set if HW or SW trigger received during conversion</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_DMAABT</name>
              <description>dma abort interrupt, set if seqence dma write pointer reachs sw read pointer if stop_en is set</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CMPT</name>
              <description>the whole sequence complete interrupt</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CVC</name>
              <description>one conversion complete in seq_queue if related seq_int_en is set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_FIFO_FULL</name>
              <description>DMA fifo full interrupt, user need to check clock frequency if it's set.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHB_ERR</name>
              <description>set if got hresp=1, generally caused by wrong trg_dma_addr or seq_dma_addr</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_POS</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDOG</name>
              <description>set if one chanel watch dog event triggered</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_en</name>
          <description>No description available</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF0FFFF</resetMask>
          <fields>
            <field>
              <name>TRIG_CMPT</name>
              <description>interrupt for one trigger conversion complete if enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_CFLCT</name>
              <description>read conflict interrupt, set if wait_dis is set, one conversion is in progress, SW read another channel</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_SW_CFLCT</name>
              <description>sequence queue conflict interrupt, set if HW or SW trigger received during conversion</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_DMAABT</name>
              <description>dma abort interrupt, set if seqence dma write pointer reachs sw read pointer if stop_en is set</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CMPT</name>
              <description>the whole sequence complete interrupt</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CVC</name>
              <description>one conversion complete in seq_queue if related seq_int_en is set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_FIFO_FULL</name>
              <description>DMA fifo full interrupt, user need to check clock frequency if it's set.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHB_ERR</name>
              <description>set if got hresp=1, generally caused by wrong trg_dma_addr or seq_dma_addr</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_POS</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDOG</name>
              <description>set if one chanel watch dog event triggered</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trigmux_en</name>
          <description>No description available</description>
          <addressOffset>0x1118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0190FFFF</resetMask>
          <fields>
            <field>
              <name>SEQ_CMPT</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CVC</name>
              <description>No description available</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_POS</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDOG</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trg_cmpt_flag</name>
          <description>No description available</description>
          <addressOffset>0x111c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>TRG_CMPT_FLAG</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ana_ctrl0</name>
          <description>No description available</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80001004</resetMask>
          <fields>
            <field>
              <name>MOTO_EN</name>
              <description>"set to enable moto_soc and moto_valid.
Should use AHB clock for adc, this bit can be used avoid async output"</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_CLK_ON</name>
              <description>set to enable adc clock to analog, Software should set this bit before access to any adc16_* register.
MUST set clock_period to 0 or 1 for adc16 reg access</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STARTCAL</name>
              <description>set to start the offset calibration cycle (Active H). user need to clear it after setting it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ana_status</name>
          <description>No description available</description>
          <addressOffset>0x1210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000080</resetMask>
          <fields>
            <field>
              <name>CALON</name>
              <description>Indicates if the ADC is in calibration mode (Active H).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>34</dim>
          <dimIncrement>0x2</dimIncrement>
          <dimIndex>adc16_para00,adc16_para01,adc16_para02,adc16_para03,adc16_para04,adc16_para05,adc16_para06,adc16_para07,adc16_para08,adc16_para09,adc16_para10,adc16_para11,adc16_para12,adc16_para13,adc16_para14,adc16_para15,adc16_para16,adc16_para17,adc16_para18,adc16_para19,adc16_para20,adc16_para21,adc16_para22,adc16_para23,adc16_para24,adc16_para25,adc16_para26,adc16_para27,adc16_para28,adc16_para29,adc16_para30,adc16_para31,adc16_para32,adc16_para33</dimIndex>
          <name>ADC16_PARAMS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1400</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PARAM_VAL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc16_config0</name>
          <description>No description available</description>
          <addressOffset>0x1444</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01F07FFF</resetMask>
          <fields>
            <field>
              <name>REG_EN</name>
              <description>set to enable regulator</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BANDGAP_EN</name>
              <description>set to enable bandgap. user should set reg_en and bandgap_en before use adc16.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_AVG_CFG</name>
              <description>for average the calibration result.
0- 1 loop;   1- 2 loops;   2- 4 loops;   3- 8 loops;
4- 16 loops;  5-32 loops;   others reserved</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPT_EN</name>
              <description>set to enable preemption feature</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONV_PARAM</name>
              <description>conversion parameter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc16_config1</name>
          <description>No description available</description>
          <addressOffset>0x1460</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001F00</resetMask>
          <fields>
            <field>
              <name>COV_END_CNT</name>
              <description>used for faster conversion, user can change it to get higher convert speed(but less accuracy).
should set to (21-convert_clock_number+1).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="ADC0">
      <name>ADC1</name>
      <description>ADC1</description>
      <groupName>ADC16</groupName>
      <baseAddress>0xf0104000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ADC0">
      <name>ADC2</name>
      <description>ADC2</description>
      <groupName>ADC16</groupName>
      <baseAddress>0xf0108000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ADC0">
      <name>ADC3</name>
      <description>ADC3</description>
      <groupName>ADC16</groupName>
      <baseAddress>0xf010c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>ACMP0</name>
      <description>ACMP0</description>
      <groupName>ACMP</groupName>
      <baseAddress>0xf0130000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>chn0,chn1</dimIndex>
          <name>CHANNEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>cfg</name>
            <description>Configure Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HYST</name>
                <description>This bitfield configure the comparator hysteresis.
00: Hysteresis level 0
01: Hysteresis level 1
10: Hysteresis level 2
11: Hysteresis level 3</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACEN</name>
                <description>This bit enable the comparator internal DAC
0: DAC disabled
1: DAC enabled</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HPMODE</name>
                <description>This bit enable the comparator high performance mode.
0: HP mode disabled
1: HP mode enabled</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPEN</name>
                <description>This bit enable the comparator.
0: ACMP disabled
1: ACMP enabled</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MINSEL</name>
                <description>PIN select, from pad_ai_acmp[7:1] and dac_out</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_TRIG_EN</name>
                <description>if set, the dac value is from moto system when valid
if clr, use dac_cfg value</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PINSEL</name>
                <description>MIN select, from pad_ai_acmp[7:1] and dac_out</description>
                <bitOffset>20</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPOEN</name>
                <description>This bit enable the comparator output on pad.
0: ACMP output disabled
1: ACMP output enabled</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLTBYPS</name>
                <description>This bit bypass the comparator output digital filter.
0: The ACMP output need pass digital filter
1: The ACMP output digital filter is bypassed.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WINEN</name>
                <description>This bit enable the comparator window mode.
0: Window mode is disabled
1: Window mode is enabled</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OPOL</name>
                <description>The output polarity control bit.
0: The ACMP output remain un-changed.
1: The ACMP output is inverted.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLTMODE</name>
                <description>This bitfield define the ACMP output digital filter mode:
000-bypass
100-change immediately;
101-change after filter;
110-stalbe low;
111-stable high</description>
                <bitOffset>13</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCEN</name>
                <description>This bit enable the comparator output synchronization.
0: ACMP output not synchronized with ACMP clock.
1: ACMP output synchronized with ACMP clock.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLTLEN</name>
                <description>This bitfield define the ACMP output digital filter length. The unit is ACMP clock cycle.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>daccfg</name>
            <description>DAC configure register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DACCFG</name>
                <description>8bit DAC digital value output to analog block</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>sr</name>
            <description>Status register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>FEDGF</name>
                <description>Output falling edge flag. Write 1 to clear this flag.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REDGF</name>
                <description>Output rising edge flag. Write 1 to clear this flag.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>irqen</name>
            <description>Interrupt request enable register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>FEDGEN</name>
                <description>Output falling edge flag interrupt enable bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REDGEN</name>
                <description>Output rising edge flag interrupt enable bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>dmaen</name>
            <description>DMA request enable register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>FEDGEN</name>
                <description>Output falling edge flag DMA request enable bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REDGEN</name>
                <description>Output rising edge flag DMA request enable bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="ACMP0">
      <name>ACMP1</name>
      <description>ACMP1</description>
      <groupName>ACMP</groupName>
      <baseAddress>0xf0134000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ACMP0">
      <name>ACMP2</name>
      <description>ACMP2</description>
      <groupName>ACMP</groupName>
      <baseAddress>0xf0138000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ACMP0">
      <name>ACMP3</name>
      <description>ACMP3</description>
      <groupName>ACMP</groupName>
      <baseAddress>0xf013c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>I2S0</name>
      <description>I2S0</description>
      <groupName>I2S</groupName>
      <baseAddress>0xf0140000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x80</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SFTRST_RX</name>
              <description>software reset the RX module if asserted to be 1'b1. Self-clear.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SFTRST_TX</name>
              <description>software reset the TX module if asserted to be 1'b1. Self-clear.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SFTRST_CLKGEN</name>
              <description>software reset the CLK GEN module if asserted to be 1'b1.  Self-clear.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDNIE</name>
              <description>TX buffer data needed interrupt enable
0: TXE interrupt masked
1: TXE interrupt not masked. Used to generate an interrupt request when the TXE flag is set.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDAIE</name>
              <description>RX buffer data available interrupt enable
0: RXNE interrupt masked
1: RXNE interrupt not masked. Used to generate an interrupt request when the RXNE flag is set.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERRIE</name>
              <description>Error interrupt enable
This bit controls the generation of an interrupt when an error condition  (UD, OV) occurs.
0: Error interrupt is masked
1: Error interrupt is enabled</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DMA_EN</name>
              <description>Asserted to use DMA, else to use interrupt</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_EN</name>
              <description>Asserted to use DMA, else to use interrupt</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFOCLR</name>
              <description>Self-clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFOCLR</name>
              <description>Self-clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EN</name>
              <description>enable for each TX data pad</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EN</name>
              <description>enable for each RX data pad</description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_EN</name>
              <description>enable for the module</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RFIFO_FILLINGS</name>
          <description>Rx FIFO  Filling Level</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX3</name>
              <description>RX3 fifo fillings</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX2</name>
              <description>RX2 fifo fillings</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX1</name>
              <description>RX1 fifo fillings</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX0</name>
              <description>RX0 fifo fillings</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TFIFO_FILLINGS</name>
          <description>Tx FIFO  Filling Level</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX3</name>
              <description>TX3 fifo fillings</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX2</name>
              <description>TX2 fifo fillings</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX1</name>
              <description>TX1 fifo fillings</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX0</name>
              <description>TX0 fifo fillings</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_THRESH</name>
          <description>TX/RX FIFO Threshold setting.</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>TX fifo threshold to trigger STA[tx_dn]. When tx fifo filling is smaller than or equal to the threshold, assert the tx_dn flag.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX</name>
              <description>RX fifo threshold to trigger STA[rx_da].  When rx fifo filling is greater than or equal to the threshold, assert the rx_da flag.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Registers</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_UD</name>
              <description>Asserted when tx fifo is underflow. Should be ANDed with CTRL[tx_en] the for correct value. Write 1 to any of these 4 bits will clear the underflow error.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RX_OV</name>
              <description>Asserted when rx fifo is overflow. Write 1 to any of these 4 bits will clear the overflow error.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_DN</name>
              <description>Asserted when tx fifo data are needed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_DA</name>
              <description>Asserted when rx fifo data are available.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3</dimIndex>
          <name>RXD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3</dimIndex>
          <name>TXD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <description>Configruation Regsiters</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCLK_GATEOFF</name>
              <description>Gate off the bclk. Asserted to gate-off the BCLK.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCLK_DIV</name>
              <description>Linear prescaler to generate BCLK from MCLK.
BCLK_DIV [8:0] = 0: BCLK=No CLK.
BCLK_DIV [8:0] = 1: BCLK=MCLK/1
BCLK_DIV [8:0] = n: BCLK=MCLK/(n).
Note: These bits should be configured when the I2S is disabled. It is used only when the I2S is in master mode.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_BCLK_OUT</name>
              <description>Invert the BCLK before sending it out to pad. Only valid in BCLK master mode</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_BCLK_IN</name>
              <description>Invert the BCLK pad input before using it internally. Only valid in BCLK slave mode</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_FCLK_OUT</name>
              <description>Invert the FCLK before sending it out to pad. Only valid in FCLK master mode</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_FCLK_IN</name>
              <description>Invert the FCLK pad input before using it internally. Only valid in FCLK slave mode</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_MCLK_OUT</name>
              <description>Invert the MCLK before sending it out to pad. Only valid in MCLK master mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_MCLK_IN</name>
              <description>Invert the MCLK pad input before using it internally. Only valid in MCLK slave mode</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCLK_SEL_OP</name>
              <description>asserted to use external clk source</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FCLK_SEL_OP</name>
              <description>asserted to use external clk source</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCK_SEL_OP</name>
              <description>asserted to use external clk source</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_EDGE</name>
              <description>The start edge of a frame
0: Falling edge indicates a new frame (Just like standard I2S Philips standard)
1: Rising edge indicates a new frame</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_MAX</name>
              <description>CH_MAX[4:0] s the number of channels supported in TDM mode. When not in TDM mode, it must be set as 2.
It must be an even number, so CH_MAX[0] is always 0.
5'h2: 2 channels
5'h4: 4 channels
...
5‘h10: 16 channels (max)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDM_EN</name>
              <description>TDM mode
0: not TDM mode
1: TDM mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STD</name>
              <description>I2S standard selection
00: I2S Philips standard.
01: MSB justified standard (left justified)
10: LSB justified standard (right justified)
11: PCM standard
Note: For correct operation, these bits should be configured when the I2S is disabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATSIZ</name>
              <description>Data length to be transferred
00: 16-bit data length
01: 24-bit data length
10: 32-bit data length
11: Not allowed
Note: For correct operation, these bits should be configured when the I2S is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSIZ</name>
              <description>Channel length (number of bits per audio channel)
0: 16-bit wide
1: 32-bit wide
The bit write operation has a meaning only if DATSIZ = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.
Note: For correct operation, this bit should be configured when the I2S is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_CFGR</name>
          <description>Misc configuration Registers</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00042000</resetValue>
          <resetMask>0xFFFFEC01</resetMask>
          <fields>
            <field>
              <name>MCLK_GATEOFF</name>
              <description>Gate off the mclk. This mclk is the output of a glitch prone mux, so every time to switch the mclk, the gate off clock should be asserted at first. After the clock is switched, de-assert this bit to ungate off the mclk.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKOE</name>
              <description>Master clock output to pad enable
0: Master clock output is disabled
1: Master clock output is enabled
Note: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3</dimIndex>
          <name>RXDSLOT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3</dimIndex>
          <name>TXDSLOT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S1</name>
      <description>I2S1</description>
      <groupName>I2S</groupName>
      <baseAddress>0xf0144000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DAO</name>
      <description>DAO</description>
      <groupName>DAO</groupName>
      <baseAddress>0xf0150000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000200FF</resetMask>
          <fields>
            <field>
              <name>HPF_EN</name>
              <description>Whether HPF is enabled. This HPF is used to filter out the DC part.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONO</name>
              <description>Asserted to let the left and right channel output the same value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RIGHT_EN</name>
              <description>Asserted to enable the right channel</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEFT_EN</name>
              <description>Asserted to enable the left channel</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REMAP</name>
              <description>1: Use remap pwm version. The remap version is a version that one pwm output is tied to zero when the input pcm signal is positive or negative
0: Don't use remap pwm version</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INVERT</name>
              <description>all the outputs are inverted before sending to pad</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FALSE_LEVEL</name>
              <description>the pad output in False run mode, or when the module is disabled
0: all low
1: all high
2: P-high, N-low
3. output is not enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FALSE_RUN</name>
              <description>the module continues to consume data, but all the pads are constant, thus no audio out</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>Self-clear</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RUN</name>
              <description>Enable this module to run.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CFGR</name>
          <description>Configuration Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>FRAME_EDGE</name>
              <description>The start edge of a frame
0: Falling edge indicates a new frame (Just like standard I2S Philips standard)
1: Rising edge indicates a new frame</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_MAX</name>
              <description>CH_MAX[3:0] is the number if channels supported in TDM mode. When not in TDM mode, it must be set as 2.
It must be an even number, so CH_MAX[0] is always 0.
4'h2: 2 channels
4'h4: 4 channels
etc</description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDM_EN</name>
              <description>TDM mode
0: not TDM mode
1: TDM mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STD</name>
              <description>I2S standard selection
00: I2S Philips standard.
01: MSB justified standard (left justified)
10: LSB justified standard (right justified)
11: PCM standard
For more details on I2S standards.
Note: For correct operation, these bits should be configured when the I2S is disabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATSIZ</name>
              <description>Data length to be transferred
00: 16-bit data length
01: 24-bit data length
10: 32-bit data length
11: Not allowed
Note: For correct operation, these bits should be configured when the I2S is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSIZ</name>
              <description>Channel length (number of bits per audio channel)
0: 16-bit wide
1: 32-bit wide
The bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.
Note: For correct operation, this bit should be configured when the I2S is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXSLT</name>
          <description>RX Slot Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Slot enable for the channels.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPF_MA</name>
          <description>HPF A Coef Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COEF</name>
              <description>Composite value of  coef A of the Order-1 HPF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPF_B</name>
          <description>HPF B Coef Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COEF</name>
              <description>coef B of the Order-1 HPF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM</name>
      <description>PDM</description>
      <groupName>PDM</groupName>
      <baseAddress>0xf0154000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x809FF7FF</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>software reset the module. Self-clear.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOF_FEDGE</name>
              <description>asserted if the falling edge of the ref fclk from DAO is the start of a new frame. This is used to to align DAO feedback signal.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USE_COEF_RAM</name>
              <description>Asserted to use Coef RAM instead of Coef ROM</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILT_CRX_ERR_IE</name>
              <description>data accessed out of boundary error interruput enable. The error happens when the module cannot calculate the enough number of data in time.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OFIFO_OVFL_ERR_IE</name>
              <description>output fifo overflow error interrupt enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC_OVLD_ERR_IE</name>
              <description>CIC overload error interrupt enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC_SAT_ERR_IE</name>
              <description>Error interrupt enable
This bit controls the generation of an interrupt when an error condition  (CIC saturation) occurs.
0: Error interrupt is masked
1: Error interrupt is enabled</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEC_AFT_CIC</name>
              <description>decimation rate after CIC. Now it is forced to be 3.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPT_DLY</name>
              <description>Capture cycle delay&gt;=0, should be less than PDM_CLK_HFDIV</description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_HFDIV</name>
              <description>The clock divider will work at least 4.
0: div-by-2,
1: div-by-4
. . .
n: div-by-2*(n+1)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_DIV_BYPASS</name>
              <description>asserted to bypass the pdm clock divider</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_OE</name>
              <description>pdm_clk_output_en</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPF_EN</name>
              <description>pdm high pass filter enable. This order-1 HPF only applies to the PDM mic data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CH_CTRL</name>
          <description>Channel Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF03FF</resetMask>
          <fields>
            <field>
              <name>CH_POL</name>
              <description>Asserted to select PDM_CLK high level captured, otherwise to select PDM_CLK low level captured.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_EN</name>
              <description>Asserted to enable the channel.
Ch8 &amp; 9 are refs.
Ch0-7 are pdm mics.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ST</name>
          <description>Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>FILT_CRX_ERR</name>
              <description>data accessed out of boundary error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OFIFO_OVFL_ERR</name>
              <description>output fifo overflow error. The reason may be sampling frequency mismatch, either fast or slow.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CIC_OVLD_ERR</name>
              <description>CIC overload error. write 1 clear</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CIC_SAT_ERR</name>
              <description>CIC saturation. Write 1 clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CH_CFG</name>
          <description>Channel Configuration Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>CH9_TYPE</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH8_TYPE</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH7_TYPE</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_TYPE</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH5_TYPE</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_TYPE</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_TYPE</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_TYPE</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_TYPE</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_TYPE</name>
              <description>Type of Channel 0
2'b00: dec-by-3 wiith filter type0 (CIC Compenstation+norm filter)
2'b01: dec-by-3 with filter type 1 (No CIC compenstation, only norm filter)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_CFG</name>
          <description>CIC configuration register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>POST_SCALE</name>
              <description>the shift value after CIC results.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SGD</name>
              <description>Sigma_delta_order[1:0]
2'b00: 7
2'b01: 6
2'b10: 5
Others: unused</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC_DEC_RATIO</name>
              <description>CIC decimation factor</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_INBUF</name>
          <description>In Buf Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_PTR</name>
              <description>The buf size-1 for each channel</description>
              <bitOffset>22</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PITCH</name>
              <description>The spacing between starting address of adjacent channels</description>
              <bitOffset>11</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START_ADDR</name>
              <description>The starting address of channel 0 in filter data buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_FILT0</name>
          <description>Filter 0 Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>COEF_LEN_M0</name>
              <description>Coef length of filter type 2'b00 in coef memory</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_START_ADDR</name>
              <description>Starting address of Coef of filter type 2'b00 in coef memory</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_FILT1</name>
          <description>Filter 1 Control Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>COEF_LEN_M1</name>
              <description>Coef length of filter type 2'b01 in coef memory</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_START_ADDR</name>
              <description>Starting address of Coef of filter type 2'b01 in coef memory</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RUN</name>
          <description>Run Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>PDM_EN</name>
              <description>Asserted to enable the module</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMAddr</name>
          <description>Memory Access Address</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>0--0x0FFFFFFF: COEF_RAM
0x10000000--0x1FFFFFFF: DATA_RAM</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMData</name>
          <description>Memory Access Data</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>The data write-to/read-from buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPF_MA</name>
          <description>HPF A Coef Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COEF</name>
              <description>Composite value of  coef A of the Order-1 HPF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPF_B</name>
          <description>HPF B Coef Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COEF</name>
              <description>coef B of the Order-1 HPF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MCAN0</name>
      <description>MCAN0</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0300000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x408</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ENDN</name>
          <description>endian register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x87654321</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVT</name>
              <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBTP</name>
          <description>data bit timing and prescaler, writeable when CCCR.CCE and CCCR.INT are set</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000A33</resetValue>
          <resetMask>0x009F1FFF</resetMask>
          <fields>
            <field>
              <name>TDC</name>
              <description>transmitter delay compensation enable
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBRP</name>
              <description>Data Bit Rate Prescaler
The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit Rate Prescaler are 0 to 31.
When TDC = ‘1’, the range is limited to 0,1. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTSEG1</name>
              <description>Data time segment before sample point
Valid values are 0 to 31. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTSEG2</name>
              <description>Data time segment after sample point
Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSJW</name>
              <description>Data (Re)Synchronization Jump Width
Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST</name>
          <description>test register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F3FF0</resetMask>
          <fields>
            <field>
              <name>SVAL</name>
              <description>Started Valid
0= Value of TXBNS not valid
1= Value of TXBNS valid</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXBNS</name>
              <description>Tx Buffer Number Started
Tx Buffer number of message whose transmission was started last. Valid when SVAL is set. Valid values are 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PVAL</name>
              <description>Prepared Valid
0= Value of TXBNP not valid
1= Value of TXBNP valid</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXBNP</name>
              <description>Tx Buffer Number Prepared
Tx Buffer number of message that is ready for transmission. Valid when PVAL is set.Valid values are 0 to 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receive Pin
Monitors the actual value of pin m_can_rx
0= The CAN bus is dominant (m_can_rx = ‘0’)
1= The CAN bus is recessive (m_can_rx = ‘1’)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Control of Transmit Pin
00 Reset value, m_can_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_can_tx
10 Dominant (‘0’) level at pin m_can_tx
11 Recessive (‘1’) at pin m_can_tx</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LBCK</name>
              <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RWD</name>
          <description>ram watchdog</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>WDV</name>
              <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDC</name>
              <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of “00” the counter is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCCR</name>
          <description>CC control register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>NISO</name>
              <description>Non ISO Operation
If this bit is set, the M_CAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0
Note: When the generic parameter iso_only_g is set to ‘1’ in hardware synthesis, this bit becomes reserved and is read as ‘0’. The M_CAN always operates with the CAN FD frame format according to ISO 11898-1:2015.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXP</name>
              <description>Transmit Pause
If this bit is set, the M_CAN pauses for two CAN bit times before starting the next transmission after
itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFBI</name>
              <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PXHD</name>
              <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled
Note: When protocol exception handling is disabled, the M_CAN will transmit an error frame when it detects a protocol exception condition.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WMM</name>
              <description>Wide Message Marker
Enables the use of 16-bit Wide Message Markers. When 16-bit Wide Message Markers are used (WMM = ‘1’), 16-bit internal timestamping is disabled for the Tx Event FIFO.
0= 8-bit Message Marker used
1= 16-bit Message Marker used, replacing 16-bit timestamps in Tx Event FIFO</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTSU</name>
              <description>Use Timestamping Unit
When UTSU is set, 16-bit Wide Message Markers are also enabled regardless of the value of WMM.
0= Internal time stamping
1= External time stamping by TSU
Note: When generic parameter connected_tsu_g = ‘0’, there is no TSU connected to the M_CAN.
In this case bit UTSU is fixed to zero by synthesis.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRSE</name>
              <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled
Note: When CAN FD operation is disabled FDOE = ‘0’, BRSE is not evaluated.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FDOE</name>
              <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST</name>
              <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAR</name>
              <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MON</name>
              <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to ‘1’. The bit can be reset by the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR</name>
              <description>Clock Stop Request
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after all pending transfer requests have been completed and the CAN bus reached idle.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSA</name>
              <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_CAN may be set in power down by stopping m_can_hclk and m_can_cclk</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ASM</name>
              <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to ‘1’. The bit can be reset by the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CCE</name>
              <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = ‘1’)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Initialization
0= Normal Operation
1= Initialization is started</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NBTP</name>
          <description>nominal bit timing and prescaler register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x06000A03</resetValue>
          <resetMask>0xFFFFFF7F</resetMask>
          <fields>
            <field>
              <name>NSJW</name>
              <description>Nominal (Re)Synchronization Jump Width
Valid values are 0 to 127. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NBRP</name>
              <description>Nominal Bit Rate Prescaler
The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NTSEG1</name>
              <description>Nominal Time segment before sample point
Valid values are 1 to 255. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NTSEG2</name>
              <description>Nominal Time segment after sample point
Valid values are 1 to 127. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCC</name>
          <description>timestamp counter configuration</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F0003</resetMask>
          <fields>
            <field>
              <name>TCP</name>
              <description>Timestamp Counter Prescaler
Configures the timestamp and timeout counters time unit in multiples of CAN bit times [1…16]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSS</name>
              <description>timestamp Select
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as “00”</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCV</name>
          <description>timestamp counter value</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TSC</name>
              <description>Timestamp Counter
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).When TSCC.TSS = “01”, the Timestamp Counter is incremented in multiples of CAN bit times [1…16] depending on the configuration of TSCC.TCP.
A wrap around sets interrupt flag IR.TSW. Write access resets the counter to zero. When TSCC.TSS = “10”, TSC reflects the external Timestamp Counter value. A write access has no impact.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOCC</name>
          <description>timeout counter configuration</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0xFFFF0000</resetValue>
          <resetMask>0xFFFF0007</resetMask>
          <fields>
            <field>
              <name>TOP</name>
              <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOS</name>
              <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured by TOCC.TOP and continues down-counting.
When the Timeout Counter is controlled by one of the FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RP</name>
              <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOCV</name>
          <description>timeout counter value</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [1…16] depending on the configuration of TSCC.TCP.
When decremented to zero, interrupt flag IR.TOO is set and the Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.
Note: Byte access: when TOCC.TOS = “00，writing one of the register bytes 3/2/1/0 will preset the Timeout Counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECR</name>
          <description>error counter register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>CEL</name>
              <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the 8-bit Transmit Error Counter TEC or the 7-bit Receive Error Counter REC to be incremented.
The counter is also incremented when the Bus_Off limit is reached. It is not incremented when only RP is set without changing REC. The increment of CEL follows after the increment of REC or TEC.
The counter is reset by read access to CEL. The counter stops at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.
Note: Byte access: Reading byte 2 will reset CEL to zero, reading bytes 3/1/0 has no impact.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RP</name>
              <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REC</name>
              <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TEC</name>
              <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255
Note: When CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSR</name>
          <description>protocol status register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000707</resetValue>
          <resetMask>0x007F7FFF</resetMask>
          <fields>
            <field>
              <name>TDCV</name>
              <description>Transmitter Delay Compensation Value
Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO.
The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PXE</name>
              <description>Protocol Exception Event
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred
Note: Byte access: Reading byte 0 will reset PXE, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RFDF</name>
              <description>Received a CAN FD Message
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received
Note: Byte access: Reading byte 0 will reset RFDF, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RBRS</name>
              <description>BRS flag of last received CAN FD Message
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set
Note: Byte access: Reading byte 0 will reset RBRS, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESI</name>
              <description>ESI flag of last received CAN FD Message
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set
Note: Byte access: Reading byte 0 will reset RESI, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DLEC</name>
              <description>Data Phase Last Error Code
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set.Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with
its BRS flag set has been transferred (reception or transmission) without error.
Note: Byte access: Reading byte 0 will set DLEC to “111”, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BO</name>
              <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EW</name>
              <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EP</name>
              <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACT</name>
              <description>Activity
Monitors the module’s CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter
Note: ACT is set to “00” by a Protocol Exception Event.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEC</name>
              <description>Last Error Code
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to ‘0’when a message has been transferred (reception or transmission) without error.
0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_CAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value ‘1’), but the monitored bus
value was dominant.
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a dominant level (data or identifier bit logical value‘0’), but the monitored bus value was recessive.
 During Bus_Off recovery this status is set each time a sequence of 11 recessive bits has been monitored. This enables the CPU to monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to ‘7’. When the LEC shows the value ‘7’, no CAN bus event was detected since the last CPU read access to the Protocol Status Register.
Note: When a frame in CAN FD format has reached the data phase with BRS flag set, the next CAN event (error or valid frame) will be shown in DLEC instead of LEC. An error in a fixed stuff bit of a CAN FD CRC sequence will be shown as a Form Error, not Stuff Error.
Note: The Bus_Off recovery sequence (see ISO 11898-1:2015) cannot be shortened by setting or resetting CCCR.INIT. If the device goes Bus_Off, it will set CCCR.INIT of its own accord,stopping all bus activities.
 Once CCCR.INIT has been cleared by the CPU, the device will then wait for 129 occurrences of Bus Idle (129 * 11 consecutive recessive bits) before resuming normal operation.
At the end of the Bus_Off recovery sequence, the Error Management Counters will be reset. During the waiting time after the resetting of CCCR.INIT, each time a sequence of 11 recessive bits has been monitored, a Bit0Error code is written to PSR.LEC,
enabling the CPU to readily check up whether the CAN bus is stuck at dominant or continuously disturbed and to monitor the Bus_Off recovery sequence. ECR.REC is used to count these sequences.
Note: Byte access: Reading byte 0 will set LEC to “111”, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TDCR</name>
          <description>transmitter delay compensation</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>TDCO</name>
              <description>Transmitter Delay Compensation SSP Offset
Offset value defining the distance between the measured delay from m_can_tx to m_can_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDCF</name>
              <description>Transmitter Delay Compensation Filter Window Length
Defines the minimum value for the SSP position, dominant edges on m_can_rx that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than TDCO. Valid values are 0 to 127 mtq.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IR</name>
          <description>interrupt register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARA</name>
              <description>Access to Reserved Address
0= No access to reserved address occurred
1= Access to reserved address occurred</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PED</name>
              <description>Protocol Error in Data Phase (Data Bit Time is used)
0= No protocol error in data phase
1= Protocol error in data phase detected (PSR.DLEC ≠ 0,7)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEA</name>
              <description>Protocol Error in Arbitration Phase (Nominal Bit Time is used)
0= No protocol error in arbitration phase
1= Protocol error in arbitration phase detected (PSR.LEC ≠ 0,7)</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDI</name>
              <description>Watchdog Interrupt
0= No Message RAM Watchdog event occurred
1= Message RAM Watchdog event due to missing READY</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BO</name>
              <description>Bus_Off Status
0= Bus_Off status unchanged
1= Bus_Off status changed</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EW</name>
              <description>Warning Status
0= Error_Warning status unchanged
1= Error_Warning status changed</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EP</name>
              <description>Error Passive
0= Error_Passive status unchanged
1= Error_Passive status changed</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELO</name>
              <description>Error Logging Overflow
0= CAN Error Logging Counter did not overflow
1= Overflow of CAN Error Logging Counter occurred</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEU</name>
              <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. Controlled by input signal m_can_aeim_berr[1] generated by an optional external parity / ECC logic attached to the Message RAM.
An uncorrected Message RAM bit error sets CCCR.INIT to ‘1’. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected (e.g. parity logic)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEC</name>
              <description>Bit Error Corrected
Message RAM bit error detected and corrected. Controlled by input signal m_can_aeim_berr[0] generated by an optional external parity / ECC logic attached to the Message RAM.
0= No bit error detected when reading from Message RAM
1= Bit error detected and corrected (e.g. ECC)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRX</name>
              <description>Message stored to Dedicated Rx Buffer
The flag is set whenever a received message has been stored into a dedicated Rx Buffer.
0= No Rx Buffer updated
1= At least one received message stored into an Rx Buffer</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOO</name>
              <description>Timeout Occurred
0= No timeout
1= Timeout reached</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAF</name>
              <description>Message RAM Access Failure
The flag is set, when the Rx Handler
.has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message
storage is aborted and the Rx Handler starts processing of the following message.
.was not able to write a message to the Message RAM. In this case message storage is aborted.
In both cases the FIFO put index is not updated resp. the New Data flag for a dedicated Rx Buffer is not set, a partly stored message is overwritten when the next message is stored to this location.
The flag is also set when the Tx Handler was not able to read a message from the Message RAM in time. In this case message transmission is aborted. In case of a Tx Handler access failure the
M_CAN is switched into Restricted Operation Mode (see Section 3.1.5). To leave Restricted Operation Mode, the Host CPU has to reset CCCR.ASM.
0= No Message RAM access failure occurred
1= Message RAM access failure occurred</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSW</name>
              <description>Timestamp Wraparound
0= No timestamp counter wrap-around
1= Timestamp counter wrapped around</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFL</name>
              <description>Tx Event FIFO Element Lost
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFF</name>
              <description>Tx Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFW</name>
              <description>Tx Event FIFO Watermark Reached
0= Tx Event FIFO fill level below watermark
1= Tx Event FIFO fill level reached watermark</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFN</name>
              <description>Tx Event FIFO New Entry
0= Tx Event FIFO unchanged
1= Tx Handler wrote Tx Event FIFO element</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFE</name>
              <description>Tx FIFO Empty
0= Tx FIFO non-empty
1= Tx FIFO empty</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCF</name>
              <description>Transmission Cancellation Finished
0= No transmission cancellation finished
1= Transmission cancellation finished</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TC</name>
              <description>Transmission Completed
0= No transmission completed
1= Transmission completed</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPM</name>
              <description>High Priority Message
0= No high priority message received
1= High priority message received</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1L</name>
              <description>Rx FIFO 1 Message Lost
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1F</name>
              <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1W</name>
              <description>Rx FIFO 1 Watermark Reached
0= Rx FIFO 1 fill level below watermark
1= Rx FIFO 1 fill level reached watermark</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1N</name>
              <description>Rx FIFO 1 New Message
0= No new message written to Rx FIFO 1
1= New message written to Rx FIFO 1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0L</name>
              <description>Rx FIFO 0 Message Lost
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0F</name>
              <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0W</name>
              <description>Rx FIFO 0 Watermark Reached
0= Rx FIFO 0 fill level below watermark
1= Rx FIFO 0 fill level reached watermark</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0N</name>
              <description>Rx FIFO 0 New Message
0= No new message written to Rx FIFO 0
1= New message written to Rx FIFO 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IE</name>
          <description>interrupt enable</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARAE</name>
              <description>Access to Reserved Address Enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEDE</name>
              <description>Protocol Error in Data Phase Enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEAE</name>
              <description>Protocol Error in Arbitration Phase Enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDIE</name>
              <description>Watchdog Interrupt Enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOE</name>
              <description>Bus_Off Status Interrupt Enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EWE</name>
              <description>Warning Status Interrupt Enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Error Passive Interrupt Enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELOE</name>
              <description>Error Logging Overflow Interrupt Enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEUE</name>
              <description>Bit Error Uncorrected Interrupt Enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BECE</name>
              <description>Bit Error Corrected Interrupt Enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRXE</name>
              <description>Message stored to Dedicated Rx Buffer Interrupt Enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOOE</name>
              <description>Timeout Occurred Interrupt Enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAFE</name>
              <description>Message RAM Access Failure Interrupt Enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSWE</name>
              <description>Timestamp Wraparound Interrupt Enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFLE</name>
              <description>Tx Event FIFO Event Lost Interrupt Enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFFE</name>
              <description>Tx Event FIFO Full Interrupt Enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFWE</name>
              <description>Tx Event FIFO Watermark Reached Interrupt Enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFNE</name>
              <description>Tx Event FIFO New Entry Interrupt Enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFEE</name>
              <description>Tx FIFO Empty Interrupt Enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCFE</name>
              <description>Transmission Cancellation Finished Interrupt Enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCE</name>
              <description>Transmission Completed Interrupt Enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPME</name>
              <description>High Priority Message Interrupt Enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1LE</name>
              <description>Rx FIFO 1 Message Lost Interrupt Enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1FE</name>
              <description>Rx FIFO 1 Full Interrupt Enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1WE</name>
              <description>Rx FIFO 1 Watermark Reached Interrupt Enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1NE</name>
              <description>Rx FIFO 1 New Message Interrupt Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0LE</name>
              <description>Rx FIFO 0 Message Lost Interrupt Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0FE</name>
              <description>Rx FIFO 0 Full Interrupt Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0WE</name>
              <description>Rx FIFO 0 Watermark Reached Interrupt Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0NE</name>
              <description>Rx FIFO 0 New Message Interrupt Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ILS</name>
          <description>interrupt line select</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARAL</name>
              <description>Access to Reserved Address Line</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEDL</name>
              <description>Protocol Error in Data Phase Line</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEAL</name>
              <description>Protocol Error in Arbitration Phase Line</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDIL</name>
              <description>Watchdog Interrupt Line</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOL</name>
              <description>Bus_Off Status Interrupt Line</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EWL</name>
              <description>Warning Status Interrupt Line</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPL</name>
              <description>Error Passive Interrupt Line</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELOL</name>
              <description>Error Logging Overflow Interrupt Line</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEUL</name>
              <description>Bit Error Uncorrected Interrupt Line</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BECL</name>
              <description>Bit Error Corrected Interrupt Line</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRXL</name>
              <description>Message stored to Dedicated Rx Buffer Interrupt Line</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOOL</name>
              <description>Timeout Occurred Interrupt Line</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAFL</name>
              <description>Message RAM Access Failure Interrupt Line</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSWL</name>
              <description>Timestamp Wraparound Interrupt Line</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFLL</name>
              <description>Tx Event FIFO Event Lost Interrupt Line</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFFL</name>
              <description>Tx Event FIFO Full Interrupt Line</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFWL</name>
              <description>Tx Event FIFO Watermark Reached Interrupt Line</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFNL</name>
              <description>Tx Event FIFO New Entry Interrupt Line</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFEL</name>
              <description>Tx FIFO Empty Interrupt Line</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCFL</name>
              <description>Transmission Cancellation Finished Interrupt Line</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCL</name>
              <description>Transmission Completed Interrupt Line</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPML</name>
              <description>High Priority Message Interrupt Line</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1LL</name>
              <description>Rx FIFO 1 Message Lost Interrupt Line</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1FL</name>
              <description>Rx FIFO 1 Full Interrupt Line</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1WL</name>
              <description>Rx FIFO 1 Watermark Reached Interrupt Line</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1NL</name>
              <description>Rx FIFO 1 New Message Interrupt Line</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0LL</name>
              <description>Rx FIFO 0 Message Lost Interrupt Line</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0FL</name>
              <description>Rx FIFO 0 Full Interrupt Line</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0WL</name>
              <description>Rx FIFO 0 Watermark Reached Interrupt Line</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0NL</name>
              <description>Rx FIFO 0 New Message Interrupt Line</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ILE</name>
          <description>interrupt line enable</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>EINT1</name>
              <description>Enable Interrupt Line 1
0= Interrupt line m_can_int1 disabled
1= Interrupt line m_can_int1 enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EINT0</name>
              <description>Enable Interrupt Line 0
0= Interrupt line m_can_int0 disabled
1= Interrupt line m_can_int0 enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GFC</name>
          <description>global filter configuration</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>ANFS</name>
              <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANFE</name>
              <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RRFS</name>
              <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RRFE</name>
              <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIDFC</name>
          <description>standard ID filter configuration</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFC</resetMask>
          <fields>
            <field>
              <name>LSS</name>
              <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
&gt;128= Values greater than 128 are interpreted as 128</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FLSSA</name>
              <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XIDFC</name>
          <description>extended ID filter configuration</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007FFFFC</resetMask>
          <fields>
            <field>
              <name>LSE</name>
              <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
&gt;64= Values greater than 64 are interpreted as 64</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FLESA</name>
              <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XIDAM</name>
          <description>extended id and mask</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x1FFFFFFF</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>EIDM</name>
              <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message ID of a received frame.
 Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all bits set to one the mask is not active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>29</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPMS</name>
          <description>high priority message status</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>FLST</name>
              <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIDX</name>
              <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MSI</name>
              <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIDX</name>
              <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = ‘1’.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NDAT1</name>
          <description>new data1</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ND1</name>
              <description>New Data[31:0]
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective Rx Buffer has been updated from a received frame.
The flags remain set until the Host clears them.A flag is cleared by writing a ’1’ to the corresponding bit position. Writing a ’0’ has no effect. A hard reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NDAT2</name>
          <description>new data2</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ND2</name>
              <description>New Data[63:32]
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective Rx Buffer has been updated from a received frame.
The flags remain set until the Host clears them. A flag is cleared by writing a ’1’ to the corresponding bit position. Writing a ’0’ has no effect. A hard reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0C</name>
          <description>rx fifo 0 configuration</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7FFFFC</resetMask>
          <fields>
            <field>
              <name>F0OM</name>
              <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0WM</name>
              <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
&gt;64= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0S</name>
              <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
&gt;64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0SA</name>
              <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0S</name>
          <description>rx fifo 0 status</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x033F3F7F</resetMask>
          <fields>
            <field>
              <name>RF0L</name>
              <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero
Note: Overwriting the oldest message when RXF0C.F0OM = ‘1’ will not set this flag.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0F</name>
              <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0PI</name>
              <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0GI</name>
              <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0FL</name>
              <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0A</name>
          <description>rx fifo0 acknowledge</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>F0AI</name>
              <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the buffer index of the last element read from Rx FIFO 0 to F0AI.
This will set the Rx FIFO 0 Get Index RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXBC</name>
          <description>rx buffer configuration</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFC</resetMask>
          <fields>
            <field>
              <name>RBSA</name>
              <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).Also used to reference debug messages A,B,C.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1C</name>
          <description>rx fifo1 configuration</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7FFFFC</resetMask>
          <fields>
            <field>
              <name>F1OM</name>
              <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1WM</name>
              <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
&gt;64= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1S</name>
              <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
&gt;64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1SA</name>
              <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1S</name>
          <description>rx fifo1 status</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC33F3F7F</resetMask>
          <fields>
            <field>
              <name>DMS</name>
              <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RF1L</name>
              <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero
Note: Overwriting the oldest message when RXF1C.F1OM = ‘1’ will not set this flag.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1F</name>
              <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1PI</name>
              <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1GI</name>
              <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1FL</name>
              <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1A</name>
          <description>rx fifo 1 acknowledge</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>F1AI</name>
              <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the buffer index of the last element read from Rx FIFO 1 to F1AI.
This will set the Rx FIFO 1 Get Index RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXESC</name>
          <description>rx buffer/fifo element size configuration</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000777</resetMask>
          <fields>
            <field>
              <name>RBDS</name>
              <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1DS</name>
              <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0DS</name>
              <description>Rx FIFO 0 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field
Note: In case the data field size of an accepted CAN frame exceeds the data field size configured for the matching Rx Buffer or Rx FIFO,
only the number of bytes as configured by RXESC are stored to the Rx Buffer resp. Rx FIFO element. The rest of the frame’s data field is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBC</name>
          <description>tx buffer configuration</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7F3FFFFC</resetMask>
          <fields>
            <field>
              <name>TFQM</name>
              <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFQS</name>
              <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
&gt;32= Values greater than 32 are interpreted as 32</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NDTB</name>
              <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
&gt;32= Values greater than 32 are interpreted as 32</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TBSA</name>
              <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).
Note: Be aware that the sum of TFQS and NDTB may be not greater than 32. There is no check for erroneous configurations. The Tx Buffers section in the Message RAM starts with the dedicated Tx Buffers.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXFQS</name>
          <description>tx fifo/queue status</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F1F3F</resetMask>
          <fields>
            <field>
              <name>TFQF</name>
              <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFQPI</name>
              <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFGI</name>
              <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
(TXBC.TFQM = ‘1’).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFFL</name>
              <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when Tx Queue operation is configured (TXBC.TFQM = ‘1’)
Note: In case of mixed configurations where dedicated Tx Buffers are combined with a Tx FIFO or a Tx Queue, the Put and Get Indices indicate the number of the Tx Buffer starting with
the first dedicated Tx Buffers.
Example: For a configuration of 12 dedicated Tx Buffers and a Tx FIFO of 20 Buffers a Put Index of 15 points to the fourth buffer of the Tx FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXESC</name>
          <description>tx buffer element size configuration</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>TBDS</name>
              <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field
Note: In case the data length code DLC of a Tx Buffer element is configured to a value higher than the Tx Buffer data field size TXESC.TBDS, the bytes not defined by the Tx Buffer are transmitted as “0xCC” (padding bytes).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBRP</name>
          <description>tx buffer request pending</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRP</name>
              <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set, a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register TXBRP. In case a transmission has already been started when a cancellation is requested,
this is done at the end of the transmission, regardless whether the transmission was successful or not. The cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signalled via TXBCF
? after successful transmission together with the corresponding TXBTO bit
? when the transmission has not yet been started at the point of cancellation
? when the transmission has been aborted due to lost arbitration
? when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending
Note: TXBRP bits which are set while a Tx scan is in progress are not considered during this particular Tx scan. In case a cancellation is requested for such a Tx Buffer, this Add Request is cancelled immediately, the corresponding TXBRP bit is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBAR</name>
          <description>tx buffer add request</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AR</name>
              <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a ‘1’ will set the corresponding Add Request bit; writing a ‘0’ has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan process has completed.
0= No transmission request added
1= Transmission requested added
Note: If an add request is applied for a Tx Buffer with pending transmission request (corresponding TXBRP bit already set), this add request is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCR</name>
          <description>tx buffer cancellation request</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CR</name>
              <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a ‘1’ will set the corresponding Cancellation Request bit; writing a ‘0’ has no impact.
This enables the Host to set cancellation requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBTO</name>
          <description>tx buffer transmission occurred</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TO</name>
              <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission is requested by writing a ‘1’ to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCF</name>
          <description>tx buffer cancellation finished</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CF</name>
              <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding TXBRP bit is cleared after a cancellation was requested via TXBCR.
In case the corresponding TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a new transmission is requested by writing a ‘1’ to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBTIE</name>
          <description>tx buffer transmission interrupt enable</description>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIE</name>
              <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCIE</name>
          <description>tx buffer cancellation finished interrupt enable</description>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFIE</name>
              <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFC</name>
          <description>tx event fifo configuration</description>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3FFFFC</resetMask>
          <fields>
            <field>
              <name>EFWM</name>
              <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
&gt;32= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFS</name>
              <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
&gt;32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS - 1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFSA</name>
              <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFS</name>
          <description>tx event fifo status</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x031F1F3F</resetMask>
          <fields>
            <field>
              <name>TEFL</name>
              <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFF</name>
              <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFPI</name>
              <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFGI</name>
              <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFFL</name>
              <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFA</name>
          <description>tx event fifo acknowledge</description>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>EFAI</name>
              <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TS_SEL0,TS_SEL1,TS_SEL2,TS_SEL3,TS_SEL4,TS_SEL5,TS_SEL6,TS_SEL7,TS_SEL8,TS_SEL9,TS_SEL10,TS_SEL11,TS_SEL12,TS_SEL13,TS_SEL14,TS_SEL15</dimIndex>
          <name>TS_SEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TS</name>
              <description>Timestamp Word TS
default can save 16 timestamps with 32bit;
if ts64_en is set, then work at 64bit mode, can save 8 timestamps with 01/23/45….</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CREL</name>
          <description>core release register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REL</name>
              <description>Core Release
One digit, BCD-coded</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STEP</name>
              <description>Step of Core Release
One digit, BCD-coded.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SUBSTEP</name>
              <description>Sub-step of Core Release
One digit, BCD-coded</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>YEAR</name>
              <description>Timestamp Year
One digit, BCD-coded. This field is set by generic parameter on
synthesis.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MON</name>
              <description>Timestamp Month
Two digits, BCD-coded. This field is set by generic parameter
on synthesis.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DAY</name>
              <description>Timestamp Day
Two digits, BCD-coded. This field is set by generic parameter
on synthesis.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCFG</name>
          <description>timestamp configuration</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF0F</resetMask>
          <fields>
            <field>
              <name>TBPRE</name>
              <description>Timebase Prescaler
0x00 to 0xFF
The value by which the oscillator frequency is divided for
generating the timebase counter clock. Valid values for the
Timebase Prescaler are 0 to 255. The actual interpretation by
the hardware of this value is such that one more than the value
programmed here is used. Affects only the TSU internal
timebase. When the internal timebase is excluded by synthesis,
TBPRE[7:0] is fixed to 0x00, the Timestamp Prescaler is not
used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN64</name>
              <description>set to use 64bit timestamp.
when enabled, tsu can save up to 8 different timestamps, TS(k) and TS(k+1) are used for one 64bit timestamp, k is 0~7.
TSP can be used to select different one</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCP</name>
              <description>Select Capturing Position
0: Capture Timestamp at EOF
1: Capture Timestamp at SOF</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TBCS</name>
              <description>Timebase Counter Select
When the internal timebase is excluded by synthesis, TBCS is
fixed to ‘1’.
0: Timestamp value captured from internal timebase counter,
 ATB.TB[31:0] is the internal timbase counter
1: Timestamp value captured from input tsu_tbin[31:0],ATB.TB[31:0] is tsu_tbin[31:0]</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSUE</name>
              <description>Timestamp Unit Enable
0: TSU disabled
1: TSU enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSS1</name>
          <description>timestamp status1</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSL</name>
              <description>Timestamp Lost
Each Timestamp register (TS0-TS15) is assigned one bit. The bits are set when the timestamp stored in the related Timestamp register was overwritten before it was read.
Reading a Timestamp register resets the related bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSN</name>
              <description>Timestamp New
Each Timestamp register (TS0-TS15) is assigned one bit. The bits are set when a timestamp was stored in the related
Timestamp register. Reading a Timestamp register resets the related bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSS2</name>
          <description>timestamp status2</description>
          <addressOffset>0x24c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>TSP</name>
              <description>Timestamp Pointer
The Timestamp Pointer is incremented by one each time a timestamp is captured. From its maximum value (3, 7, or 15
depending on number_ts_g), it is incremented to 0.
Value also signalled on output m_can_tsp[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ATB</name>
          <description>actual timebase</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TB</name>
              <description>timebase for timestamp generation 31-0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ATBH</name>
          <description>actual timebase high</description>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TBH</name>
              <description>timebase for timestamp generation 63-32</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GLB_CTL</name>
          <description>global control</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xE0000003</resetMask>
          <fields>
            <field>
              <name>M_CAN_STBY</name>
              <description>m_can standby control</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STBY_CLR_EN</name>
              <description>m_can standby clear control
0:controlled by software by standby bit[bit31]
1:auto clear standby by hardware when rx data is  0</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STBY_POL</name>
              <description>standby polarity selection</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN_SEL</name>
              <description>external timestamp select. each CAN block has 4 timestamp input, this register is used to select one of them as timestame if TSCFG.TBCS is set to 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GLB_STATUS</name>
          <description>global status</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000C</resetMask>
          <fields>
            <field>
              <name>M_CAN_INT1</name>
              <description>m_can interrupt status1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>M_CAN_INT0</name>
              <description>m_can interrupt status0</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN1</name>
      <description>MCAN1</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0304000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN2</name>
      <description>MCAN2</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0308000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN3</name>
      <description>MCAN3</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf030c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN4</name>
      <description>MCAN4</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0310000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN5</name>
      <description>MCAN5</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0314000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN6</name>
      <description>MCAN6</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0318000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN7</name>
      <description>MCAN7</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf031c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PTPC</name>
      <description>PTPC</description>
      <groupName>PTPC</groupName>
      <baseAddress>0xf037c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3004</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x1000</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>PTPC[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>Ctrl0</name>
            <description>Control Register 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>SUBSEC_DIGITAL_ROLLOVER</name>
                <description>Format for ns counter rollover,
1-digital, overflow time 1000000000/0x3B9ACA00
0-binary, overflow time  0x7FFFFFFF</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_KEEP</name>
                <description>set  will keep capture snap till software read capt_snapl.
If this bit is set, software should read capt_snaph first to avoid wrong result.
If this bit is cleared, capture result will be updated at each capture event</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_POS_EN</name>
                <description>set will use posege of input capture signal to latch timestamp value</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_NEG_EN</name>
                <description>No description available</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>COMP_EN</name>
                <description>set to enable compare, will be cleared by HW when compare event triggered</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UPDATE_TIMER</name>
                <description>update timer with +/- ts_updt, pulse, clear after set</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>INIT_TIMER</name>
                <description>initial timer with ts_updt, pulse, clear after set</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>FINE_COARSE_SEL</name>
                <description>0: coarse update, ns counter add ss_incr[7:0] each clk
1: fine update, ns counter add ss_incr[7:0] each time addend counter overflow</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMER_ENABLE</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ctrl1</name>
            <description>Control Register 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>SS_INCR</name>
                <description>constant value used to add ns counter;
such as for 50MHz timer clock, set it to 8'd20</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>timeh</name>
            <description>timestamp high</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMESTAMP_HIGH</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>timel</name>
            <description>timestamp low</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMESTAMP_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ts_updth</name>
            <description>timestamp update high</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC_UPDATE</name>
                <description>together with ts_updtl, used to initial or update timestamp</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ts_updtl</name>
            <description>timestamp update low</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADD_SUB</name>
                <description>1 for sub; 0 for add, used only at update</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NS_UPDATE</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>31</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>addend</name>
            <description>No description available</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDEND</name>
                <description>used in fine update mode only</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tarh</name>
            <description>No description available</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TARGET_TIME_HIGH</name>
                <description>used for generate compare signal if enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tarl</name>
            <description>No description available</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TARGET_TIME_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>pps_ctrl</name>
            <description>No description available</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>PPS_CTRL</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>capt_snaph</name>
            <description>No description available</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPT_SNAP_HIGH</name>
                <description>take snapshot for input capture signal, at pos or neg or both;
the result can be kept or updated at each event according to cfg0.bit8</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>capt_snapl</name>
            <description>No description available</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPT_SNAP_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>time_sel</name>
          <description>No description available</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>CAN3_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN2_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN1_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN0_TIME_SEL</name>
              <description>set to use ptpc1 for canx
clr to use ptpc0 for canx</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_sts</name>
          <description>No description available</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00070007</resetMask>
          <fields>
            <field>
              <name>COMP_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PPS_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>COMP_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PPS_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_en</name>
          <description>No description available</description>
          <addressOffset>0x2008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00070007</resetMask>
          <fields>
            <field>
              <name>COMP_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ptpc_can_ts_sel</name>
          <description>No description available</description>
          <addressOffset>0x3000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>TSU_TBIN3_SEL</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN2_SEL</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN1_SEL</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN0_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>QEI0</name>
      <description>QEI0</description>
      <groupName>QEIV2</groupName>
      <baseAddress>0xf0400000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x298</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>cr</name>
          <description>Control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x807FFF7F</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>1- load phcnt, zcnt, spdcnt and tmrcnt into their read registers. Hardware auto-clear; read as 0</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZCNTCFG</name>
              <description>1- zcnt will increment when phcnt upcount to phmax, decrement when phcnt downcount to 0
0- zcnt will increment or decrement when Z input assert</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHCALIZ</name>
              <description>1- phcnt will set to phidx when Z input assert(for abz digital signsl)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Z_ONLY_EN</name>
              <description>1- phcnt will set to phidx when Z input assert(for xy analog signal and digital z, also need set phcaliz)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>H2FDIR0</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>H2FDIR1</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>H2RDIR0</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>H2RDIR1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSEPOS</name>
              <description>1- pause position output valid when PAUSE assert</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSESPD</name>
              <description>1- pause spdcnt when PAUSE assert</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSEPH</name>
              <description>1- pause phcnt when PAUSE assert</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSEZ</name>
              <description>1- pause zcnt when PAUSE assert</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HFDIR0</name>
              <description>1- HOMEF will set at H rising edge when dir == 1 (negative rotation direction)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HFDIR1</name>
              <description>1- HOMEF will set at H rising edge when dir == 0 (positive rotation direction)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HRDIR0</name>
              <description>1- HOMEF will set at H falling edge when dir == 1 (negative rotation direction)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HRDIR1</name>
              <description>1- HOMEF will set at H falling edge when dir == 1 (positive rotation direction)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTPOS</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAPEN</name>
              <description>1- load phcnt, zcnt, spdcnt and tmrcnt into their snap registers when snapi input assert</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCNT</name>
              <description>1- reset zcnt, spdcnt and tmrcnt to 0. reset phcnt to phidx</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_SEL</name>
              <description>define the width/counter value(affect width_match, width_match2, width_cur, timer_cur, width_read, timer_read,
width_snap0,width_snap1, timer_snap0, timer_snap1)
0 : same as hpm1000/500/500s;
1: use width for position; use timer for angle</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENCTYP</name>
              <description>000-abz; 001-pd; 010-ud; 011-UVW(hal)
100-single A; 101-single sin;  110: sin&amp;cos</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phcfg</name>
          <description>Phase configure register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHMAX</name>
              <description>maximum phcnt number, phcnt will rollover to 0 when it upcount to phmax</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>wdgcfg</name>
          <description>Watchdog configure register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDGEN</name>
              <description>1- enable wdog counter</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDOG_CFG</name>
              <description>define as stop if phase_cnt change is less than it
if 0, then each change of phase_cnt will clear wdog counter;
if 2, then phase_cnt change larger than 2 will clear wdog counter</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDGTO</name>
              <description>watch dog timeout value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phidx</name>
          <description>Phase index register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHIDX</name>
              <description>phcnt reset value, phcnt will reset to phidx when phcaliz set to 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trgoen</name>
          <description>Tigger output enable register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFC0000</resetMask>
          <fields>
            <field>
              <name>WDGFEN</name>
              <description>1- enable trigger output when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEFEN</name>
              <description>1- enable trigger output when homef flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPFEN</name>
              <description>1- enable trigger output when poscmpf flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHFEN</name>
              <description>1- enable trigger output when zphf flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMISSFEN</name>
              <description>No description available</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIDTHTMFEN</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS2CMPFEN</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCHGFEN</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE0FEN</name>
              <description>No description available</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE1FEN</name>
              <description>No description available</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE0FEN</name>
              <description>No description available</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE1FEN</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOME2FEN</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTFEN</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>readen</name>
          <description>Read event enable register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFC0000</resetMask>
          <fields>
            <field>
              <name>WDGFEN</name>
              <description>1- load counters to their read registers when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEFEN</name>
              <description>1- load counters to their read registers when homef flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPFEN</name>
              <description>1- load counters to their read registers when poscmpf flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHFEN</name>
              <description>1- load counters to their read registers when zphf flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMISSFEN</name>
              <description>No description available</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIDTHTMFEN</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS2CMPFEN</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCHGFEN</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE0FEN</name>
              <description>No description available</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE1FEN</name>
              <description>No description available</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE0FEN</name>
              <description>No description available</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE1FEN</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOME2FEN</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTFEN</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>zcmp</name>
          <description>Z comparator</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZCMP</name>
              <description>zcnt postion compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phcmp</name>
          <description>Phase comparator</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHCMP</name>
              <description>phcnt position compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>spdcmp</name>
          <description>Speed comparator</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPDCMP</name>
              <description>spdcnt position compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dmaen</name>
          <description>DMA request enable register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFC0000</resetMask>
          <fields>
            <field>
              <name>WDGFEN</name>
              <description>1- generate dma request when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEFEN</name>
              <description>1- generate dma request when homef flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPFEN</name>
              <description>1- generate dma request when poscmpf flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHFEN</name>
              <description>1- generate dma request when zphf flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMISSFEN</name>
              <description>No description available</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIDTHTMFEN</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS2CMPFEN</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCHGFEN</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE0FEN</name>
              <description>No description available</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE1FEN</name>
              <description>No description available</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE0FEN</name>
              <description>No description available</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE1FEN</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOME2FEN</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTFEN</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sr</name>
          <description>Status register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFC0000</resetMask>
          <fields>
            <field>
              <name>WDGF</name>
              <description>watchdog flag</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEF</name>
              <description>home flag</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPF</name>
              <description>postion compare match flag</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHF</name>
              <description>z input flag</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMISSF</name>
              <description>No description available</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIDTHTMF</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS2CMPF</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCHGF</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE0F</name>
              <description>No description available</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE1F</name>
              <description>No description available</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE0F</name>
              <description>No description available</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE1F</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOME2F</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTF</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irqen</name>
          <description>Interrupt request register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFC0000</resetMask>
          <fields>
            <field>
              <name>WDGIE</name>
              <description>1- generate interrupt when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEIE</name>
              <description>1- generate interrupt when homef flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPIE</name>
              <description>1- generate interrupt when poscmpf flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHIE</name>
              <description>1- generate interrupt when zphf flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMISSE</name>
              <description>No description available</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIDTHTME</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS2CMPE</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCHGE</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE0E</name>
              <description>No description available</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE1E</name>
              <description>No description available</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE0E</name>
              <description>No description available</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE1E</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOME2E</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTE</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>current,read,snap0,snap1</dimIndex>
          <name>COUNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x30</addressOffset>
          <register>
            <name>z</name>
            <description>Z counter</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ZCNT</name>
                <description>zcnt value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ph</name>
            <description>Phase counter</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x461FFFFF</resetMask>
            <fields>
              <field>
                <name>DIR</name>
                <description>1- reverse rotation
0- forward rotation</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ASTAT</name>
                <description>1- a input is high
0- a input is low</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BSTAT</name>
                <description>1- b input is high
0- b input is low</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PHCNT</name>
                <description>phcnt value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>21</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>spd</name>
            <description>Speed counter</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xEFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIR</name>
                <description>1- reverse rotation
0- forward rotation</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ASTAT</name>
                <description>1- a input is high
0- a input is low</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BSTAT</name>
                <description>1- b input is high
0- b input is low</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPDCNT</name>
                <description>spdcnt value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tmr</name>
            <description>Timer counter</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TMRCNT</name>
                <description>32 bit free run timer</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>zcmp2</name>
          <description>Z comparator</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZCMP2</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phcmp2</name>
          <description>Phase comparator</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHCMP2</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>spdcmp2</name>
          <description>Speed comparator</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPDCMP2</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>match_cfg</name>
          <description>No description available</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFE00FE00</resetMask>
          <fields>
            <field>
              <name>ZCMPDIS</name>
              <description>1- postion compare not include zcnt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCMPDIS</name>
              <description>1- postion compare not include rotation direction</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCMP</name>
              <description>0- position compare need positive rotation
1- position compare need negative rotation</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPDCMPDIS</name>
              <description>No description available</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_MATCH_DIS</name>
              <description>No description available</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_MATCH_DIR</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_MATCH_OPT</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZCMP2DIS</name>
              <description>No description available</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCMP2DIS</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCMP2</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPDCMP2DIS</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_MATCH_DIS2</name>
              <description>No description available</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_MATCH2_DIR</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_MATCH2_OPT</name>
              <description>No description available</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>6</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>filt_cfg_a,filt_cfg_b,filt_cfg_z,filt_cfg_h,filt_cfg_h2,filt_cfg_f</dimIndex>
          <name>FILT_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00001000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>OUTINV</name>
              <description>1- Filter will invert the output
0- Filter will not invert the output</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>This bitfields defines the filter mode
000-bypass;
100-rapid change mode;
101-delay filter mode;
110-stable low mode;
111-stable high mode</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNCEN</name>
              <description>set to enable sychronization input signal with TRGM clock</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTLEN</name>
              <description>This bitfields defines the filter counter length.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>qei_cfg</name>
          <description>qei config register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF00F1F3F</resetMask>
          <fields>
            <field>
              <name>SW_PULSE0_RESTART</name>
              <description>set to restart cycle counter for configed pulse_num. HW auto clear</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_PULSE1_RESTART</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CYCLE0_RESTART</name>
              <description>set to restart pulse counter for configed cycle_num. HW auto clear</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CYCLE1_RESTART</name>
              <description>No description available</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE0_ONESHOT</name>
              <description>set to use oneshot mode for configed pulse_num</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PULSE1_ONESHOT</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE0_ONESHOT</name>
              <description>set to use oneshot mode for configed cycle_num</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE1_ONESHOT</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPEED_DIR_CHG_EN</name>
              <description>clear counter if detect direction change</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_PULSE0_EN</name>
              <description>set to enable trigger start cycle counter for configed pulse_num(from the selected edge)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_PULSE1_EN</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_CYCLE0_EN</name>
              <description>set to enable trigger start pulse counter for configed cycle_num</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_CYCLE1_EN</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UVW_POS_OPT0</name>
              <description>set to output next area position for QEO use;
clr to output exact point position for MMC use</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NEGEDGE_EN</name>
              <description>bit4:  negedge enable
bit3:  posedge enable
bit2:  W in hal enable
bit1:  signal b(or V in hal) enable
bit0:  signal a(or U in hal) enable
such as:
01001:  use posedge A
11010:  use both edge of signal B
11111:  use both edge of all HAL siganls</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSIDGE_EN</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGZ_EN</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGB_EN</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGA_EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse0_num</name>
          <description>pulse0_num</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE0_NUM</name>
              <description>for speed detection, will count the cycle number for configed pulse_num</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse1_num</name>
          <description>pulse1_num</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE1_NUM</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle0_cnt</name>
          <description>cycle0_cnt</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE0_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle0pulse_cnt</name>
          <description>cycle0pulse_cnt</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE0PULSE_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle1_cnt</name>
          <description>cycle1_cnt</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE1_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle1pulse_cnt</name>
          <description>cycle1pulse_cnt</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE1PULSE_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle0_snap0</name>
          <description>cycle0_snap0</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE0_SNAP0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle0_snap1</name>
          <description>cycle0_snap1</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE0_SNAP1</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle1_snap0</name>
          <description>cycle1_snap0</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE1_SNAP0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle1_snap1</name>
          <description>cycle1_snap1</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE1_SNAP1</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle0_num</name>
          <description>cycle0_num</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE0_NUM</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cycle1_num</name>
          <description>cycle1_num</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE1_NUM</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse0_cnt</name>
          <description>pulse0_cnt</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE0_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse0cycle_cnt</name>
          <description>pulse0cycle_cnt</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE0CYCLE_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse1_cnt</name>
          <description>pulse1_cnt</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE1_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse1cycle_cnt</name>
          <description>pulse1cycle_cnt</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE1CYCLE_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse0_snap0</name>
          <description>pulse0_snap0</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE0_SNAP0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse0cycle_snap0</name>
          <description>pulse0cycle_snap0</description>
          <addressOffset>0x15c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE0CYCLE_SNAP0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse0_snap1</name>
          <description>pulse0_snap1</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE0_SNAP1</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse0cycle_snap1</name>
          <description>pulse0cycle_snap1</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE0CYCLE_SNAP1</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse1_snap0</name>
          <description>pulse1_snap0</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE1_SNAP0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse1cycle_snap0</name>
          <description>pulse1cycle_snap0</description>
          <addressOffset>0x16c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE1CYCLE_SNAP0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse1_snap1</name>
          <description>pulse1_snap1</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE1_SNAP1</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pulse1cycle_snap1</name>
          <description>pulse1cycle_snap1</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE1CYCLE_SNAP1</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>timestamp</name>
          <description>timestamp</description>
          <addressOffset>0x1e0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMESTAMP</name>
              <description>for SIN/COS mode, it saves the timestampe of the begining of first ADC sample time;
for ABZ mode, it saves the timestampe of edge of input signals</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc_threshold</name>
          <description>adc_threshold</description>
          <addressOffset>0x1f0</addressOffset>
          <size>32</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOW_LIMIT</name>
              <description>for SINCOS mode, if (max+min/2) of the two adc result, is small than limit,
then this value is treated as unvalid, no position output.
this is uesd to avoid wrong adc resule(such as 0 or same sin cos value)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIGH_LIMIT</name>
              <description>high limit for SINCOS mode adc result</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adcx_cfg0</name>
          <description>adcx_cfg0</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000019F</resetMask>
          <fields>
            <field>
              <name>X_ADCSEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>X_ADC_ENABLE</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>X_CHAN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adcx_cfg1</name>
          <description>adcx_cfg1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x00004000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>X_PARAM1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>X_PARAM0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adcx_cfg2</name>
          <description>adcx_cfg2</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>X_OFFSET</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adcy_cfg0</name>
          <description>adcy_cfg0</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000019F</resetMask>
          <fields>
            <field>
              <name>Y_ADCSEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Y_ADC_ENABLE</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Y_CHAN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adcy_cfg1</name>
          <description>adcy_cfg1</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Y_PARAM1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Y_PARAM0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adcy_cfg2</name>
          <description>adcy_cfg2</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Y_OFFSET</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cal_cfg</name>
          <description>cal_cfg</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>XY_DELAY</name>
              <description>valid x/y delay, larger than this delay will be treated as invalid data.
Default 1.25us@200MHz;   max 80ms;</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phase_param</name>
          <description>phase_param</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHASE_PARAM</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pos_threshold</name>
          <description>pos_threshold</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POS_THRESHOLD</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>6</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>uvw_pos0,uvw_pos1,uvw_pos2,uvw_pos3,uvw_pos4,uvw_pos5</dimIndex>
          <name>UVW_POS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UVW_POS0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>6</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>uvw_pos0_cfg,uvw_pos1_cfg,uvw_pos2_cfg,uvw_pos3_cfg,uvw_pos4_cfg,uvw_pos5_cfg</dimIndex>
          <name>UVW_POS_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x258</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>POS_EN</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>U_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>V_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>W_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phase_cnt</name>
          <description>phase_cnt</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHASE_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phase_update</name>
          <description>phase_update</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INC</name>
              <description>set to add value to phase_cnt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DEC</name>
              <description>set to minus value from phase_cnt(set inc and dec same time willl act inc)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>VALUE</name>
              <description>value to be added or minus from phase_cnt. only valid when inc or dec is set in one 32bit write operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>position</name>
          <description>position</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POSITION</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>position_update</name>
          <description>position_update</description>
          <addressOffset>0x28c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INC</name>
              <description>set to add value to position</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DEC</name>
              <description>set to minus value from position(set inc and dec same time willl act inc)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>VALUE</name>
              <description>value to be added or minus from position. only valid when inc or dec is set in one 32bit write operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>angle</name>
          <description>No description available</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ANGLE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pos_timeout</name>
          <description>pos_timeout</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <resetValue>0x7FFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>enable position timeout feature, if timeout, send valid again</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>postion timeout value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="QEI0">
      <name>QEI1</name>
      <description>QEI1</description>
      <groupName>QEIV2</groupName>
      <baseAddress>0xf0404000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="QEI0">
      <name>QEI2</name>
      <description>QEI2</description>
      <groupName>QEIV2</groupName>
      <baseAddress>0xf0408000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="QEI0">
      <name>QEI3</name>
      <description>QEI3</description>
      <groupName>QEIV2</groupName>
      <baseAddress>0xf040c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>QEO0</name>
      <description>QEO0</description>
      <groupName>QEOV2</groupName>
      <baseAddress>0xf0410000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x21c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WAVE_mode</name>
          <description>analog waves mode</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF7</resetMask>
          <fields>
            <field>
              <name>WAVE2_ABOVE_MAX_LIMIT</name>
              <description>wave2 above max limit mode.
0: output all bits are 1.
1: output 0x0.
2: output as level_max_limit2.level0_max_limit</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE2_HIGH_AREA1_LIMIT</name>
              <description>wave2 high area1 limit mode.
0: output all bits are 1.
1: output as level_max_limit2.level0_max_limit</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE2_HIGH_AREA0_LIMIT</name>
              <description>wave2 high area0 limit mode.
0: output all bits are 1.
1: output as level_max_limit2.level0_max_limit</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE2_LOW_AREA1_LIMIT</name>
              <description>wave2 low area1 limit mode.
0: output 0.
1: output as level_min_limit2.level1_min_limit</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE2_LOW_AREA0_LIMIT</name>
              <description>wave2 low area0 limit mode.
0: output 0.
1: output as level_min_limit2.level1_min_limit</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE2_BELOW_MIN_LIMIT</name>
              <description>wave2 below min limit mode.
0: output 0.
1: output all bits are 1.
2: output as level_min_limit2.level1_min_limit</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE1_ABOVE_MAX_LIMIT</name>
              <description>wave1 above max limit mode.
0: output all bits are 1.
1: output 0x0.
2: output as level_max_limit1.level0_max_limit</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE1_HIGH_AREA1_LIMIT</name>
              <description>wave1 high area1 limit mode.
0: output all bits are 1.
1: output as level_max_limit1.level0_max_limit</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE1_HIGH_AREA0_LIMIT</name>
              <description>wave1 high area0 limit mode.
0: output all bits are 1.
1: output as level_max_limit1.level0_max_limit</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE1_LOW_AREA1_LIMIT</name>
              <description>wave1 low area1 limit mode.
0: output 0.
1: output as level_min_limit1.level1_min_limit</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE1_LOW_AREA0_LIMIT</name>
              <description>wave1 low area0 limit mode.
0: output 0.
1: output as level_min_limit1.level1_min_limit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE1_BELOW_MIN_LIMIT</name>
              <description>wave1 below min limit mode.
0: output 0.
1: output all bits are 1.
2: output as level_min_limit1.level1_min_limit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE0_ABOVE_MAX_LIMIT</name>
              <description>wave0 above max limit mode.
0: output all bits are 1.
1: output 0x0.
2: output as level_max_limit0.level0_max_limit</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE0_HIGH_AREA1_LIMIT</name>
              <description>wave0 high area1 limit mode.
0: output all bits are 1.
1: output as level_max_limit0.level0_max_limit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE0_HIGH_AREA0_LIMIT</name>
              <description>wave0 high area0 limit mode.
0: output all bits are 1.
1: output as level_max_limit0.level0_max_limit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE0_LOW_AREA1_LIMIT</name>
              <description>wave0 low area1 limit mode.
0: output 0.
1: output as level_min_limit0.level1_min_limit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE0_LOW_AREA0_LIMIT</name>
              <description>wave0 low area0 limit mode.
0: output 0.
1: output as level_min_limit0.level1_min_limit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVE0_BELOW_MIN_LIMIT</name>
              <description>wave0 below min limit mode.
0: output 0.
1: output all bits are 1.
2: output as level_min_limit0.level1_min_limit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SADDLE_TYPE</name>
              <description>saddle type seclect;
0:standard saddle.
1: triple-cos saddle.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_DQ_VALID</name>
              <description>enable vd or vq valid to trigger analog wave calcuation
0: disable.
1: enable.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_POS_VALID</name>
              <description>enable position valid to trigger analog wave calcuation
0: disable.
1: enable.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_WAVE_VD_VQ_INJECT</name>
              <description>wave VdVq inject enable.
0: disable VdVq inject.
1: enable VdVq inject.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VD_VQ_SEL</name>
              <description>vd_vq sel ctrl:
0: from CLC.
1: from software.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAVES_OUTPUT_TYPE</name>
              <description>wave0/1/2 output mode.
0: cosine wave.
1: saddle wave.
2. abs cosine wave.
3. saw wave</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAVE_resolution</name>
          <description>resolution of wave0/1/2</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINES</name>
              <description>wave0/1/2 resolution</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>3</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>wave0,wave1,wave2</dimIndex>
          <name>WAVE_PHASE_SHIFT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>wave0 phase shifter value, default is 0x0. write other value will shift phase early as (cfg_value/2^32) period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAVE_vd_inject</name>
          <description>wave vd inject value</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VD_VAL</name>
              <description>Vd inject value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAVE_vq_inject</name>
          <description>wave vq inject value</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VQ_VAL</name>
              <description>Vq inject value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAVE_vd_vq_load</name>
          <description>load wave0/1/2 vd vq value</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>LOAD</name>
              <description>load wave0/1/2 vd vq value.  always read 0
0: vd vq keep previous value.
1: load wave0/1/2 vd vq value at sametime.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>3</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>wave0,wave1,wave2</dimIndex>
          <name>WAVE_AMPLITUDE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>EN_SCAL</name>
              <description>enable wave amplitude scaling. 0: disable; 1: enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMP_VAL</name>
              <description>amplitude scaling value. bit15-12 are integer part value. bit11-0 are fraction value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>3</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>wave0,wave1,wave2</dimIndex>
          <name>WAVE_MID_POINT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>wave0 output middle point, use this value as 32 bit signed value. bit 31 is signed bit. bit30-27 is integer part value. bit26-0 is fraction value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>wave0,wave1,wave2</dimIndex>
          <name>WAVE_LIMIT0[%s]</name>
          <description>no description available</description>
          <addressOffset>0x48</addressOffset>
          <register>
            <name>min_level0</name>
            <description>wave0 low area limit value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LIMIT_LEVEL0</name>
                <description>low area limit level0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>max_level0</name>
            <description>wave0 high area limit value</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LIMIT_LEVEL0</name>
                <description>high area limit level0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>wave0,wave1,wave2</dimIndex>
          <name>WAVE_LIMIT1[%s]</name>
          <description>no description available</description>
          <addressOffset>0x60</addressOffset>
          <register>
            <name>min_level1</name>
            <description>wave0 low area limit value level1</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LIMIT_LEVEL1</name>
                <description>low area limit level1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>max_level1</name>
            <description>wave0 high area limit value level1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LIMIT_LEVEL1</name>
                <description>high area limit level1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>3</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>wave0,wave1,wave2</dimIndex>
          <name>WAVE_DEADZONE_SHIFT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>wave0 deadzone shifter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAVE_pwm_cycle</name>
          <description>pwm_cycle</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>pwm_cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_mode</name>
          <description>wave_a/b/z output mode</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x99111333</resetMask>
          <fields>
            <field>
              <name>ABZ_OUTPUT_ENABLE</name>
              <description>abz output enable：
0：abz output disable, all keep 0
1：abz output enable.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REVERSE_EDGE_TYPE</name>
              <description>pulse reverse wave，reverse edge point:
0: between pulse's posedge and negedge, min period dedicated by the num line_width
1: edge change point flow pulse's negedge.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSITION_SYNC_MODE</name>
              <description>position sync mode:
0: only sync integer line part into qeo own position.
1: sync integer and fraction part into qeo own position.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_WDOG</name>
              <description>enable abz wdog:
0: disable abz wdog.
1: enable abz wdog.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Z_POLARITY</name>
              <description>wave_z polarity.
0: normal output.
1: invert normal output</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>B_POLARITY</name>
              <description>wave_b polarity.
0: normal output.
1: invert normal output</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>A_POLARITY</name>
              <description>wave_a polarity.
0: normal output.
1: invert normal output</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Z_TYPE</name>
              <description>wave_z type:
0: zero pulse type, start and end line number decided by z_start、z_end and z_offset.
1: zero pulse type, z output start to high when position= z_start, and mantain numbers of 1/4 line cfg in z_pulse_width register
2: reserved
3: wave_z output as tree-phase wave same as wave_a/wave_b</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>B_TYPE</name>
              <description>wave_b type:
0: Two-phase orthogonality wave_b.
1: reverse wave of pulse/reverse type.
2: down wave of up/down type.
3: Three-phase orthogonality wave_b.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>A_TYPE</name>
              <description>wave_a type:
0: Two-phase orthogonality wave_a.
1: pulse wave of pulse/reverse type.
2: up wave of up/down type.
3: Three-phase orthogonality wave_a.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_resolution</name>
          <description>resolution of wave_a/b/z</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINES</name>
              <description>wave_a/b/z resolution</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>3</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>a,b,z</dimIndex>
          <name>ABZ_PHASE_SHIFT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>wave_a phase shifter value, default is 0x0. write other value will shift phase early as (cfg_value/2^32) period.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_line_width</name>
          <description>Two-phase orthogonality wave 1/4 period</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINE</name>
              <description>the num of system clk by 1/4 period when using as Two-phase orthogonality.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_wdog_width</name>
          <description>wdog width of qeo</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WIDTH</name>
              <description>wave will step 1/4 line to reminder user QEO still in controlled if QEO has no any toggle after the num of wdog_width sys clk.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_postion_sync</name>
          <description>sync abz owned postion</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>POSTION</name>
              <description>load next valid postion into  abz owned postion.  always read 0
0: sync abz owned postion with next valid postion.
1: not sync.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_overall_offset</name>
          <description>abz overall position offset</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>abz position overall offset, it affects abz position before resolution convert</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_z_start</name>
          <description>zero phase start line num</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Z_START</name>
              <description>number of Z start line</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_z_end</name>
          <description>zero phase end line num</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Z_END</name>
              <description>number of Z end line</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_z_offset</name>
          <description>zero phase start and end 1/4 line num</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000330</resetMask>
          <fields>
            <field>
              <name>Z_END_OFFSET</name>
              <description>number of Z end 1/4 line</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Z_START_OFFSET</name>
              <description>number of Z start 1/4 line</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABZ_z_pulse_width</name>
          <description>zero pulse witdth</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>number of z_pulse_width</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_mode</name>
          <description>pwm mode</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF831F</resetMask>
          <fields>
            <field>
              <name>PWM7_SAFETY</name>
              <description>PWM safety mode phase table</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM6_SAFETY</name>
              <description>PWM safety mode phase table</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM5_SAFETY</name>
              <description>PWM safety mode phase table</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM4_SAFETY</name>
              <description>PWM safety mode phase table</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3_SAFETY</name>
              <description>PWM safety mode phase table</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2_SAFETY</name>
              <description>PWM safety mode phase table</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_SAFETY</name>
              <description>PWM safety mode phase table</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_SAFETY</name>
              <description>PWM safety mode phase table</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_PWM</name>
              <description>enable PWM force output
0: disable
1: enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_ENTER_SAFETY_MODE</name>
              <description>PWM  enter safety mode
0: not enter
1: enter</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_SAFETY_BYPASS</name>
              <description>PWM safety mode bypass
0: not bypass
1: bypass</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REVISE_UP_DN</name>
              <description>exchange PWM pairs’ output
0: not exchange.
1: exchange.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_NUM</name>
              <description>pwm force phase number.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_resolution</name>
          <description>resolution of pwm</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINES</name>
              <description>pwm resolution</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>a,b,c,d</dimIndex>
          <name>PWM_PHASE_SHIFT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>pwm_a phase shifter value, default is 0x0. write other value will shift phase early as (cfg_value/2^32) period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>24</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>posedge0,posedge1,posedge2,posedge3,posedge4,posedge5,posedge6,posedge7,posedge8,posedge9,posedge10,posedge11,negedge0,negedge1,negedge2,negedge3,negedge4,negedge5,negedge6,negedge7,negedge8,negedge9,negedge10,negedge11</dimIndex>
          <name>PWM_PHASE_TABLE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PWM7</name>
              <description>pwm phase table value</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM6</name>
              <description>pwm phase table value</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM5</name>
              <description>pwm phase table value</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM4</name>
              <description>pwm phase table value</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3</name>
              <description>pwm phase table value</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2</name>
              <description>pwm phase table value</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1</name>
              <description>pwm phase table value</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0</name>
              <description>pwm phase table value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_postion_software</name>
          <description>softwave inject postion</description>
          <addressOffset>0x1f8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POSTION_SOFTWAVE</name>
              <description>softwave inject postion</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_postion_sel</name>
          <description>select softwave inject postion</description>
          <addressOffset>0x1fc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>POSTION_SEL</name>
              <description>enable softwave inject postion.
0: disable.
1: enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_status</name>
          <description>qeo status</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0001</resetMask>
          <fields>
            <field>
              <name>PWM_FOURCE</name>
              <description>qeo_pwm_force observe</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PWM_SAFETY</name>
              <description>pwm_fault status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_debug0</name>
          <description>qeo debug 0</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_DAC0</name>
              <description>wave0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_debug1</name>
          <description>qeo debug 1</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x11110000</resetMask>
          <fields>
            <field>
              <name>QEO_FINISH</name>
              <description>qeo finish observe</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PAD_Z</name>
              <description>pad_z observe</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PAD_B</name>
              <description>pad_b observe</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PAD_A</name>
              <description>pad_a observe</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_debug2</name>
          <description>qeo debug 2</description>
          <addressOffset>0x20c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ABZ_OWN_POSTION</name>
              <description>abz_own_postion observe</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_debug3</name>
          <description>qeo debug 3</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ABZ_OWN_POSTION</name>
              <description>abz_own_postion observe</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_debug4</name>
          <description>qeo debug 4</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_DAC1</name>
              <description>wave1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_debug5</name>
          <description>qeo debug 5</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_DAC2</name>
              <description>wave2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="QEO0">
      <name>QEO1</name>
      <description>QEO1</description>
      <groupName>QEOV2</groupName>
      <baseAddress>0xf0414000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="QEO0">
      <name>QEO2</name>
      <description>QEO2</description>
      <groupName>QEOV2</groupName>
      <baseAddress>0xf0418000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="QEO0">
      <name>QEO3</name>
      <description>QEO3</description>
      <groupName>QEOV2</groupName>
      <baseAddress>0xf041c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PWM0</name>
      <description>PWM0</description>
      <groupName>PWMV2</groupName>
      <baseAddress>0xf0420000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x980</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>work_ctrl0</name>
          <description>No description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SHADOW_UNLOCK</name>
              <description>write 0x… first to unlock, then set related bits in unlock_sel to unlock following shadow registers(from 0x04 to 0x78),
otherwise the shadow registers can not be written.
The shadow registers will be loaded to work registers only when shadow_lock is 1 or lock is not enabled
This bit can be cleared by set shadow_lock bit in work_ctrl1</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>unlock</name>
          <description>No description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UNLOCK_BIT</name>
              <description>bit2 to bit 29 for value_shadow, bit30 for force_mode
the shadow registers can be updated only when related unlock_bit is set;
this register can only be updated after unlock</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>28</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27</dimIndex>
          <name>SHADOW_VAL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>shadow registers, if used as reload or compare point, shall be 24bit clock cycles plus 1bit half cycle and 7bit high-resolution delay</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>force_mode</name>
          <description>No description available</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>POLARITY</name>
              <description>one bit for one pwm channel, it's used as shadow register when pwm_cfg0.polarity_opt0 is set.
output polarity, set to 1 will invert the output(after pwm selection, pair mode, dead area insertion, before force/fault)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_MODE</name>
              <description>2bit for each PWM channel(0~7);
00:  force output 0
01:  force output 1
10:  output highz(pad_oe_*=0)
11:  no force
this field may be changed by software as shadow register , the update time should be defined by chan_cfg.load, only for PWM channels.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>work_ctrl1</name>
          <description>No description available</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_LOCK</name>
              <description>one to lock,  sofware can't write any shadow registers
Software have to write 0x…. to work_ctrl0 to clear this bit.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>PWM[%s]</name>
          <description>no description available</description>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>cfg0</name>
            <description>No description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x01000F77</resetMask>
            <fields>
              <field>
                <name>TRIG_SEL4</name>
                <description>for N=0/2/4/6, clear to select 2 compare point(N*2~N*2+1);
set to select 4 compare point(N*2~N*2+3);
or use 2 compare point(N*2+2~N*2+3);
for N=1/3/5/7, this bit is no means, it can work on pair mode, or use 2 compare point (N*2+2~N*2+3);
assume select ab or abcd,  abcd can between 0 and 2T.
output will be 1 when counter value between a and b;
if b&lt;=a then output all 0; if b&gt;=(T+a), then output all 1;</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FAULT_SEL_ASYNC</name>
                <description>select from 16bit async fault from pad</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FAULT_POL_ASYNC</name>
                <description>fault polarity for input fault from pad, 1-active low;  0-active high;</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FAULT_EN_ASYNC</name>
                <description>set to enable the input async faults from pad directly</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FAULT_EN_SYNC</name>
                <description>set to enable the input faults from trig_mux(trigger_in[0] for channel0/1, 1 for 23, 2 for 45, 3 for 67)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POL_UPDATE_SEL</name>
                <description>used when polarity_opt0 is set, define when to update polarity working register.
0:  software set work_ctrl1.shadow_lock bit
1:  update at reload point;</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_POLARITY</name>
                <description>output polarity, set to 1 will invert the output(after pwm selection, pair mode, dead area insertion, before force/fault)
when polarity_opt0 is set, this bit is controlled by shadow register, can't be writable; read as working register
use compare channel settings(in cmp_cfg) as shadow register update</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POLARITY_OPT0</name>
                <description>set to use shadow polarity</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg1</name>
            <description>No description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x1FFF7777</resetMask>
            <fields>
              <field>
                <name>HIGHZ_EN_N</name>
                <description>0 to highz pwm outputs(pad_oe*=0), software need set this bit to 1 to enable pwm output</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_UPDATE_TIME</name>
                <description>define when to use the shadow register value for working register(force_mode)
00:  software set work_ctrl1.shadow_lock bit
01:  use the related counter rld_cmp_sel0 and rld_cmp_sel1, to select one compare point
10:  related counter reload time(selected by pwm_cnt)
11:  use force_trig_sel to select one of the input trigger
NOTE: 00/01 are not recommended since the update time is not controllable, may cause error in complex application.
00 is used for initialization or debug, not suggest for real time update</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FAULT_MODE</name>
                <description>00:  force output 0
01:  force output 1
1x:  output highz(pad_oe_*=0)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FAULT_REC_TIME</name>
                <description>00:  immediately
01:  after main counter reload time
10:  use fault_rec_sel to select one of the input trigger
11:  software write fault_clear in glb_ctrl2, no effort if pwm_fault is still assert</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SW_FORCE_EN</name>
                <description>0 for hardware force, from trig_mux selected by pwm_force_sel
1 for software force, from glb_ctrl.sw_force</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_MODE</name>
                <description>if set to 1, PWM work at pair mode,
pwm_cfg for channel 2m is used for channel 2m+1(m=0,1,2,3),
except the dead area, which is separate for each channel even in pair mode
software need set this bit for both channel of one pair, otherwise result unknown.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_LOGIC</name>
                <description>valid only for pwm0/2/4/6 when trig_sel4 is set
00:  ab OR cd;
01:  ab AND cd;
10:  ab XOR cd;
11:  cd</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_TIME</name>
                <description>00:  force immediately
01:  force at main counter reload time
10:  force at trig signal selected by force_act_sel
11: no force
the force assert/deassert will happen at the force_time;
qeo force and value also latched at this time</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_TRIG_SEL</name>
                <description>select one trigger from 8, should set to pulse in trig_mux, will load shadow register(force)mode) to force_mode_work at this time</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_ACT_SEL</name>
                <description>select one trigger from 8, should set to pulse in trig_mux, will load hw/sw force at this time</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_FORCE_SEL</name>
                <description>select one trigger from 8 as force signal, should be level signal, 1 for force active, 0 for no force</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FAULT_REC_SEL</name>
                <description>select one trigger from 8, should set to pulse in trig_mux, used for fault recovery if fault_rec_time is set to 2'b10</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>dead_area</name>
            <description>No description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>DEAD_AREA</name>
                <description>16bit cycle delay plus 8bit hr_delay
min value is 2 cycles, less than 0x200 will be treated as no dead area;
NOTE: dead insertion must be configured with pair, that is, for pwm 01/23/45/67.
otherwise the result maybe UNKNOWN!!!</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>TRIGGER_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>TRIGGER_OUT_SEL</name>
              <description>select one from 24 compare result as trigger out, set at compare point, clear at reload point.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>glb_ctrl</name>
          <description>No description available</description>
          <addressOffset>0x1f0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF0318</resetMask>
          <fields>
            <field>
              <name>SW_FORCE</name>
              <description>software write 1 to start software force, if the pwm_cfg&lt;n&gt;.sw_force_en is set, force will take effort</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DELAY</name>
              <description>add delay after dead_area insertiong logic, for hr_pwm</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HR_PWM_EN</name>
              <description>set to enable hr pwm, clear to bypass delay chain.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAC_DISABLE</name>
              <description>set to disable bit[7:0] in DAC value when Calculation Unit use it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>glb_ctrl2</name>
          <description>No description available</description>
          <addressOffset>0x1f4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F20FF01</resetMask>
          <fields>
            <field>
              <name>DAC_SW_MODE</name>
              <description>set for software DAC mode, software can write dac_value*_sv directly, and dac_valid from moto system is ignored</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEBUG_IN_EN</name>
              <description>set to enable debug_in signal as fault signal, generally disable pwm output</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULT_CLEAR</name>
              <description>software write 1 to clear fault event if pwm_cfg.fault_rec_time is 2'b11.
software need to clear it after the fault signal is de-assert and before next fault
one bit for one pwm channel</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHADOW_LOCK_EN</name>
              <description>enable shadow_lock feature, if cleared, shadow_lock will be always 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>CNT_RELOAD_WORK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>counter0 reload working register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>24</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23</dimIndex>
          <name>CMP_VAL_WORK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>compare point working register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>force_work</name>
          <description>No description available</description>
          <addressOffset>0x27c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>OUT_POLARITY</name>
              <description>force working register</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FORCE_MODE</name>
              <description>force_mode work register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>CNT_VAL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>main counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>DAC_VALUE_SV[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>save dac0_value when dac0_valid if dac_sw_mode is 0;
software write dac_value directly if dac_sw_mode is 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>CAPTURE_POS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF13</resetMask>
          <fields>
            <field>
              <name>CAPTURE_POS</name>
              <description>related counter value captured at input negedge</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CAPTURE_SELGPIO</name>
              <description>0: result from CAP[  7:0],  from trgm
1: result from CAP[15:8],  from gpio</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNT_INDEX</name>
              <description>related counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>CAPTURE_NEG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>CAPTURE_NEG</name>
              <description>counter value captured at input negedge</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts</name>
          <description>No description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000003F</resetMask>
          <fields>
            <field>
              <name>IRQ_CAL_OVERFLOW</name>
              <description>end of output burst</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IRQ_BURSTEND</name>
              <description>end of output burst</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ_FAULT</name>
              <description>for external fault event</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ_CAPTURE_NEG</name>
              <description>capture negedge status</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ_CAPTURE_POS</name>
              <description>capture posedge status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ_RELOAD</name>
              <description>when clock counter reach the reload time</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ_CMP</name>
              <description>for 24 channel, compare event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en</name>
          <description>No description available</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>IRQ_EN_OVERFLOW</name>
              <description>enable interrupt when calculation unit overflow</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts_cmp</name>
          <description>No description available</description>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_STS_CMP</name>
              <description>interrupt flag for compare point match event, and each bit means one compare point.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts_reload</name>
          <description>No description available</description>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>IRQ_STS_RELOAD</name>
              <description>interrupt flag for reload event , and each bit means one main counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts_cap_pos</name>
          <description>No description available</description>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>IRQ_STS_CAP_POS</name>
              <description>interrupt flag for posedge capture event , and each bit means one capture channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts_cap_neg</name>
          <description>No description available</description>
          <addressOffset>0x41c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>IRQ_STS_CAP_NEG</name>
              <description>interrupt flag for negedge capture event , and each bit means one capture channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts_fault</name>
          <description>No description available</description>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>IRQ_STS_FAULT</name>
              <description>interrupt flag for external fault event , and each bit means one external fault channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts_burstend</name>
          <description>No description available</description>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>IRQ_STS_BURSTEND</name>
              <description>interrupt flag for output burst done event , and each bit means one main counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en_cmp</name>
          <description>No description available</description>
          <addressOffset>0x430</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_EN_CMP</name>
              <description>interrupt enable field for compare point match event, and each bit means one compare point.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en_reload</name>
          <description>No description available</description>
          <addressOffset>0x434</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>IRQ_EN_RELOAD</name>
              <description>interrupt enable field for reload event , and each bit means one main counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en_cap_pos</name>
          <description>No description available</description>
          <addressOffset>0x438</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>IRQ_EN_CAP_POS</name>
              <description>interrupt enable field for posedge capture event , and each bit means one capture channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en_cap_neg</name>
          <description>No description available</description>
          <addressOffset>0x43c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>IRQ_EN_CAP_NEG</name>
              <description>interrupt enable field for negedge capture event , and each bit means one capture channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en_fault</name>
          <description>No description available</description>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>IRQ_EN_FAULT</name>
              <description>interrupt enable field for external fault event , and each bit means one external fault channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en_burstend</name>
          <description>No description available</description>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>IRQ_EN_BURSTEND</name>
              <description>interrupt enable field for output burst done event , and each bit means one main counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dma_en</name>
          <description>No description available</description>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x9F9F9F9F</resetMask>
          <fields>
            <field>
              <name>DMA3_EN</name>
              <description>enable dma3</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA3_SEL</name>
              <description>selelct one of compare point(0~23) or one reload point(24~27) as dma0</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA2_EN</name>
              <description>enable dma2</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA2_SEL</name>
              <description>selelct one of compare point(0~23) or one reload point(24~27) as dma0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA1_EN</name>
              <description>enable dma1</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA1_SEL</name>
              <description>selelct one of compare point(0~23) or one reload point(24~27) as dma0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA0_EN</name>
              <description>enable dma0</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA0_SEL</name>
              <description>selelct one of compare point(0~23) or one reload point(24~27) as dma0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>CNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x500</addressOffset>
          <register>
            <name>cfg0</name>
            <description>No description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x1F1F731F</resetMask>
            <fields>
              <field>
                <name>RLD_CMP_SEL1</name>
                <description>select one compare point from 24, set to 0x1F to disable current selection, used for reload value, compare value, force value update</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RLD_CMP_SEL0</name>
                <description>select one compare point from 24, set to 0x1F to disable current selection</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RLD_TRIG_SEL</name>
                <description>select one trigger from 8, should set to pulse in trig_mux</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RLD_UPDATE_TIME</name>
                <description>define when to use the calculation output value as reload time
00:  software set work_ctrl1.shadow_lock bit
01:  use compare point selected by rld_cmp_sel0 or rld_cmp_sel1
10:  counter reload time
11:  use rld_trig_sel to select one of the input trigger
NOTE: 00 is not recommended since the update time is not controllable, may cause error in complex application.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_D_PARAM</name>
                <description>input dac data parameter</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg1</name>
            <description>No description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x039F9F1F</resetMask>
            <fields>
              <field>
                <name>CNT_DAC_INDEX</name>
                <description>select one of the dac value</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_LU_EN</name>
                <description>set to enable up limit, use cnt_lu_off to select one of the shadow register value as limitation</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_LIM_UP</name>
                <description>up limit offset selection, from one of the shadow_val</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_LL_EN</name>
                <description>set to enable low limit</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_LIM_LO</name>
                <description>low limit offset selection, from one of the shadow_val</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_IN_OFF</name>
                <description>input data offset selection, from one of the shadow_val, default just shadow reload time</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg2</name>
            <description>No description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8778F78F</resetMask>
            <fields>
              <field>
                <name>CNT_RELOAD_EN</name>
                <description>set to use input signal(selected by cnt_reload_trig) to reload timer</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_RELOAD_TRIG</name>
                <description>select one trigger from 8, should set to pulse in trig_mux</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_UPDATE_TRIG1</name>
                <description>select one trigger from 8, should set to pulse in trig_mux</description>
                <bitOffset>20</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_UPDATE_EN1</name>
                <description>set to enable using trig1 to load calculation cell output to counter</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_TRIG1</name>
                <description>change counter value to one of the calculation cell output when cnt_update_triger1 issued</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_UPDATE_TRIG0</name>
                <description>select one trigger from 8, should set to pulse in trig_mux</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_UPDATE_EN0</name>
                <description>set to enable using trig0 to load calculation cell output to counter</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_TRIG0</name>
                <description>change counter value to one of the calculation cell output when cnt_update_triger0 issued</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg3</name>
            <description>No description available</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0072FFFF</resetMask>
            <fields>
              <field>
                <name>CNT_START_SEL</name>
                <description>select one trigger from 8, should set to pulse in trig_mux</description>
                <bitOffset>20</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_HW_START_EN</name>
                <description>enable use trigger to start pwm output(at next reload point), by cnt_start_sel</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_BURST</name>
                <description>output pwm wave for configured burst(timer period),
0 for one burst;  1 for two burst.
set to 0xFFFF for always output pwm wave
bit's only used when setting cnt_sw_start or trigger selected by cnt_start_sel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>cnt_glbcfg</name>
          <description>No description available</description>
          <addressOffset>0x540</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F0F0F</resetMask>
          <fields>
            <field>
              <name>CNT_SW_START</name>
              <description>set to start pwm output(at next reload point), write only, Auto clear.
User can disable pwm output before burst end by start again with cnt_burst=0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMER_RESET</name>
              <description>set to clear current timer. Auto clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMER_ENABLE</name>
              <description>1 to enable the main cycle counter; 0 to stop the counter;
NOTE:  when counter stopped, the related trigger_out will be cleared to 0, the related pwm output will keep value not changed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>CAL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <register>
            <name>cfg0</name>
            <description>No description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>CAL_LU_PARAM</name>
                <description>up limit parameter</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_LL_PARAM</name>
                <description>low limit parameter</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_T_PARAM</name>
                <description>period parameter</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_D_PARAM</name>
                <description>dac/counter value parameter</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg1</name>
            <description>No description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x379F9F1F</resetMask>
            <fields>
              <field>
                <name>CAL_T_INDEX</name>
                <description>select one of 4 counter reload time</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_IN_INDEX</name>
                <description>0~3 to select one of the dac input value; 4~7 to select one of the current counter value</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_LU_EN</name>
                <description>set to enable up limit</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_LIM_UP</name>
                <description>up limit offset selection, select from one of the shadow_val</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_LL_EN</name>
                <description>set to enable low limit</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_LIM_LO</name>
                <description>low limit offset selection, select from one of the shadow_val</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_IN_OFF</name>
                <description>offset for calculation unit, select from one of the shadow_val.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>24</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23</dimIndex>
          <name>CMP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x800</addressOffset>
          <register>
            <name>cfg</name>
            <description>No description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x773FC000</resetMask>
            <fields>
              <field>
                <name>CMP_TRIG_SEL</name>
                <description>select one trigger from 8, should set to pulse in trig_mux</description>
                <bitOffset>28</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMP_UPDATE_TIME</name>
                <description>define when to use the shadow register value for working register(trig_cmp)
000:  software set work_ctrl1.shadow_lock bit
001:  update immediately(at next cycle)
010:  related counter reload time
011:  use cmp_update_trigger(from trig_mux, selected by cmp_trig_sel)
100:  use the related counter rld_cmp_sel0  to select one compare point
101:  use the related counter rld_cmp_sel1, to select one compare point
11x:  reserved, no update.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMP_IN_SEL</name>
                <description>0x00~0x1B select one of the shadow_val directly
0x20~0x2F select one of the calculation cell output
0x30~0x37 select one of capture_pos value(low 8bit are 0)
0x38+k select T/4
0x3E select 0xFFFFF000
0x3F select 0xFFFFFF00
others select 0</description>
                <bitOffset>16</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMP_CNT</name>
                <description>select one from 4 counters, only for N&gt;=16.
for N&lt;16, this field is0, every 4 compare point related to one counter(0123 for counter0, 4567 for counter1….)</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="PWM0">
      <name>PWM1</name>
      <description>PWM1</description>
      <groupName>PWMV2</groupName>
      <baseAddress>0xf0424000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="PWM0">
      <name>PWM2</name>
      <description>PWM2</description>
      <groupName>PWMV2</groupName>
      <baseAddress>0xf0428000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="PWM0">
      <name>PWM3</name>
      <description>PWM3</description>
      <groupName>PWMV2</groupName>
      <baseAddress>0xf042c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>RDC0</name>
      <description>RDC0</description>
      <groupName>RDC</groupName>
      <baseAddress>0xf0440000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xf0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>rdc_ctl</name>
          <description>rdc control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003FF37F</resetMask>
          <fields>
            <field>
              <name>TS_SEL</name>
              <description>Time stamp selection for accumulation
0: end of accumulation
1: start of accumulation
2: center of accumulation</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_LEN</name>
              <description>Accumulate time, support on the fly change
0：1 cycle
1：2 cycles
…
255: 256 cycles</description>
              <bitOffset>12</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_OUT_MASK</name>
              <description>rdc output mask</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IIR_EN</name>
              <description>IIR enable for adc input</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RECTIFY_SEL</name>
              <description>Select reference point of rectify signal
0: 0 phase of internal exciting signal
1: 90 phase of internal exciting signal
2: 180 phase of internal exciting signal
3: 270 phase of internal exciting signal
4: use value on external pin
5: use  invert value on external pin</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_FAST</name>
              <description>every adc value can be  as one accumulate value</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_EN</name>
              <description>Enable rdc accumulate
0: rdc disable
1: rdc enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXC_START</name>
              <description>Write 1 start excite signal, always read 0
0: no effect
1: start excite signal</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXC_EN</name>
              <description>Enable rdc excite signal
0: rdc disable
1: rdc enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>acc_i</name>
          <description>accumulate result of i_channel</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACC</name>
              <description>accumulate result of i_channel, this is a signed number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>acc_q</name>
          <description>accumulate result of q_channel</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACC</name>
              <description>accumulate result of q_channel, this is a signed number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>in_ctl</name>
          <description>input channel selection</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0011F11F</resetMask>
          <fields>
            <field>
              <name>PORT_Q_SEL</name>
              <description>Input port selection for q_channel,
0:sel port0
1:sel port1</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_Q_SEL</name>
              <description>Input channel selection for q_channel
0: channel 0 selected
1: channel 1 selected
…
31: channel 31 selected</description>
              <bitOffset>12</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_I_SEL</name>
              <description>Input port selection for i_channel,
0:sel port0
1:sel port1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_I_SEL</name>
              <description>Input channel selection for i_channel
0: channel 0 selected
1: channel 1 selected
…
31: channel 31 selected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>out_ctl</name>
          <description>output channel selection</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001F1F</resetMask>
          <fields>
            <field>
              <name>CH_Q_SEL</name>
              <description>Output channel selection for q_channel</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_I_SEL</name>
              <description>Output channel selection for i_channel</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>iir_b</name>
          <description>IIR parameter for b branch</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x01000007</resetMask>
          <fields>
            <field>
              <name>LOWPASS</name>
              <description>IIR in lowpass mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IIR_B</name>
              <description>IIR parameter for b branch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>iir_a</name>
          <description>IIR parameter for a branch</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00F601F4</resetValue>
          <resetMask>0x00FF01FF</resetMask>
          <fields>
            <field>
              <name>IIR_A2</name>
              <description>IIR parameter a2 for a branch</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IIR_A1</name>
              <description>IIR parameter a1 for a branch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>exc_timming</name>
          <description>excitation signal timming setting</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x000400C8</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>SWAP</name>
              <description>Swap output of PWM and DAC
0: disable swap
1: swap output</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_PRD</name>
              <description>Pwm period in samples，
0：1 sample period
1:   2 sample period
...
15: 16 sample period</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SMP_NUM</name>
              <description>Number of sample every excitation period
0: 4 point
1: 8 point
…
8: 1024 point</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SMP_RATE</name>
              <description>The period for excitation sample in clock cycle，
0: not allowed
1: 1 cycle
2: 2 cycles
…
65535 : 65535 cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>exc_scaling</name>
          <description>amplitude scaling for excitation</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000011</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>AMP_EXP</name>
              <description>Amplitude scaling for excitation,  amplitude = [table value] x man / 2^exp</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMP_MAN</name>
              <description>Amplitude scaling for excitation,  amplitude = [table value] x man / 2^exp</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>exc_offset</name>
          <description>amplitude offset setting</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00800000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>AMP_OFFSET</name>
              <description>Offset for excitation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pwm_scaling</name>
          <description>amplitude scaling for excitation</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000111</resetValue>
          <resetMask>0x000031FF</resetMask>
          <fields>
            <field>
              <name>N_POL</name>
              <description>Polarity of exc_n signal
0: high active
1: low active</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>P_POL</name>
              <description>Polarity of exc_p signal
0: high active
1: low active</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DITHER</name>
              <description>Enable dither of pwm
0: disable
1: enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMP_EXP</name>
              <description>Amplitude scaling for excitation,  amplitude = [table value] x man / 2^exp</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMP_MAN</name>
              <description>Amplitude scaling for excitation,  amplitude = [table value] x man / 2^exp</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pwm_offset</name>
          <description>amplitude offset setting</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000064</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>AMP_OFFSET</name>
              <description>Offset for excitation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trig_out0_cfg</name>
          <description>Configuration for trigger out 0 in clock cycle</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00100019</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Enable trigger out0
0: disable
1: enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEAD_TIM</name>
              <description>Lead time for trigger out0 from center of low level , this is a signed value
…
2: 2 cycle befor center of low level
1: 1 cycle before center of low level
0: center of low level
-1: 1cycle after center of low level
-2: 2cycle after center of low level</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trig_out1_cfg</name>
          <description>Configuration for trigger out 1 in clock cycle</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x0010004B</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Enable trigger out1
0: disable
1: enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEAD_TIM</name>
              <description>Lead time for trigger out0 from center of hight level , this is a signed value
…
2: 2 cycle befor center of hight level
1: 1 cycle before center of hight level
0: center of hight level
-1: 1cycle after center of hight level
-2: 2cycle after center of hight level</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pwm_dz</name>
          <description>pwm dead zone control in clock cycle</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DZ_N</name>
              <description>Exc_n dead zone  in clock cycle before swap
0: no dead zone
1: 1 cycle dead zone
2: 2 cycle dead zone
…</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZ_P</name>
              <description>Exc_p dead zone  in clock cycle before swap
0: no dead zone
1: 1 cycle dead zone
2: 2 cycle dead zone
…</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sync_out_ctrl</name>
          <description>synchronize output signal control</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0033</resetMask>
          <fields>
            <field>
              <name>PWM_OUT_DLY</name>
              <description>Delay bettween the delyed trigger and the first pwm pulse in clock cycle
1: 1 cycle
2: 2 cycle
…</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN2TRIG_EN</name>
              <description>Enable trigger out from the min point of exciting signal
1: enable
0: disable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX2TRIG_EN</name>
              <description>Enable trigger out from the max point of exciting signal
1: enable
0: disable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_OUT_SEL</name>
              <description>Select output synchornize signal
0: 0 phase of internal exciting signal
1: 90 phase of internal exciting signal
2: 180 phase of internal exciting signal
3: 270 phase of internal exciting signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>exc_sync_dly</name>
          <description>trigger in delay timming in soc bus cycle</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x01000001</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>DISABLE</name>
              <description>Disable hardware trigger input
0: enable
1: disable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY</name>
              <description>Trigger in delay timming in bus cycle from rising edge of trigger signal
0:   1 cycle
1:  2 cycle
…
0xffffff:  2^24 cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>max_min_pos</name>
          <description>max min data position of channel</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>MAX_MIN_POS</name>
              <description>max min value position
0: max min value at adc input
1: max min value at IIR output</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>max_i</name>
          <description>max value of  i_channel</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF01</resetMask>
          <fields>
            <field>
              <name>MAX</name>
              <description>Max value of  i_channel, write clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Max value valid, write clear
0: max value is not valid
1: max value is valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>min_i</name>
          <description>min value of  i_channel</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF01</resetMask>
          <fields>
            <field>
              <name>MIN</name>
              <description>Min value of  i_channel, write clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Min value valid, write clear
0: min value is not valid
1: min value is valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>max_q</name>
          <description>max value of  q_channel</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF01</resetMask>
          <fields>
            <field>
              <name>MAX</name>
              <description>Max value of  q_channel, write clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Max value valid, write clear
0: max value is not valid
1: max value is valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>min_q</name>
          <description>min value of  q_channel</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF01</resetMask>
          <fields>
            <field>
              <name>MIN</name>
              <description>Min value of  q_channel, write clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Min value valid, write clear
0: min value is not valid
1: min value is valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>thrs_i</name>
          <description>the offset setting for edge detection of the i_channel</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF01</resetMask>
          <fields>
            <field>
              <name>THRS</name>
              <description>The offset setting for edge detection of the i_channel, signed number
…
2: the offset is 0x800000+2
1: the offset is 0x800000+1
0: the offset is 0x800000
-1: the offset is 0x800000-1
-2: the offset is 0x800000-2
…</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THRS4ACC</name>
              <description>enable thrs data for accumulate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>thrs_q</name>
          <description>the offset setting for edge detection of the q_channel</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF01</resetMask>
          <fields>
            <field>
              <name>THRS</name>
              <description>The offset setting for edge detection of the q_channel, signed number
…
2: the offset is 0x800000+2
1: the offset is 0x800000+1
0: the offset is 0x800000
-1: the offset is 0x800000-1
-2: the offset is 0x800000-2
…</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THRS4ACC</name>
              <description>enable thrs data for accumulate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>edg_det_ctl</name>
          <description>the control for edge detection</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000080</resetValue>
          <resetMask>0x000003F7</resetMask>
          <fields>
            <field>
              <name>HOLD</name>
              <description>The minimum edge distance  in sample
0:1 sample
1:2 sample
2:3 samples
…
63:64 samples</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER</name>
              <description>The continuous positive or negative number for edge detection
0: 1
1: 2
…
7: 8</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>acc_scaling</name>
          <description>scaling for accumulation result</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>TOXIC_LK</name>
              <description>Toxic accumulation data be removed control
1: enable
0: disable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_SHIFT</name>
              <description>Accumulation value shift control, this is a sign number.
0: {acc[39],acc[38:8]}
1: {acc[39],acc[37:7]}
2: {acc[39],acc[36:6]}
…
7: {acc[39],acc[31:1]}
8: {acc[39],acc[30:0]}
9: acc/2^9
10: acc/2^10
…
15:acc/2^15</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>exc_period</name>
          <description>period of excitation</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00001770</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EXC_PERIOD</name>
              <description>The num in clock cycle for period of excitation
0: invalid value
1:1 cycle
2:2 cycles
…</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sync_delay_i</name>
          <description>delay  setting in clock cycle for synchronous signal</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DELAY</name>
              <description>Delay  in clock cycle for synchronous signal, the value shoud less than half of exc_period.exc_period.
0: invalid value
1: 1 cycles
2: 2 cycles
...</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rise_delay_i</name>
          <description>delay in clock cycle between excitation synchrnous signal and rising edge of i_channel data</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RISE_DELAY</name>
              <description>Delay value on rising edge of  i_channel data
0: 1 cycle
1: 2 cycles
…</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>fall_delay_i</name>
          <description>delay in clock cycle between excitation synchrnous signal and falling edge of i_channel data</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FALL_DELAY</name>
              <description>Delay value on falling edge of  i_channel data
0: 1 cycle
1: 2 cycles
…</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sample_rise_i</name>
          <description>sample value on rising edge of rectify signal</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>sample value on rising edge of rectify signal</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sample_fall_i</name>
          <description>sample value on falling edge of rectify signal</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>sample value on falling edge of rectify signal</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>acc_cnt_i</name>
          <description>number of accumulation</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_NEG</name>
              <description>sample number during the negtive of rectify signal
1: 1
2: 2
…</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNT_POS</name>
              <description>sample number during the positive of rectify signal
1: 1
2: 2
…</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sign_cnt_i</name>
          <description>sample counter of opposite sign with rectify signal</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_NEG</name>
              <description>Positive sample counter during negative rectify signal</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNT_POS</name>
              <description>Negative sample counter during positive rectify signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sync_delay_q</name>
          <description>delay  setting in clock cycle for synchronous signal</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DELAY</name>
              <description>Delay  in clock cycle for synchronous signal, the value shoud less than half of exc_period.exc_period.
0: invalid value
1: 1 cycles
2: 2 cycles
...</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rise_delay_q</name>
          <description>delay in clock cycle between excitation synchrnous signal and rising edge of q_channel data</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RISE_DELAY</name>
              <description>Delay value on rising edge of  q_channel data
0: 1 cycle
1: 2 cycles
…</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>fall_delay_q</name>
          <description>delay in clock cycle between excitation synchrnous signal and falling edge of q_channel data</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FALL_DELAY</name>
              <description>Delay value on falling edge of  q_channel data
0: 1 cycle
1: 2 cycles
…</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sample_rise_q</name>
          <description>sample value on rising edge of rectify signal</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>sample value on rising edge of rectify signal</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sample_fall_q</name>
          <description>sample value on falling edge of rectify signal</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>sample value on falling edge of rectify signal</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>acc_cnt_q</name>
          <description>number of accumulation</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_NEG</name>
              <description>sample number during the negtive of rectify signal
1: 1
2: 2
…</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNT_POS</name>
              <description>sample number during the positive of rectify signal
1: 1
2: 2
…</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sign_cnt_q</name>
          <description>sample counter of opposite sign with rectify signal</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_NEG</name>
              <description>Positive sample counter during negative rectify signal</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNT_POS</name>
              <description>Negative sample counter during positive rectify signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>amp_max</name>
          <description>the maximum of acc amplitude</description>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <resetValue>0x01000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX</name>
              <description>the maximum of acc amplitude</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>amp_min</name>
          <description>the minimum of acc amplitude</description>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <resetValue>0x00400000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MIN</name>
              <description>the minimum of acc amplitude</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_en</name>
          <description>the interrupt mask control</description>
          <addressOffset>0xe8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>INT_EN</name>
              <description>enable interrupt output</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_VLD_I_EN</name>
              <description>i_channel accumulate valid interrupt enable for i_channel</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_VLD_Q_EN</name>
              <description>q_channel accumulate valid interrupt enable for i_channel</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RISING_DELAY_I_EN</name>
              <description>i_channel delayed rectify signal rising edge interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FALLING_DELAY_I_EN</name>
              <description>i_channel delayed rectify signal falling edge interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RISING_DELAY_Q_EN</name>
              <description>q_channel delayed rectify signal rising edge interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FALLING_DELAY_Q_EN</name>
              <description>q_channel delayed rectify signal falling edge interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_RISING_I_EN</name>
              <description>i_channel rising edge interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_FALLING_I_EN</name>
              <description>i_channel falling edge interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_RISING_Q_EN</name>
              <description>q_channel rising edge interrupt enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_FALLING_Q_EN</name>
              <description>q_channel falling edge interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_VLD_I_OVH_EN</name>
              <description>i_channel accumulate overflow interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_VLD_Q_OVH_EN</name>
              <description>q_channel accumulate overflow interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_VLD_I_OVL_EN</name>
              <description>i_channel accumulate underflow interrupt enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_VLD_Q_OVL_EN</name>
              <description>q_channel accumulate underflow interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_AMP_OVH_EN</name>
              <description>accumulate ample overflow interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_AMP_OVL_EN</name>
              <description>accumulate ample underflow interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc_int_state</name>
          <description>the interrupt state</description>
          <addressOffset>0xec</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ACC_VLD_I_STA</name>
              <description>i_channel accumulate valid interrupt status for i_channel</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ACC_VLD_Q_STA</name>
              <description>q_channel accumulate valid interrupt status for i_channel</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RISING_DELAY_I_STA</name>
              <description>i_channel delayed rectify signal rising edge interrupt status</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FALLING_DELAY_I_STA</name>
              <description>i_channel delayed rectify signal falling edge interrupt status</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RISING_DELAY_Q_STA</name>
              <description>q_channel delayed rectify signal rising edge interrupt status</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FALLING_DELAY_Q_STA</name>
              <description>q_channel delayed rectify signal falling edge interrupt status</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SAMPLE_RISING_I_STA</name>
              <description>i_channel rising edge interrupt status</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SAMPLE_FALLING_I_STA</name>
              <description>i_channel falling edge interrupt status</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SAMPLE_RISING_Q_STA</name>
              <description>q_channel rising edge interrupt status</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SAMPLE_FALLING_Q_STA</name>
              <description>q_channel falling edge interrupt status</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ACC_VLD_I_OVH_STA</name>
              <description>i_channel accumulate overflow interrupt status</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ACC_VLD_Q_OVH_STA</name>
              <description>q_channel accumulate overflow interrupt status</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ACC_VLD_I_OVL_STA</name>
              <description>i_channel accumulate underflow interrupt status</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ACC_VLD_Q_OVL_STA</name>
              <description>q_channel accumulate underflow interrupt status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ACC_AMP_OVH_STA</name>
              <description>accumulate ample overflow interrupt status</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ACC_AMP_OVL_STA</name>
              <description>accumulate ample underflow interrupt status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="RDC0">
      <name>RDC1</name>
      <description>RDC1</description>
      <groupName>RDC</groupName>
      <baseAddress>0xf0444000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SDM0</name>
      <description>SDM0</description>
      <groupName>SDM</groupName>
      <baseAddress>0xf0450000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x110</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>SDM control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFE</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>software reset the module if asserted to be1’b1.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHMD</name>
              <description>Channel Rcv mode
Bits[2:0] for Ch0.
Bits[5:3] for Ch1
Bits[8:6] for Ch2
Bits[11:9] for Ch3
3'b000: Capture at posedge of MCLK
3'b001: Capture at both posedge and negedge of MCLK
3'b010: Manchestor Mode
3'b011: Capture at negedge of MCLK
3'b100: Capture at every other posedge of MCLK
3'b101: Capture at every other negedge of MCLK
Others: Undefined</description>
              <bitOffset>14</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_MCLK</name>
              <description>Asserted to double sync the mclk input pin before its usage inside the module</description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_MDAT</name>
              <description>Asserted to double sync the mdat input pin before its usage inside the module</description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_EN</name>
              <description>Channel Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>Interrupt enable register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3DRY</name>
              <description>Ch3 Data Ready interrupt enable.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2DRY</name>
              <description>Ch2 Data Ready interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1DRY</name>
              <description>Ch1 Data Ready interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0DRY</name>
              <description>Ch0 Data Ready interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3ERR</name>
              <description>Ch3 Error interrupt enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2ERR</name>
              <description>Ch2 Error interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1ERR</name>
              <description>Ch1 Error interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0ERR</name>
              <description>Ch0 Error interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status Registers</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3DRY</name>
              <description>Ch3 Data Ready.
De-assert this bit by reading the data (or data fifo) registers.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH2DRY</name>
              <description>Ch2 Data Ready</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH1DRY</name>
              <description>Ch1 Data Ready</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0DRY</name>
              <description>Ch0 Data Ready</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH3ERR</name>
              <description>Ch3 Error.
ORed together by channel related error signals and corresponding error interrupt enable signals.
De-assert this bit by write-1-clear the corresponding error status bits in the channel status registers.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH2ERR</name>
              <description>Ch2 Error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH1ERR</name>
              <description>Ch1 Error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0ERR</name>
              <description>Ch0 Error</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>CH[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <register>
            <name>SDFIFOCTRL</name>
            <description>Data FIFO Path Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF01F4</resetMask>
            <fields>
              <field>
                <name>GATE_SAMPLES</name>
                <description>The number-1-3 of input PDM bit samples to be gated when CIC_GATE_EN=1. Max 255. So the minimum gated samples is 4 samples when GATE_SAMPLES=0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THRSH</name>
                <description>FIFO threshold (0,..,16) (fillings &gt; threshold, then gen int)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>D_RDY_INT_EN</name>
                <description>FIFO data ready interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDCTRLP</name>
            <description>Data Path Control Primary Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MANCH_THR</name>
                <description>Manchester Decoding threshold. 3/4 of PERIOD_MCLK[7:0]</description>
                <bitOffset>25</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDOG_THR</name>
                <description>Watch dog threshold for channel failure of CLK halting</description>
                <bitOffset>17</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AF_IE</name>
                <description>Acknowledge feedback interrupt enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DFFOVIE</name>
                <description>Ch Data FIFO overflow interrupt enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSATIE</name>
                <description>Ch CIC Data Saturation Interrupt Enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIE</name>
                <description>Ch Data Ready Interrupt Enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCSEL</name>
                <description>Select the PWM SYNC Source</description>
                <bitOffset>7</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FFSYNCCLREN</name>
                <description>Auto clear FIFO when a new SDSYNC event is found. Only valid when WTSYNCEN=1</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WTSYNACLR</name>
                <description>1: Asserted to Auto clear WTSYNFLG when the SDFFINT is gen
0: WTSYNFLG should be cleared manually by WTSYNMCLR</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WTSYNMCLR</name>
                <description>1: Manually clear WTSYNFLG. Auto-clear.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WTSYNCEN</name>
                <description>1: Start to store data only after PWM SYNC event
0: Start to store data whenever enabled</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>D32</name>
                <description>1:32 bit data
0:16 bit data</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DR_OPT</name>
                <description>1: Use Data FIFO Ready as data ready when fifo fillings are greater than the threshold
0: Use Data Reg Ready as data ready</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN</name>
                <description>Data Path Enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDCTRLE</name>
            <description>Data Path Control Extra Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFE77FFFF</resetMask>
            <fields>
              <field>
                <name>CIC_GATE_TYPE</name>
                <description>1: the gate cycle is determined by SDFIFOCTRLn[GATE_SAMPLES].
0: the gate cycle is determined by the CIC decimation counter, and the minimal gated off PDM bits are determined by SDFIFOCTRLn[GATE_SAMPLES], and at the same time, to keep alignment with normal PCM sampling time.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_GATE_POL</name>
                <description>1: When mask signal is 1, pause the CIC stage at he rising edge of mask signal.
0: When mask signal is 0, pause the CIC stage at he falling edge of mask signal.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_GATE_SEL</name>
                <description>Select the mask signal for CIC gate signal.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_GATE_EN</name>
                <description>1: the CIC stage can be paused by the mask input.
0: the CIC stage won't be paused by the mask input.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMESTAMP_TYPE</name>
                <description>1. Use the time (when the data is calculated out) - delta_time_of_filter_span as the timestamp.
0: Use the time when the data is calculated out.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DFIFO_S_T</name>
                <description>1: the output of SDFIFO is data and timestamp interleaved. First is data.
0: the output of SDFIFO is data only</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_S_T</name>
                <description>"1: the read output of SData is data and timestamp interleaved. First is data.
0: the read output of SData is data only"</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SGD_ORDR</name>
                <description>CIC order
0: SYNC1
1: SYNC2
2: SYNC3
3: FAST_SYNC</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PWMSYNC</name>
                <description>Asserted to double sync the PWM trigger signal</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_SCL</name>
                <description>CIC shift control</description>
                <bitOffset>11</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_DEC_RATIO</name>
                <description>CIC decimation ratio. 0 means div-by-256</description>
                <bitOffset>3</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IGN_INI_SAMPLES</name>
                <description>NotZero: Don't store the first samples that are not accurate
Zero: Store all samples</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDST</name>
            <description>Data Path Status</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF8033FF</resetMask>
            <fields>
              <field>
                <name>PERIOD_MCLK</name>
                <description>maxim of mclk spacing in cycles, using edges of mclk signal.  In manchester coding mode, it is just the period of MCLK. In other modes, it is almost the half period.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SDATA_D0_T1</name>
                <description>1: next readout is timestamp
0: next readout is data</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SDFIFO_D0_T1</name>
                <description>1: next readout is timestamp
0: next readout is data</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_DR</name>
                <description>FIFO data ready</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>AF</name>
                <description>Achnowledge flag</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DOV_ERR</name>
                <description>Data FIFO Overflow Error. Error flag.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DSAT_ERR</name>
                <description>CIC out Data saturation err. Error flag.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>WTSYNFLG</name>
                <description>Wait-for-sync event found</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FILL</name>
                <description>Data FIFO Fillings</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDATA</name>
            <description>Data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Data</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDFIFO</name>
            <description>FIFO Data</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>FIFO Data</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCAMP</name>
            <description>instant Amplitude Results</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>instant Amplitude Results</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCHTL</name>
            <description>Amplitude Threshold for High Limit</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Amplitude Threshold for High Limit</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCHTLZ</name>
            <description>Amplitude Threshold for zero crossing</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Amplitude Threshold for zero crossing</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCLLT</name>
            <description>Amplitude Threshold for low limit</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Amplitude Threshold for low limit</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCCTRL</name>
            <description>Amplitude Path Control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFC01FF</resetMask>
            <fields>
              <field>
                <name>HZ_EN</name>
                <description>Zero Crossing Enable</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MF_IE</name>
                <description>Module failure Interrupt enable</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HL_IE</name>
                <description>HLT Interrupt Enable</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LL_IE</name>
                <description>LLT interrupt Enable</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SGD_ORDR</name>
                <description>CIC order
0: SYNC1
1: SYNC2
2: SYNC3
3: FAST_SYNC</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_DEC_RATIO</name>
                <description>CIC decimation ratio. 0 means div-by-32</description>
                <bitOffset>4</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IGN_INI_SAMPLES</name>
                <description>NotZero: Ignore the first samples that are not accurate
Zero: Use all samples</description>
                <bitOffset>1</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN</name>
                <description>Amplitude Path Enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCST</name>
            <description>Amplitude Path Status</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HZ</name>
                <description>Amplitude rising above HZ event found.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MF</name>
                <description>power modulator Failure found. MCLK not found. Error flag.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMPH</name>
                <description>HLT out of range. Error flag.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMPL</name>
                <description>LLT out of range. Error flag.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SDM0">
      <name>SDM1</name>
      <description>SDM1</description>
      <groupName>SDM</groupName>
      <baseAddress>0xf0454000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PLB</name>
      <description>PLB</description>
      <groupName>PLB</groupName>
      <baseAddress>0xf0460000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x500</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>TYPE_A[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>LOOKUP_TABLE[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>LOOKUP_TABLE</name>
                <description>using 4 bit trig_in as lookup index. software can program this register as trig_in's true table.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>sw_inject</name>
            <description>TYPE A CHN&amp;index0 software inject</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>SW_INJECT</name>
                <description>software can inject value to TYPEA's output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>TYPE_B[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <register>
            <dim>2</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>0,1</dimIndex>
            <name>LUT[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOOKUP_TABLE</name>
                <description>lut0 and lut1 union as 64bit, consider each 4bit as one slice. then, total 16 slice. slice0 as bit3:0, slice1 as bit7:4...etc. using 4bit trig in as index of slice. the operate sel in data unit of type B channle is decided by which slice value choosed by trig_in</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>CMP[%s]</name>
            <description>no description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CMP_VALUE</name>
                <description>cmp value, using as data unit operation</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>mode</name>
            <description>TYPE B CHN&amp;index0 mode ctrl</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0001FFFF</resetMask>
            <fields>
              <field>
                <name>OPT_SEL</name>
                <description>operation selection in data unit.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3_SEL</name>
                <description>trig out 3 output type in current channel</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2_SEL</name>
                <description>trig out 2 output type in current channel</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1_SEL</name>
                <description>trig out 1 output type in current channel</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT0_SEL</name>
                <description>trig out 0 output type in current channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>sw_inject</name>
            <description>TYPE B CHN&amp;index0 software inject</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOFTWARE_INJECT</name>
                <description>data unit value can be changed if program this register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYNT</name>
      <description>SYNT</description>
      <groupName>SYNT</groupName>
      <baseAddress>0xf0464000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x60</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>gcr</name>
          <description>Global control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF000003F</resetMask>
          <fields>
            <field>
              <name>TIMESTAMP_INC_NEW</name>
              <description>set to increase the timesamp with new value, auto clr</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMESTAMP_DEC_NEW</name>
              <description>set to decrease the timesamp with new value, auto clr</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMESTAMP_SET_NEW</name>
              <description>set  the timesamp to new value, auto clr</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMESTAMP_RESET</name>
              <description>reset timesamp  to 0, auto clr</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMESTAMP_DEBUG_EN</name>
              <description>set to enable cpu_debug_mode to stop the timesamp</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMESTAMP_ENABLE</name>
              <description>set to enable the timesamp , clr to stop</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_ONESHOT</name>
              <description>set for one shot mode, timer will run only once.
Software need reset timer first to start another one shot</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_DEBUG_EN</name>
              <description>set to enable cpu_debug_mode to stop the counter</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRST</name>
              <description>1- Reset counter</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>1- Enable counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rld</name>
          <description>Counter reload register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RLD</name>
              <description>counter reload value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>timestamp_new</name>
          <description>timestamp new value register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>new value for timesamp , can be used as set/inc/dec</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cnt</name>
          <description>Counter</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>timestamp_sav</name>
          <description>timestamp trig save value</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>use the trigger to save timesamp  here</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>timestamp_cur</name>
          <description>timestamp read value</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>current timesamp  value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>CMP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP</name>
              <description>comparator value, the output will assert when counter count to this value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SEI</name>
      <description>SEI</description>
      <groupName>SEI</groupName>
      <baseAddress>0xf0470000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>13</dim>
          <dimIncrement>0x400</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12</dimIndex>
          <name>CTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>ENGINE_CTRL</name>
            <description>Engine control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WATCH</name>
                <description>Enable watch dog
0: Watch dog disabled
1: Watch dog enabled</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ARMING</name>
                <description>Wait for trigger before excuting
0: Execute on enable
1: Wait trigger before exection after enabled</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXCEPT</name>
                <description>Explain timout as exception
0: when timeout, pointer move to next instruction
1: when timeout, pointer jump to timeout vector</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REWIND</name>
                <description>Rewind execution pointer
0: run
1: clean status and rewind</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Enable
0: disable
1: enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENGINE_PTR_CFG</name>
            <description>Pointer configuration register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF1FFFFF</resetMask>
            <fields>
              <field>
                <name>DAT_CDM</name>
                <description>Select DATA register to receive CDM bit in BiSSC slave mode
0: ignore
1: command
2: data register 2
3: data register 3
...
29:data register 29
30: value 0 when send, ignore in receive
31: value1 when send, ignore in receive</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DAT_BASE</name>
                <description>Bias for data register access, if calculated index bigger than 32, index will wrap around
0: real data index
1: access index is 1 greater than instruction address
2: access index is 2 greater than instruction address
...
31: access index is 31 greater than instruction address</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POINTER_WDOG</name>
                <description>Pointer to the instruction that the program starts executing after the instruction timeout. The timeout is WDOG_TIME</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POINTER_INIT</name>
                <description>Initial execute pointer</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENGINE_WDG_CFG</name>
            <description>Watch dog configuration register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>WDOG_TIME</name>
                <description>Time out count for each instruction, counter in bit time.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENGINE_EXE_STA</name>
            <description>Execution status</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00110101</resetMask>
            <fields>
              <field>
                <name>TRIGERED</name>
                <description>Execution has been triggered
0: Execution not triggered
1: Execution triggered</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ARMED</name>
                <description>Waiting for trigger for execution
0: Not in waiting status
1: In waiting status</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXPIRE</name>
                <description>Watchdog timer expired
0: Not expired
1: Expired</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STALL</name>
                <description>Program finished
0: Program is executing
1: Program finished</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENGINE_EXE_PTR</name>
            <description>Execution pointer</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x1F1F00FF</resetMask>
            <fields>
              <field>
                <name>HALT_CNT</name>
                <description>Halt count in halt instrution</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BIT_CNT</name>
                <description>Bit count in send and receive instruction execution</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>POINTER</name>
                <description>Current program pointer</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENGINE_EXE_INST</name>
            <description>Execution instruction</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INST</name>
                <description>Current instruction</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENGINE_WDG_STA</name>
            <description>Watch dog status</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>WDOG_CNT</name>
                <description>Current watch dog counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XCVR_CTRL</name>
            <description>Transceiver control register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRISMP</name>
                <description>Tipple sampe
0: sample 1 time for data transition
1: sample 3 times in receive and result in 2oo3</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAR_CLR</name>
                <description>Clear parity error, this is a self clear bit
0: no effect
1: clear parity error</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>RESTART</name>
                <description>Restart tranceiver, this is a self clear bit
0: no effect
1: reset tranceiver</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Tranceiver mode
0: synchronous maaster
1: synchronous slave
2: asynchronous mode
3: asynchronous mode</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XCVR_TYPE_CFG</name>
            <description>Transceiver configuration register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WAIT_LEN</name>
                <description>Number of extra stop bit for asynchronous mode
0: 1 bit
1: 2 bit
...
255: 256 bit</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_LEN</name>
                <description>Number of data bit for asynchronous mode
0: 1 bit
1: 2 bit
...
31: 32 bit</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAR_POL</name>
                <description>Polarity of parity for asynchronous mode
0: even
1: odd</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAR_EN</name>
                <description>enable parity check for asynchronous mode
0: disable
1: enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DA_IDLEZ</name>
                <description>Idle state driver of data line
0: output
1: high-Z</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CK_IDLEZ</name>
                <description>Idle state driver of clock line
0: output
1: high-Z</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DA_IDLEV</name>
                <description>Idle state value of data line
0: data'0'
1: data'1'</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CK_IDLEV</name>
                <description>Idle state value of clock line
0: data'0'
1: data'1'</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XCVR_BAUD_CFG</name>
            <description>Transceiver baud rate register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SYNC_POINT</name>
                <description>Baud synchronous time, minmum bit time</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BAUD_DIV</name>
                <description>Baud rate, bit time in system clock cycle</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XCVR_DATA_CFG</name>
            <description>Transceiver data timing configuration</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXD_POINT</name>
                <description>data transmit point  in system clcok cycle</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RXD_POINT</name>
                <description>data receive point in system clcok cycle</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XCVR_CLK_CFG</name>
            <description>Transceiver clock timing configuration</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CK1_POINT</name>
                <description>clock point 1 in system clcok cycle</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CK0_POINT</name>
                <description>clock point 0 in system clcok cycle</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XCVR_PIN</name>
            <description>Transceiver pin status</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x07070707</resetMask>
            <fields>
              <field>
                <name>OE_CK</name>
                <description>CK drive state
0: input
1: output</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DI_CK</name>
                <description>CK state
0: data 0
1: data 1</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DO_CK</name>
                <description>CK output
0: data 0
1: data 1</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OE_RX</name>
                <description>RX drive state
0: input
1: output</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DI_RX</name>
                <description>RX state
0: data 0
1: data 1</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DO_RX</name>
                <description>RX output
0: data 0
1: data 1</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OE_DE</name>
                <description>DE drive state
0: input
1: output</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DI_DE</name>
                <description>DE state
0: data 0
1: data 1</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DO_DE</name>
                <description>DE output
0: data 0
1: data 1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OE_TX</name>
                <description>TX drive state
0: input
1: output</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DI_TX</name>
                <description>TX state
0: data 0
1: data 1</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DO_TX</name>
                <description>TX output
0: data 0
1: data 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XCVR_STATE</name>
            <description>FSM of asynchronous</description>
            <addressOffset>0x3c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x07070000</resetMask>
            <fields>
              <field>
                <name>RECV_STATE</name>
                <description>FSM of asynchronous receive</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEND_STATE</name>
                <description>FSM of asynchronous transmit</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRG_IN_CFG</name>
            <description>Trigger input configuration</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x83878787</resetMask>
            <fields>
              <field>
                <name>REWIND_EN</name>
                <description>enable rewind cmd register by LATCH</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REWIND_SEL</name>
                <description>select one LATCH to rewind CMD register
0:LATCH[0]
1:LATCH[1]
2:LATCH[2]
3:LATCH[3]</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRD_EN</name>
                <description>Enable period trigger (tigger 2)
0: periodical trigger disabled
1: periodical trigger enabled</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC_SEL</name>
                <description>Synchronize sigal selection (tigger 2)
0: trigger in 0
1: trigger in 1
...
7: trigger in 7</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IN1_EN</name>
                <description>Enable trigger 1
0: disable trigger 1
1: enable trigger 1</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IN1_SEL</name>
                <description>Trigger 1 sigal selection
0: trigger in 0
1: trigger in 1
...
7: trigger in 7</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IN0_EN</name>
                <description>Enable trigger 0
0: disable trigger 1
1: enable trigger 1</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IN0_SEL</name>
                <description>Trigger 0 sigal selection
0: trigger in 0
1: trigger in 1
...
7: trigger in 7</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRG_SW</name>
            <description>Software trigger</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>SOFT</name>
                <description>Software trigger (tigger 3). this bit is self-clear
0: trigger source disabled
1: trigger source enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRG_PRD_CFG</name>
            <description>Period trigger configuration</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0001</resetMask>
            <fields>
              <field>
                <name>ARMING</name>
                <description>Wait for trigger synchronous before trigger
0: Trigger directly
1: Wait trigger source before period trigger</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC</name>
                <description>Synchronous
0: Not synchronous
1: Synchronous every trigger source</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRG_PRD</name>
            <description>Trigger period</description>
            <addressOffset>0x4c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Trigger period</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRG_OUT_CFG</name>
            <description>Trigger output configuration</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x87878787</resetMask>
            <fields>
              <field>
                <name>OUT3_EN</name>
                <description>Enable trigger 3
0: disable trigger 3
1: enable trigger 3</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3_SEL</name>
                <description>Trigger 3 sigal selection
0: trigger out 0
1: trigger out 1
...
7: trigger out 7</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2_EN</name>
                <description>Enable trigger 2
0: disable trigger 2
1: enable trigger 2</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2_SEL</name>
                <description>Trigger 2 sigal selection
0: trigger out 0
1: trigger out 1
...
7: trigger out 7</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1_EN</name>
                <description>Enable trigger 1
0: disable trigger 1
1: enable trigger 1</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1_SEL</name>
                <description>Trigger 1 sigal selection
0: trigger out 0
1: trigger out 1
...
7: trigger out 7</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT0_EN</name>
                <description>Enable trigger 0
0: disable trigger 1
1: enable trigger 1</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT0_SEL</name>
                <description>Trigger 0 sigal selection
0: trigger out 0
1: trigger out 1
...
7: trigger out 7</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRG_PRD_STS</name>
            <description>Period trigger status</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00110000</resetMask>
            <fields>
              <field>
                <name>TRIGERED</name>
                <description>Period has been triggered
0: Not triggered
1: Triggered</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ARMED</name>
                <description>Waiting for trigger
0: Not in waiting status
1: In waiting status</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRG_PRD_CNT</name>
            <description>Period trigger counter</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD_CNT</name>
                <description>Trigger period counter</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>TRG_TABLE_CMD[%s]</name>
            <description>no description available</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CMD_TRIGGER0</name>
                <description>Trigger command</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>TRG_TABLE_TIME[%s]</name>
            <description>no description available</description>
            <addressOffset>0xa0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIGGER0_TIME</name>
                <description>Trigger time</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_MODE</name>
            <description>command register mode</description>
            <addressOffset>0xc0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xE0FFCFFF</resetMask>
            <fields>
              <field>
                <name>WLEN</name>
                <description>word length
0: 1 bit
1: 2 bit
...
31: 32 bit</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WORDER</name>
                <description>word order
0: sample as bit order
1: different from bit order</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BORDER</name>
                <description>bit order
0: LSB first
1: MSB first</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SIGNED</name>
                <description>Signed
0: unsigned value
1: signed value</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REWIND</name>
                <description>Write 1 to rewind read/write pointer, this is a self clear bit</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Data mode(CMD register only support data mode)
0: data mode
1: check mode
2: CRC mode</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_IDX</name>
            <description>command register configuration</description>
            <addressOffset>0xc4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LAST_BIT</name>
                <description>Last bit index for tranceive</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIRST_BIT</name>
                <description>First bit index for tranceive</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MAX_BIT</name>
                <description>Highest bit index</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MIN_BIT</name>
                <description>Lowest bit index</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_CMD</name>
            <description>command</description>
            <addressOffset>0xe0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>DATA</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_SET</name>
            <description>command bit set register</description>
            <addressOffset>0xe4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_SET</name>
                <description>DATA bit set</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_CLR</name>
            <description>command bit clear register</description>
            <addressOffset>0xe8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_CLR</name>
                <description>DATA bit clear</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_INV</name>
            <description>command bit invert register</description>
            <addressOffset>0xec</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_TGL</name>
                <description>DATA bit toggle</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_IN</name>
            <description>Commad input</description>
            <addressOffset>0xf0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_IN</name>
                <description>Commad input</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_OUT</name>
            <description>Command output</description>
            <addressOffset>0xf4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_OUT</name>
                <description>Command output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_STS</name>
            <description>Command status</description>
            <addressOffset>0xf8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xE0FFFFFF</resetMask>
            <fields>
              <field>
                <name>WORD_IDX</name>
                <description>Word index</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_CNT</name>
                <description>Word counter</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BIT_IDX</name>
                <description>Bit index</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>8</dim>
            <dimIncrement>0x20</dimIncrement>
            <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
            <name>CMD_CMD_TABLE[%s]</name>
            <description>no description available</description>
            <addressOffset>0x100</addressOffset>
            <register>
              <name>MIN</name>
              <description>command start value</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CMD_MIN</name>
                  <description>minimum command value</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAX</name>
              <description>command end value</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CMD_MAX</name>
                  <description>maximum command value</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MSK</name>
              <description>command compare bit enable</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CMD_MASK</name>
                  <description>compare mask</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PTA</name>
              <description>command pointer 0 - 3</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PTR3</name>
                  <description>pointer3</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR2</name>
                  <description>pointer2</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR1</name>
                  <description>pointer1</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR0</name>
                  <description>pointer0</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PTB</name>
              <description>command pointer 4 - 7</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PTR7</name>
                  <description>pointer7</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR6</name>
                  <description>pointer6</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR5</name>
                  <description>pointer5</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR4</name>
                  <description>pointer4</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PTC</name>
              <description>command pointer 8 - 11</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PTR11</name>
                  <description>pointer11</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR10</name>
                  <description>pointer10</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR9</name>
                  <description>pointer9</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR8</name>
                  <description>pointer8</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PTD</name>
              <description>command pointer 12 - 15</description>
              <addressOffset>0x1c</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PTR15</name>
                  <description>pointer15</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR14</name>
                  <description>pointer14</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR13</name>
                  <description>pointer13</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PTR12</name>
                  <description>pointer12</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <dim>4</dim>
            <dimIncrement>0x20</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>CMD_LATCH[%s]</name>
            <description>no description available</description>
            <addressOffset>0x200</addressOffset>
            <register>
              <dim>4</dim>
              <dimIncrement>0x4</dimIncrement>
              <dimIndex>0_1,1_2,2_3,3_0</dimIndex>
              <name>TRAN[%s]</name>
              <description>no description available</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFF0FFFFF</resetMask>
              <fields>
                <field>
                  <name>POINTER</name>
                  <description>pointer</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CFG_TM</name>
                  <description>timeout
0: high
1: low
2: rise
3: fall</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>2</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CFG_RXD</name>
                  <description>data received
0: high
1: low
2: rise
3: fall</description>
                  <bitOffset>14</bitOffset>
                  <bitWidth>2</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CFG_TXD</name>
                  <description>data send
0: high
1: low
2: rise
3: fall</description>
                  <bitOffset>12</bitOffset>
                  <bitWidth>2</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CFG_CLK</name>
                  <description>clock
0: high
1: low
2: rise
3: fall</description>
                  <bitOffset>10</bitOffset>
                  <bitWidth>2</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CFG_PTR</name>
                  <description>pointer
0: match
1: not match
2:entry
3:leave</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>2</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OV_TM</name>
                  <description>override timeout check</description>
                  <bitOffset>4</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OV_RXD</name>
                  <description>override RX data check</description>
                  <bitOffset>3</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OV_TXD</name>
                  <description>override TX data check</description>
                  <bitOffset>2</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OV_CLK</name>
                  <description>override clock check</description>
                  <bitOffset>1</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OV_PTR</name>
                  <description>override pointer check</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CFG</name>
              <description>Latch configuration</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x8700FFFF</resetMask>
              <fields>
                <field>
                  <name>EN</name>
                  <description>Enable latch
0: disable
1: enable</description>
                  <bitOffset>31</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SELECT</name>
                  <description>Output select
0: state0-state1
1: state1-state2
2: state2-state3
3: state3-state0</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>3</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DELAY</name>
                  <description>Delay in system clock cycle, for state transition</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TIME</name>
              <description>Latch time</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LAT_TIME</name>
                  <description>Latch time</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STS</name>
              <description>Latch status</description>
              <addressOffset>0x1c</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x0700FFFF</resetMask>
              <fields>
                <field>
                  <name>STATE</name>
                  <description>State</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>3</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LAT_CNT</name>
                  <description>Latch counter</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>POS_SMP_EN</name>
            <description>Sample selection register</description>
            <addressOffset>0x280</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ACC_EN</name>
                <description>Position include acceleration
0: use acceleration from sample override acceleration register
1: use acceleration from motor group</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACC_SEL</name>
                <description>Data register for acceleration transfer</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPD_EN</name>
                <description>Position include speed
0: use speed from sample override speed register
1: use speed from motor group</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPD_SEL</name>
                <description>Data register for speed transfer</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_EN</name>
                <description>Position include revolution
0: use revolution from sample override revolution register
1: use revolution  from motor group</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_SEL</name>
                <description>Data register for revolution transfer</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POS_EN</name>
                <description>Position include position
0: use position from sample override position register
1: use position from motor group</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POS_SEL</name>
                <description>Data register for position transfer</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SMP_CFG</name>
            <description>Sample configuration</description>
            <addressOffset>0x284</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0103FFFF</resetMask>
            <fields>
              <field>
                <name>ONCE</name>
                <description>Sample one time
0: Sample during windows time
1: Close sample window after first sample</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LAT_SEL</name>
                <description>Latch selection
0: latch 0
1: latch 1
2: latch 2
3: latch 3</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WINDOW</name>
                <description>Sample window, in clock cycle</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SMP_DAT</name>
            <description>Sample data</description>
            <addressOffset>0x288</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAT_SEL</name>
                <description>Data register sampled, each bit represent a data register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SMP_POS</name>
            <description>Sample override position</description>
            <addressOffset>0x290</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POS</name>
                <description>Sample override position</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SMP_REV</name>
            <description>Sample override revolution</description>
            <addressOffset>0x294</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REV</name>
                <description>Sample override revolution</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SMP_SPD</name>
            <description>Sample override speed</description>
            <addressOffset>0x298</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SPD</name>
                <description>Sample override speed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SMP_ACC</name>
            <description>Sample override accelerate</description>
            <addressOffset>0x29c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ACC</name>
                <description>Sample override accelerate</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_EN</name>
            <description>Update configuration</description>
            <addressOffset>0x2a0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ACC_EN</name>
                <description>Position include acceleration
0: use acceleration from update override acceleration register
1: use acceleration from data register</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACC_SEL</name>
                <description>Data register for acceleration transfer</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPD_EN</name>
                <description>Position include speed
0: use speed from update override speed register
1: use speed from data register</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPD_SEL</name>
                <description>Data register for speed transfer</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_EN</name>
                <description>Position include revolution
0: use revolution from update override revolution register
1: use revolution from data register</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_SEL</name>
                <description>Data register for revolution transfer</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POS_EN</name>
                <description>Position include position
0: use position from update override position register
1: use position from data register</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POS_SEL</name>
                <description>Data register for position transfer</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_CFG</name>
            <description>Update configuration</description>
            <addressOffset>0x2a4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x81030000</resetMask>
            <fields>
              <field>
                <name>TIME_OVRD</name>
                <description>Use override time
0: use time sample from motor group
1: use override time</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ONERR</name>
                <description>Sample one time
0: Sample during windows time
1: Close sample window after first sample</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LAT_SEL</name>
                <description>Latch selection
0: latch 0
1: latch 1
2: latch 2
3: latch 3</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_DAT</name>
            <description>Update data</description>
            <addressOffset>0x2a8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAT_SEL</name>
                <description>Data register sampled, each bit represent a data register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_TIME</name>
            <description>Update overide time</description>
            <addressOffset>0x2ac</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIME</name>
                <description>Update override time</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_POS</name>
            <description>Update override position</description>
            <addressOffset>0x2b0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POS</name>
                <description>Update override position</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_REV</name>
            <description>Update override revolution</description>
            <addressOffset>0x2b4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REV</name>
                <description>Update override revolution</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_SPD</name>
            <description>Update override speed</description>
            <addressOffset>0x2b8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SPD</name>
                <description>Update override speed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_ACC</name>
            <description>Update override accelerate</description>
            <addressOffset>0x2bc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ACC</name>
                <description>Update override accelerate</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SMP_VAL</name>
            <description>Sample valid</description>
            <addressOffset>0x2c0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x80808080</resetMask>
            <fields>
              <field>
                <name>ACC</name>
                <description>Position include acceleration</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SPD</name>
                <description>Position include speed</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REV</name>
                <description>Position include revolution</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>POS</name>
                <description>Position include position</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SMP_STS</name>
            <description>Sample status</description>
            <addressOffset>0x2c4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0100FFFF</resetMask>
            <fields>
              <field>
                <name>OCCUR</name>
                <description>Sample occured
0: Sample not happened
1: Sample occured</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WIN_CNT</name>
                <description>Sample window counter</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_TIME_IN</name>
            <description>input time</description>
            <addressOffset>0x2cc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIME</name>
                <description>input time</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_POS_IN</name>
            <description>Input position</description>
            <addressOffset>0x2d0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POS</name>
                <description>Input position</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_REV_IN</name>
            <description>Input revolution</description>
            <addressOffset>0x2d4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REV</name>
                <description>Input revolution</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_SPD_IN</name>
            <description>Input speed</description>
            <addressOffset>0x2d8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SPD</name>
                <description>Input speed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_ACC_IN</name>
            <description>Input accelerate</description>
            <addressOffset>0x2dc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ACC</name>
                <description>Input accelerate</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POS_UPD_STS</name>
            <description>Update status</description>
            <addressOffset>0x2e4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x01000000</resetMask>
            <fields>
              <field>
                <name>UPD_ERR</name>
                <description>Update  error
0: data receive normally
1: data receive error</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IRQ_INT_EN</name>
            <description>Interrupt Enable</description>
            <addressOffset>0x300</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF1F3FF7</resetMask>
            <fields>
              <field>
                <name>TRG_ERR3</name>
                <description>Trigger3 failed</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRG_ERR2</name>
                <description>Trigger2 failed</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRG_ERR1</name>
                <description>Trigger1 failed</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRG_ERR0</name>
                <description>Trigger0 failed</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGER3</name>
                <description>Trigger3</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGER2</name>
                <description>Trigger2</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGER1</name>
                <description>Trigger1</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGER0</name>
                <description>Trigger0</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SMP_ERR</name>
                <description>Sample error</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LATCH3</name>
                <description>Latch3</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LATCH2</name>
                <description>Latch2</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LATCH1</name>
                <description>Latch1</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LATCH0</name>
                <description>Latch0</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Timeout</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRX_ERR</name>
                <description>Transfer error</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INSTR1_END</name>
                <description>Instruction 1 end</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INSTR0_END</name>
                <description>Instruction 0 end</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PTR1_END</name>
                <description>Pointer 1 end</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PTR0_END</name>
                <description>Pointer 0 end</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INSTR1_ST</name>
                <description>Instruction 1 start</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INSTR0_ST</name>
                <description>Instruction 0 start</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PTR1_ST</name>
                <description>Pointer 1 start</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PTR0_ST</name>
                <description>Pointer 0 start</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDOG</name>
                <description>Watch dog</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EXCEPT</name>
                <description>Exception</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>Stall</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IRQ_INT_FLAG</name>
            <description>Interrupt flag</description>
            <addressOffset>0x304</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF1F3FF7</resetMask>
            <fields>
              <field>
                <name>TRG_ERR3</name>
                <description>Trigger3 failed</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TRG_ERR2</name>
                <description>Trigger2 failed</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TRG_ERR1</name>
                <description>Trigger1 failed</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TRG_ERR0</name>
                <description>Trigger0 failed</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TRIGER3</name>
                <description>Trigger3</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TRIGER2</name>
                <description>Trigger2</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TRIGER1</name>
                <description>Trigger1</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TRIGER0</name>
                <description>Trigger0</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>SMP_ERR</name>
                <description>Sample error</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>LATCH3</name>
                <description>Latch3</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>LATCH2</name>
                <description>Latch2</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>LATCH1</name>
                <description>Latch1</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>LATCH0</name>
                <description>Latch0</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Timeout</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TRX_ERR</name>
                <description>Transfer error</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>INSTR1_END</name>
                <description>Instruction 1 end</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>INSTR0_END</name>
                <description>Instruction 0 end</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>PTR1_END</name>
                <description>Pointer 1 end</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>PTR0_END</name>
                <description>Pointer 0 end</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>INSTR1_ST</name>
                <description>Instruction 1 start</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>INSTR0_ST</name>
                <description>Instruction 0 start</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>PTR1_ST</name>
                <description>Pointer 1 start</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>PTR0_ST</name>
                <description>Pointer 0 start</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>WDOG</name>
                <description>Watch dog</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>EXCEPT</name>
                <description>Exception</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>STALL</name>
                <description>Stall</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IRQ_INT_STS</name>
            <description>Interrupt status</description>
            <addressOffset>0x308</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF1F3FF7</resetMask>
            <fields>
              <field>
                <name>TRG_ERR3</name>
                <description>Trigger3 failed</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRG_ERR2</name>
                <description>Trigger2 failed</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRG_ERR1</name>
                <description>Trigger1 failed</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRG_ERR0</name>
                <description>Trigger0 failed</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRIGER3</name>
                <description>Trigger3</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRIGER2</name>
                <description>Trigger2</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRIGER1</name>
                <description>Trigger1</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRIGER0</name>
                <description>Trigger0</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SMP_ERR</name>
                <description>Sample error</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LATCH3</name>
                <description>Latch3</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LATCH2</name>
                <description>Latch2</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LATCH1</name>
                <description>Latch1</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LATCH0</name>
                <description>Latch0</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Timeout</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRX_ERR</name>
                <description>Transfer error</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INSTR1_END</name>
                <description>Instruction 1 end</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INSTR0_END</name>
                <description>Instruction 0 end</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PTR1_END</name>
                <description>Pointer 1 end</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PTR0_END</name>
                <description>Pointer 0 end</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INSTR1_ST</name>
                <description>Instruction 1 start</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INSTR0_ST</name>
                <description>Instruction 0 start</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PTR1_ST</name>
                <description>Pointer 1 start</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PTR0_ST</name>
                <description>Pointer 0 start</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WDOG</name>
                <description>Watch dog</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXCEPT</name>
                <description>Exception</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STALL</name>
                <description>Stall</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IRQ_POINTER0</name>
            <description>Match pointer 0</description>
            <addressOffset>0x310</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>POINTER</name>
                <description>Match pointer 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IRQ_POINTER1</name>
            <description>Match pointer 1</description>
            <addressOffset>0x314</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>POINTER</name>
                <description>Match pointer 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IRQ_INSTR0</name>
            <description>Match instruction 0</description>
            <addressOffset>0x318</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INSTR</name>
                <description>Match instruction 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IRQ_INSTR1</name>
            <description>Match instruction 1</description>
            <addressOffset>0x31c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INSTR</name>
                <description>Match instruction 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>256</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255</dimIndex>
          <name>INSTR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x3400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OP</name>
              <description>operation
0: halt
1: jump
2: send with timeout check
3: send without timout check
4: wait with timeout check
5: wait without timout check
6: receive with timeout check
7: receive without timout check</description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CK</name>
              <description>clock
0: low
1: rise-fall
2: fall-rise
3: high</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC</name>
              <description>CRC register
0: don't calculate CRC
1: do not set this value
2: data register 2
3: data register 3
...
29: data register 29
30: value 0 when send, wait 0 in receive
31: value1 when send,  wait 1 in receive</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAT</name>
              <description>DATA register
0: ignore data
1: command
2: data register 2
3: data register 3
...
29: data register 29
30: value 0 when send, wait 0 in receive
31: value1 when send,  wait 1 in receive</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPR</name>
              <description>[1] When OP is 0, this area is the halt time in baudrate, 0 represents infinite time.
[2] When OP is 1, this area is the the pointer to the command table.
OPR[4]=1, OPR[3:0] value is CMD_TABLE instruct pointer;
OPR[4]=0, OPR[3:0]=0 is INIT_POINTER;
OPR[4]=0, OPR[3:0]=1 is WDG_POINTER.
[3] When OP is 2-7, this area is the data length as fellow:
0: 1 bit
1: 2 bit
 ...
31: 32 bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>32</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31</dimIndex>
          <name>DAT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x3800</addressOffset>
          <register>
            <name>MODE</name>
            <description>No description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_LEN</name>
                <description>CRC length
0: 1 bit
1: 2 bit
...
31: 32 bit</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WLEN</name>
                <description>word length
0: 1 bit
1: 2 bit
...
31: 32 bit</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_SHIFT</name>
                <description>CRC shift mode, this mode is used to perform repeat code check
0: CRC
1: shift mode</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_INV</name>
                <description>CRC invert
0: use CRC
1: use inverted CRC</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WORDER</name>
                <description>word order
0: sample as bit order
1: different from bit order</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BORDER</name>
                <description>bit order
0: LSB first
1: MSB first</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SIGNED</name>
                <description>Signed
0: unsigned value
1: signed value</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REWIND</name>
                <description>Write 1 to rewind read/write pointer, this is a self clear bit</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Data mode
0: data mode
1: check mode
2: CRC mode</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IDX</name>
            <description>Data register bit index</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LAST_BIT</name>
                <description>Last bit index for tranceive</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIRST_BIT</name>
                <description>First bit index for tranceive</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MAX_BIT</name>
                <description>Highest bit index</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MIN_BIT</name>
                <description>Lowest bit index</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GOLD</name>
            <description>Gold data for data check</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GOLD_VALUE</name>
                <description>Gold value for check mode</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRCINIT</name>
            <description>CRC calculation initial vector</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_INIT</name>
                <description>CRC initial value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRCPOLY</name>
            <description>CRC calculation polynomial</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_POLY</name>
                <description>CRC polymonial</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data value</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>DATA</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Data bit set</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_SET</name>
                <description>DATA bit set</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLR</name>
            <description>Data bit clear</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_CLR</name>
                <description>DATA bit clear</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INV</name>
            <description>Data bit invert</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_INV</name>
                <description>DATA bit toggle</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IN</name>
            <description>Data input</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_IN</name>
                <description>Data input</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT</name>
            <description>Data output</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_OUT</name>
                <description>Data output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STS</name>
            <description>Data status</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_IDX</name>
                <description>CRC index</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_IDX</name>
                <description>Word index</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_CNT</name>
                <description>Word counter</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BIT_IDX</name>
                <description>Bit index</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TRGM0</name>
      <description>TRGM0</description>
      <groupName>TRGM</groupName>
      <baseAddress>0xf047c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x13c8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>64</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PWM0_IN0,PWM0_IN1,PWM0_IN2,PWM0_IN3,PWM0_IN4,PWM0_IN5,PWM0_IN6,PWM0_IN7,PWM1_IN0,PWM1_IN1,PWM1_IN2,PWM1_IN3,PWM1_IN4,PWM1_IN5,PWM1_IN6,PWM1_IN7,PWM2_IN0,PWM2_IN1,PWM2_IN2,PWM2_IN3,PWM2_IN4,PWM2_IN5,PWM2_IN6,PWM2_IN7,PWM3_IN0,PWM3_IN1,PWM3_IN2,PWM3_IN3,PWM3_IN4,PWM3_IN5,PWM3_IN6,PWM3_IN7,MOTO_GPIO_IN0,MOTO_GPIO_IN1,MOTO_GPIO_IN2,MOTO_GPIO_IN3,MOTO_GPIO_IN4,MOTO_GPIO_IN5,MOTO_GPIO_IN6,MOTO_GPIO_IN7,MOTO_GPIO_IN8,MOTO_GPIO_IN9,MOTO_GPIO_IN10,MOTO_GPIO_IN11,MOTO_GPIO_IN12,MOTO_GPIO_IN13,MOTO_GPIO_IN14,MOTO_GPIO_IN15,MOTO_GPIO_IN16,MOTO_GPIO_IN17,MOTO_GPIO_IN18,MOTO_GPIO_IN19,MOTO_GPIO_IN20,MOTO_GPIO_IN21,MOTO_GPIO_IN22,MOTO_GPIO_IN23,MOTO_GPIO_IN24,MOTO_GPIO_IN25,MOTO_GPIO_IN26,MOTO_GPIO_IN27,MOTO_GPIO_IN28,MOTO_GPIO_IN29,MOTO_GPIO_IN30,MOTO_GPIO_IN31</dimIndex>
          <name>FILTCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>OUTINV</name>
              <description>1- Filter will invert the output
0- Filter will not invert the output</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>This bitfields defines the filter mode
000-bypass;
100-rapid change mode;
101-delay filter mode;
110-stalbe low mode;
111-stable high mode</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNCEN</name>
              <description>set to enable sychronization input signal with TRGM clock</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTLEN_SHIFT</name>
              <description>No description available</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTLEN_BASE</name>
              <description>This bitfields defines the filter counter length.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>DMACFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000003F</resetMask>
          <fields>
            <field>
              <name>DMAMUX_EN</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASRCSEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GCR</name>
          <description>No description available</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGOPEN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_MATRIX_SEL0</name>
          <description>adc matrix select register0</description>
          <addressOffset>0x540</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDC1_ADC1_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDC1_ADC0_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDC0_ADC1_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDC0_ADC0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_MATRIX_SEL1</name>
          <description>adc matrix select register1</description>
          <addressOffset>0x544</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QEI3_ADC1_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEI3_ADC0_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEI2_ADC1_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEI2_ADC0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_MATRIX_SEL2</name>
          <description>adc matrix select register2</description>
          <addressOffset>0x548</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VSC1_ADC0_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSC0_ADC2_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSC0_ADC1_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSC0_ADC0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_MATRIX_SEL3</name>
          <description>adc matrix select register3</description>
          <addressOffset>0x54c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLC0_IQ_ADC_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLC0_ID_ADC_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSC1_ADC2_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSC1_ADC1_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_MATRIX_SEL4</name>
          <description>adc matrix select register2</description>
          <addressOffset>0x550</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLC1_VB_ADC_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLC1_IQ_ADC_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLC1_ID_ADC_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLC0_VB_ADC_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_MATRIX_SEL0</name>
          <description>dac matrix select register0</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACMP3_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP2_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP1_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP0_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_MATRIX_SEL1</name>
          <description>dac matrix select register1</description>
          <addressOffset>0x584</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACMP7_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP6_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP5_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP4_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_MATRIX_SEL2</name>
          <description>dac matrix select register2</description>
          <addressOffset>0x588</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0_DAC3_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_DAC2_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_DAC1_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_DAC0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_MATRIX_SEL3</name>
          <description>dac matrix select register3</description>
          <addressOffset>0x58c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM1_DAC3_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_DAC2_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_DAC1_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_DAC0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_MATRIX_SEL4</name>
          <description>dac matrix select register4</description>
          <addressOffset>0x590</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM2_DAC3_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2_DAC2_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2_DAC1_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2_DAC0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_MATRIX_SEL5</name>
          <description>dac matrix select register5</description>
          <addressOffset>0x594</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM3_DAC3_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3_DAC2_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3_DAC1_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3_DAC0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_MATRIX_SEL6</name>
          <description>dac matrix select register6</description>
          <addressOffset>0x598</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QEO1_VQ_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO1_VD_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO0_VQ_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO0_VD_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_MATRIX_SEL7</name>
          <description>dac matrix select register7</description>
          <addressOffset>0x59c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QEO3_VQ_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO3_VD_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO2_VQ_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO2_VD_DAC_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POS_MATRIX_SEL0</name>
          <description>position matrix select register0</description>
          <addressOffset>0x5c0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEI_POSIN3_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEI_POSIN2_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEI_POSIN1_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEI_POSIN0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POS_MATRIX_SEL1</name>
          <description>position matrix select register0</description>
          <addressOffset>0x5c4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QEO1_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO0_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MTG1_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MTG0_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POS_MATRIX_SEL2</name>
          <description>position matrix select register2</description>
          <addressOffset>0x5c8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VSC1_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSC0_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO3_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QEO2_POS_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,4,1,5,2,6,3,7</dimIndex>
          <name>TRGM_IN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGM_IN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>TRGM_OUT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x680</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGM_OUT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pwm_delay_cfg</name>
          <description>pwm delay chain config register</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>DELAY_CHAN_CALIB_SW</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pwm_calib_cfg</name>
          <description>pwm delay chain calibration control register</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000801F</resetMask>
          <fields>
            <field>
              <name>CALIB_SW_START</name>
              <description>No description available</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CALIB_PERIOD</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>242</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>MOT_GPIO0,MOT_GPIO1,MOT_GPIO2,MOT_GPIO3,MOT_GPIO4,MOT_GPIO5,MOT_GPIO6,MOT_GPIO7,MOT_GPIO8,MOT_GPIO9,MOT_GPIO10,MOT_GPIO11,MOT_GPIO12,MOT_GPIO13,MOT_GPIO14,MOT_GPIO15,MOT_GPIO16,MOT_GPIO17,MOT_GPIO18,MOT_GPIO19,MOT_GPIO20,MOT_GPIO21,MOT_GPIO22,MOT_GPIO23,MOT_GPIO24,MOT_GPIO25,MOT_GPIO26,MOT_GPIO27,MOT_GPIO28,MOT_GPIO29,MOT_GPIO30,MOT_GPIO31,SDM_PWM_SOC0,SDM_PWM_SOC1,SDM_PWM_SOC2,SDM_PWM_SOC3,SDM_PWM_SOC4,SDM_PWM_SOC5,SDM_PWM_SOC6,SDM_PWM_SOC7,SDM_PWM_SOC8,SDM_PWM_SOC9,SDM_PWM_SOC10,SDM_PWM_SOC11,SDM_PWM_SOC12,SDM_PWM_SOC13,SDM_PWM_SOC14,SDM_PWM_SOC15,ADC0_STRGI,ADC1_STRGI,ADC2_STRGI,ADC3_STRGI,ADCx_PTRGI0A,ADCx_PTRGI0B,ADCx_PTRGI0C,ADCx_PTRGI1A,ADCx_PTRGI1B,ADCx_PTRGI1C,ADCx_PTRGI2A,ADCx_PTRGI2B,ADCx_PTRGI2C,ADCx_PTRGI3A,ADCx_PTRGI3B,ADCx_PTRGI3C,VSC0_TRIG_IN0,VSC0_TRIG_IN1,VSC1_TRIG_IN0,VSC1_TRIG_IN1,RDC0_TRIG_IN0,RDC0_TRIG_IN1,RDC1_TRIG_IN0,RDC1_TRIG_IN1,QEI0_TRIG_IN,QEI1_TRIG_IN,QEI2_TRIG_IN,QEI3_TRIG_IN,QEI0_PAUSE,QEI1_PAUSE,QEI2_PAUSE,QEI3_PAUSE,QEO0_TRIG_IN0,QEO0_TRIG_IN1,QEO1_TRIG_IN0,QEO1_TRIG_IN1,QEO2_TRIG_IN0,QEO2_TRIG_IN1,QEO3_TRIG_IN0,QEO3_TRIG_IN1,SEI_TRIG_IN0,SEI_TRIG_IN1,SEI_TRIG_IN2,SEI_TRIG_IN3,SEI_TRIG_IN4,SEI_TRIG_IN5,SEI_TRIG_IN6,SEI_TRIG_IN7,CMP0_WIN,CMP1_WIN,CMP2_WIN,CMP3_WIN,CMP4_WIN,CMP5_WIN,CMP6_WIN,CMP7_WIN,GPTMR0_IN2,GPTMR0_IN3,GPTMR0_SYNCI,GPTMR1_IN2,GPTMR1_IN3,GPTMR1_SYNCI,GPTMR2_IN2,GPTMR2_IN3,GPTMR2_SYNCI,GPTMR3_IN2,GPTMR3_IN3,GPTMR3_SYNCI,GPTMR4_IN2,GPTMR4_IN3,GPTMR4_SYNCI,GPTMR5_IN2,GPTMR5_IN3,GPTMR5_SYNCI,GPTMR6_IN2,GPTMR6_IN3,GPTMR6_SYNCI,GPTMR7_IN2,GPTMR7_IN3,GPTMR7_SYNCI,PLB_IN_00,PLB_IN_01,PLB_IN_02,PLB_IN_03,PLB_IN_04,PLB_IN_05,PLB_IN_06,PLB_IN_07,PLB_IN_08,PLB_IN_09,PLB_IN_10,PLB_IN_11,PLB_IN_12,PLB_IN_13,PLB_IN_14,PLB_IN_15,PLB_IN_16,PLB_IN_17,PLB_IN_18,PLB_IN_19,PLB_IN_20,PLB_IN_21,PLB_IN_22,PLB_IN_23,PLB_IN_24,PLB_IN_25,PLB_IN_26,PLB_IN_27,PLB_IN_28,PLB_IN_29,PLB_IN_30,PLB_IN_31,PLB_IN_32,PLB_IN_33,PLB_IN_34,PLB_IN_35,PLB_IN_36,PLB_IN_37,PLB_IN_38,PLB_IN_39,PLB_IN_40,PLB_IN_41,PLB_IN_42,PLB_IN_43,PLB_IN_44,PLB_IN_45,PLB_IN_46,PLB_IN_47,PLB_IN_48,PLB_IN_49,PLB_IN_50,PLB_IN_51,PLB_IN_52,PLB_IN_53,PLB_IN_54,PLB_IN_55,PLB_IN_56,PLB_IN_57,PLB_IN_58,PLB_IN_59,PLB_IN_60,PLB_IN_61,PLB_IN_62,PLB_IN_63,PWM0_TRIG_IN0,PWM0_TRIG_IN1,PWM0_TRIG_IN2,PWM0_TRIG_IN3,PWM0_TRIG_IN4,PWM0_TRIG_IN5,PWM0_TRIG_IN6,PWM0_TRIG_IN7,PWM1_TRIG_IN0,PWM1_TRIG_IN1,PWM1_TRIG_IN2,PWM1_TRIG_IN3,PWM1_TRIG_IN4,PWM1_TRIG_IN5,PWM1_TRIG_IN6,PWM1_TRIG_IN7,PWM2_TRIG_IN0,PWM2_TRIG_IN1,PWM2_TRIG_IN2,PWM2_TRIG_IN3,PWM2_TRIG_IN4,PWM2_TRIG_IN5,PWM2_TRIG_IN6,PWM2_TRIG_IN7,PWM3_TRIG_IN0,PWM3_TRIG_IN1,PWM3_TRIG_IN2,PWM3_TRIG_IN3,PWM3_TRIG_IN4,PWM3_TRIG_IN5,PWM3_TRIG_IN6,PWM3_TRIG_IN7,CAN_PTPC0_CAP,CAN_PTPC1_CAP,UART_TRIG0,UART_TRIG1,SYNCTIMER_TRIG,TRGM_IRQ0,TRGM_IRQ1,TRGM_DMA0,TRGM_DMA1,MTG0_TRIG_IN0,MTG0_TRIG_IN1,MTG0_TRIG_IN2,MTG0_TRIG_IN3,MTG1_TRIG_IN0,MTG1_TRIG_IN1,MTG1_TRIG_IN2,MTG1_TRIG_IN3,ESC_TRIG_IN</dimIndex>
          <name>TRGOCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000700FF</resetMask>
          <fields>
            <field>
              <name>OUTINV</name>
              <description>1- Invert the output</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FEDG2PEN</name>
              <description>1- The selected input signal falling edge will be convert to an pulse on output.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REDG2PEN</name>
              <description>1- The selected input signal rising edge will be convert to an pulse on output.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGOSEL</name>
              <description>This bitfield selects one of the TRGM inputs as output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MTG0</name>
      <description>MTG0</description>
      <groupName>MTG</groupName>
      <baseAddress>0xf0490000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3080</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x1000</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>TRA[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>control</name>
            <description>tra&amp;index0_control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000003F</resetMask>
            <fields>
              <field>
                <name>CMD_FAIL_IRQ_EN</name>
                <description>No description available</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK_IRQ_EN</name>
                <description>No description available</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_FAIL_IRQ</name>
                <description>No description available</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>LOCK_IRQ</name>
                <description>No description available</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>SW_LOCK</name>
                <description>No description available</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OVALID_CLEAR</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>shift</name>
            <description>tra&amp;index0_shift</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xE000077F</resetMask>
            <fields>
              <field>
                <name>ACC_SHIFT_FAIL_IRQ</name>
                <description>No description available</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VEL_SHIFT_FAIL_IRQ</name>
                <description>No description available</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>SHIFT_FAIL_EN</name>
                <description>No description available</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>JER_SHIFT</name>
                <description>No description available</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACC_SHIFT</name>
                <description>No description available</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>VEL_SHIFT</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>link</name>
            <description>tra&amp;index0_link</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007777</resetMask>
            <fields>
              <field>
                <name>LINK_CFG_3</name>
                <description>No description available</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LINK_CFG_2</name>
                <description>No description available</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LINK_CFG_1</name>
                <description>No description available</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LINK_CFG_0</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>4</dim>
            <dimIncrement>0x20</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>CMD[%s]</name>
            <description>no description available</description>
            <addressOffset>0x20</addressOffset>
            <register>
              <name>control</name>
              <description>tra&amp;index0_cmd&amp;index1_control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xE000001F</resetMask>
              <fields>
                <field>
                  <name>PASS_IRQ</name>
                  <description>No description available</description>
                  <bitOffset>31</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>write-only</access>
                </field>
                <field>
                  <name>PASS_IRQ_EN</name>
                  <description>No description available</description>
                  <bitOffset>30</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MODE</name>
                  <description>No description available</description>
                  <bitOffset>29</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OBJECT</name>
                  <description>No description available</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>5</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>rev_preset</name>
              <description>tra&amp;index0_cmd&amp;index1_rev_preset</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REV_PRESET</name>
                  <description>No description available</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>pos_preset</name>
              <description>tra&amp;index0_cmd&amp;index1_pos_preset</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>POS_PRESET</name>
                  <description>No description available</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>vel_preset</name>
              <description>tra&amp;index0_cmd&amp;index1_vel_preset</description>
              <addressOffset>0xc</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>VEL_PRESET</name>
                  <description>No description available</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>acc_preset</name>
              <description>tra&amp;index0_cmd&amp;index1_acc_preset</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ACC_PRESET</name>
                  <description>No description available</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>jer_preset</name>
              <description>tra&amp;index0_cmd&amp;index1_jer_preset</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>JER_PRESET</name>
                  <description>No description available</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>timestamp</name>
              <description>tra&amp;index0_cmd&amp;index1_timestamp</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMESTAMP</name>
                  <description>No description available</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>lock_rev</name>
            <description>tra&amp;index0_lock_rev</description>
            <addressOffset>0xa0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK_REV</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>lock_pos</name>
            <description>tra&amp;index0_lock_pos</description>
            <addressOffset>0xa4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK_POS</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>lock_vel</name>
            <description>tra&amp;index0_lock_vel</description>
            <addressOffset>0xa8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK_VEL</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>lock_acc</name>
            <description>tra&amp;index0_lock_acc</description>
            <addressOffset>0xac</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK_ACC</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>lock_time</name>
            <description>tra&amp;index0_lock_time</description>
            <addressOffset>0xb0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK_TIME</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>step_limit_ctrl</name>
            <description>tra&amp;index0_step_limit_ctrl</description>
            <addressOffset>0xc0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00001F07</resetMask>
            <fields>
              <field>
                <name>POS_ONE_WAY_FORCE_MODE</name>
                <description>No description available</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POS_ONE_WAY_MODE</name>
                <description>No description available</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POS_ONE_WAY_EN</name>
                <description>No description available</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POS_STEP_MODE</name>
                <description>No description available</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POS_STEP_EN</name>
                <description>No description available</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>VEL_ONE_WAY_MODE</name>
                <description>No description available</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>VEL_ONE_WAY_EN</name>
                <description>No description available</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>VEL_STEP_EN</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>vel_step_max</name>
            <description>tra&amp;index0_vel_step_max</description>
            <addressOffset>0xc4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VEL_STEP_MAX</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>vel_step_min</name>
            <description>tra&amp;index0_vel_step_min</description>
            <addressOffset>0xc8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VEL_STEP_MIN</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>pos_step_max</name>
            <description>tra&amp;index0_pos_step_max</description>
            <addressOffset>0xcc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POS_STEP_MAX</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>pos_step_min</name>
            <description>tra&amp;index0_pos_step_min</description>
            <addressOffset>0xd0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POS_STEP_MIN</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>vel_limit_p</name>
            <description>tra&amp;index0_vel_limit_p</description>
            <addressOffset>0xd4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VEL_LIMIT_P</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>vel_limit_n</name>
            <description>tra&amp;index0_vel_limit_n</description>
            <addressOffset>0xd8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VEL_LIMIT_N</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>EVENT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2000</addressOffset>
          <register>
            <name>control</name>
            <description>event&amp;index0_control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFC00F</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>No description available</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SOURCE_MUX</name>
                <description>No description available</description>
                <bitOffset>27</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OBJECT</name>
                <description>No description available</description>
                <bitOffset>23</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>No description available</description>
                <bitOffset>19</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR</name>
                <description>No description available</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR_MODE</name>
                <description>No description available</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OVER_MODE_CMP</name>
                <description>No description available</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG_NUM</name>
                <description>No description available</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EVENT_OVER_IRQ_EN</name>
                <description>No description available</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EVENT_IRQ_EN</name>
                <description>No description available</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EVENT_OVER_IRQ</name>
                <description>No description available</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>EVENT_IRQ</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>preset_0</name>
            <description>event&amp;index0_preset_0</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESET</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>preset_1</name>
            <description>event&amp;index0_preset_1</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESET</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>preset_2</name>
            <description>event&amp;index0_preset_2</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESET</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>preset_3</name>
            <description>event&amp;index0_preset_3</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESET</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>timestamp</name>
            <description>event&amp;index0_timestamp</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMESTAMP</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>sw_event</name>
          <description>sw_event</description>
          <addressOffset>0x2080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SW_EVENT_TRIG</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sw_glb_reset</name>
          <description>sw_glb_reset</description>
          <addressOffset>0x2084</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SW_GLB_RESET</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_control</name>
          <description>filter_control</description>
          <addressOffset>0x3000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xE0FA3F7F</resetMask>
          <fields>
            <field>
              <name>MUL_ERR_IRQ_0</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MUL_ERR_IRQ_1</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MUL_ERR_IRQ_EN</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_BYPASS_STATUS</name>
              <description>No description available</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_BYPASS_F_I_EN</name>
              <description>No description available</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_BYPASS_I_F_EN</name>
              <description>No description available</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_LOCK</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_EN</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REV_INI_MODE</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TIME1</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TIME0</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_TIME1</name>
              <description>No description available</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_TIME0</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>A_EN</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_INI</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_BYPASS_EN</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FF_MODE</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FF_EN</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_EN</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_rev_value</name>
          <description>filter_rev_value</description>
          <addressOffset>0x3010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_pos_value</name>
          <description>filter_pos_value</description>
          <addressOffset>0x3014</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_vel_value</name>
          <description>filter_vel_value</description>
          <addressOffset>0x3018</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_acc_value</name>
          <description>filter_acc_value</description>
          <addressOffset>0x301c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_mot_sel</name>
          <description>filter_mot_sel</description>
          <addressOffset>0x3020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3F3F3F</resetMask>
          <fields>
            <field>
              <name>OUTPUT_VEL_SEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_ACC_SEL</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_VEL_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_ACC_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_stage_sel</name>
          <description>filter_stage_sel</description>
          <addressOffset>0x3024</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>STAGE5_SEL</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE4_SEL</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE3_SEL</name>
              <description>No description available</description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE2_SEL</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE1_SEL</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE0_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_time_constant_tp</name>
          <description>filter_time_constant_tp</description>
          <addressOffset>0x3028</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>TP</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_time_constant_tz</name>
          <description>filter_time_constant_tz</description>
          <addressOffset>0x302c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>TZ</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_time_constant_tz_1</name>
          <description>filter_time_constant_tz_1</description>
          <addressOffset>0x3030</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>TZ_1</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_zero_tz_sel</name>
          <description>filter_zero_tz_sel</description>
          <addressOffset>0x3034</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>STAGE5</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE4</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE3</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE2</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE1</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_gain</name>
          <description>filter_gain</description>
          <addressOffset>0x3038</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0FFFFFF</resetMask>
          <fields>
            <field>
              <name>GAIN_T0_EN</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN_T1_EN</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>K</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_stage_shift0</name>
          <description>filter_stage_shift0</description>
          <addressOffset>0x303c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STAGE3_SHIFT1</name>
              <description>No description available</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE3_SHIFT0</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE2_SHIFT1</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE2_SHIFT0</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE1_SHIFT1</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE1_SHIFT0</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE0_SHIFT1</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE0_SHIFT0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_stage_shift1</name>
          <description>filter_stage_shift1</description>
          <addressOffset>0x3040</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>STAGE5_SHIFT1</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE5_SHIFT0</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE4_SHIFT1</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STAGE4_SHIFT0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_param_shift</name>
          <description>filter_param_shift</description>
          <addressOffset>0x3044</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACC_SHIFT_PARAM</name>
              <description>No description available</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VEL_SHIFT_PARAM</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN_K_SHIFT</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN_T0_SHIFT</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN_T1_SHIFT</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TP_SHIFT</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TZ_1_SHIFT</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TZ_SHIFT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_time_shift</name>
          <description>filter_time_shift</description>
          <addressOffset>0x3048</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ACC_SHIFT_TIME1</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VEL_SHIFT_TIME1</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACC_SHIFT_TIME0</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VEL_SHIFT_TIME0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_ff_shift</name>
          <description>filter_ff_shift</description>
          <addressOffset>0x304c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>OUTPUT_ACC_SHIFT</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_ACC_SHIFT</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_VEL_SHIFT</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_VEL_SHIFT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_time1_sw_adjust</name>
          <description>filter_time1_sw_adjust</description>
          <addressOffset>0x3050</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_time0_sw_adjust</name>
          <description>filter_time0_sw_adjust</description>
          <addressOffset>0x3054</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_error_limit_l</name>
          <description>filter_error_limit</description>
          <addressOffset>0x3060</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERROR_LIMIT_L</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_error_limit_h</name>
          <description>filter_error_limit</description>
          <addressOffset>0x3064</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERROR_LIMIT_H</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_timeout_cnt</name>
          <description>filter_timeout_cnt</description>
          <addressOffset>0x306c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT_CNT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_rev_lock</name>
          <description>filter_rev_lock</description>
          <addressOffset>0x3070</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REV_STATUS</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_pos_lock</name>
          <description>filter_pos_lock</description>
          <addressOffset>0x3074</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POS_STATUS</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_vel_lock</name>
          <description>filter_vel_lock</description>
          <addressOffset>0x3078</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VEL_STATUS</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>filter_acc_lock</name>
          <description>filter_acc_lock</description>
          <addressOffset>0x307c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACC_STATUS</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MTG0">
      <name>MTG1</name>
      <description>MTG1</description>
      <groupName>MTG</groupName>
      <baseAddress>0xf0494000</baseAddress>
    </peripheral>
    <peripheral>
      <name>VSC0</name>
      <description>VSC0</description>
      <groupName>VSC</groupName>
      <baseAddress>0xf04a0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x128</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>abc_mode</name>
          <description>abc mode</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8FFF3338</resetMask>
          <fields>
            <field>
              <name>PHASE_ABSENT_MODE</name>
              <description>whether using value_a and value_b instead of three phase</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_C_WIDTH</name>
              <description>numbers of value_c for each convert</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_B_WIDTH</name>
              <description>numbers of value_b for each convert</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_A_WIDTH</name>
              <description>numbers of value_a for each convert</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_C_LOC</name>
              <description>the adc index of value_c:
2'b:00: resevered;
2'b:01: from adc0;
2'b:10: from adc1;
2'b:11: from adc2;</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_B_LOC</name>
              <description>the adc index of value_b:
2'b:00: resevered;
2'b:01: from adc0;
2'b:10: from adc1;
2'b:11: from adc2;</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_A_LOC</name>
              <description>the adc index of value_a:
2'b:00: resevered;
2'b:01: from adc0;
2'b:10: from adc1;
2'b:11: from adc2;</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_VSC</name>
              <description>enable vsc convert:
0: disable vsc convert
1: enable vsc convert</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc_chan_assign</name>
          <description>assign adc_chan for value_a/b/c</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001F1F1F</resetMask>
          <fields>
            <field>
              <name>VALUE_C_CHAN</name>
              <description>value_c's adc chan</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_B_CHAN</name>
              <description>value_b's adc chan</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_A_CHAN</name>
              <description>value_a's adc chan</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_a_data_opt</name>
          <description>value_a data operation mode</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>OPT_3</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_2</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_1</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_0</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_b_data_opt</name>
          <description>value_b data operation mode</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>OPT_3</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_2</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_1</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_0</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_c_data_opt</name>
          <description>value_c data operation mode</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>OPT_3</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_2</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_1</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_0</name>
              <description>0: PLUS_MUL_1
1: PLUS_MUL_2
5: PLUS_DIV_2
6: PLUS_DIV_3
7: PLUS_DIV_4
8: MINUS MUL 1
9: MINUS MUL 2
13: MINUS DIV 2
14: MINUS DIV 3
15: MINUS DIV 4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_a_offset</name>
          <description>value_a offset</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_A_OFFSET</name>
              <description>value_a offset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_b_offset</name>
          <description>value_b_offset</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_B_OFFSET</name>
              <description>value_b_offset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_c_offset</name>
          <description>value_c offset</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_C_OFFSET</name>
              <description>value_c offset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_status</name>
          <description>irq status</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_STATUS</name>
              <description>irq status bit:
bit0: vsc convert done irq.
bit1: in adc three-phase mode, if ABS(value_a+value_b+value_c) &gt; adc_phase_tolerate, will trigger irq.
bit2: value_c overflow during capture process.
bit3: value_b_overflow during capture process.
bit4: value_a_overflow during capture process.
bit5: adc2 chan not capture enough adc value.
bit6: adc1 chan not capture enough adc value.
bit7: adc0 chan not capture enough adc value.
bit8: position not got valid before pos_wait_cycle timeout.
bit9: adc2 wait cycle timeout.
bit10: adc1 wait cycle timeout.
bit11: adc0 wait cycle timeout.
bit12: trigger_in break vsc convert even if adc or position is ready.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_a_sw</name>
          <description>value_a software inject value</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_A_SW</name>
              <description>value_a_sw</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_b_sw</name>
          <description>value_b software inject value</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_B_SW</name>
              <description>value_b_sw</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_c_sw</name>
          <description>value_c software inject value</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE_C_SW</name>
              <description>value_c_sw</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>value_sw_ready</name>
          <description>software inject value_a/value_b/value_c ready</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>VALUE_SW_READY</name>
              <description>software inject value_a/value_b/value_c ready</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trigger_sw</name>
          <description>software trigger event</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>TRIGGER_SW</name>
              <description>software trigger to start waiting adc capture value, same as hardwire trigger_in</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>timelock</name>
          <description>timestamp mode and postion capture ctrl</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000303F</resetMask>
          <fields>
            <field>
              <name>POSITION_CAPTURE_MODE</name>
              <description>postion capture mode:
00: position use last valid data when adc value capture finish
01: position use frist valid data after adc value capture
10: position use last valid data before adc value capture
other: reserved</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_TIMESTAMP_SEL</name>
              <description>adc timestamp select：
0：reserved;
1: from value_a;
2: from value_b;
3: from value_c;</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE_COUNTER_SEL</name>
              <description>adc timestamp use which number index of adc_timestamp_sel used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>position_sw</name>
          <description>position software inject value</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POSITION_SW</name>
              <description>position_sw</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc_wait_cycle</name>
          <description>adc wait cycle after trigger adc capture event</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_WAIT_CYCLE</name>
              <description>adc wait cycle after trigger adc capture event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pos_wait_cycle</name>
          <description>pos wait cycle after trigger adc capture event</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POS_WAIT_CYCLE</name>
              <description>position wait cycle after trigger adc capture event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_enable</name>
          <description>irq bit enable</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_ENABLE</name>
              <description>irq enable bit:
bit0: vsc convert done irq.
bit1: in adc three-phase mode, if ABS(value_a+value_b+value_c) &gt; adc_phase_tolerate, will trigger irq.
bit2: value_c overflow during capture process.
bit3: value_b_overflow during capture process.
bit4: value_a_overflow during capture process.
bit5: adc2 chan not capture enough adc value.
bit6: adc1 chan not capture enough adc value.
bit7: adc0 chan not capture enough adc value.
bit8: position not got valid before pos_wait_cycle timeout.
bit9: adc2 wait cycle timeout.
bit10: adc1 wait cycle timeout.
bit11: adc0 wait cycle timeout.
bit12: trigger_in break vsc convert even if adc or position is ready.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc_phase_tolerate</name>
          <description>adc phase tolerate</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_PHASE_TOLERATE</name>
              <description>in adc three-phase mode, if ABS(value_a+value_b+value_c) &gt; adc_phase_tolerate, will trigger irq.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pos_pole</name>
          <description>position pole num</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>POS_POLE</name>
              <description>pole number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>id_posedge</name>
          <description>posedge order Id value</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID_POSEDGE</name>
              <description>posedge order Id value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>iq_posedge</name>
          <description>posedge order Iq value</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IQ_POSEDGE</name>
              <description>posedge order Iq value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>id_negedge</name>
          <description>negedge order Id value</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID_NEGEDGE</name>
              <description>negedge order Id value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>iq_negedge</name>
          <description>negedge order Iq value</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IQ_NEGEDGE</name>
              <description>negedge order Iq value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>alpha_posedge</name>
          <description>posedge order alpha value</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALPHA_POSEDGE</name>
              <description>posedge order alpha value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>beta_posedge</name>
          <description>posedge order beta value</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BETA_POSEDGE</name>
              <description>posedge order beta value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>alpha_negedge</name>
          <description>negedge order alpha value</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALPHA_NEGEDGE</name>
              <description>negedge order alpha value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>beta_negedge</name>
          <description>negedge order beta value</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BETA_NEGEDGE</name>
              <description>negedge order beta value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>timestamp_locked</name>
          <description>timestamp_locked</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMESTAMP_LOCKED</name>
              <description>timestamp_locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>debug_status0</name>
          <description>debug_status0</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>VALUE_A_COUNTER</name>
              <description>value_a_counter</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VALUE_B_COUNTER</name>
              <description>value_b_counter</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VALUE_C_COUNTER</name>
              <description>value_c_counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="VSC0">
      <name>VSC1</name>
      <description>VSC1</description>
      <groupName>VSC</groupName>
      <baseAddress>0xf04a4000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CLC0</name>
      <description>CLC0</description>
      <groupName>CLC</groupName>
      <baseAddress>0xf04b0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x204</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x100</dimIncrement>
          <dimIndex>vd,vq</dimIndex>
          <name>VDVQ_CHAN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>mode</name>
            <description>&amp;index0 mode ctrl</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x810107FF</resetMask>
            <fields>
              <field>
                <name>ENABLE_CLC</name>
                <description>enable CLC</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MASK_MODE</name>
                <description>open mode: CLC keep working even if bad irq status ocurred</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ_MODE</name>
                <description>dq mode</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_IRQ</name>
                <description>enable irq:
irq_data_in_forbid     , // 10
irq_forb_err_boundary  , // 9
irq_p3z3_over_lo       , // 8
irq_p3z3_over_hi       , // 7
irq_p3z3_err_boundary  , // 6
irq_z2_over_sf         , // 5
irq_z2_over_lo         , // 4
irq_z2_over_hi         , // 3
irq_z2_err_boundary    , // 2
irq_coef_err_boundary  , // 1
irq_valid_clc            // 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>adc_expect</name>
            <description>&amp;index0 adc expect</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADC_EXPECT</name>
                <description>adc expect value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>adc_chan</name>
            <description>&amp;index0 adc used channel</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000001F</resetMask>
            <fields>
              <field>
                <name>ADC_CHAN</name>
                <description>adc used chan ID</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>adc_offset</name>
            <description>&amp;index0 adc used offset</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADC_OFFSET</name>
                <description>adc used offset</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>eadc_lowth</name>
            <description>&amp;index0 eadc_lowth value used in error adc cofficient selection</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EADC_LOWTH</name>
                <description>if error adc not bigger than eadc_lowth or not less than eadc_highth, use zone 2 cofficient；if not less than midlowth and not bigger than midhighth, use zone 0 cofficient；otherwire, use zone 1 cofficient</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>eadc_highth</name>
            <description>&amp;index0 eadc_highth value used in error adc cofficient selection</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EADC_HIGHTH</name>
                <description>if error adc not bigger than eadc_lowth or not less than eadc_highth, use zone 2 cofficient；if not less than midlowth and not bigger than midhighth, use zone 0 cofficient；otherwire, use zone 1 cofficient</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>eadc_midlowth</name>
            <description>&amp;index0 eadc_midlowth value used in error adc cofficient selection</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EADC_MIDLOWTH</name>
                <description>if error adc not bigger than eadc_lowth or not less than eadc_highth, use zone 2 cofficient；if not less than midlowth and not bigger than midhighth, use zone 0 cofficient；otherwire, use zone 1 cofficient</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>eadc_midhighth</name>
            <description>&amp;index0 eadc_midhighth value used in error adc cofficient selection</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EADC_MIDHIGHTH</name>
                <description>if error adc not bigger than eadc_lowth or not less than eadc_highth, use zone 2 cofficient；if not less than midlowth and not bigger than midhighth, use zone 0 cofficient；otherwire, use zone 1 cofficient</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p2z2_clamp_lo</name>
            <description>&amp;index0 2p2z output clamp low threshold</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>2P2Z_CLAMP_LO</name>
                <description>2p2z output clamp low threshold</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p2z2_clamp_hi</name>
            <description>&amp;index0 2p2z output clamp high threshold</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>2P2Z_CLAMP_HI</name>
                <description>2p2z output clamp high threshold</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p3z3_clamp_lo</name>
            <description>&amp;index0 3p3z output clamp low threshold</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>3P3Z_CLAMP_LO</name>
                <description>3p3z output clamp low threshold</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p3z3_clamp_hi</name>
            <description>&amp;index0 3p3z output clamp high threshold</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>3P3Z_CLAMP_HI</name>
                <description>3p3z output clamp high threshold</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>3</dim>
            <dimIncrement>0x20</dimIncrement>
            <dimIndex>0,1,2</dimIndex>
            <name>COEFF[%s]</name>
            <description>no description available</description>
            <addressOffset>0x40</addressOffset>
            <register>
              <name>coeff_b0</name>
              <description>&amp;index0 zone &amp;index1 b0</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COEFF_B0</name>
                  <description>coefficient b0</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>coeff_b1</name>
              <description>&amp;index0 zone &amp;index1 b1</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COEFF_B1</name>
                  <description>coefficient b1</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>coeff_b2</name>
              <description>&amp;index0 zone &amp;index1 b2</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COEFF_B2</name>
                  <description>coefficient b2</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>coeff_b3</name>
              <description>&amp;index0 zone &amp;index1 b3</description>
              <addressOffset>0xc</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COEFF_B3</name>
                  <description>coefficient b3</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>coeff_a0</name>
              <description>&amp;index0 zone &amp;index1 a0</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COEFF_A0</name>
                  <description>coefficient a0</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>coeff_a1</name>
              <description>&amp;index0 zone &amp;index1 a1</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COEFF_A1</name>
                  <description>coefficient a1</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>coeff_a2</name>
              <description>&amp;index0 zone &amp;index1 a2</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COEFF_A2</name>
                  <description>coefficient a2</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>coeff_ks</name>
              <description>&amp;index0 zone &amp;index1 kscaling</description>
              <addressOffset>0x1c</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x0000001F</resetMask>
              <fields>
                <field>
                  <name>COEFF_KSCALING</name>
                  <description>coefficient kscaling</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>5</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>pwm_period</name>
            <description>&amp;index0 pwm_period</description>
            <addressOffset>0xa0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PWM_PERIOD</name>
                <description>pwm_period</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>output_value</name>
            <description>&amp;index0 output value</description>
            <addressOffset>0xa4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT_VALUE</name>
                <description>output_value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>timestamp</name>
            <description>&amp;index0 adc timestamp used</description>
            <addressOffset>0xa8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMESTAMP</name>
                <description>timestamp</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>eadc_curr</name>
            <description>&amp;index0 error adc latest value</description>
            <addressOffset>0xac</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EADC_CURR</name>
                <description>error adc latest value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>eadc_pre0</name>
            <description>&amp;index0 error adc previous0 value</description>
            <addressOffset>0xb0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EADC_PRE0</name>
                <description>error adc previous 0 value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>eadc_pre1</name>
            <description>&amp;index0 error adc previous1 value</description>
            <addressOffset>0xb4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EADC_PRE1</name>
                <description>error adc previous 1 value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p2z2_curr</name>
            <description>&amp;index0 2p2z latest value</description>
            <addressOffset>0xb8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>2P2Z_CURR</name>
                <description>2p2z latest value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p2z2_pre0</name>
            <description>&amp;index0 2p2z previous0 value</description>
            <addressOffset>0xbc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>2P2Z_PRE0</name>
                <description>2p2z previous 0 value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p3z3_curr</name>
            <description>&amp;index0 3p3z latest value</description>
            <addressOffset>0xc4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>3P3Z_CURR</name>
                <description>3p3z latest value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p3z3_forbid_lo</name>
            <description>&amp;index0 3p3z output forbid low threshold</description>
            <addressOffset>0xcc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>3P3Z_FORBID_LO</name>
                <description>3p3z output forbid low threshold</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p3z3_forbid_md</name>
            <description>&amp;index0 3p3z output forbid middle threshold</description>
            <addressOffset>0xd0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>3P3Z_FORBID_MD</name>
                <description>3p3z output forbid middle threshold</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>p3z3_forbid_hi</name>
            <description>&amp;index0 3p3z output forbid high threshold</description>
            <addressOffset>0xd4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>3P3Z_FORBID_HI</name>
                <description>3p3z output forbid high threshold</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>adc_sw</name>
            <description>&amp;index0 adc software inject value</description>
            <addressOffset>0xe0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADC_SW</name>
                <description>adc software inject value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>status</name>
            <description>&amp;index0 irq_status</description>
            <addressOffset>0xfc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000007FF</resetMask>
            <fields>
              <field>
                <name>STATUS</name>
                <description>status, write 1 to clear it. :
irq_data_in_forbid     , // 10
irq_forb_err_boundary  , // 9
irq_p3z3_over_lo       , // 8
irq_p3z3_over_hi       , // 7
irq_p3z3_err_boundary  , // 6
irq_z2_over_sf         , // 5
irq_z2_over_lo         , // 4
irq_z2_over_hi         , // 3
irq_z2_err_boundary    , // 2
irq_coef_err_boundary  , // 1
irq_valid_clc            // 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>11</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>dq_adc_sw_ready</name>
          <description>enable d/q chan software inject adc value</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>DQ_ADC_SW_READY</name>
              <description>enable d/q chan software inject adc value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CLC0">
      <name>CLC1</name>
      <description>CLC1</description>
      <groupName>CLC</groupName>
      <baseAddress>0xf04b4000</baseAddress>
    </peripheral>
    <peripheral>
      <name>ENET0</name>
      <description>ENET0</description>
      <groupName>ENET</groupName>
      <baseAddress>0xf1400000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3028</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MACCFG</name>
          <description>MAC Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>SARC</name>
              <description>Source Address Insertion or Replacement Control
 This field controls the source address insertion or replacement for all transmitted frames.
Bit 30 specifies which MAC Address register (0 or 1) is used for source address insertion or replacement based on the values of Bits [29:28]:
- 2'b0x: The input signals mti_sa_ctrl_i and ati_sa_ctrl_i control the SA field generation.
- 2'b10: - If Bit 30 is set to 0, the MAC inserts the content of the MAC Address 0 registers (registers 16 and 17) in the SA field of all transmitted frames.
             - If Bit 30 is set to 1 and the Enable MAC Address Register 1 option is selected during core configuration,
                the MAC inserts the content of the MAC Address 1 registers (registers 18 and 19) in the SA field of all transmitted frames.
- 2'b11: - If Bit 30 is set to 0, the MAC replaces the content of the MAC Address 0 registers (registers 16 and 17) in the SA field of all transmitted frames.
             - If Bit 30 is set to 1 and the Enable MAC Address Register 1 option is selected during core configuration,
                the MAC replaces the content of the MAC Address 1 registers (registers 18 and 19) in the SA field of all transmitted frames.
Note: - Changes to this field take effect only on the start of a frame.
If you write this register field when a frame is being transmitted, only the subsequent frame can use the updated value,
that is, the current frame does not use the updated value.
- These bits are reserved and RO when the Enable SA, VLAN, and CRC Insertion on TX feature is not selected during core configuration.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOKPE</name>
              <description>IEEE 802.3as Support for 2K Packets
 When set, the MAC considers all frames, with up to 2,000 bytes length, as normal packets.
When Bit 20 (JE) is not set, the MAC considers all received frames of size more than 2K bytes as Giant frames.
When this bit is reset and Bit 20 (JE) is not set, the MAC considers all received frames of size more than 1,518 bytes (1,522 bytes for tagged) as Giant frames.
When Bit 20 is set, setting this bit has no effect on Giant Frame status.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SFTERR</name>
              <description>SMII Force Transmit Error
 When set, this bit indicates to the PHY to force a transmit error in the SMII frame being transmitted. This bit is reserved if the SMII PHY port is not selected during core configuration.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CST</name>
              <description>CRC Stripping for Type Frames
 When this bit is set, the last 4 bytes (FCS) of all frames of Ether type (Length/Type field greater than or equal to 1,536) are stripped and dropped before forwarding the frame to the application.
This function is not valid when the IP Checksum Engine (Type 1) is enabled in the MAC receiver. This function is valid when Type 2 Checksum Offload Engine is enabled.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TC</name>
              <description>Transmit Configuration in RGMII, SGMII, or SMII
 When set, this bit enables the transmission of duplex mode, link speed, and link up or down information to the PHY in the RGMII, SMII,
 or SGMII port. When this bit is reset, no such information is driven to the PHY.
This bit is reserved (and RO) if the RGMII, SMII, or SGMII PHY port is not selected during core configuration.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WD</name>
              <description>Watchdog Disable
 When this bit is set, the MAC disables the watchdog timer on the receiver. The MAC can receive frames of up to 16,383 bytes.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JD</name>
              <description>Jabber Disable
 When this bit is set, the MAC disables the jabber timer on the transmitter. The MAC can transfer frames of up to 16,383 bytes.
When this bit is reset, the MAC cuts off the transmitter if the application sends out more than 2,048 bytes of data (10,240 if JE is set high) during transmission.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BE</name>
              <description>Frame Burst Enable
 When this bit is set, the MAC allows frame bursting during transmission in the GMII half-duplex mode. This bit is reserved (and RO) in the 10/100 Mbps only or full-duplex-only configurations.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JE</name>
              <description>Jumbo Frame Enable
 When this bit is set, the MAC allows Jumbo frames of 9,018 bytes (9,022 bytes for VLAN tagged frames) without reporting a giant frame error in the receive frame status.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IFG</name>
              <description>Inter-Frame Gap
 These bits control the minimum IFG between frames during transmission.
- 000: 96 bit times
- 001: 88 bit times
- 010: 80 bit times - ...
- 111: 40 bit times In the half-duplex mode, the minimum IFG can be configured only for 64 bit times (IFG = 100).
Lower values are not considered.
In the 1000-Mbps mode, the minimum IFG supported is 64 bit times (and above) in the GMAC-CORE configuration and 80 bit times (and above) in other configurations.
 When a JAM pattern is being transmitted because of backpressure activation, the MAC does not consider the minimum IFG.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRS</name>
              <description>Disable Carrier Sense During Transmission
 When set high, this bit makes the MAC transmitter ignore the (G)MII CRS signal during frame transmission in the half-duplex mode.
 This request results in no errors generated because of Loss of Carrier or No Carrier during such transmission.
When this bit is low, the MAC transmitter generates such errors because of Carrier Sense and can even abort the transmissions.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PS</name>
              <description>Port Select
 This bit selects the Ethernet line speed.
- 0: For 1000 Mbps operations
- 1: For 10 or 100 Mbps operations In 10 or 100 Mbps operations, this bit, along with FES bit, selects the exact line speed.
In the 10/100 Mbps-only (always 1) or 1000 Mbps-only (always 0) configurations, this bit is read-only with the appropriate value. In default 10/100/1000 Mbps configuration,
this bit is R_W. The mac_portselect_o or mac_speed_o[1] signal reflects the value of this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FES</name>
              <description>Speed
 This bit selects the speed in the MII, RMII, SMII, RGMII, SGMII, or RevMII interface:
- 0: 10 Mbps
- 1: 100 Mbps This bit is reserved (RO) by default and is enabled only when the parameter SPEED_SELECT = Enabled.
This bit generates link speed encoding when Bit 24 (TC) is set in the RGMII, SMII, or SGMII mode.
This bit is always enabled for RGMII, SGMII, SMII, or RevMII interface.
In configurations with RGMII, SGMII, SMII, or RevMII interface, this bit is driven as an output signal (mac_speed_o[0]) to reflect the value of this bit in the mac_speed_o signal.
In configurations with RMII, MII, or GMII interface, you can optionally drive this bit as an output signal (mac_speed_o[0]) to reflect its value in the mac_speed_o signal.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DO</name>
              <description>Disable Receive Own
 When this bit is set, the MAC disables the reception of frames when the phy_txen_o is asserted in the half-duplex mode.
When this bit is reset, the MAC receives all packets that are given by the PHY while transmitting.
This bit is not applicable if the MAC is operating in the full-duplex mode. This bit is reserved (RO with default value) if the MAC is configured for the full-duplex-only operation.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LM</name>
              <description>Loopback Mode
 When this bit is set, the MAC operates in the loopback mode at GMII or MII.
The (G)MII Receive clock input (clk_rx_i) is required for the loopback to work properly, because the Transmit clock is not looped-back internally.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DM</name>
              <description>Duplex Mode
 When this bit is set, the MAC operates in the full-duplex mode where it can transmit and receive simultaneously.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPC</name>
              <description>Checksum Offload
When this bit is set, the MAC calculates the 16-bit one’s complement of the one’s complement sum of all received Ethernet frame payloads.
It also checks whether the IPv4 Header checksum (assumed to be bytes 25–26 or 29–30 (VLAN-tagged)
of the received Ethernet frame) is correct for the received frame and gives the status in the receive status word.
The MAC also appends the 16-bit checksum calculated for the IP header datagram payload (bytes after the IPv4 header)
and appends it to the Ethernet frame transferred to the application (when Type 2 COE is deselected).
When this bit is reset, this function is disabled.
When Type 2 COE is selected, this bit, when set, enables the IPv4 header checksum checking and IPv4 or IPv6 TCP, UDP, or ICMP payload checksum checking.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DR</name>
              <description>Disable Retry
When this bit is set, the MAC attempts only one transmission.
When a collision occurs on the GMII or MII interface,
the MAC ignores the current frame transmission and reports a Frame Abort with excessive collision error in the transmit frame status.
When this bit is reset, the MAC attempts retries based on the settings of the BL field (Bits [6:5]).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LUD</name>
              <description>Link Up or Down
 This bit indicates whether the link is up or down during the transmission of configuration in the RGMII, SGMII, or SMII interface:
- 0: Link Down
- 1: Link Up</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACS</name>
              <description>Automatic Pad or CRC Stripping
 When this bit is set, the MAC strips the Pad or FCS field on the incoming frames only if the value of the length field is less than 1,536 bytes.
All received frames with length field greater than or equal to 1,536 bytes are passed to the application without stripping the Pad or FCS field.
When this bit is reset, the MAC passes all incoming frames, without modifying them, to the Host.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BL</name>
              <description>Back-Off Limit
 The Back-Off limit determines the random integer number (r) of slot time delays
 (4,096 bit times for 1000 Mbps and 512 bit times for 10/100 Mbps) for which the MAC waits before rescheduling a transmission attempt during retries after a collision.
This bit is applicable only in the half-duplex mode and is reserved (RO) in the full-duplex-only configuration.
- 00: k= min (n, 10)
- 01: k = min (n, 8)
- 10: k = min (n, 4)
- 11: k = min (n, 1) where n = retransmission attempt. The random integer r takes the value in the range 0 ≤ r &lt; 2k</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC</name>
              <description>Deferral Check
 When this bit is set, the deferral check function is enabled in the MAC.
The MAC issues a Frame Abort status, along with the excessive deferral error bit set in the transmit frame status,
when the transmit state machine is deferred for more than 24,288 bit times in the 10 or 100 Mbps mode.
 If the MAC is configured for 1000 Mbps operation or if the Jumbo frame mode is enabled in the 10 or 100 Mbps mode,
 the threshold for deferral is 155,680 bits times. Deferral begins when the transmitter is ready to transmit,
but it is prevented because of an active carrier sense signal (CRS) on GMII or MII. The defer time is not cumulative.
For example, if the transmitter defers for 10,000 bit times because the CRS signal is active and then the CRS signal becomes inactive,
the transmitter transmits and collision happens.
Because of collision, the transmitter needs to back off and then defer again after back off completion.
In such a scenario, the deferral timer is reset to 0 and it is restarted.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter Enable
 When this bit is set, the transmit state machine of the MAC is enabled for transmission on the GMII or MII. When this bit is reset,
 the MAC transmit state machine is disabled after the completion of the transmission of the current frame, and does not transmit any further frames.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver Enable
 When this bit is set, the receiver state machine of the MAC is enabled for receiving frames from the GMII or MII. When this bit is reset,
the MAC receive state machine is disabled after the completion of the reception of the current frame, and does not receive any further frames from the GMII or MII.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRELEN</name>
              <description>Preamble Length for Transmit frames
 These bits control the number of preamble bytes that are added to the beginning of every Transmit frame.
 The preamble reduction occurs only when the MAC is operating in the full-duplex mode.
- 2'b00: 7 bytes of preamble
- 2'b01: 5 bytes of preamble
- 2'b10: 3 bytes of preamble
- 2'b11: Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MACFF</name>
          <description>MAC Frame Filter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x803087FF</resetMask>
          <fields>
            <field>
              <name>RA</name>
              <description>Receive All
 When this bit is set, the MAC Receiver module passes all received frames, irrespective of whether they pass the address filter or not, to the Application.
The result of the SA or DA filtering is updated (pass or fail) in the corresponding bits in the Receive Status Word. When this bit is reset,
the Receiver module passes only those frames to the Application that pass the SA or DA address filter.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DNTU</name>
              <description>Drop non-TCP/UDP over IP Frames
 When set, this bit enables the MAC to drop the non-TCP or UDP over IP frames. The MAC forward only those frames that are processed by the Layer 4 filter.
When reset, this bit enables the MAC to forward all non-TCP or UDP over IP frames.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPFE</name>
              <description>Layer 3 and Layer 4 Filter Enable
 When set, this bit enables the MAC to drop frames that do not match the enabled Layer 3 and Layer 4 filters. If Layer 3 or Layer 4 filters are not enabled for matching,
this bit does not have any effect. When reset, the MAC forwards all frames irrespective of the match status of the Layer 3 and Layer 4 fields.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VTFE</name>
              <description>VLAN Tag Filter Enable
 When set, this bit enables the MAC to drop VLAN tagged frames that do not match the VLAN Tag comparison.
When reset, the MAC forwards all frames irrespective of the match status of the VLAN Tag.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPF</name>
              <description>Hash or Perfect Filter
 When this bit is set, it configures the address filter to pass a frame if it matches either the perfect filtering or the hash filtering as set by the HMC or HUC bits.
When this bit is low and the HUC or HMC bit is set, the frame is passed only if it matches the Hash filter.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAF</name>
              <description>Source Address Filter Enable
 When this bit is set, the MAC compares the SA field of the received frames with the values programmed in the enabled SA registers. If the comparison fails,
 the MAC drops the frame. When this bit is reset, the MAC forwards the received frame to the application with updated SAF bit of the Rx Status depending on the SA address comparison.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAIF</name>
              <description>SA Inverse Filtering
When this bit is set, the Address Check block operates in inverse filtering mode for the SA address comparison. The frames whose SA matches the SA registers are marked as failing the SA Address filter.
When this bit is reset, frames whose SA does not match the SA registers are marked as failing the SA Address filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCF</name>
              <description>Pass Control Frames
 These bits control the forwarding of all control frames (including unicast and multicast Pause frames).
- 00: MAC filters all control frames from reaching the application.
- 01: MAC forwards all control frames except Pause frames to application even if they fail the Address filter.
- 10: MAC forwards all control frames to application even if they fail the Address Filter.
- 11: MAC forwards control frames that pass the Address Filter.
The following conditions should be true for the Pause frames processing:
- Condition 1: The MAC is in the full-duplex mode and flow control is enabled by setting Bit 2 (RFE) of Register 6 (Flow Control Register) to 1.
- Condition 2: The destination address (DA) of the received frame matches the special multicast address or the MAC Address 0 when Bit 3 (UP) of the Register 6 (Flow Control Register) is set.
- Condition 3: The Type field of the received frame is 0x8808 and the OPCODE field is 0x0001.
Note: This field should be set to 01 only when the Condition 1 is true,
that is, the MAC is programmed to operate in the full-duplex mode and the RFE bit is enabled.
Otherwise, the Pause frame filtering may be inconsistent.
When Condition 1 is false, the Pause frames are considered as generic control frames.
Therefore, to pass all control frames (including Pause frames) when the full-duplex mode and flow control is not enabled,
you should set the PCF field to 10 or 11 (as required by the application).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBF</name>
              <description>Disable Broadcast Frames
 When this bit is set, the AFM module blocks all incoming broadcast frames. In addition, it overrides all other filter settings.
When this bit is reset, the AFM module passes all received broadcast frames.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PM</name>
              <description>Pass All Multicast
When set, this bit indicates that all received frames with a multicast destination address (first bit in the destination address field is '1') are passed.
When reset, filtering of multicast frame depends on HMC bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAIF</name>
              <description>DA Inverse Filtering
 When this bit is set, the Address Check block operates in inverse filtering mode for the DA address comparison for both unicast and multicast frames.
When reset, normal filtering of frames is performed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HMC</name>
              <description>Hash Multicast
When set, the MAC performs destination address filtering of received multicast frames according to the hash table. When reset,
the MAC performs a perfect destination address filtering for multicast frames, that is, it compares the DA field with the values programmed in DA registers.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HUC</name>
              <description>Hash Unicast
 When set, the MAC performs destination address filtering of unicast frames according to the hash table.
When reset, the MAC performs a perfect destination address filtering for unicast frames, that is, it compares the DA field with the values programmed in DA registers.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PR</name>
              <description>Promiscuous Mode
When this bit is set, the Address Filter module passes all incoming frames irrespective of the destination or source address.
 The SA or DA Filter Fails status bits of the Receive Status Word are always cleared when PR is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_H</name>
          <description>Hash Table High Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTH</name>
              <description>Hash Table High
 This field contains the upper 32 bits of the Hash table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_L</name>
          <description>Hash Table Low Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTL</name>
              <description>Hash Table Low
 This field contains the lower 32 bits of the Hash table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMII_ADDR</name>
          <description>GMII Address Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PA</name>
              <description>Physical Layer Address
 This field indicates which of the 32 possible PHY devices are being accessed. For RevMII, this field gives the PHY Address of the RevMII module.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GR</name>
              <description>GMII Register
 These bits select the desired GMII register in the selected PHY device. For RevMII, these bits select the desired CSR register in the RevMII Registers set.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CR</name>
              <description>CSR Clock Range
 The CSR Clock Range selection determines the frequency of the MDC clock according to the CSR clock frequency used in your design.
The CSR clock corresponding to different GMAC configurations is given in Table 9-2 on page 564.
The suggested range of CSR clock frequency applicable for each value (when Bit[5] = 0)
ensures that the MDC clock is approximately between the frequency range 1.0 MHz–2.5 MHz.
- 0000: The CSR clock frequency is 60–100 MHz and the MDC clock frequency is CSR clock/42.
- 0001: The CSR clock frequency is 100–150 MHz and the MDC clock frequency is CSR clock/62.
- 0010: The CSR clock frequency is 20–35 MHz and the MDC clock frequency is CSR clock/16.
- 0011: The CSR clock frequency is 35–60 MHz and the MDC clock frequency is CSR clock/26.
- 0100: The CSR clock frequency is 150–250 MHz and the MDC clock frequency is CSR clock/102.
- 0101: The CSR clock frequency is 250–300 MHz and the MDC clock is CSR clock/124.
- 0110, 0111: Reserved
When Bit 5 is set, you can achieve higher frequency of the MDC clock than the frequency limit of 2.5 MHz (specified in the IEEE Std 802.3) and program a clock divider of lower value.
For example,
when CSR clock is of 100 MHz frequency and you program these bits as 1010,
then the resultant MDC clock is of 12.5 MHz which is outside the limit of IEEE 802.3 specified range.
Program the following values only if the interfacing chips support faster MDC clocks.
- 1000: CSR clock/4
- 1001: CSR clock/6
- 1010: CSR clock/8
- 1011: CSR clock/10
- 1100: CSR clock/12
- 1101: CSR clock/14
- 1110: CSR clock/16
- 1111: CSR clock/18 These bits are not used for accessing RevMII. These bits are read-only if the RevMII interface is selected as single PHY interface.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GW</name>
              <description>GMII Write
 When set, this bit indicates to the PHY or RevMII that this is a Write operation using the GMII Data register. If this bit is not set,
it indicates that this is a Read operation, that is, placing the data in the GMII Data register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GB</name>
              <description>GMII Busy
 This bit should read logic 0 before writing to Register 4 and Register 5.
During a PHY or RevMII register access, the software sets this bit to 1’b1 to indicate that a Read or Write access is in progress.
 Register 5 is invalid until this bit is cleared by the MAC.
Therefore, Register 5 (GMII Data) should be kept valid until the MAC clears this bit during a PHY Write operation.
Similarly for a read operation, the contents of Register 5 are not valid until this bit is cleared.
The subsequent read or write operation should happen only after the previous operation is complete.
Because there is no acknowledgment from the PHY to MAC after a read or write operation is completed,
there is no change in the functionality of this bit even when the PHY is not present.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMII_DATA</name>
          <description>GMII Data Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>GD</name>
              <description>GMII Data
 This field contains the 16-bit data value read from the PHY or RevMII after a Management Read operation
or the 16-bit data value to be written to the PHY or RevMII before a Management Write operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLOWCTRL</name>
          <description>Flow Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF00BF</resetMask>
          <fields>
            <field>
              <name>PT</name>
              <description>Pause Time
 This field holds the value to be used in the Pause Time field in the transmit control frame.
If the Pause Time bits is configured to be double-synchronized to the (G)MII clock domain,
 then consecutive writes to this register should be performed only after at least four clock cycles in the destination clock domain.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZPQ</name>
              <description>Disable Zero-Quanta Pause
 When this bit is set, it disables the automatic generation of the Zero-Quanta Pause frames on the de-assertion of
the flow-control signal from the FIFO layer (MTL or external sideband flow control signal sbd_flowctrl_i/mti_flowctrl_i).
When this bit is reset, normal operation with automatic Zero-Quanta Pause frame generation is enabled.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLT</name>
              <description>Pause Low Threshold
 This field configures the threshold of the Pause timer at which the input flow control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic retransmission of the Pause frame.
The threshold values should be always less than the Pause Time configured in Bits[31:16].
 For example, if PT = 100H (256 slot-times), and PLT = 01,
then a second Pause frame is automatically transmitted if the mti_flowctrl_i signal is asserted at 228 (256 – 28) slot times after the first Pause frame is transmitted.
The following list provides the threshold values for different values:
- 00: The threshold is Pause time minus 4 slot times (PT – 4 slot times).
- 01: The threshold is Pause time minus 28 slot times (PT – 28 slot times).
- 10: The threshold is Pause time minus 144 slot times (PT – 144 slot times).
- 11: The threshold is Pause time minus 256 slot times (PT – 256 slot times). The slot time is defined as the time taken to transmit 512 bits (64 bytes) on the GMII or MII interface.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UP</name>
              <description>Unicast Pause Frame Detect A pause frame is processed when it has the unique multicast address specified in the IEEE Std 802.3.
When this bit is set, the MAC can also detect Pause frames with unicast address of the station.
This unicast address should be as specified in the MAC Address0 High Register and MAC Address0 Low Register.
When this bit is reset, the MAC only detects Pause frames with unique multicast address.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFE</name>
              <description>Receive Flow Control Enable
 When this bit is set, the MAC decodes the received Pause frame and disables its transmitter for a specified (Pause) time. When this bit is reset, the decode function of the Pause frame is disabled.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit Flow Control Enable
In the full-duplex mode, when this bit is set, the MAC enables the flow control operation to transmit Pause frames.
When this bit is reset, the flow control operation in the MAC is disabled, and the MAC does not transmit any Pause frames.
In the half-duplex mode, when this bit is set, the MAC enables the backpressure operation. When this bit is reset, the backpressure feature is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FCB_BPA</name>
              <description>Flow Control Busy or Backpressure Activate
 This bit initiates a Pause frame in the full-duplex mode and activates the backpressure function in the half-duplex mode if the TFE bit is set.
In the full-duplex mode, this bit should be read as 1'b0 before writing to the Flow Control register.
 To initiate a Pause frame, the Application must set this bit to 1'b1.
During a transfer of the Control Frame, this bit continues to be set to signify that a frame transmission is in progress.
After the completion of Pause frame transmission, the MAC resets this bit to 1'b0.
The Flow Control register should not be written to until this bit is cleared. In the half-duplex mode,
when this bit is set (and TFE is set), then backpressure is asserted by the MAC.
During backpressure, when the MAC receives a new frame, the transmitter starts sending a JAM pattern resulting in a collision.
This control register bit is logically ORed with the mti_flowctrl_i input signal for the backpressure function.
When the MAC is configured for the full-duplex mode, the BPA is automatically disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VLAN_TAG</name>
          <description>VLAN Tag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>VTHM</name>
              <description>VLAN Tag Hash Table Match Enable
 When set, the most significant four bits of the VLAN tag’s CRC are used to index the content of Register 354 (VLAN Hash Table Register).
A value of 1 in the VLAN Hash Table register, corresponding to the index, indicates that the frame matched the VLAN hash table.
When Bit 16 (ETV) is set, the CRC of the 12-bit VLAN Identifier (VID) is used for comparison whereas when ETV is reset,
the CRC of the 16-bit VLAN tag is used for comparison. When reset, the VLAN Hash Match operation is not performed.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ESVL</name>
              <description>Enable S-VLAN
 When this bit is set, the MAC transmitter and receiver also consider the S-VLAN (Type = 0x88A8) frames as valid VLAN tagged frames.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VTIM</name>
              <description>VLAN Tag Inverse Match Enable
When set, this bit enables the VLAN Tag inverse matching. The frames that do not have matching VLAN Tag are marked as matched. When reset, this bit enables the VLAN Tag perfect matching.
 The frames with matched VLAN Tag are marked as matched.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETV</name>
              <description>Enable 12-Bit VLAN Tag Comparison
 When this bit is set, a 12-bit VLAN identifier is used for comparing and filtering instead of the complete 16-bit VLAN tag.
 Bits [11:0] of VLAN tag are compared with the corresponding field in the received VLAN-tagged frame. Similarly, when enabled,
only 12 bits of the VLAN tag in the received frame are used for hash-based VLAN filtering.
When this bit is reset, all 16 bits of the 15th and 16th bytes of the received VLAN frame are used for comparison and VLAN hash filtering.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VL</name>
              <description>VLAN Tag Identifier for Receive Frames
 This field contains the 802.1Q VLAN tag to identify the VLAN frames and is compared to the 15th and 16th bytes of the frames being received for VLAN frames.
The following list describes the bits of this field:
 - Bits [15:13]: User Priority
- Bit 12: Canonical Format Indicator (CFI) or Drop Eligible Indicator (DEI)
- Bits[11:0]: VLAN tag’s VLAN Identifier (VID) field When the ETV bit is set, only the VID (Bits[11:0]) is used for comparison.
   If VL (VL[11:0] if ETV is set) is all zeros, the MAC does not check the fifteenth and 16th bytes for VLAN tag comparison,
  and declares all frames with a Type field value of 0x8100 or 0x88a8 as VLAN frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RWKFRMFILT</name>
          <description>Remote Wake-Up Frame Filter Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPFRMFILT</name>
              <description>This is the address through which the application writes or reads the remote wake-up frame filter registers (wkupfmfilter_reg).
The wkupfmfilter_reg register is a pointer to eight wkupfmfilter_reg registers.
The wkupfmfilter_reg register is loaded by sequentially loading the eight register values.
Eight sequential writes to this address (0x0028) write all wkupfmfilter_reg registers.
 Similarly, eight sequential reads from this address (0x0028) read all wkupfmfilter_reg registers</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMT_CSR</name>
          <description>PMT Control and Status Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x9F000267</resetMask>
          <fields>
            <field>
              <name>RWKFILTRST</name>
              <description>Remote Wake-Up Frame Filter Register Pointer Reset
When this bit is set, it resets the remote wake-up frame filter register pointer to 3’b000. It is automatically cleared after 1 clock cycle.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWKPTR</name>
              <description>Remote Wake-up FIFO Pointer
This field gives the current value (0 to 31) of the Remote Wake-up Frame filter register pointer. When the value of this pointer is equal to 7, 15, 23 or 31,
the contents of the Remote Wake-up Frame Filter Register are transferred to the clk_rx_i domain when a write occurs to that register.
 The maximum value of the pointer is 7, 15, 23 and 31 respectively depending on the number of Remote Wakeup Filters selected during configuration.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GLBLUCAST</name>
              <description>Global Unicast
When set, enables any unicast packet filtered by the MAC (DAF) address recognition to be a remote wake-up frame.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWKPRCVD</name>
              <description>Remote Wake-Up Frame Received
When set, this bit indicates the power management event is generated because of the reception of a remote wake-up frame. This bit is cleared by a Read into this register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MGKPRCVD</name>
              <description>Magic Packet Received
When set, this bit indicates that the power management event is generated because of the reception of a magic packet. This bit is cleared by a Read into this register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWKPKTEN</name>
              <description>Remote Wake-Up Frame Enable
When set, enables generation of a power management event because of remote wake-up frame reception.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MGKPKTEN</name>
              <description>Magic Packet Enable
When set, enables generation of a power management event because of magic packet reception.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN</name>
              <description>Power Down
When set, the MAC receiver drops all received frames until it receives the expected magic packet or remote wake-up frame.
This bit is then self-cleared and the power-down mode is disabled.
The Software can also clear this bit before the expected magic packet or remote wake-up frame is received.
The frames, received by the MAC after this bit is cleared, are forwarded to the application.
This bit must only be set when the Magic Packet Enable, Global Unicast, or Remote Wake-Upr Fame Enable bit is set high.
Note: You can gate-off the CSR clock during the power-down mode.
However, when the CSR clock is gated-off, you cannot perform any read or write operations on this register. Therefore, the Software cannot clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPI_CSR</name>
          <description>LPI Control and Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F030F</resetMask>
          <fields>
            <field>
              <name>LPITXA</name>
              <description>LPI TX Automate
This bit controls the behavior of the MAC when it is entering or coming out of the LPI mode on the transmit side.
This bit is not functional in the GMAC-CORE configuration in which the Tx clock gating is done during the LPI mode. If the LPITXA and LPIEN bits are set to 1,
the MAC enters the LPI mode only after all outstanding frames (in the core) and pending frames (in the application interface) have been transmitted.
The MAC comes out of the LPI mode when the application sends any frame for transmission or the application issues a TX FIFO Flush command.
 In addition, the MAC automatically clears the LPIEN bit when it exits the LPI state.
If TX FIFO Flush is set in Bit 20 of Register 6 (Operation Mode Register),
when the MAC is in the LPI mode, the MAC exits the LPI mode.
When this bit is 0, the LPIEN bit directly controls behavior of the MAC when it is entering or coming out of the LPI mode.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLSEN</name>
              <description>PHY Link Status Enable
This bit enables the link status received on the RGMII, SGMII, or SMII receive paths to be used for activating the LPI LS TIMER.
When set, the MAC uses the link-status bits of Register 54 (SGMII/RGMII/SMII Control and Status Register) and Bit 17 (PLS) for the LPI LS Timer trigger.
 When cleared, the MAC ignores the link-status bits of Register 54 and takes only the PLS bit. This bit is RO and reserved if you have not selected the RGMII, SGMII, or SMII PHY interface.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLS</name>
              <description>PHY Link Status
This bit indicates the link status of the PHY. The MAC Transmitter asserts the LPI pattern only when the link status is up (okay) at least for the time indicated by the LPI LS TIMER.
When set, the link is considered to be okay (up) and when reset, the link is considered to be down.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPIEN</name>
              <description>LPI Enable
When set, this bit instructs the MAC Transmitter to enter the LPI state. When reset, this bit instructs the MAC to exit the LPI state and resume normal transmission.
This bit is cleared when the LPITXA bit is set and the MAC exits the LPI state because of the arrival of a new packet for transmission.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLPIST</name>
              <description>Receive LPI State
When set, this bit indicates that the MAC is receiving the LPI pattern on the GMII or MII interface.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TLPIST</name>
              <description>Transmit LPI State
When set, this bit indicates that the MAC is transmitting the LPI pattern on the GMII or MII interface.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLPIEX</name>
              <description>Receive LPI Exit
When set, this bit indicates that the MAC Receiver has stopped receiving the LPI pattern on the GMII or MII interface, exited the LPI state, and resumed the normal reception.
This bit is cleared by a read into this register.
Note: This bit may not get set if the MAC stops receiving the LPI pattern for a very short duration, such as, less than 3 clock cycles of CSR clock.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLPIEN</name>
              <description>Receive LPI Entry
When set, this bit indicates that the MAC Receiver has received an LPI pattern and entered the LPI state. This bit is cleared by a read into this register.
Note: This bit may not get set if the MAC stops receiving the LPI pattern for a very short duration, such as, less than 3 clock cycles of CSR clock.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TLPIEX</name>
              <description>Transmit LPI Exit
When set, this bit indicates that the MAC transmitter has exited the LPI state after the user has cleared the LPIEN bit and the LPI TW Timer has expired. This bit is cleared by a read into this register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TLPIEN</name>
              <description>Transmit LPI Entry
 When set, this bit indicates that the MAC Transmitter has entered the LPI state because of the setting of the LPIEN bit. This bit is cleared by a read into this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPI_TCR</name>
          <description>LPI Timers Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>LST</name>
              <description>LPI LS TIMER
This field specifies the minimum time (in milliseconds) for which the link status from the PHY should be up (OKAY) before the LPI pattern can be transmitted to the PHY.
 The MAC does not transmit the LPI pattern even when the LPIEN bit is set unless the LPI LS Timer reaches the programmed terminal count.
The default value of the LPI LS Timer is 1000 (1 sec) as defined in the IEEE standard.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWT</name>
              <description>LPI TW TIMER
This field specifies the minimum time (in microseconds) for which the MAC waits after it stops transmitting
 the LPI pattern to the PHY and before it resumes the normal transmission.
The TLPIEX status bit is set after the expiry of this timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_STATUS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000EFF</resetMask>
          <fields>
            <field>
              <name>GPIIS</name>
              <description>GPI Interrupt Status
When the GPIO feature is enabled, this bit is set when any active event (LL or LH) occurs on the GPIS field (Bits [3:0])
 of Register 56 (General Purpose IO Register) and the corresponding GPIE bit is enabled.
This bit is cleared on reading lane 0 (GPIS) of Register 56 (General Purpose IO Register).
 When the GPIO feature is not enabled, this bit is reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LPIIS</name>
              <description>LPI Interrupt Status
When the Energy Efficient Ethernet feature is enabled, this bit is set for any LPI state entry or exit in the MAC Transmitter or Receiver.
This bit is cleared on reading Bit 0 of Register 12 (LPI Control and Status Register). In all other modes, this bit is reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSIS</name>
              <description>Timestamp Interrupt Status
When the Advanced Timestamp feature is enabled, this bit is set when any of the following conditions is true:
- The system time value equals or exceeds the value specified in the Target Time High and Low registers.
- There is an overflow in the seconds register.
 - The Auxiliary snapshot trigger is asserted. This bit is cleared on reading Bit 0 of Register 458 (Timestamp Status Register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MMCRXIPIS</name>
              <description>MMC Receive Checksum Offload Interrupt Status
This bit is set high when an interrupt is generated in the MMC Receive Checksum Offload Interrupt Register. This bit is cleared when all the bits in this interrupt register are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MMCTXIS</name>
              <description>MMC Transmit Interrupt Status
This bit is set high when an interrupt is generated in the MMC Transmit Interrupt Register. This bit is cleared when all the bits in this interrupt register are cleared.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MMCRXIS</name>
              <description>MMC Receive Interrupt Status
This bit is set high when an interrupt is generated in the MMC Receive Interrupt Register. This bit is cleared when all the bits in this interrupt register are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MMCIS</name>
              <description>MMC Interrupt Status
This bit is set high when any of the Bits [7:5] is set high and cleared only when all of these bits are low.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMTIS</name>
              <description>PMT Interrupt Status
This bit is set when a magic packet or remote wake-up frame is received in the power-down mode (see Bits 5 and 6 in the PMT Control and Status Register).
This bit is cleared when both Bits[6:5] are cleared because of a read operation to the PMT Control and Status register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PCSANCIS</name>
              <description>PCS Auto-Negotiation Complete
This bit is set when the Auto-negotiation is completed in the TBI, RTBI, or SGMII PHY interface (Bit 5 in Register 49 (AN Status Register)).
This bit is cleared when you perform a read operation to the AN Status register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PCSLCHGIS</name>
              <description>PCS Link Status Changed
This bit is set because of any change in Link Status in the TBI, RTBI, or SGMII PHY interface (Bit 2 in Register 49 (AN Status Register)).
This bit is cleared when you perform a read operation on the AN Status register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RGSMIIIS</name>
              <description>RGMII or SMII Interrupt Status
This bit is set because of any change in value of the Link Status of RGMII or SMII interface (Bit 3 in Register 54 (SGMII/RGMII/SMII Control and Status Register)).
This bit is cleared when you perform a read operation on the SGMII/RGMII/SMII Control and Status Register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000060F</resetMask>
          <fields>
            <field>
              <name>LPIIM</name>
              <description>LPI Interrupt Mask
When set, this bit disables the assertion of the interrupt signal because of the setting of the LPI Interrupt Status bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSIM</name>
              <description>Timestamp Interrupt Mask
 When set, this bit disables the assertion of the interrupt signal because of the setting of Timestamp Interrupt Status bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMTIM</name>
              <description>PMT Interrupt Mask
 When set, this bit disables the assertion of the interrupt signal because of the setting of PMT Interrupt Status bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCSANCIM</name>
              <description>PCS AN Completion Interrupt Mask
When set, this bit disables the assertion of the interrupt signal because of the setting of PCS Auto-negotiation complete bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCSLCHGIM</name>
              <description>PCS Link Status Interrupt Mask
When set, this bit disables the assertion of the interrupt signal because of the setting of the PCS Link-status changed bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RGSMIIIM</name>
              <description>RGMII or SMII Interrupt Mask
When set, this bit disables the assertion of the interrupt signal because of the setting of the RGMII or SMII Interrupt Status bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAC_ADDR_0_HIGH</name>
          <description>MAC Address 0 High Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>AE</name>
              <description>Address Enable
 This bit is RO. The bit value is fixed at 1.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDRHI</name>
              <description>MAC Address0 [47:32]
 This field contains the upper 16 bits (47:32) of the first 6-byte MAC address. The MAC uses this field for filtering the received frames and inserting the MAC address in the Transmit Flow Control (Pause) Frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAC_ADDR_0_LOW</name>
          <description>MAC Address 0 Low Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRLO</name>
              <description>MAC Address0 [31:0]
 This field contains the lower 32 bits of the first 6-byte MAC address. This is used by the MAC for filtering the received frames and inserting the MAC address in the Transmit Flow Control (Pause) Frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>1,2,3,4</dimIndex>
          <name>MAC_ADDR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x48</addressOffset>
          <register>
            <name>HIGH</name>
            <description>MAC Address High Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF00FFFF</resetMask>
            <fields>
              <field>
                <name>AE</name>
                <description>Address Enable
When this bit is set, the address filter module uses the second MAC address for perfect filtering. When this bit is reset, the address filter module ignores the address for filtering.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SA</name>
                <description>Source Address
When this bit is set, the MAC Address1[47:0] is used to compare with the SA fields of the received frame. When this bit is reset, the MAC Address1[47:0] is used to compare with the DA fields of the received frame.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MBC</name>
                <description>Mask Byte Control
These bits are mask control bits for comparison of each of the MAC Address bytes.
When set high, the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers.
Each bit controls the masking of the bytes as follows:
- Bit 29: Register 18[15:8]
- Bit 28: Register 18[7:0]
- Bit 27: Register 19[31:24] -
...
- Bit 24: Register 19[7:0]
You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ADDRHI</name>
                <description>MAC Address1 [47:32]
This field contains the upper 16 bits (47:32) of the second 6-byte MAC address.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOW</name>
            <description>MAC Address Low Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDRLO</name>
                <description>MAC Address1 [31:0]
This field contains the lower 32 bits of the second 6-byte MAC address. The content of this field is undefined until loaded by the Application after the initialization process.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>XMII_CSR</name>
          <description>SGMII/RGMII/SMII Control and Status Register</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>FALSCARDET</name>
              <description>False Carrier Detected
 This bit indicates whether the SMII PHY detected false carrier (1'b1). This bit is reserved when the MAC is configured for the SGMII or RGMII PHY interface.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JABTO</name>
              <description>Jabber Timeout
 This bit indicates whether there is jabber timeout error (1'b1) in the received frame. This bit is reserved when the MAC is configured for the SGMII or RGMII PHY interface.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LNKSTS</name>
              <description>Link Status
 This bit indicates whether the link between the local PHY and the remote PHY is up or down.
It gives the status of the link between the SGMII of MAC and the SGMII of the local PHY.
The status bits are received from the local PHY during ANEG betweent he MAC and PHY on the SGMII link.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LNKSPEED</name>
              <description>Link Speed
 This bit indicates the current speed of the link:
- 00: 2.5 MHz
- 01: 25 MHz
- 10: 125 MHz Bit 2 is reserved when the MAC is configured for the SMII PHY interface.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LNKMOD</name>
              <description>Link Mode
 This bit indicates the current mode of operation of the link:
- 1’b0: Half-duplex mode
- 1’b1: Full-duplex mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDOG_WTO</name>
          <description>Watchdog Timeout Register</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00013FFF</resetMask>
          <fields>
            <field>
              <name>PWE</name>
              <description>Programmable Watchdog Enable
 When this bit is set and Bit 23 (WD) of Register 0 (MAC Configuration Register) is reset,
the WTO field (Bits[13:0]) is used as watchdog timeout for a received frame.
When this bit is cleared, the watchdog timeout for a received frame is controlled by the setting of Bit 23 (WD) and Bit 20 (JE) in Register 0 (MAC Configuration Register).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WTO</name>
              <description>Watchdog Timeout
When Bit 16 (PWE) is set and Bit 23 (WD) of Register 0 (MAC Configuration Register) is reset,
this field is used as watchdog timeout for a received frame.
 If the length of a received frame exceeds the value of this field, such frame is terminated and declared as an error frame.
Note: When Bit 16 (PWE) is set, the value in this field should be more than 1,522 (0x05F2).
Otherwise, the IEEE Std 802.3-specified valid tagged frames are declared as error frames and are dropped.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_cntrl</name>
          <description>MMC Control establishes the operating mode of MMC.</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000013F</resetMask>
          <fields>
            <field>
              <name>UCDBC</name>
              <description>Update MMC Counters for Dropped Broadcast Frames
When set, the MAC updates all related MMC Counters for Broadcast frames that are dropped because of the setting of Bit 5 (DBF) of Register 1 (MAC Frame Filter).
 When reset, the MMC Counters are not updated for dropped Broadcast frames.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTPRSTLVL</name>
              <description>Full-Half Preset
When this bit is low and Bit 4 is set, all MMC counters get preset to almost-half value. All octet counters get preset to 0x7FFF_F800 (half
- 2KBytes) and all frame-counters gets preset to 0x7FFF_FFF0 (half
- 16). When this bit is high and Bit 4 is set, all MMC counters get preset to almost-full value. All octet counters get preset to 0xFFFF_F800 (full
- 2KBytes) and all frame-counters gets preset to 0xFFFF_FFF0 (full
- 16). For 16-bit counters, the almost-half preset values are 0x7800 and 0x7FF0 for the respective octet and frame counters. Similarly, the almost-full preset values for the 16-bit counters are 0xF800 and 0xFFF0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTPRST</name>
              <description>Counters Preset
When this bit is set, all counters are initialized or preset to almost full or almost half according to Bit 5. This bit is cleared automatically after 1 clock cycle.
This bit, along with Bit 5, is useful for debugging and testing the assertion of interrupts because of MMC counter becoming half-full or full.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTFREEZ</name>
              <description>MMC Counter Freeze
When this bit is set, it freezes all MMC counters to their current value.
Until this bit is reset to 0, no MMC counter is updated because of any transmitted or received frame.
 If any MMC counter is read with the Reset on Read bit set, then that counter is also cleared in this mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTONRD</name>
              <description>Reset on Read
When this bit is set, the MMC counters are reset to zero after Read (self-clearing after reset). The counters are cleared when the least significant byte lane (Bits[7:0]) is read.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTSTOPRO</name>
              <description>Counter Stop Rollover
When this bit is set, the counter does not roll over to zero after reaching the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTRST</name>
              <description>Counters Reset
When this bit is set, all counters are reset. This bit is cleared automatically after 1 clock cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_intr_rx</name>
          <description>MMC Receive Interrupt</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCTRLFIS</name>
              <description>MMC Receive Control Frame Counter Interrupt Status
This bit is set when the rxctrlframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRCVERRFIS</name>
              <description>MMC Receive Error Frame Counter Interrupt Status
This bit is set when the rxrcverror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXWDOGFIS</name>
              <description>MMC Receive Watchdog Error Frame Counter Interrupt Status
This bit is set when the rxwatchdog error counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXVLANGBFIS</name>
              <description>MMC Receive VLAN Good Bad Frame Counter Interrupt Status
This bit is set when the rxvlanframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFOVFIS</name>
              <description>MMC Receive FIFO Overflow Frame Counter Interrupt Status
This bit is set when the rxfifooverflow counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPAUSFIS</name>
              <description>MMC Receive Pause Frame Counter Interrupt Status
This bit is set when the rxpauseframes counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXORANGEFIS</name>
              <description>MMC Receive Out Of Range Error Frame Counter Interrupt Status.
This bit is set when the rxoutofrangetype counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLENERFIS</name>
              <description>MMC Receive Length Error Frame Counter Interrupt Status
This bit is set when the rxlengtherror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUCGFIS</name>
              <description>MMC Receive Unicast Good Frame Counter Interrupt Status
This bit is set when the rxunicastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX1024TMAXOCTGBFIS</name>
              <description>MMC Receive 1024 to Maximum Octet Good Bad Frame Counter Interrupt Status.
This bit is set when the rx1024tomaxoctets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX512T1023OCTGBFIS</name>
              <description>MMC Receive 512 to 1023 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx512to1023octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX256T511OCTGBFIS</name>
              <description>MMC Receive 256 to 511 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx256to511octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX128T255OCTGBFIS</name>
              <description>MMC Receive 128 to 255 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx128to255octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX65T127OCTGBFIS</name>
              <description>MMC Receive 65 to 127 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx65to127octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX64OCTGBFIS</name>
              <description>MMC Receive 64 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx64octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOSIZEGFIS</name>
              <description>MMC Receive Oversize Good Frame Counter Interrupt Status
This bit is set when the rxoversize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUSIZEGFIS</name>
              <description>MMC Receive Undersize Good Frame Counter Interrupt Status
This bit is set when the rxundersize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXJABERFIS</name>
              <description>MMC Receive Jabber Error Frame Counter Interrupt Status
This bit is set when the rxjabbererror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRUNTFIS</name>
              <description>MMC Receive Runt Frame Counter Interrupt Status
This bit is set when the rxrunterror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXALGNERFIS</name>
              <description>MMC Receive Alignment Error Frame Counter Interrupt Status
This bit is set when the rxalignmenterror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCRCERFIS</name>
              <description>MMC Receive CRC Error Frame Counter Interrupt Status
This bit is set when the rxcrcerror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXMCGFIS</name>
              <description>MMC Receive Multicast Good Frame Counter Interrupt Status
This bit is set when the rxmulticastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXBCGFIS</name>
              <description>MMC Receive Broadcast Good Frame Counter Interrupt Status
This bit is set when the rxbroadcastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGOCTIS</name>
              <description>MMC Receive Good Octet Counter Interrupt Status
This bit is set when the rxoctetcount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGBOCTIS</name>
              <description>MMC Receive Good Bad Octet Counter Interrupt Status
This bit is set when the rxoctetcount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGBFRMIS</name>
              <description>MMC Receive Good Bad Frame Counter Interrupt Status
This bit is set when the rxframecount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_intr_tx</name>
          <description>MMC Transmit Interrupt</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOSIZEGFIS</name>
              <description>MMC Transmit Oversize Good Frame Counter Interrupt Status
This bit is set when the txoversize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXVLANGFIS</name>
              <description>MMC Transmit VLAN Good Frame Counter Interrupt Status
This bit is set when the txvlanframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXPAUSFIS</name>
              <description>MMC Transmit Pause Frame Counter Interrupt Status
This bit is set when the txpauseframeserror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEXDEFFIS</name>
              <description>MMC Transmit Excessive Deferral Frame Counter Interrupt Status
This bit is set when the txexcessdef counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGFRMIS</name>
              <description>MMC Transmit Good Frame Counter Interrupt Status
This bit is set when the txframecount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGOCTIS</name>
              <description>MMC Transmit Good Octet Counter Interrupt Status
This bit is set when the txoctetcount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXCARERFIS</name>
              <description>MMC Transmit Carrier Error Frame Counter Interrupt Status
This bit is set when the txcarriererror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEXCOLFIS</name>
              <description>MMC Transmit Excessive Collision Frame Counter Interrupt Status
This bit is set when the txexesscol counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLATCOLFIS</name>
              <description>MMC Transmit Late Collision Frame Counter Interrupt Status
This bit is set when the txlatecol counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDEFFIS</name>
              <description>MMC Transmit Deferred Frame Counter Interrupt Status
This bit is set when the txdeferred counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCOLGFIS</name>
              <description>MMC Transmit Multiple Collision Good Frame Counter Interrupt Status
This bit is set when the txmulticol_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCOLGFIS</name>
              <description>MMC Transmit Single Collision Good Frame Counter Interrupt Status
This bit is set when the txsinglecol_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUFLOWERFIS</name>
              <description>MMC Transmit Underflow Error Frame Counter Interrupt Status
This bit is set when the txunderflowerror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBCGBFIS</name>
              <description>MMC Transmit Broadcast Good Bad Frame Counter Interrupt Status
This bit is set when the txbroadcastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCGBFIS</name>
              <description>MMC Transmit Multicast Good Bad Frame Counter Interrupt Status
The bit is set when the txmulticastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUCGBFIS</name>
              <description>MMC Transmit Unicast Good Bad Frame Counter Interrupt Status
This bit is set when the txunicastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX1024TMAXOCTGBFIS</name>
              <description>MMC Transmit 1024 to Maximum Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx1024tomaxoctets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX512T1023OCTGBFIS</name>
              <description>MMC Transmit 512 to 1023 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx512to1023octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX256T511OCTGBFIS</name>
              <description>MMC Transmit 256 to 511 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx256to511octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX128T255OCTGBFIS</name>
              <description>MMC Transmit 128 to 255 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx128to255octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX65T127OCTGBFIS</name>
              <description>MMC Transmit 65 to 127 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx65to127octets_gb counter reaches half the maximum value, and also when it reaches the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX64OCTGBFIS</name>
              <description>MMC Transmit 64 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx64octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCGFIS</name>
              <description>MMC Transmit Multicast Good Frame Counter Interrupt Status
This bit is set when the txmulticastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBCGFIS</name>
              <description>MMC Transmit Broadcast Good Frame Counter Interrupt Status
This bit is set when the txbroadcastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGBFRMIS</name>
              <description>MMC Transmit Good Bad Frame Counter Interrupt Status
This bit is set when the txframecount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGBOCTIS</name>
              <description>MMC Transmit Good Bad Octet Counter Interrupt Status
This bit is set when the txoctetcount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_intr_mask_rx</name>
          <description>MMC Receive Interrupt mask</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFE</resetMask>
          <fields>
            <field>
              <name>RXCTRLFIM</name>
              <description>MMC Receive Control Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxctrlframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRCVERRFIM</name>
              <description>MMC Receive Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxrcverror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXWDOGFIM</name>
              <description>MMC Receive Watchdog Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxwatchdog counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXVLANGBFIM</name>
              <description>MMC Receive VLAN Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxvlanframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFOVFIM</name>
              <description>MMC Receive FIFO Overflow Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxfifooverflow counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPAUSFIM</name>
              <description>MMC Receive Pause Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxpauseframes counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXORANGEFIM</name>
              <description>MMC Receive Out Of Range Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxoutofrangetype counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLENERFIM</name>
              <description>MMC Receive Length Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxlengtherror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUCGFIM</name>
              <description>MMC Receive Unicast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxunicastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX1024TMAXOCTGBFIM</name>
              <description>MMC Receive 1024 to Maximum Octet Good Bad Frame Counter Interrupt Mask.
Setting this bit masks the interrupt when the rx1024tomaxoctets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX512T1023OCTGBFIM</name>
              <description>MMC Receive 512 to 1023 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx512to1023octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX256T511OCTGBFIM</name>
              <description>MMC Receive 256 to 511 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx256to511octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX128T255OCTGBFIM</name>
              <description>MMC Receive 128 to 255 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx128to255octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX65T127OCTGBFIM</name>
              <description>MMC Receive 65 to 127 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx65to127octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX64OCTGBFIM</name>
              <description>MMC Receive 64 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx64octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOSIZEGFIM</name>
              <description>MMC Receive Oversize Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxoversize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUSIZEGFIM</name>
              <description>MMC Receive Undersize Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxundersize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXJABERFIM</name>
              <description>MMC Receive Jabber Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxjabbererror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRUNTFIM</name>
              <description>MMC Receive Runt Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxrunterror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXALGNERFIM</name>
              <description>MMC Receive Alignment Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxalignmenterror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCRCERFIM</name>
              <description>MMC Receive CRC Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxcrcerror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXMCGFIM</name>
              <description>MMC Receive Multicast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxmulticastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXBCGFIM</name>
              <description>MMC Receive Broadcast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxbroadcastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGOCTIM</name>
              <description>MMC Receive Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxoctetcount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGBOCTIM</name>
              <description>MMC Receive Good Bad Octet Counter Interrupt Mask.
Setting this bit masks the interrupt when the rxoctetcount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_intr_mask_tx</name>
          <description>MMC Transmit Interrupt Mask</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOSIZEGFIM</name>
              <description>MMC Transmit Oversize Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txoversize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXVLANGFIM</name>
              <description>MMC Transmit VLAN Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txvlanframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXPAUSFIM</name>
              <description>MMC Transmit Pause Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txpauseframes counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEXDEFFIM</name>
              <description>MMC Transmit Excessive Deferral Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txexcessdef counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGFRMIM</name>
              <description>MMC Transmit Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txframecount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGOCTIM</name>
              <description>MMC Transmit Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the txoctetcount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXCARERFIM</name>
              <description>MMC Transmit Carrier Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txcarriererror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEXCOLFIM</name>
              <description>MMC Transmit Excessive Collision Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txexcesscol counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLATCOLFIM</name>
              <description>MMC Transmit Late Collision Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txlatecol counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDEFFIM</name>
              <description>MMC Transmit Deferred Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txdeferred counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCOLGFIM</name>
              <description>MMC Transmit Multiple Collision Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txmulticol_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCOLGFIM</name>
              <description>MMC Transmit Single Collision Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txsinglecol_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUFLOWERFIM</name>
              <description>MMC Transmit Underflow Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txunderflowerror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBCGBFIM</name>
              <description>MMC Transmit Broadcast Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txbroadcastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCGBFIM</name>
              <description>MMC Transmit Multicast Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txmulticastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUCGBFIM</name>
              <description>MMC Transmit Unicast Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txunicastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX1024TMAXOCTGBFIM</name>
              <description>MMC Transmit 1024 to Maximum Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx1024tomaxoctets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX512T1023OCTGBFIM</name>
              <description>MMC Transmit 512 to 1023 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx512to1023octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX256T511OCTGBFIM</name>
              <description>MMC Transmit 256 to 511 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx256to511octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX128T255OCTGBFIM</name>
              <description>MMC Transmit 128 to 255 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx128to255octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX65T127OCTGBFIM</name>
              <description>MMC Transmit 65 to 127 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx65to127octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX64OCTGBFIM</name>
              <description>MMC Transmit 64 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx64octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCGFIM</name>
              <description>MMC Transmit Multicast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txmulticastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBCGFIM</name>
              <description>MMC Transmit Broadcast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txbroadcastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGBFRMIM</name>
              <description>MMC Transmit Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txframecount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGBOCTIM</name>
              <description>MMC Transmit Good Bad Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the txoctetcount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx64octets_gb</name>
          <description>Number of good and bad frames transmitted with length 64 bytes,
exclusive of preamble and retried frames.</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length 64 bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx65to127octets_gb</name>
          <description>Number of good and bad frames transmitted with length between
65 and 127 (inclusive) bytes, exclusive of preamble and retried
frames.</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 65 and 127 (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx128to255octets_gb</name>
          <description>Number of good and bad frames transmitted with length between
128 and 255 (inclusive) bytes, exclusive of preamble and retried
frames.</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 128 and 255 (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx256to511octets_gb</name>
          <description>Number of good and bad frames transmitted with length between
256 and 511 (inclusive) bytes, exclusive of preamble and retried
frames.</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 256 and 511 (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx512to1023octets_gb</name>
          <description>Number of good and bad frames transmitted with length between
512 and 1,023 (inclusive) bytes, exclusive of preamble and retried
frames.</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 512 and 1,023 (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx1024tomaxoctets_gb</name>
          <description>Number of good and bad frames transmitted with length between
1,024 and maxsize (inclusive) bytes, exclusive of preamble and
retried frames.</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 1,024 and maxsize (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rxframecount_gb</name>
          <description>Number of good and bad frames received</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames received.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_ipc_intr_mask_rx</name>
          <description>MMC IPC Receive Checksum Offload Interrupt Mask maintains
the mask for the interrupt generated from the receive IPC statistic
counters.</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>RXICMPEROIM</name>
              <description>MMC Receive ICMP Error Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxicmp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPGOIM</name>
              <description>MMC Receive ICMP Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxicmp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPEROIM</name>
              <description>MMC Receive TCP Error Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxtcp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPGOIM</name>
              <description>MMC Receive TCP Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxtcp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPEROIM</name>
              <description>MMC Receive UDP Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxudp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPGOIM</name>
              <description>MMC Receive IPV6 No Payload Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxudp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6NOPAYOIM</name>
              <description>MMC Receive IPV6 Header Error Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_nopay_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6HEROIM</name>
              <description>MMC Receive IPV6 Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_hdrerr_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6GOIM</name>
              <description>MMC Receive IPV6 Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4UDSBLOIM</name>
              <description>MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_udsbl_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4FRAGOIM</name>
              <description>MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_frag_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4NOPAYOIM</name>
              <description>MMC Receive IPV4 No Payload Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_nopay_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4HEROIM</name>
              <description>MMC Receive IPV4 Header Error Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_hdrerr_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4GOIM</name>
              <description>MMC Receive IPV4 Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPERFIM</name>
              <description>MMC Receive ICMP Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxicmp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPGFIM</name>
              <description>MMC Receive ICMP Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxicmp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPERFIM</name>
              <description>MMC Receive TCP Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxtcp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPGFIM</name>
              <description>MMC Receive TCP Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxtcp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPERFIM</name>
              <description>MMC Receive UDP Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxudp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPGFIM</name>
              <description>MMC Receive UDP Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxudp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6NOPAYFIM</name>
              <description>MMC Receive IPV6 No Payload Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_nopay_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6HERFIM</name>
              <description>MMC Receive IPV6 Header Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_hdrerr_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6GFIM</name>
              <description>MMC Receive IPV6 Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4UDSBLFIM</name>
              <description>MMC Receive IPV4 UDP Checksum Disabled Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_udsbl_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4FRAGFIM</name>
              <description>MMC Receive IPV4 Fragmented Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_frag_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4NOPAYFIM</name>
              <description>MMC Receive IPV4 No Payload Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_nopay_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4HERFIM</name>
              <description>MMC Receive IPV4 Header Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_hdrerr_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4GFIM</name>
              <description>MMC Receive IPV4 Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_ipc_intr_rx</name>
          <description>MMC Receive Checksum Offload Interrupt maintains the interrupt
that the receive IPC statistic counters generate. See Table 4-25
for further detail.</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>RXICMPEROIS</name>
              <description>MMC Receive ICMP Error Octet Counter Interrupt Status
This bit is set when the rxicmp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPGOIS</name>
              <description>MMC Receive ICMP Good Octet Counter Interrupt Status
This bit is set when the rxicmp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPEROIS</name>
              <description>MMC Receive TCP Error Octet Counter Interrupt Status
This bit is set when the rxtcp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPGOIS</name>
              <description>MMC Receive TCP Good Octet Counter Interrupt Status
This bit is set when the rxtcp_gd_octets counter reaches half of the maximum value or the maximum value</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPEROIS</name>
              <description>MMC Receive UDP Error Octet Counter Interrupt Status
This bit is set when the rxudp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPGOIS</name>
              <description>MMC Receive UDP Good Octet Counter Interrupt Status
This bit is set when the rxudp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6NOPAYOIS</name>
              <description>MMC Receive IPV6 No Payload Octet Counter Interrupt Status
This bit is set when the rxipv6_nopay_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6HEROIS</name>
              <description>MMC Receive IPV6 Header Error Octet Counter Interrupt Status
This bit is set when the rxipv6_hdrerr_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6GOIS</name>
              <description>MMC Receive IPV6 Good Octet Counter Interrupt Status
This bit is set when the rxipv6_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4UDSBLOIS</name>
              <description>MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Status
This bit is set when the rxipv4_udsbl_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4FRAGOIS</name>
              <description>MMC Receive IPV4 Fragmented Octet Counter Interrupt Status
This bit is set when the rxipv4_frag_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4NOPAYOIS</name>
              <description>MMC Receive IPV4 No Payload Octet Counter Interrupt Status
This bit is set when the rxipv4_nopay_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4HEROIS</name>
              <description>MMC Receive IPV4 Header Error Octet Counter Interrupt Status
This bit is set when the rxipv4_hdrerr_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4GOIS</name>
              <description>MMC Receive IPV4 Good Octet Counter Interrupt Status
This bit is set when the rxipv4_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPERFIS</name>
              <description>MMC Receive ICMP Error Frame Counter Interrupt Status
This bit is set when the rxicmp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPGFIS</name>
              <description>MMC Receive ICMP Good Frame Counter Interrupt Status
This bit is set when the rxicmp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPERFIS</name>
              <description>MMC Receive TCP Error Frame Counter Interrupt Status
This bit is set when the rxtcp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPGFIS</name>
              <description>MMC Receive TCP Good Frame Counter Interrupt Status
This bit is set when the rxtcp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPERFIS</name>
              <description>MMC Receive UDP Error Frame Counter Interrupt Status
This bit is set when the rxudp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPGFIS</name>
              <description>MMC Receive UDP Good Frame Counter Interrupt Status
This bit is set when the rxudp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6NOPAYFIS</name>
              <description>MMC Receive IPV6 No Payload Frame Counter Interrupt Status
This bit is set when the rxipv6_nopay_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6HERFIS</name>
              <description>MMC Receive IPV6 Header Error Frame Counter Interrupt Status
This bit is set when the rxipv6_hdrerr_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6GFIS</name>
              <description>MMC Receive IPV6 Good Frame Counter Interrupt Status
This bit is set when the rxipv6_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4UDSBLFIS</name>
              <description>MMC Receive IPV4 UDP Checksum Disabled Frame Counter Interrupt Status
This bit is set when the rxipv4_udsbl_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4FRAGFIS</name>
              <description>MMC Receive IPV4 Fragmented Frame Counter Interrupt Status
This bit is set when the rxipv4_frag_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4NOPAYFIS</name>
              <description>MMC Receive IPV4 No Payload Frame Counter Interrupt Status
This bit is set when the rxipv4_nopay_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4HERFIS</name>
              <description>MMC Receive IPV4 Header Error Frame Counter Interrupt Status
This bit is set when the rxipv4_hdrerr_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4GFIS</name>
              <description>MMC Receive IPV4 Good Frame Counter Interrupt Status
This bit is set when the rxipv4_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rxipv4_gd_fms</name>
          <description>Number of good IPv4 datagrams received with the TCP, UDP, or
ICMP payload</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good IPv4 datagrams received with the TCP, UDP, or ICMP payload</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>1</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0</dimIndex>
          <name>L3_L4_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>L3_L4_CTRL</name>
            <description>Layer 3 and Layer 4 Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x003DFFFD</resetMask>
            <fields>
              <field>
                <name>L4DPIM0</name>
                <description>Layer 4 Destination Port Inverse Match Enable
 When set, this bit indicates that the Layer 4 Destination Port number field is enabled for inverse matching.
When reset, this bit indicates that the Layer 4 Destination Port number field is enabled for perfect matching.
 This bit is valid and applicable only when Bit 20 (L4DPM0) is set high.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4DPM0</name>
                <description>Layer 4 Destination Port Match Enable
 When set, this bit indicates that the Layer 4 Destination Port number field is enabled for matching.
When reset, the MAC ignores the Layer 4 Destination Port number field for matching.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4SPIM0</name>
                <description>Layer 4 Source Port Inverse Match Enable
When set, this bit indicates that the Layer 4 Source Port number field is enabled for inverse matching.
When reset, this bit indicates that the Layer 4 Source Port number field is enabled for perfect matching.
This bit is valid and applicable only when Bit 18 (L4SPM0) is set high.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4SPM0</name>
                <description>Layer 4 Source Port Match Enable
When set, this bit indicates that the Layer 4 Source Port number field is enabled for matching. When reset, the MAC ignores the Layer 4 Source Port number field for matching.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4PEN0</name>
                <description>Layer 4 Protocol Enable
When set, this bit indicates that the Source and Destination Port number fields for UDP frames are used for matching.
When reset, this bit indicates that the Source and Destination Port number fields for TCP frames are used for matching.
The Layer 4 matching is done only when either L4SPM0 or L4DPM0 bit is set high.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3HDBM0</name>
                <description>Layer 3 IP DA Higher Bits Match
 IPv4 Frames: This field contains the number of higher bits of IP Destination Address that are matched in the IPv4 frames. The following list describes the values of this field:
- 0: No bits are masked.
- 1: LSb[0] is masked.
- 2: Two LSbs [1:0] are masked. - ...
- 31: All bits except MSb are masked. IPv6 Frames: Bits [12:11] of this field correspond to Bits [6:5] of L3HSBM0,
which indicate the number of lower bits of IP Source or Destination Address that are masked in the IPv6 frames.
The following list describes the concatenated values of the L3HDBM0[1:0] and L3HSBM0 bits:
- 0: No bits are masked.
- 1: LSb[0] is masked.
- 2: Two LSbs [1:0] are masked. - …
- 127: All bits except MSb are masked. This field is valid and applicable only if L3DAM0 or L3SAM0 is set high.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3HSBM0</name>
                <description>Layer 3 IP SA Higher Bits Match
 IPv4 Frames: This field contains the number of lower bits of IP Source Address that are masked for matching in the IPv4 frames. The following list describes the values of this field:
- 0: No bits are masked.
- 1: LSb[0] is masked.
- 2: Two LSbs [1:0] are masked. - ...
- 31: All bits except MSb are masked. IPv6 Frames: This field contains Bits [4:0] of the field that indicates the number of higher bits of IP Source or Destination Address matched in the IPv6 frames.
This field is valid and applicable only if L3DAM0 or L3SAM0 is set high.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3DAIM0</name>
                <description>Layer 3 IP DA Inverse Match Enable
When set, this bit indicates that the Layer 3 IP Destination Address field is enabled for inverse matching.
When reset, this bit indicates that the Layer 3 IP Destination Address field is enabled for perfect matching. This bit is valid and applicable only when Bit 4 (L3DAM0) is set high.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3DAM0</name>
                <description>Layer 3 IP DA Match Enable
When set, this bit indicates that Layer 3 IP Destination Address field is enabled for matching. When reset, the MAC ignores the Layer 3 IP Destination Address field for matching.
Note: When Bit 0 (L3PEN0) is set, you should set either this bit or Bit 2 (L3SAM0) because either IPv6 DA or SA can be checked for filtering.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3SAIM0</name>
                <description>Layer 3 IP SA Inverse Match Enable
When set, this bit indicates that the Layer 3 IP Source Address field is enabled for inverse matching. When reset, this bit indicates that the Layer 3 IP Source Address field is enabled for perfect matching.
This bit is valid and applicable only when Bit 2 (L3SAM0) is set high.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3SAM0</name>
                <description>Layer 3 IP SA Match Enable
When set, this bit indicates that the Layer 3 IP Source Address field is enabled for matching. When reset, the MAC ignores the Layer 3 IP Source Address field for matching.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3PEN0</name>
                <description>Layer 3 Protocol Enable
 When set, this bit indicates that the Layer 3 IP Source or Destination Address matching is enabled for the IPv6 frames.
When reset, this bit indicates that the Layer 3 IP Source or Destination Address matching is enabled for the IPv4 frames.
The Layer 3 matching is done only when either L3SAM0 or L3DAM0 bit is set high.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L4_Addr</name>
            <description>Layer 4 Address Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L4DP0</name>
                <description>Layer 4 Destination Port Number Field
When Bit 16 (L4PEN0) is reset and Bit 20 (L4DPM0) is set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with the TCP Destination Port Number field in the IPv4 or IPv6 frames.
When Bit 16 (L4PEN0) and Bit 20 (L4DPM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with the UDP Destination Port Number field in the IPv4 or IPv6 frames.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4SP0</name>
                <description>Layer 4 Source Port Number Field
 When Bit 16 (L4PEN0) is reset and Bit 20 (L4DPM0) is set in Register 256 (Layer 3 and Layer 4 Control Register 0),
 this field contains the value to be matched with the TCP Source Port Number field in the IPv4 or IPv6 frames.
When Bit 16 (L4PEN0) and Bit 20 (L4DPM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with the UDP Source Port Number field in the IPv4 or IPv6 frames.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L3_Addr_0</name>
            <description>Layer 3 Address 0 Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L3A00</name>
                <description>Layer 3 Address 0 Field
 When Bit 0 (L3PEN0) and Bit 2 (L3SAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [31:0] of the IP Source Address field in the IPv6 frames.
When Bit 0 (L3PEN0) and Bit 4 (L3DAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [31:0] of the IP Destination Address field in the IPv6 frames.
When Bit 0 (L3PEN0) is reset and Bit 2 (L3SAM0) is set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with the IP Source Address field in the IPv4 frames.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L3_Addr_1</name>
            <description>Layer 3 Address 1 Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L3A10</name>
                <description>Layer 3 Address 1 Field
 When Bit 0 (L3PEN0) and Bit 2 (L3SAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [63:32] of the IP Source Address field in the IPv6 frames.
When Bit 0 (L3PEN0) and Bit 4 (L3DAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [63:32] of the IP Destination Address field in the IPv6 frames.
When Bit 0 (L3PEN0) is reset and Bit 4 (L3DAM0) is set in Register 256 (Layer 3 and Layer 4 Control Register 0),
 this field contains the value to be matched with the IP Destination Address field in the IPv4 frames.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L3_Addr_2</name>
            <description>Layer 3 Address 2 Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L3A20</name>
                <description>Layer 3 Address 2 Field
 When Bit 0 (L3PEN0) and Bit 2 (L3SAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [95:64] of the IP Source Address field in the IPv6 frames.
When Bit 0 (L3PEN0) and Bit 4 (L3DAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains value to be matched with Bits [95:64] of the IP Destination Address field in the IPv6 frames.
When Bit 0 (L3PEN0) is reset in Register 256 (Layer 3 and Layer 4 Control Register 0), this register is not used.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L3_Addr_3</name>
            <description>Layer 3 Address 3 Register</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L3A30</name>
                <description>Layer 3 Address 3 Field When Bit 0 (L3PEN0) and Bit 2 (L3SAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [127:96] of the IP Source Address field in the IPv6 frames.
 When Bit 0 (L3PEN0) and Bit 4 (L3DAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [127:96] of the IP Destination Address field in the IPv6 frames.
When Bit 0 (L3PEN0) is reset in Register 256 (Layer 3 and Layer 4 Control Register 0), this register is not used.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>VLAN_TAG_INC_RPL</name>
          <description>VLAN Tag Inclusion or Replacement Register</description>
          <addressOffset>0x584</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>CSVL</name>
              <description>C-VLAN or S-VLAN
 When this bit is set, S-VLAN type (0x88A8) is inserted or replaced in the 13th and 14th bytes of transmitted frames. When this bit is reset, C-VLAN type (0x8100) is inserted or replaced in the transmitted frames.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VLP</name>
              <description>VLAN Priority Control
When this bit is set, the control Bits [17:16] are used for VLAN deletion, insertion, or replacement. When this bit is reset, the mti_vlan_ctrl_i control input is used, and Bits [17:16] are ignored.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VLC</name>
              <description>VLAN Tag Control in Transmit Frames
- 2’b00: No VLAN tag deletion, insertion, or replacement
- 2’b01: VLAN tag deletion The MAC removes the VLAN type (bytes 13 and 14) and VLAN tag (bytes 15 and 16) of all transmitted frames with VLAN tags.
- 2’b10: VLAN tag insertion The MAC inserts VLT in bytes 15 and 16 of the frame after inserting the Type value (0x8100/0x88a8) in bytes 13 and 14.
This operation is performed on all transmitted frames, irrespective of whether they already have a VLAN tag.
- 2’b11: VLAN tag replacement The MAC replaces VLT in bytes 15 and 16 of all VLAN-type transmitted frames (Bytes 13 and 14 are 0x8100/0x88a8).
Note: Changes to this field take effect only on the start of a frame.
If you write this register field when a frame is being transmitted, only the subsequent frame can use the updated value, that is, the current frame does not use the updated value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VLT</name>
              <description>VLAN Tag for Transmit Frames
 This field contains the value of the VLAN tag to be inserted or replaced. The value must only be changed when the transmit lines are inactive or during the initialization phase.
 Bits[15:13] are the User Priority, Bit 12 is the CFI/DEI, and Bits[11:0] are the VLAN tag’s VID field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VLAN_HASH</name>
          <description>VLAN Hash Table Register</description>
          <addressOffset>0x588</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>VLHT</name>
              <description>VLAN Hash Table
 This field contains the 16-bit VLAN Hash Table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTRL</name>
          <description>Timestamp Control Register</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F07FF3F</resetMask>
          <fields>
            <field>
              <name>ATSEN3</name>
              <description>Auxiliary Snapshot 3 Enable
This field controls capturing the Auxiliary Snapshot Trigger 3. When this bit is set, the Auxiliary snapshot of event on ptp_aux_trig_i[3] input is enabled. When this bit is reset, the events on this input are ignored.
This bit is reserved when the Add IEEE 1588 Auxiliary Snapshot option is not selected during core configuration or the selected number in the Number of IEEE 1588 Auxiliary Snapshot Inputs option is less than four.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSEN2</name>
              <description>Auxiliary Snapshot 2 Enable
This field controls capturing the Auxiliary Snapshot Trigger 2. When this bit is set, the Auxiliary snapshot of event on ptp_aux_trig_i[2] input is enabled. When this bit is reset, the events on this input are ignored.
This bit is reserved when the Add IEEE 1588 Auxiliary Snapshot option is not selected during core configuration or the selected number in the Number of IEEE 1588 Auxiliary Snapshot Inputs option is less than three.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSEN1</name>
              <description>Auxiliary Snapshot 1 Enable
This field controls capturing the Auxiliary Snapshot Trigger 1. When this bit is set, the Auxiliary snapshot of event on ptp_aux_trig_i[1] input is enabled. When this bit is reset, the events on this input are ignored.
This bit is reserved when the Add IEEE 1588 Auxiliary Snapshot option is not selected during core configuration or the selected number in the Number of IEEE 1588 Auxiliary Snapshot Inputs option is less than two.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSEN0</name>
              <description>Auxiliary Snapshot 0 Enable
This field controls capturing the Auxiliary Snapshot Trigger 0. When this bit is set, the Auxiliary snapshot of event on ptp_aux_trig_i[0] input is enabled. When this bit is reset, the events on this input are ignored.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSFC</name>
              <description>Auxiliary Snapshot FIFO Clear
When set, it resets the pointers of the Auxiliary Snapshot FIFO. This bit is cleared when the pointers are reset and the FIFO is empty. When this bit is high, auxiliary snapshots get stored in the FIFO.
This bit is reserved when the Add IEEE 1588 Auxiliary Snapshot option is not selected during core configuration.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSENMACADDR</name>
              <description>Enable MAC address for PTP Frame Filtering
When set, the DA MAC address (that matches any MAC Address register) is used to filter the PTP frames when PTP is directly sent over Ethernet.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAPTYPSEL</name>
              <description>Select PTP packets for Taking Snapshots
 These bits along with Bits 15 and 14 decide the set of PTP packet types for which snapshot needs to be taken.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSMSTRENA</name>
              <description>Enable Snapshot for Messages Relevant to Master
When set, the snapshot is taken only for the messages relevant to the master node. Otherwise, the snapshot is taken for the messages relevant to the slave node.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSEVNTENA</name>
              <description>Enable Timestamp Snapshot for Event Messages
When set, the timestamp snapshot is taken only for event messages (SYNC, Delay_Req, Pdelay_Req, or Pdelay_Resp). When reset, the snapshot is taken for all messages except Announce, Management, and Signaling.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSIPV4ENA</name>
              <description>Enable Processing of PTP Frames Sent over IPv4-UDP
 When set, the MAC receiver processes the PTP packets encapsulated in UDP over IPv4 packets. When this bit is clear, the MAC ignores the PTP transported over UDP-IPv4 packets. This bit is set by default.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSIPV6ENA</name>
              <description>Enable Processing of PTP Frames Sent over IPv6-UDP
When set, the MAC receiver processes PTP packets encapsulated in UDP over IPv6 packets. When this bit is clear, the MAC ignores the PTP transported over UDP-IPv6 packets.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSIPENA</name>
              <description>Enable Processing of PTP over Ethernet Frames
When set, the MAC receiver processes the PTP packets encapsulated directly in the Ethernet frames. When this bit is clear, the MAC ignores the PTP over Ethernet packets</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSVER2ENA</name>
              <description>Enable PTP packet Processing for Version 2 Format
When set, the PTP packets are processed using the 1588 version 2 format. Otherwise, the PTP packets are processed using the version 1 format.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSCTRLSSR</name>
              <description>Timestamp Digital or Binary Rollover Control
When set, the Timestamp Low register rolls over after 0x3B9A_C9FF value (that is, 1 nanosecond accuracy) and increments the timestamp (High) seconds.
 When reset, the rollover value of sub-second register is 0x7FFF_FFFF.
The sub-second increment has to be programmed correctly depending on the PTP reference clock frequency and the value of this bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSENALL</name>
              <description>Enable Timestamp for All Frames
When set, the timestamp snapshot is enabled for all frames received by the MAC.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSADDREG</name>
              <description>Addend Reg Update
When set, the content of the Timestamp Addend register is updated in the PTP block for fine correction. This is cleared when the update is completed.
This register bit should be zero before setting it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSTRIG</name>
              <description>Timestamp Interrupt Trigger Enable
When set, the timestamp interrupt is generated when the System Time becomes greater than the value written in the Target Time register.
This bit is reset after the generation of the Timestamp Trigger Interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSUPDT</name>
              <description>Timestamp Update
When set, the system time is updated (added or subtracted) with the value specified in Register 452 (System Time – Seconds Update Register)
and Register 453 (System Time – Nanoseconds Update Register). This bit should be read zero before updating it.
This bit is reset when the update is completed in hardware. The “Timestamp Higher Word” register (if enabled during core configuration) is not updated.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSINIT</name>
              <description>Timestamp Initialize
When set, the system time is initialized (overwritten) with the value specified in the Register 452 (System Time – Seconds Update Register)
and Register 453 (System Time – Nanoseconds Update Register). This bit should be read zero before updating it.
This bit is reset when the initialization is complete.
The “Timestamp Higher Word” register (if enabled during core configuration) can only be initialized.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSCFUPDT</name>
              <description>Timestamp Fine or Coarse Update
When set, this bit indicates that the system times update should be done using the fine update method. When reset, it indicates the system timestamp update should be done using the Coarse method.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSENA</name>
              <description>Timestamp Enable
When set, the timestamp is added for the transmit and receive frames. When disabled, timestamp is not added for the transmit and receive frames and the Timestamp Generator is also suspended.
You need to initialize the Timestamp (system time) after enabling this mode. On the receive side, the MAC processes the 1588 frames only if this bit is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SUB_SEC_INCR</name>
          <description>Sub-Second Increment Register</description>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>SSINC</name>
              <description>Sub-second Increment Value
The value programmed in this field is accumulated every clock cycle (of clk_ptp_i) with the contents of the sub-second register.
For example, when PTP clock is 50 MHz (period is 20 ns), you should program 20 (0x14)
when the System Time- Nanoseconds register has an accuracy of 1 ns [Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register)].
When TSCTRLSSR is clear, the Nanoseconds register has a resolution of ~0.465ns.
In this case, you should program a value of 43 (0x2B) that is derived by 20ns/0.465.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYST_SEC</name>
          <description>System Time - Seconds Register</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSS</name>
              <description>Timestamp Second
 The value in this field indicates the current value in seconds of the System Time maintained by the MAC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYST_NSEC</name>
          <description>System Time - Nanoseconds Register</description>
          <addressOffset>0x70c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSSS</name>
              <description>Timestamp Sub Seconds
 The value in this field has the sub second representation of time, with an accuracy of 0.46 ns.
When Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register), each bit represents 1 ns and the maximum value is 0x3B9A_C9FF, after which it rolls-over to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYST_SEC_UPD</name>
          <description>System Time - Seconds Update Register</description>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSS</name>
              <description>Timestamp Second
 The value in this field indicates the time in seconds to be initialized or added to the system time.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYST_NSEC_UPD</name>
          <description>System Time - Nanoseconds Update Register</description>
          <addressOffset>0x714</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDSUB</name>
              <description>Add or Subtract Time
 When this bit is set, the time value is subtracted with the contents of the update register. When this bit is reset, the time value is added with the contents of the update register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSSS</name>
              <description>Timestamp Sub Seconds
The value in this field has the sub second representation of time, with an accuracy of 0.46 ns.
When Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register), each bit represents 1 ns and the programmed value should not exceed 0x3B9A_C9FF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_ADDEND</name>
          <description>Timestamp Addend Register</description>
          <addressOffset>0x718</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSAR</name>
              <description>Timestamp Addend Register
This field indicates the 32-bit time value to be added to the Accumulator register to achieve time synchronization.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TGTTM_SEC</name>
          <description>Target Time Seconds Register</description>
          <addressOffset>0x71c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSTR</name>
              <description>Target Time Seconds Register
 This register stores the time in seconds.
When the timestamp value matches or exceeds both Target Timestamp registers,
then based on Bits [6:5] of Register 459 (PPS Control Register), the MAC starts or stops the PPS signal output and generates an interrupt (if enabled).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TGTTM_NSEC</name>
          <description>Target Time Nanoseconds Register</description>
          <addressOffset>0x720</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGTBUSY</name>
              <description>Target Time Register Busy
 The MAC sets this bit when the PPSCMD field (Bit [3:0]) in Register 459 (PPS Control Register) is programmed to 010 or 011.
Programming the PPSCMD field to 010 or 011, instructs the MAC to synchronize the Target Time Registers to the PTP clock domain.
The MAC clears this bit after synchronizing the Target Time Registers to the PTP clock domain
The application must not update the Target Time Registers when this bit is read as 1.
Otherwise, the synchronization of the previous programmed time gets corrupted. This bit is reserved when the Enable Flexible Pulse-Per-Second Output feature is not selected.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TTSLO</name>
              <description>Target Timestamp Low Register
This register stores the time in (signed) nanoseconds.
When the value of the timestamp matches the both Target Timestamp registers,
then based on the TRGTMODSEL0 field (Bits [6:5]) in Register 459 (PPS Control Register),
the MAC starts or stops the PPS signal output and generates an interrupt (if enabled).
This value should not exceed 0x3B9A_C9FF when Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register).
The actual start or stop time of the PPS signal output may have an error margin up to one unit of sub-second increment value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTM_H_SEC</name>
          <description>System Time - Higher Word Seconds Register</description>
          <addressOffset>0x724</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TSHWR</name>
              <description>Timestamp Higher Word Register
This field contains the most significant 16-bits of the timestamp seconds value. This register is optional and can be selected using the Enable IEEE 1588 Higher Word Register option during core configuration.
The register is directly written to initialize the value. This register is incremented when there is an overflow from the 32-bits of the System Time - Seconds register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_STATUS</name>
          <description>Timestamp Status Register</description>
          <addressOffset>0x728</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F0F03FF</resetMask>
          <fields>
            <field>
              <name>ATSNS</name>
              <description>Number of Auxiliary Timestamp Snapshots
This field indicates the number of Snapshots available in the FIFO. A value equal to the selected depth of FIFO (4, 8, or 16) indicates that the Auxiliary Snapshot FIFO is full.
These bits are cleared (to 00000) when the Auxiliary snapshot FIFO clear bit is set.
This bit is valid only if the Add IEEE 1588 Auxiliary Snapshot option is selected during core configuration.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ATSSTM</name>
              <description>Auxiliary Timestamp Snapshot Trigger Missed
 This bit is set when the Auxiliary timestamp snapshot FIFO is full and external trigger was set.
This indicates that the latest snapshot is not stored in the FIFO. This bit is valid only if the Add IEEE 1588 Auxiliary Snapshot option is selected during core configuration.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ATSSTN</name>
              <description>Auxiliary Timestamp Snapshot Trigger Identifier
These bits identify the Auxiliary trigger inputs for which the timestamp available in the Auxiliary Snapshot Register is applicable.
When more than one bit is set at the same time, it means that corresponding auxiliary triggers were sampled at the same clock.
These bits are applicable only if the number of Auxiliary snapshots is more than one.
One bit is assigned for each trigger as shown in the following list:
- Bit 16: Auxiliary trigger 0
- Bit 17: Auxiliary trigger 1
- Bit 18: Auxiliary trigger 2
- Bit 19: Auxiliary trigger 3
 The software can read this register to find the triggers that are set when the timestamp is taken.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTRGTERR3</name>
              <description>Timestamp Target Time Error
This bit is set when the target time, being programmed in Register 496 and Register 497, is already elapsed. This bit is cleared when read by the application.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTARGT3</name>
              <description>Timestamp Target Time Reached for Target Time PPS3
When set, this bit indicates that the value of system time is greater than or equal to the value specified in Register 496 (PPS3 Target Time High Register) and Register 497 (PPS3 Target Time Low Register).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTRGTERR2</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTARGT2</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTRGTERR1</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTARGT1</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTRGTERR</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AUXTSTRIG</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTARGT</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSSOVF</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PPS_CTRL</name>
          <description>PPS Control Register</description>
          <addressOffset>0x72c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x6767677F</resetMask>
          <fields>
            <field>
              <name>TRGTMODSEL3</name>
              <description>Target Time Register Mode for PPS3 Output
This field indicates the Target Time registers (register 496 and 497) mode for PPS3 output signal. This field is similar to the TRGTMODSEL0 field.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSCMD3</name>
              <description>Flexible PPS3 Output Control
This field controls the flexible PPS3 output (ptp_pps_o[3]) signal. This field is similar to PPSCMD0[2:0] in functionality.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TRGTMODSEL2</name>
              <description>Target Time Register Mode for PPS2 Output
This field indicates the Target Time registers (register 488 and 489) mode for PPS2 output signal. This field is similar to the TRGTMODSEL0 field.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSCMD2</name>
              <description>Flexible PPS2 Output Control
This field controls the flexible PPS2 output (ptp_pps_o[2]) signal. This field is similar to PPSCMD0[2:0] in functionality.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TRGTMODSEL1</name>
              <description>Target Time Register Mode for PPS1 Output
This field indicates the Target Time registers (register 480 and 481) mode for PPS1 output signal. This field is similar to the TRGTMODSEL0 field.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSCMD1</name>
              <description>Flexible PPS1 Output Control
This field controls the flexible PPS1 output (ptp_pps_o[1]) signal. This field is similar to PPSCMD0[2:0] in functionality.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TRGTMODSEL0</name>
              <description>Target Time Register Mode for PPS0 Output
 This field indicates the Target Time registers (register 455 and 456) mode for PPS0 output signal:
- 00: Indicates that the Target Time registers are programmed only for generating the interrupt event.
- 01: Reserved
- 10: Indicates that the Target Time registers are programmed for generating the interrupt event and starting or stopping the generation of the PPS0 output signal.
- 11: Indicates that the Target Time registers are programmed only for starting or stopping the generation of the PPS0 output signal. No interrupt is asserted.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSEN0</name>
              <description>Flexible PPS Output Mode Enable
When set low, Bits [3:0] function as PPSCTRL (backward compatible). When set high, Bits[3:0] function as PPSCMD.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSCTRLCMD0</name>
              <description>PPSCTRL0: PPS0 Output Frequency Control
This field controls the frequency of the PPS0 output (ptp_pps_o[0]) signal.
The default value of PPSCTRL is 0000, and the PPS output is 1 pulse (of width clk_ptp_i) every second.
For other values of PPSCTRL, the PPS output becomes a generated clock of following frequencies:
- 0001: The binary rollover is 2 Hz, and the digital rollover is 1 Hz.
- 0010: The binary rollover is 4 Hz, and the digital rollover is 2 Hz.
- 0011: The binary rollover is 8 Hz, and the digital rollover is 4 Hz.
- 0100: The binary rollover is 16 Hz, and the digital rollover is 8 Hz. - ...
- 1111: The binary rollover is 32.768 KHz, and the digital rollover is 16.384 KHz.
Note: In the binary rollover mode, the PPS output (ptp_pps_o) has a duty cycle of 50 percent with these frequencies.
In the digital rollover mode, the PPS output frequency is an average number.
The actual clock is of different frequency that gets synchronized every second. For example:
- When PPSCTRL = 0001, the PPS (1 Hz) has a low period of 537 ms and a high period of 463 ms
- When PPSCTRL = 0010, the PPS (2 Hz) is a sequence of:
  - One clock of 50 percent duty cycle and 537 ms period
  - Second clock of 463 ms period (268 ms low and 195 ms high)
- When PPSCTRL = 0011, the PPS (4 Hz) is a sequence of:
  - Three clocks of 50 percent duty cycle and 268 ms period
  - Fourth clock of 195 ms period (134 ms low and 61 ms high)
PPSCMD0: Flexible PPS0 Output Control
0000: No Command
0001: START Single Pulse
This command generates single pulse rising at the start point defined in
Target Time Registers and of a duration defined
in the PPS0 Width Register.
0010: START Pulse Train
This command generates the train of pulses rising at the start point
defined in the Target Time Registers and of a duration defined in the
PPS0 Width Register and repeated at interval defined in the PPS
Interval Register. By default, the PPS pulse train is free-running unless
stopped by ‘STOP Pulse train at time’ or ‘STOP Pulse Train
immediately’ commands.
0011: Cancel START
This command cancels the START Single Pulse and START Pulse Train
commands if the system time has not crossed the programmed start
time.
0100: STOP Pulse train at time
This command stops the train of pulses initiated by the START Pulse
Train command (PPSCMD = 0010) after the time programmed in the
Target Time registers elapses.
0101: STOP Pulse Train immediately
This command immediately stops the train of pulses initiated by the
START Pulse Train command (PPSCMD = 0010).
0110: Cancel STOP Pulse train
This command cancels the STOP pulse train at time command if the
programmed stop time has not elapsed. The PPS pulse train becomes
free-running on the successful execution of this command.
0111-1111: Reserved
Note: These bits get cleared automatically</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUX_TS_NSEC</name>
          <description>Auxiliary Timestamp - Nanoseconds Register</description>
          <addressOffset>0x730</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUXTSLO</name>
              <description>Contains the lower 31 bits (nano-seconds field) of the auxiliary timestamp.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUX_TS_SEC</name>
          <description>Auxiliary Timestamp - Seconds Register</description>
          <addressOffset>0x734</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUXTSHI</name>
              <description>Contains the lower 32 bits of the Seconds field of the auxiliary timestamp.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PPS0_INTERVAL</name>
          <description>PPS Interval Register</description>
          <addressOffset>0x760</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPSINT</name>
              <description>PPS0 Output Signal Interval
These bits store the interval between the rising edges of PPS0 signal output in terms of units of sub-second increment value.
You need to program one value less than the required interval.
For example, if the PTP reference clock is 50 MHz (period of 20ns),
and desired interval between rising edges of PPS0 signal output is 100ns
 (that is, five units of sub-second increment value), then you should program value 4 (5 – 1) in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PPS0_WIDTH</name>
          <description>PPS Width Register</description>
          <addressOffset>0x764</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPSWIDTH</name>
              <description>PPS0 Output Signal Width
These bits store the width between the rising edge and corresponding falling edge of the PPS0 signal output in terms of units of sub-second increment value.
You need to program one value less than the required interval.
For example, if PTP reference clock is 50 MHz (period of 20ns),
and desired width between the rising and corresponding falling edges of PPS0 signal output is 80ns
 (that is, four units of sub-second increment value), then you should program value 3 (4 – 1) in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>1,2,3</dimIndex>
          <name>PPS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x780</addressOffset>
          <register>
            <name>TGTTM_SEC</name>
            <description>PPS Target Time Seconds Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSTRH1</name>
                <description>PPS1 Target Time Seconds Register
This register stores the time in seconds.
When the timestamp value matches or exceeds both Target Timestamp registers,
then based on Bits [14:13], TRGTMODSEL1, of Register 459 (PPS Control Register),
the MAC starts or stops the PPS signal output and generates an interrupt (if enabled).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TGTTM_NSEC</name>
            <description>PPS Target Time Nanoseconds Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRGTBUSY1</name>
                <description>PPS1 Target Time Register Busy
The MAC sets this bit when the PPSCMD1 field (Bits [10:8]) in Register 459 (PPS Control Register) is programmed to 010 or 011.
Programming the PPSCMD1 field to 010 or 011 instructs the MAC to synchronize the Target Time Registers to the PTP clock domain.
The MAC clears this bit after synchronizing the Target Time Registers to the PTP clock domain
The application must not update the Targeers wht Time Registen this bit is read as 1.
Otherwise, the synchronization of the previous programmed time gets corrupted.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TTSL1</name>
                <description>Target Time Low for PPS1 Register
This register stores the time in (signed) nanoseconds.
When the value of the timestamp matches the both Target Timestamp registers,
then based on the TRGTMODSEL1 field (Bits [14:13]) in Register 459 (PPS Control Register),
 the MAC starts or stops the PPS signal output and generates an interrupt (if enabled).
 This value should not exceed 0x3B9A_C9FF when Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register).
The actual start or stop time of the PPS signal output may have an error margin up to one unit of sub-second increment value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>31</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTERVAL</name>
            <description>PPS Interval Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PPSINT</name>
                <description>PPS1 Output Signal Interval
These bits store the interval between the rising edges of PPS1 signal output in terms of units of sub-second increment value.
You need to program one value less than the required interval. For example, if the PTP reference clock is 50 MHz (period of 20ns),
 and desired interval between rising edges of PPS1 signal output is 100ns (that is, five units of sub-second increment value),
then you should program value 4 (5 – 1) in this register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WIDTH</name>
            <description>PPS Width Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PPSWIDTH</name>
                <description>PPS1 Output Signal Width
These bits store the width between the rising edge and corresponding falling edge of the PPS1 signal output in terms of units of sub-second increment value.
You need to program one value less than the required interval. For example,
 if PTP reference clock is 50 MHz (period of 20ns),
and desired width between the rising and corresponding falling edges of PPS1 signal output is 80ns (that is, four units of sub-second increment value),
then you should program value 3 (4 – 1) in this register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DMA_BUS_MODE</name>
          <description>Bus Mode Register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xBFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RIB</name>
              <description>Rebuild INCRx Burst
When this bit is set high and the AHB master gets an EBT (Retry, Split, or Losing bus grant),
 the AHB master interface rebuilds the pending beats of any burst transfer initiated with INCRx.
The AHB master interface rebuilds the beats with a combination of specified bursts with INCRx and SINGLE.
By default, the AHB master interface rebuilds pending beats of an EBT with an unspecified (INCR) burst.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRWG</name>
              <description>Channel Priority
Weights This field sets the priority weights for Channel 0 during the round-robin arbitration between the DMA channels for the system bus.
- 00: The priority weight is 1.
- 01: The priority weight is 2.
- 10: The priority weight is 3.
- 11: The priority weight is 4. This field is present in all DWC_gmac configurations except GMAC-AXI when you select the AV feature. Otherwise, this field is reserved and read-only (RO).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXPR</name>
              <description>Transmit Priority
When set, this bit indicates that the transmit DMA has higher priority than the receive DMA during arbitration for the system-side bus. In the GMAC-AXI configuration, this bit is reserved and read-only (RO).</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MB</name>
              <description>Mixed Burst
When this bit is set high and the FB bit is low, the AHB master interface starts all bursts of length more than 16 with INCR (undefined burst),
whereas it reverts to fixed burst transfers (INCRx and SINGLE) for burst length of 16 and less.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAL</name>
              <description>Address-Aligned Beats
When this bit is set high and the FB bit is equal to 1,
the AHB or AXI interface generates all bursts aligned to the start address LS bits. If the FB bit is equal to 0,
 the first burst (accessing the start address of data buffer) is not aligned, but subsequent bursts are aligned to the address.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PBLX8</name>
              <description>PBLx8 Mode
When set high, this bit multiplies the programmed PBL value (Bits [22:17] and Bits[13:8]) eight times.
Therefore, the DMA transfers the data in 8, 16, 32, 64, 128, and 256 beats depending on the PBL value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USP</name>
              <description>Use Separate PBL
When set high, this bit configures the Rx DMA to use the value configured in Bits [22:17] as PBL.
The PBL value in Bits [13:8] is applicable only to the Tx DMA operations.
When reset to low, the PBL value in Bits [13:8] is applicable for both DMA engines.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RPBL</name>
              <description>Rx DMA PBL
This field indicates the maximum number of beats to be transferred in one Rx DMA transaction.
This is the maximum value that is used in a single block Read or Write.
The Rx DMA always attempts to burst as specified in the RPBL bit each time it starts a Burst transfer on the host bus.
 You can program RPBL with values of 1, 2, 4, 8, 16, and 32. Any other value results in undefined behavior.
This field is valid and applicable only when USP is set high.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FB</name>
              <description>Fixed Burst
 This bit controls whether the AHB or AXI master interface performs fixed burst transfers or not.
When set, the AHB interface uses only SINGLE, INCR4, INCR8, or INCR16 during start of the normal burst transfers.
When reset, the AHB or AXI interface uses SINGLE and INCR burst transfer operations.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PR</name>
              <description>Priority Ratio
 These bits control the priority ratio in the weighted round-robin arbitration between the Rx DMA and Tx DMA.
 These bits are valid only when Bit 1 (DA) is reset. The priority ratio is Rx:Tx or Tx:Rx depending on whether Bit 27 (TXPR) is reset or set.
- 00: The Priority Ratio is 1:1.
- 01: The Priority Ratio is 2:1.
- 10: The Priority Ratio is 3:1.
- 11: The Priority Ratio is 4:1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PBL</name>
              <description>Programmable Burst Length
These bits indicate the maximum number of beats to be transferred in one DMA transaction.
This is the maximum value that is used in a single block Read or Write.
The DMA always attempts to burst as specified in PBL each time it starts a Burst transfer on the host bus.
PBL can be programmed with permissible values of 1, 2, 4, 8, 16, and 32.
Any other value results in undefined behavior. When USP is set high, this PBL value is applicable only for Tx DMA transactions.
If the number of beats to be transferred is more than 32, then perform the following steps: 1. Set the PBLx8 mode. 2. Set the PBL.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATDS</name>
              <description>Alternate Descriptor Size
When set, the size of the alternate descriptor (described in “Alternate or Enhanced Descriptors” on page 545) increases to 32 bytes (8 DWORDS).
This is required when the Advanced Timestamp feature or the IPC Full Checksum Offload Engine (Type 2) is enabled in the receiver.
The enhanced descriptor is not required if the Advanced Timestamp and IPC Full Checksum Offload Engine (Type 2) features are not enabled.
 In such case, you can use the 16 bytes descriptor to save 4 bytes of memory.
This bit is present only when you select the Alternate Descriptor feature and any one of the following features during core configuration:
- Advanced Timestamp feature - IPC Full Checksum Offload Engine (Type 2) feature Otherwise, this bit is reserved and is read-only.
When reset, the descriptor size reverts back to 4 DWORDs (16 bytes).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSL</name>
              <description>Descriptor Skip Length
This bit specifies the number of Word, Dword, or Lword (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between two unchained descriptors.
The address skipping starts from the end of current descriptor to the start of next descriptor.
When the DSL value is equal to zero, the descriptor table is taken as contiguous by the DMA in Ring mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DA</name>
              <description>DMA Arbitration Scheme
This bit specifies the arbitration scheme between the transmit and receive paths of Channel 0.
- 0: Weighted round-robin with Rx:Tx or Tx:Rx The priority between the paths is according to the priority specified in Bits [15:14] (PR) and priority weights specified in Bit 27 (TXPR).
- 1: Fixed priority The transmit path has priority over receive path when Bit 27 (TXPR) is set. Otherwise, receive path has priority over the transmit path.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWR</name>
              <description>Software Reset
 When this bit is set, the MAC DMA Controller resets the logic and all internal registers of the MAC.
It is cleared automatically after the reset operation is complete in all of the DWC_gmac clock domains.
Before reprogramming any register of the DWC_gmac, you should read a zero (0) value in this bit.
Note: - The Software reset function is driven only by this bit.
Bit 0 of Register 64 (Channel 1 Bus Mode Register) or Register 128 (Channel 2 Bus Mode Register) has no impact on the Software reset function.
- The reset operation is completed only when all resets in all active clock domains are de-asserted.
Therefore, it is essential that all PHY inputs clocks (applicable for the selected PHY interface) are present for the software reset completion.
The time to complete the software reset operation depends on the frequency of the slowest active clock.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_TX_POLL_DEMAND</name>
          <description>Transmit Poll Demand Register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPD</name>
              <description>Transmit Poll Demand
When these bits are written with any value,
the DMA reads the current descriptor to which the Register 18 (Current Host Transmit Descriptor Register) is pointing.
 If that descriptor is not available (owned by the Host),
the transmission returns to the Suspend state and Bit 2 (TU) of Register 5 (Status Register) is asserted.
If the descriptor is available, the transmission resumes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RX_POLL_DEMAND</name>
          <description>Receive Poll Demand Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPD</name>
              <description>Receive Poll Demand
When these bits are written with any value,
the DMA reads the current descriptor to which the Register 19 (Current Host Receive Descriptor Register) is pointing.
 If that descriptor is not available (owned by the Host),
the reception returns to the Suspended state and Bit 7 (RU) of Register 5 (Status Register) is asserted.
If the descriptor is available, the Rx DMA returns to the active state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RX_DESC_LIST_ADDR</name>
          <description>Receive Descriptor List Address Register</description>
          <addressOffset>0x100c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDESLA</name>
              <description>Start of Receive List
This field contains the base address of the first descriptor in the Receive Descriptor list.
The LSB bits (1:0, 2:0, or 3:0) for 32-bit, 64-bit, or 128-bit bus width are ignored and internally taken as all-zero by the DMA. Therefore, these LSB bits are read-only (RO).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_TX_DESC_LIST_ADDR</name>
          <description>Transmit Descriptor List Address Register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDESLA</name>
              <description>Start of Transmit List
This field contains the base address of the first descriptor in the Transmit Descriptor list.
The LSB bits (1:0, 2:0, 3:0) for 32-bit, 64-bit, or 128-bit bus width are ignored and are internally taken as all-zero by the DMA. Therefore, these LSB bits are read-only (RO).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFE7FF</resetMask>
          <fields>
            <field>
              <name>GLPII</name>
              <description>GLPII: GMAC LPI Interrupt (for Channel 0)
This bit indicates an interrupt event in the LPI logic of the MAC.
To reset this bit to 1'b0, the software must read the corresponding registers in the DWC_gmac to get the exact cause of the interrupt and clear its source.
Note: GLPII status is given only in Channel 0 DMA register and is applicable only when the Energy Efficient Ethernet feature is enabled. Otherwise, this bit is reserved.
When this bit is high, the interrupt signal from the MAC (sbd_intr_o) is high.
-or- GTMSI: GMAC TMS Interrupt (for Channel 1 and Channel 2) This bit indicates an interrupt event in the traffic manager and scheduler logic of DWC_gmac.
To reset this bit, the software must read the corresponding registers (Channel Status Register) to get the exact cause of the interrupt and clear its source.
Note: GTMSI status is given only in Channel 1 and Channel 2 DMA register when the AV feature is enabled and corresponding additional transmit channels are present.
Otherwise, this bit is reserved. When this bit is high, the interrupt signal from the MAC (sbd_intr_o) is high.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TTI</name>
              <description>Timestamp Trigger Interrupt
This bit indicates an interrupt event in the Timestamp Generator block of the DWC_gmac.
The software must read the corresponding registers in the DWC_gmac to get the exact cause of the interrupt and clear its source to reset this bit to 1'b0.
 When this bit is high, the interrupt signal from the DWC_gmac subsystem (sbd_intr_o) is high.
This bit is applicable only when the IEEE 1588 Timestamp feature is enabled. Otherwise, this bit is reserved.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPI</name>
              <description>GMAC PMT Interrupt
This bit indicates an interrupt event in the PMT module of the DWC_gmac.
 The software must read the PMT Control and Status Register in the MAC to get the exact cause of interrupt and clear its source to reset this bit to 1’b0.
The interrupt signal from the DWC_gmac subsystem (sbd_intr_o) is high when this bit is high.
This bit is applicable only when the Power Management feature is enabled.
Otherwise, this bit is reserved. Note: The GPI and pmt_intr_o interrupts are generated in different clock domains.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GMI</name>
              <description>GMAC MMC Interrupt
 This bit reflects an interrupt event in the MMC module of the DWC_gmac.
The software must read the corresponding registers in the DWC_gmac
to get the exact cause of the interrupt and clear the source of interrupt to make this bit as 1’b0.
The interrupt signal from the DWC_gmac subsystem (sbd_intr_o) is high when this bit is high.
This bit is applicable only when the MAC Management Counters (MMC) are enabled. Otherwise, this bit is reserved.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GLI</name>
              <description>GMAC Line Interface Interrupt
When set, this bit reflects any of the following interrupt events in the DWC_gmac interfaces (if present and enabled in your configuration):
- PCS (TBI, RTBI, or SGMII): Link change or auto-negotiation complete event
- SMII or RGMII: Link change event - General Purpose Input Status (GPIS):
     Any LL or LH event on the gpi_i input ports To identify the exact cause of the interrupt,
    the software must first read Bit 11 and Bits[2:0] of Register 14 (Interrupt Status Register) and then to clear the source of interrupt (which also clears the GLI interrupt),
     read any of the following corresponding registers:
- PCS (TBI, RTBI, or SGMII): Register 49 (AN Status Register)
- SMII or RGMII: Register 54 (SGMII/RGMII/SMII Control and Status Register)
- General Purpose Input (GPI): Register 56 (General Purpose IO Register) The interrupt signal from the DWC_gmac subsystem (sbd_intr_o) is high when this bit is high.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EB</name>
              <description>Error Bits
This field indicates the type of error that caused a Bus Error, for example, error response on the AHB or AXI interface.
 This field is valid only when Bit 13 (FBI) is set. This field does not generate an interrupt.
- 0 0 0: Error during Rx DMA Write Data Transfer
- 0 1 1: Error during Tx DMA Read Data Transfer
- 1 0 0: Error during Rx DMA Descriptor Write Access
- 1 0 1: Error during Tx DMA Descriptor Write Access
- 1 1 0: Error during Rx DMA Descriptor Read Access
- 1 1 1: Error during Tx DMA Descriptor Read Access Note: 001 and 010 are reserved.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TS</name>
              <description>Transmit Process State
This field indicates the Transmit DMA FSM state. This field does not generate an interrupt.
- 3’b000: Stopped; Reset or Stop Transmit Command issued
- 3’b001: Running; Fetching Transmit Transfer Descriptor
- 3’b010: Running; Waiting for status
- 3’b011: Running; Reading Data from host memory buffer and queuing it to transmit buffer (Tx FIFO)
- 3’b100: TIME_STAMP write state
- 3’b101: Reserved for future use
- 3’b110: Suspended; Transmit Descriptor Unavailable or Transmit Buffer Underflow
- 3’b111: Running; Closing Transmit Descriptor</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RS</name>
              <description>Receive Process State
This field indicates the Receive DMA FSM state. This field does not generate an interrupt.
- 3’b000: Stopped: Reset or Stop Receive Command issued
- 3’b001: Running: Fetching Receive Transfer Descriptor
- 3’b010: Reserved for future use
- 3’b011: Running: Waiting for receive packet
- 3’b100: Suspended: Receive Descriptor Unavailable
- 3’b101: Running: Closing Receive Descriptor
- 3’b110: TIME_STAMP write state
- 3’b111: Running: Transferring the receive packet data from receive buffer to host memory</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NIS</name>
              <description>Normal Interrupt Summary
Normal Interrupt Summary bit value is the logical OR of the following bits when the corresponding interrupt bits are enabled in
Register 7 (Interrupt Enable Register):
- Register 5[0]: Transmit Interrupt
- Register 5[2]: Transmit Buffer Unavailable
- Register 5[6]: Receive Interrupt
- Register 5[14]: Early Receive Interrupt Only unmasked bits
 (interrupts for which interrupt enable is set in Register 7) affect the Normal Interrupt Summary bit.
 This is a sticky bit and must be cleared (by writing 1 to this bit) each time a corresponding bit, which causes NIS to be set, is cleared.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AIS</name>
              <description>Abnormal Interrupt Summary
Abnormal Interrupt Summary bit value is the logical OR of the following
when the corresponding interrupt bits are enabled in Register 7 (Interrupt Enable Register):
- Register 5[1]: Transmit Process Stopped
- Register 5[3]: Transmit Jabber Timeout
- Register 5[4]: Receive FIFO Overflow
- Register 5[5]: Transmit Underflow
- Register 5[7]: Receive Buffer Unavailable
- Register 5[8]: Receive Process Stopped
- Register 5[9]: Receive Watchdog Timeout
- Register 5[10]: Early Transmit Interrupt
- Register 5[13]: Fatal Bus Error Only unmasked bits affect the Abnormal Interrupt Summary bit.
This is a sticky bit and must be cleared (by writing 1 to this bit) each time a corresponding bit, which causes AIS to be set, is cleared.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERI</name>
              <description>Early Receive Interrupt
This bit indicates that the DMA filled the first data buffer of the packet. This bit is cleared when the software writes 1 to this bit or Bit 6 (RI) of this register is set (whichever occurs earlier).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FBI</name>
              <description>Fatal Bus Error Interrupt
This bit indicates that a bus error occurred, as described in Bits [25:23]. When this bit is set, the corresponding DMA engine disables all of its bus accesses.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETI</name>
              <description>Early Transmit Interrupt
This bit indicates that the frame to be transmitted is fully transferred to the MTL Transmit FIFO.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWT</name>
              <description>Receive Watchdog Timeout
When set, this bit indicates that the Receive Watchdog Timer expired while receiving the current frame and the current frame is truncated after the watchdog timeout.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RPS</name>
              <description>Receive Process Stopped
This bit is asserted when the Receive Process enters the Stopped state.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RU</name>
              <description>Receive Buffer Unavailable
This bit indicates that the host owns the Next Descriptor in the Receive List and the DMA cannot acquire it.
The Receive Process is suspended. To resume processing Receive descriptors,
 the host should change the ownership of the descriptor and issue a Receive Poll Demand command.
 If no Receive Poll Demand is issued, the Receive Process resumes when the next recognized incoming frame is received.
This bit is set only when the previous Receive Descriptor is owned by the DMA.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RI</name>
              <description>Receive Interrupt
This bit indicates that the frame reception is complete.
When reception is complete, the Bit 31 of RDES1 (Disable Interrupt on Completion) is reset in the last Descriptor,
and the specific frame status information is updated in the descriptor.
The reception remains in the Running state.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNF</name>
              <description>Transmit Underflow
This bit indicates that the Transmit Buffer had an Underflow during frame transmission. Transmission is suspended and an Underflow Error TDES0[1] is set.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVF</name>
              <description>Receive Overflow
This bit indicates that the Receive Buffer had an Overflow during frame reception. If the partial frame is transferred to the application, the overflow status is set in RDES0[11].</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TJT</name>
              <description>Transmit Jabber Timeout
This bit indicates that the Transmit Jabber Timer expired, which happens when the frame size exceeds 2,048 (10,240 bytes when the Jumbo frame is enabled).
When the Jabber Timeout occurs, the transmission process is aborted and placed in the Stopped state. This causes the Transmit Jabber Timeout TDES0[14] flag to assert.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TU</name>
              <description>Transmit Buffer Unavailable
This bit indicates that the host owns the Next Descriptor in the Transmit List and the DMA cannot acquire it. Transmission is suspended. Bits[22:20] explain the Transmit Process state transitions.
To resume processing Transmit descriptors, the host should change the ownership of the descriptor by setting TDES0[31] and then issue a Transmit Poll Demand command.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPS</name>
              <description>Transmit Process Stopped
This bit is set when the transmission is stopped.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TI</name>
              <description>Transmit Interrupt
This bit indicates that the frame transmission is complete. When transmission is complete, Bit 31 (OWN) of TDES0 is reset, and the specific frame status information is updated in the descriptor.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_OP_MODE</name>
          <description>Operation Mode Register</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x13F1FFFE</resetMask>
          <fields>
            <field>
              <name>DT</name>
              <description>Disable Dropping of TCP/IP Checksum Error Frames
When this bit is set, the MAC does not drop the frames which only have errors detected by the Receive Checksum Offload engine.
 Such frames do not have any errors (including FCS error) in the Ethernet frame received by the MAC but have errors only in the encapsulated payload.
When this bit is reset, all error frames are dropped if the FEF bit is reset. If the IPC Full Checksum Offload Engine (Type 2) is disabled, this bit is reserved (RO with value 1'b0).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSF</name>
              <description>Receive Store and Forward
When this bit is set, the MTL reads a frame from the Rx FIFO only after the complete frame has been written to it, ignoring the RTC bits.
 When this bit is reset, the Rx FIFO operates in the cut-through mode, subject to the threshold specified by the RTC bits.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFF</name>
              <description>Disable Flushing of Received Frames
When this bit is set, the Rx DMA does not flush any frames because of the unavailability of receive descriptors or buffers as it does normally when this bit is reset. (See “Receive Process Suspended” on page 83.)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFA_2</name>
              <description>MSB of Threshold for Activating Flow Control
If the DWC_gmac is configured for an Rx FIFO size of 8 KB or more,
this bit (when set) provides additional threshold levels for activating the flow control in both half-duplex and full-duplex modes.
This bit (as Most Significant Bit), along with the RFA (Bits [10:9]), gives the following thresholds for activating flow control:
- 100: Full minus 5 KB, that is, FULL — 5 KB
- 101: Full minus 6 KB, that is, FULL — 6 KB
- 110: Full minus 7 KB, that is, FULL — 7 KB
- 111: Reserved This bit is reserved (and RO) if the Rx FIFO is 4 KB or less deep.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFD_2</name>
              <description>MSB of Threshold for Deactivating Flow Control
If the DWC_gmac is configured for Rx FIFO size of 8 KB or more,
 this bit (when set) provides additional threshold levels for deactivating the flow control in both half-duplex and full-duplex modes.
 This bit (as Most Significant Bit) along with the RFD (Bits [12:11]) gives the following thresholds for deactivating flow control:
- 100: Full minus 5 KB, that is, FULL — 5 KB
- 101: Full minus 6 KB, that is, FULL — 6 KB
- 110: Full minus 7 KB, that is, FULL — 7 KB
- 111: Reserved This bit is reserved (and RO) if the Rx FIFO is 4 KB or less deep.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSF</name>
              <description>Transmit Store and Forward
When this bit is set, transmission starts when a full frame resides in the MTL Transmit FIFO.
When this bit is set, the TTC values specified in Bits [16:14] are ignored.
This bit should be changed only when the transmission is stopped.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FTF</name>
              <description>Flush Transmit FIFO
When this bit is set, the transmit FIFO controller logic is reset to its default values and thus all data in the Tx FIFO is lost or flushed.
This bit is cleared internally when the flushing operation is complete.
The Operation Mode register should not be written to until this bit is cleared.
The data which is already accepted by the MAC transmitter is not flushed.
It is scheduled for transmission and results in underflow and runt frame transmission.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TTC</name>
              <description>Transmit Threshold Control
These bits control the threshold level of the MTL Transmit FIFO.
 Transmission starts when the frame size within the MTL Transmit FIFO is larger than the threshold.
In addition, full frames with a length less than the threshold are also transmitted.
 These bits are used only when Bit 21 (TSF) is reset.
- 000: 64
- 001: 128
- 010: 192
- 011: 256
- 100: 40
- 101: 32
- 110: 24
- 111: 16</description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ST</name>
              <description>Start or Stop Transmission Command
When this bit is set, transmission is placed in the Running state, and the DMA checks the Transmit List at the current position for a frame to be transmitted.
Descriptor acquisition is attempted either from the current position in the list,
which is the Transmit List Base Address set by Register 4 (Transmit Descriptor List Address Register),
or from the position retained when transmission was stopped previously.
 If the DMA does not own the current descriptor,
transmission enters the Suspended state and Bit 2 (Transmit Buffer Unavailable) of Register 5 (Status Register) is set.
The Start Transmission command is effective only when transmission is stopped.
If the command is issued before setting Register 4 (Transmit Descriptor List Address Register),
 then the DMA behavior is unpredictable. When this bit is reset,
the transmission process is placed in the Stopped state after completing the transmission of the current frame.
The Next Descriptor position in the Transmit List is saved,
and it becomes the current position when transmission is restarted.
To change the list address, you need to program Register 4 (Transmit Descriptor List Address Register) with a new value when this bit is reset.
The new value is considered when this bit is set again.
The stop transmission command is effective only when the transmission of the current frame is complete or the transmission is in the Suspended state.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFD</name>
              <description>Threshold for Deactivating Flow Control (in half-duplex and full-duplex modes) These bits control the threshold (Fill-level of Rx FIFO) at which the flow control is de-asserted after activation.
- 00: Full minus 1 KB, that is, FULL — 1 KB
- 01: Full minus 2 KB, that is, FULL — 2 KB
- 10: Full minus 3 KB, that is, FULL — 3 KB
- 11: Full minus 4 KB, that is, FULL — 4 KB
The de-assertion is effective only after flow control is asserted.
 If the Rx FIFO is 8 KB or more, an additional Bit (RFD_2) is used for more threshold levels as described in Bit 22.
These bits are reserved and read-only when the Rx FIFO depth is less than 4 KB.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFA</name>
              <description>Threshold for Activating Flow Control (in half-duplex and full-duplex modes)
These bits control the threshold (Fill level of Rx FIFO) at which the flow control is activated.
- 00: Full minus 1 KB, that is, FULL—1KB.
- 01: Full minus 2 KB, that is, FULL—2KB.
- 10: Full minus 3 KB, that is, FULL—3KB.
- 11: Full minus 4 KB, that is, FULL—4KB.
These values are applicable only to Rx FIFOs of 4 KB or more and when Bit 8 (EFC) is set high. If the Rx FIFO is 8 KB or more,
an additional Bit (RFA_2) is used for more threshold levels as described in Bit 23.
These bits are reserved and read-only when the depth of Rx FIFO is less than 4 KB.
Note: When FIFO size is exactly 4 KB, although the DWC_gmac allows you to program the value of these bits to 11,
the software should not program these bits to 2'b11. The value 2'b11 means flow control on FIFO empty condition</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFC</name>
              <description>Enable HW Flow Control
When this bit is set, the flow control signal operation based on the fill-level of Rx FIFO is enabled.
When reset, the flow control operation is disabled.
 This bit is not used (reserved and always reset) when the Rx FIFO is less than 4 KB.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Forward Error Frames
When this bit is reset, the Rx FIFO drops frames with error status (CRC error, collision error, GMII_ER, giant frame, watchdog timeout, or overflow).
However, if the start byte (write) pointer of a frame is already transferred to the read controller side (in Threshold mode),
then the frame is not dropped. In the GMAC-MTL configuration in which the Frame Length FIFO is also enabled during core configuration,
the Rx FIFO drops the error frames if that frame's start byte is not transferred (output) on the ARI bus.
When the FEF bit is set, all frames except runt error frames are forwarded to the DMA.
If the Bit 25 (RSF) is set and the Rx FIFO overflows when a partial frame is written,
then the frame is dropped irrespective of the FEF bit setting.
However, if the Bit 25 (RSF) is reset and the Rx FIFO overflows when a partial frame is written, then a partial frame may be forwarded to the DMA.
Note: When FEF bit is reset, the giant frames are dropped if the giant frame status is given in Rx Status (in Table 8-6 or Table 8-23) in the following configurations:
- The IP checksum engine (Type 1) and full checksum offload engine (Type 2) are not selected.
 - The advanced timestamp feature is not selected but the extended status is selected.
The extended status is available with the following features:
- L3-L4 filter in GMAC-CORE or GMAC-MTL configurations
- Full checksum offload engine (Type 2) with enhanced descriptor format in the GMAC-DMA, GMAC-AHB, or GMAC-AXI configurations.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FUF</name>
              <description>Forward Undersized Good Frames
When set, the Rx FIFO forwards Undersized frames (that is, frames with no Error and length less than 64 bytes) including pad-bytes and CRC
When reset, the Rx FIFO drops all frames of less than 64 bytes, unless a frame is already transferred because of the lower value of Receive Threshold, for example, RTC = 01.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DGF</name>
              <description>Drop Giant Frames
When set, the MAC drops the received giant frames in the Rx FIFO,
that is, frames that are larger than the computed giant frame limit.
When reset, the MAC does not drop the giant frames in the Rx FIFO.
Note: This bit is available in the following configurations in which the giant frame status is not provided in Rx status and giant frames are not dropped by default:
- Configurations in which IP Checksum Offload (Type 1) is selected in Rx
- Configurations in which the IPC Full Checksum Offload Engine (Type 2) is selected in Rx with normal descriptor format
- Configurations in which the Advanced Timestamp feature is selected In all other configurations, this bit is not used (reserved and always reset).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC</name>
              <description>Receive Threshold Control
These two bits control the threshold level of the MTL Receive FIFO.
Transfer (request) to DMA starts when the frame size within the MTL Receive FIFO is larger than the threshold.
In addition, full frames with length less than the threshold are automatically transferred.
The value of 11 is not applicable if the configured Receive FIFO size is 128 bytes.
These bits are valid only when the RSF bit is zero, and are ignored when the RSF bit is set to 1.
- 00: 64
- 01: 32
- 10: 96
- 11: 128</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSF</name>
              <description>Operate on Second Frame
When this bit is set, it instructs the DMA to process the second frame of the Transmit data even before the status for the first frame is obtained.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SR</name>
              <description>Start or Stop Receive
When this bit is set, the Receive process is placed in the Running state.
The DMA attempts to acquire the descriptor from the Receive list and processes the incoming frames.
The descriptor acquisition is attempted from the current position in the list,
which is the address set by the Register 3 (Receive Descriptor List Address Register) or the position retained when the Receive process was previously stopped.
If the DMA does not own the descriptor, reception is suspended and Bit 7 (Receive Buffer Unavailable) of Register 5 (Status Register) is set.
The Start Receive command is effective only when the reception has stopped.
 If the command is issued before setting Register 3 (Receive Descriptor List Address Register), the DMA behavior is unpredictable.
When this bit is cleared, the Rx DMA operation is stopped after the transfer of the current frame.
The next descriptor position in the Receive list is saved and becomes the current position after the Receive process is restarted.
The Stop Receive command is effective only when the Receive process is in either the Running (waiting for receive packet) or in the Suspended state.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INTR_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x101c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001E7FF</resetMask>
          <fields>
            <field>
              <name>NIE</name>
              <description>Normal Interrupt Summary Enable
When this bit is set, normal interrupt summary is enabled.
When this bit is reset, normal interrupt summary is disabled.
This bit enables the following interrupts in Register 5 (Status Register):
 - Register 5[0]: Transmit Interrupt
- Register 5[2]: Transmit Buffer Unavailable
- Register 5[6]: Receive Interrupt
 - Register 5[14]: Early Receive Interrupt</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AIE</name>
              <description>Abnormal Interrupt Summary Enable
When this bit is set, abnormal interrupt summary is enabled.
When this bit is reset, the abnormal interrupt summary is disabled.
This bit enables the following interrupts in Register 5 (Status Register):
- Register 5[1]: Transmit Process Stopped
- Register 5[3]: Transmit Jabber Timeout
- Register 5[4]: Receive Overflow
- Register 5[5]: Transmit Underflow
- Register 5[7]: Receive Buffer Unavailable
- Register 5[8]: Receive Process Stopped
- Register 5[9]: Receive Watchdog Timeout
- Register 5[10]: Early Transmit Interrupt
 - Register 5[13]: Fatal Bus Error</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERE</name>
              <description>Early Receive Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (Bit 16), the Early Receive Interrupt is enabled. When this bit is reset, the Early Receive Interrupt is disabled.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FBE</name>
              <description>Fatal Bus Error Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Fatal Bus Error Interrupt is enabled. When this bit is reset, the Fatal Bus Error Enable Interrupt is disabled.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETE</name>
              <description>Early Transmit Interrupt Enable
When this bit is set with an Abnormal Interrupt Summary Enable (Bit 15), the Early Transmit Interrupt is enabled. When this bit is reset, the Early Transmit Interrupt is disabled.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWE</name>
              <description>Receive Watchdog Timeout Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Receive Watchdog Timeout Interrupt is enabled. When this bit is reset, the Receive Watchdog Timeout Interrupt is disabled.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSE</name>
              <description>Receive Stopped Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Receive Stopped Interrupt is enabled. When this bit is reset, the Receive Stopped Interrupt is disabled.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RUE</name>
              <description>Receive Buffer Unavailable Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Receive Buffer Unavailable Interrupt is enabled. When this bit is reset, the Receive Buffer Unavailable Interrupt is disabled.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RIE</name>
              <description>Receive Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (Bit 16), the Receive Interrupt is enabled. When this bit is reset, the Receive Interrupt is disabled.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNE</name>
              <description>Underflow Interrupt Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Transmit Underflow Interrupt is enabled. When this bit is reset, the Underflow Interrupt is disabled.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVE</name>
              <description>Overflow Interrupt Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Receive Overflow Interrupt is enabled. When this bit is reset, the Overflow Interrupt is disabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TJE</name>
              <description>Transmit Jabber Timeout Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Transmit Jabber Timeout Interrupt is enabled. When this bit is reset, the Transmit Jabber Timeout Interrupt is disabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TUE</name>
              <description>Transmit Buffer Unavailable Enable
When this bit is set with Normal Interrupt Summary Enable (Bit 16), the Transmit Buffer Unavailable Interrupt is enabled. When this bit is reset, the Transmit Buffer Unavailable Interrupt is disabled.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSE</name>
              <description>Transmit Stopped Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Transmission Stopped Interrupt is enabled. When this bit is reset, the Transmission Stopped Interrupt is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIE</name>
              <description>Transmit Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (Bit 16), the Transmit Interrupt is enabled. When this bit is reset, the Transmit Interrupt is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_MISS_OVF_CNT</name>
          <description>Missed Frame And Buffer Overflow Counter Register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ONFCNTOVF</name>
              <description>Overflow Bit for FIFO Overflow Counter
This bit is set every time the Overflow Frame Counter (Bits[27:17]) overflows,
that is, the Rx FIFO overflows with the overflow frame counter at maximum value.
In such a scenario, the overflow frame counter is reset to all-zeros and this bit indicates that the rollover happened.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVFFRMCNT</name>
              <description>Overflow Frame Counter
This field indicates the number of frames missed by the application. This counter is incremented each time the MTL FIFO overflows. The counter is cleared when this register is read with mci_be_i[2] at 1’b1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MISCNTOVF</name>
              <description>Overflow Bit for Missed Frame Counter
This bit is set every time Missed Frame Counter (Bits[15:0]) overflows,
that is, the DMA discards an incoming frame because of the Host Receive Buffer being unavailable with the missed frame counter at maximum value. In such a scenario,
 the Missed frame counter is reset to all-zeros and this bit indicates that the rollover happened.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MISFRMCNT</name>
              <description>Missed Frame Counter
This field indicates the number of frames missed by the controller because of the Host Receive Buffer being unavailable.
This counter is incremented each time the DMA discards an incoming frame. The counter is cleared when this register is read with mci_be_i[0] at 1’b1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RX_INTR_WDOG</name>
          <description>Receive Interrupt Watchdog Timer Register</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RIWT</name>
              <description>RI Watchdog Timer Count
This bit indicates the number of system clock cycles multiplied by 256 for which the watchdog timer is set.
The watchdog timer gets triggered with the programmed value after the Rx DMA completes the transfer
of a frame for which the RI status bit is not set because of the setting in the corresponding descriptor RDES1[31].
When the watchdog timer runs out, the RI bit is set and the timer is stopped.
The watchdog timer is reset when the RI bit is set high because of automatic setting of RI as per RDES1[31] of any received frame.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_AXI_MODE</name>
          <description>AXI Bus Mode Register</description>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0FF30FF</resetMask>
          <fields>
            <field>
              <name>EN_LPI</name>
              <description>Enable Low Power Interface (LPI)
When set to 1, this bit enables the LPI mode supported by the GMAC-AXI configuration and accepts the LPI request from the AXI System Clock controller.
When set to 0, this bit disables the LPI mode and always denies the LPI request from the AXI System Clock controller.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPI_XIT_FRM</name>
              <description>Unlock on Magic Packet or Remote Wake-Up Frame
When set to 1, this bit enables the GMAC-AXI to come out of the LPI mode only when the magic packet or remote wake-up frame is received.
When set to 0, this bit enables the GMAC-AXI to come out of LPI mode when any frame is received.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_OSR_LMT</name>
              <description>AXI Maximum Write Outstanding Request Limit
This value limits the maximum outstanding request on the AXI write interface.
Maximum outstanding requests = WR_OSR_LMT+1 Note: - Bit 22 is reserved if AXI_GM_MAX_WR_REQUESTS = 4. - Bit 23 bit is reserved if AXI_GM_MAX_WR_REQUESTS != 16.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_OSR_LMT</name>
              <description>AXI Maximum Read Outstanding Request Limit
This value limits the maximum outstanding request on the AXI read interface.
Maximum outstanding requests = RD_OSR_LMT+1 Note: - Bit 18 is reserved if AXI_GM_MAX_RD_REQUESTS = 4. - Bit 19 is reserved if AXI_GM_MAX_RD_REQUESTS != 16.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ONEKBBE</name>
              <description>1 KB Boundary Crossing Enable for the GMAC-AXI Master
When set, the GMAC-AXI master performs burst transfers that do not cross 1 KB boundary.
When reset, the GMAC-AXI master performs burst transfers that do not cross 4 KB boundary.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AXI_AAL</name>
              <description>Address-Aligned Beats
This bit is read-only bit and reflects the Bit 25 (AAL) of Register 0 (Bus Mode Register).
When this bit is set to 1, the GMAC-AXI performs address-aligned burst transfers on both read and write channels.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN256</name>
              <description>AXI Burst Length 256
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 256 on the AXI master interface.
This bit is present only when the configuration parameter AXI_BL is set to 256. Otherwise, this bit is reserved and is read-only (RO).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN128</name>
              <description>AXI Burst Length 128
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 128 on the AXI master interface.
This bit is present only when the configuration parameter AXI_BL is set to 128 or more. Otherwise, this bit is reserved and is read-only (RO).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN64</name>
              <description>AXI Burst Length 64
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 64 on the AXI master interface.
This bit is present only when the configuration parameter AXI_BL is set to 64 or more. Otherwise, this bit is reserved and is read-only (RO).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN32</name>
              <description>AXI Burst Length 32
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 32 on the AXI master interface.
This bit is present only when the configuration parameter AXI_BL is set to 32 or more. Otherwise, this bit is reserved and is read-only (RO).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN16</name>
              <description>AXI Burst Length 16
When this bit is set to 1 or UNDEF is set to 1, the GMAC-AXI is allowed to select a burst length of 16 on the AXI master interface.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN8</name>
              <description>AXI Burst Length 8
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 8 on the AXI master interface.
Setting this bit has no effect when UNDEF is set to 1.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN4</name>
              <description>AXI Burst Length 4
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 4 on the AXI master interface.
Setting this bit has no effect when UNDEF is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDEF</name>
              <description>AXI Undefined Burst Length
This bit is read-only bit and indicates the complement (invert) value of Bit 16 (FB) in Register 0 (Bus Mode Register).
- When this bit is set to 1, the GMAC-AXI is allowed to perform any burst length equal to or below the maximum allowed burst length programmed in Bits[7:3].
- When this bit is set to 0, the GMAC-AXI is allowed to perform only fixed burst lengths as indicated by BLEN256, BLEN128, BLEN64, BLEN32, BLEN16, BLEN8, or BLEN4, or a burst length of 1.
If UNDEF is set and none of the BLEN bits is set, then GMAC-AXI is allowed to perform a burst length of 16.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_BUS_STATUS</name>
          <description>AHB or AXI Status Register</description>
          <addressOffset>0x102c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>AXIRDSTS</name>
              <description>AXI Master Read Channel Status
When high, it indicates that AXI master's read channel is active and transferring data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AXWHSTS</name>
              <description>AXI Master Write Channel or AHB Master Status
When high, it indicates that AXI master's write channel is active and transferring data in the GMAC-AXI configuration. In the GMAC-AHB configuration,
 it indicates that the AHB master interface FSMs are in the non-idle state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CURR_HOST_TX_DESC</name>
          <description>Current Host Transmit Descriptor Register</description>
          <addressOffset>0x1048</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURTDESAPTR</name>
              <description>Host Transmit Descriptor Address Pointer
Cleared on Reset. Pointer updated by the DMA during operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CURR_HOST_RX_DESC</name>
          <description>Current Host Receive Descriptor Register</description>
          <addressOffset>0x104c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRDESAPTR</name>
              <description>Host Receive Descriptor Address Pointer
Cleared on Reset. Pointer updated by the DMA during operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CURR_HOST_TX_BUF</name>
          <description>Current Host Transmit Buffer Address Register</description>
          <addressOffset>0x1050</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURTBUFAPTR</name>
              <description>Host Transmit Buffer Address Pointer
Cleared on Reset. Pointer updated by the DMA during operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CURR_HOST_RX_BUF</name>
          <description>Current Host Receive Buffer Address Register</description>
          <addressOffset>0x1054</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRBUFAPTR</name>
              <description>Host Receive Buffer Address Pointer
Cleared on Reset. Pointer updated by the DMA during operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL0</name>
          <description>Control Register 0</description>
          <addressOffset>0x3000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003F3F</resetMask>
          <fields>
            <field>
              <name>ENET0_RXCLK_DLY_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_TXCLK_DLY_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL2</name>
          <description>Control  Register 1</description>
          <addressOffset>0x3008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x2008F400</resetMask>
          <fields>
            <field>
              <name>ENET0_LPI_IRQ_EN</name>
              <description>lowpower interrupt enable, for internal use only, user should use core registers for enable/disable interrupt</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_REFCLK_OE</name>
              <description>set to enable output 50MHz clock to rmii phy.
User should set it if use soc internal clock as refclk</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_PHY_INF_SEL</name>
              <description>PHY mode select
000MII; 001RGMII; 100RMII;
should be set before config IOMUX, otherwise may cause glitch for RGMII</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_FLOWCTRL</name>
              <description>flow control request</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_RMII_TXCLK_SEL</name>
              <description>RMII mode output clock pad select
set to use txck as RMII refclk;
clr to use rxck as RMII refclk;  default 0(rxck)
refclk is always from pad, can use external clock from pad, or use internal clock output to pad then loopback.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="ENET0">
      <name>ENET1</name>
      <description>ENET1</description>
      <groupName>ENET</groupName>
      <baseAddress>0xf1404000</baseAddress>
    </peripheral>
    <peripheral>
      <name>USB0</name>
      <description>USB0</description>
      <groupName>USB</groupName>
      <baseAddress>0xf1420000</baseAddress>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x1a8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPTIMER0LD</name>
          <description>General Purpose Timer #0 Load Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTLD</name>
              <description>GPTLD
General Purpose Timer Load Value
These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'.
This value represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
NOTE: Max value is 0xFFFFFF or 16.777215 seconds.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER0CTRL</name>
          <description>General Purpose Timer #0 Controller Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC1FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTRUN</name>
              <description>GPTRUN
General Purpose Timer Run
GPTCNT bits are not effected when setting or clearing this bit.
0 - Stop counting
1 - Run</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTRST</name>
              <description>GPTRST
General Purpose Timer Reset
0 - No action
1 - Load counter value from GPTLD bits in n_GPTIMER0LD</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPTMODE</name>
              <description>GPTMODE
General Purpose Timer Mode
In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is
reset by software;
In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the
counter value from GPTLD bits to start again.
0 - One Shot Mode
1 - Repeat Mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTCNT</name>
              <description>GPTCNT
General Purpose Timer Counter.
This field is the count value of the countdown timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER1LD</name>
          <description>General Purpose Timer #1 Load Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTLD</name>
              <description>GPTLD
General Purpose Timer Load Value
These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'.
This value represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
NOTE: Max value is 0xFFFFFF or 16.777215 seconds.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER1CTRL</name>
          <description>General Purpose Timer #1 Controller Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC1FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTRUN</name>
              <description>GPTRUN
General Purpose Timer Run
GPTCNT bits are not effected when setting or clearing this bit.
0 - Stop counting
1 - Run</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTRST</name>
              <description>GPTRST
General Purpose Timer Reset
0 - No action
1 - Load counter value from GPTLD bits in USB_n_GPTIMER1LD</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPTMODE</name>
              <description>GPTMODE
General Purpose Timer Mode
In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is
reset by software. In repeat mode, the timer will count down to zero, generate an interrupt and
automatically reload the counter value from GPTLD bits to start again.
0 - One Shot Mode
1 - Repeat Mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTCNT</name>
              <description>GPTCNT
General Purpose Timer Counter.
This field is the count value of the countdown timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SBUSCFG</name>
          <description>System Bus Config Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>AHBBRST</name>
              <description>AHBBRST
AHB master interface Burst configuration
These bits control AHB master transfer type sequence (or priority).
NOTE: This register overrides n_BURSTSIZE register when its value is not zero.
000 - Incremental burst of unspecified length only
001 - INCR4 burst, then single transfer
010 - INCR8 burst, INCR4 burst, then single transfer
011 - INCR16 burst, INCR8 burst, INCR4 burst, then single transfer
100 - Reserved, don't use
101 - INCR4 burst, then incremental burst of unspecified length
110 - INCR8 burst, INCR4 burst, then incremental burst of unspecified length
111 - INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspecified length</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBCMD</name>
          <description>USB Command Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x00080000</resetValue>
          <resetMask>0x00FFFB7F</resetMask>
          <fields>
            <field>
              <name>ITC</name>
              <description>ITC
Interrupt Threshold Control -Read/Write.
The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts.
ITC contains the maximum interrupt interval measured in micro-frames. Valid values are
shown below.
Value Maximum Interrupt Interval
00000000 - Immediate (no threshold)
00000001 - 1 micro-frame
00000010 - 2 micro-frames
00000100 - 4 micro-frames
00001000 - 8 micro-frames
00010000 - 16 micro-frames
00100000 - 32 micro-frames
01000000 - 64 micro-frames</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_2</name>
              <description>FS_2
Frame List Size - (Read/Write or Read Only). [host mode only]
This field is Read/Write only if Programmable Frame List Flag in the HCCPARAMS registers is set to one.
This field specifies the size of the frame list that controls which bits in the Frame Index Register should be used for the Frame List Current index.
NOTE: This field is made up from USBCMD bits 15, 3 and 2.
Value Meaning
0b000 - 1024 elements (4096 bytes) Default value
0b001 - 512 elements (2048 bytes)
0b010 - 256 elements (1024 bytes)
0b011 - 128 elements (512 bytes)
0b100 - 64 elements (256 bytes)
0b101 - 32 elements (128 bytes)
0b110 - 16 elements (64 bytes)
0b111 - 8 elements (32 bytes)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATDTW</name>
              <description>ATDTW
Add dTD TripWire - Read/Write. [device mode only]
This bit is used as a semaphore to ensure proper addition of a new dTD to an active (primed) endpoint's
linked list. This bit is set and cleared by software.
This bit would also be cleared by hardware when state machine is hazard region for which adding a dTD
to a primed endpoint may go unrecognized.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUTW</name>
              <description>SUTW
Setup TripWire - Read/Write. [device mode only]
This bit is used as a semaphore to ensure that the setup data payload of 8 bytes is extracted from a QH by the DCD without being corrupted.
If the setup lockout mode is off (SLOM bit in USB core register n_USBMODE, see USBMODE ) then
there is a hazard when new setup data arrives while the DCD is copying the setup data payload
from the QH for a previous setup packet. This bit is set and cleared by software.
This bit would also be cleared by hardware when a hazard detected.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRM</name>
              <description>Asynchronous Schedule start- Write only， host mode only。
this bit is used to notify hostcontroller to start async schedule immediately.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ASPE</name>
              <description>ASPE
Asynchronous Schedule Park Mode Enable - Read/Write.
If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this bit defaults to a 1h and is R/W.
Otherwise the bit must be a zero and is RO. Software uses this bit to enable or disable Park mode.
When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.
NOTE: ASPE bit reset value: '0b' for OTG controller .</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASP</name>
              <description>ASP
Asynchronous Schedule Park Mode Count - Read/Write.
If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this field defaults to 3h and is R/W. Otherwise it defaults to zero and is Read-Only.
It contains a count of the number of successive transactions the host controller is allowed to
execute from a high-speed queue head on the Asynchronous schedule before continuing traversal of the Asynchronous schedule.
Valid values are 1h to 3h. Software must not write a zero to this bit when Park Mode Enable is a one as this will result in undefined behavior.
This field is set to 3h in all controller core.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IAA</name>
              <description>IAA
Interrupt on Async Advance Doorbell - Read/Write.
This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. Software must write a 1 to this bit to ring the doorbell.
When the host controller has evicted all appropriate cached schedule states,
it sets the Interrupt on Async Advance status bit in the USBSTS register.
If the Interrupt on Sync Advance Enable bit in the USBINTR register is one, then the host controller will assert an interrupt at the next interrupt threshold.
The host controller sets this bit to zero after it has set the Interrupt on Sync Advance status bit in the USBSTS register to one.
Software should not write a one to this bit when the asynchronous  schedule is inactive. Doing so will yield undefined results.
This bit is only used in host mode. Writing a one to this bit when device mode is selected will have undefined results.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASE</name>
              <description>ASE
Asynchronous Schedule Enable - Read/Write. Default 0b.
This bit controls whether the host controller skips processing the Asynchronous Schedule.
Only the host controller uses this bit.
Values Meaning
0 - Do not process the Asynchronous Schedule.
1 - Use the ASYNCLISTADDR register to access the Asynchronous Schedule.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSE</name>
              <description>PSE
Periodic Schedule Enable- Read/Write. Default 0b.
This bit controls whether the host controller skips processing the Periodic Schedule.
Only the host controller uses this bit.
Values Meaning
0 - Do not process the Periodic Schedule
1 - Use the PERIODICLISTBASE register to access the Periodic Schedule.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_1</name>
              <description>FS_1
See description at bit 15</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RST</name>
              <description>RST
Controller Reset (RESET) - Read/Write. Software uses this bit to reset the controller.
This bit is set to zero by the Host/Device Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.
Host operation mode:
When software writes a one to this bit, the Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value.
Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports.
Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero.
Attempting to reset an actively running host controller will result in undefined behavior.
Device operation mode:
When software writes a one to this bit, the Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value.
Writing a one to this bit when the device is in the attached state is not recommended, because the effect on an attached host is undefined.
In order to ensure that the device is not in an attached state before initiating a device controller reset, all primed endpoints should be flushed and the USBCMD Run/Stop bit should be set to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RS</name>
              <description>RS
Run/Stop (RS) - Read/Write. Default 0b. 1=Run. 0=Stop.
Host operation mode:
When set to '1b', the Controller proceeds with the execution of the schedule. The Controller continues execution as long as this bit is set to a one.
When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts.
The HC Halted bit in the status register indicates when the Controller has finished the transaction and has entered the stopped state.
Software should not write a one to this field unless the controller is in the Halted state (that is, HCHalted in the USBSTS register is a one).
Device operation mode:
Writing a one to this bit will cause the controller to enable a pull-up on D+ and initiate an attach event.
This control bit is not directly connected to the pull-up enable, as the pull-up will become disabled upon transitioning into high-speed mode.
Software should use this bit to prevent an attach event before the controller has been properly initialized. Writing a 0 to this will cause a detach event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBSTS</name>
          <description>USB Status Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030DF1FF</resetMask>
          <fields>
            <field>
              <name>TI1</name>
              <description>TI1
General Purpose Timer Interrupt 1(GPTINT1)--R/WC.
This bit is set when the counter in the GPTIMER1CTRL register transitions to zero, writing a one to this
bit will clear it.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TI0</name>
              <description>TI0
General Purpose Timer Interrupt 0(GPTINT0)--R/WC.
This bit is set when the counter in the GPTIMER0CTRL register transitions to zero, writing a one to this
bit clears it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPI</name>
              <description>USB Host Periodic Interrupt – RWC. Default = 0b.
This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction
where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule.
This bit is also set by the Host Controller when a short packet is detected and the packet is on the periodic schedule.
A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UAI</name>
              <description>USB Host Asynchronous Interrupt – RWC. Default = 0b.
This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction
where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set AND the TD was from the asynchronous schedule.
This bit is also set by the Host when a short packet is detected and the packet is on the asynchronous schedule.
A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKI</name>
              <description>NAKI
NAK Interrupt Bit--RO.
This bit is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and
corresponding TX/RX Endpoint NAK Enable bit are set. This bit is automatically cleared by hardware
when all Enabled TX/RX Endpoint NAK bits are cleared.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AS</name>
              <description>AS
Asynchronous Schedule Status - Read Only.
This bit reports the current real status of the Asynchronous Schedule. When set to zero the asynchronous schedule status is disabled and if set to one the status is enabled.
The Host Controller is not required to immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register.
When this bit and the Asynchronous Schedule Enable bit are the same value, the Asynchronous Schedule is either enabled (1) or disabled (0).
Only used in the host operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PS</name>
              <description>PS
Periodic Schedule Status - Read Only.
This bit reports the current real status of the Periodic Schedule. When set to zero the periodic schedule is disabled, and if set to one the status is enabled.
The Host Controller is not required to immediately disable or enable the Periodic Schedule when software transitions the Periodic Schedule Enable bit in the USBCMD register.
When this bit and the Periodic Schedule Enable bit are the same value, the Periodic Schedule is either enabled (1) or disabled (0).
Only used in the host operation mode.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RCL</name>
              <description>RCL
Reclamation - Read Only.
This is a read-only status bit used to detect an empty asynchronous schedule.
Only used in the host operation mode.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HCH</name>
              <description>HCH
HCHaIted - Read Only.
This bit is a zero whenever the Run/Stop bit is a one.
 The Controller sets this bit to one after it has stopped executing because of the Run/Stop bit being set to 0,
 either by software or by the Controller hardware (for example, an internal error).
Only used in the host operation mode.
Default value is '0b' for OTG core .
This is because OTG core is not operating as host in default. Please see CM bit in USB_n_USBMODE
register.
NOTE: HCH bit reset value: '0b' for OTG controller core .</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLI</name>
              <description>SLI
DCSuspend - R/WC.
When a controller enters a suspend state from an active state, this bit will be set to a one. The device controller clears the bit upon exiting from a suspend state.
Only used in device operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRI</name>
              <description>SRI
SOF Received - R/WC.
When the device controller detects a Start Of (micro) Frame, this bit will be set to a one.
When a SOF is extremely late, the device controller will automatically set this bit to indicate that an SOF was expected.
Therefore, this bit will be set roughly every 1ms in device FS mode and every 125ms in HS mode and will be synchronized to the actual SOF that is received.
Because the device controller is initialized to FS before connect, this bit will be set at an interval of 1ms during the prelude to connect and chirp.
In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.
Software writes a 1 to this bit to clear it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>URI</name>
              <description>URI
USB Reset Received - R/WC.
When the device controller detects a USB Reset and enters the default state, this bit will be set to a one.
Software can write a 1 to this bit to clear the USB Reset Received status bit.
Only used in device operation mode.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAI</name>
              <description>AAI
Interrupt on Async Advance - R/WC.
System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule
by writing a one to the Interrupt on Async Advance Doorbell bit in the n_USBCMD register. This status bit indicates the assertion of that interrupt source.
Only used in host operation mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEI</name>
              <description>System Error – RWC. Default = 0b.
In the BVCI implementation of the USBHS core, this bit is not used, and will always be cleared to '0b'.
In the AMBA implementation, this bit will be set to '1b' when an Error response is seen by the master interface (HRESP[1:0]=ERROR)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRI</name>
              <description>FRI
Frame List Rollover - R/WC.
The Host Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to
zero. The exact value at which the rollover occurs depends on the frame list size. For example. If the
frame list size (as programmed in the Frame List Size field of the USB_n_USBCMD register) is 1024, the
Frame Index Register rolls over every time FRINDEX [13] toggles. Similarly, if the size is 512, the Host
Controller sets this bit to a one every time FHINDEX [12] toggles.
Only used in host operation mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCI</name>
              <description>PCI
Port Change Detect - R/WC.
The Host Controller sets this bit to a one when on any port a Connect Status occurs, a Port Enable/Disable Change occurs,
or the Force Port Resume bit is set as the result of a J-K transition on the suspended port.
The Device Controller sets this bit to a one when the port controller enters the full or high-speed operational state.
When the port controller exits the full or high-speed operation states due to Reset or Suspend events,
the notification mechanisms are the USB Reset Received bit and the DCSuspend bits Respectively.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UEI</name>
              <description>UEI
USB Error Interrupt (USBERRINT) - R/WC.
When completion of a USB transaction results in an error condition, this bit is set by the Host/Device Controller.
This bit is set along with the USBINT bit, if the TD on which the error interrupt occurred also had its interrupt on complete (IOC) bit set.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UI</name>
              <description>UI
USB Interrupt (USBINT) - R/WC.
This bit is set by the Host/Device Controller when the cause of an interrupt is a completion of a USB
transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set.
This bit is also set by the Host/Device Controller when a short packet is detected. A short packet is when
the actual number of bytes received was less than the expected number of bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBINTR</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030D01FF</resetMask>
          <fields>
            <field>
              <name>TIE1</name>
              <description>TIE1
General Purpose Timer #1 Interrupt Enable
When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIE0</name>
              <description>TIE0
General Purpose Timer #0 Interrupt Enable
When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPIE</name>
              <description>UPIE
USB Host Periodic Interrupt Enable
When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an
interrupt at the next interrupt threshold.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UAIE</name>
              <description>UAIE
USB Host Asynchronous Interrupt Enable
When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an
interrupt at the next interrupt threshold.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKE</name>
              <description>NAKE
NAK Interrupt Enable
When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLE</name>
              <description>SLE
Sleep Interrupt Enable
When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt.
Only used in device operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRE</name>
              <description>SRE
SOF Received Interrupt Enable
When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>URE</name>
              <description>URE
USB Reset Interrupt Enable
When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in device operation mode.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAE</name>
              <description>AAE
Async Advance Interrupt Enable
When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEE</name>
              <description>SEE
System Error Interrupt Enable
When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRE</name>
              <description>FRE
Frame List Rollover Interrupt Enable
When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCE</name>
              <description>PCE
Port Change Detect Interrupt Enable
When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UEE</name>
              <description>UEE
USB Error Interrupt Enable
When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UE</name>
              <description>UE
USB Interrupt Enable
When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRINDEX</name>
          <description>USB Frame Index Register</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>FRINDEX</name>
              <description>FRINDEX
Frame Index.
The value, in this register, increments at the end of each time frame (micro-frame). Bits [N: 3] are used for the Frame List current index.
This means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index.
The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.
USBCMD [Frame List Size] Number Elements N
In device mode the value is the current frame number of the last frame transmitted. It is not used as an index.
In either mode bits 2:0 indicate the current microframe.
The bit field values description below is represented as (Frame List Size) Number Elements N.
00000000000000 - (1024) 12
00000000000001 - (512) 11
00000000000010 - (256) 10
00000000000011 - (128) 9
00000000000100 - (64) 8
00000000000101 - (32) 7
00000000000110 - (16) 6
00000000000111 - (8) 5</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEVICEADDR</name>
          <description>Device Address Register</description>
          <alternateGroup>UNION_154</alternateGroup>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF000000</resetMask>
          <fields>
            <field>
              <name>USBADR</name>
              <description>USBADR
Device Address.
These bits correspond to the USB device address</description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBADRA</name>
              <description>USBADRA
Device Address Advance. Default=0.
When this bit is '0', any writes to USBADR are instantaneous.
 When this bit is written to a '1' at the same time or before USBADR is written, the write to the USBADR field is staged and held in a hidden register.
After an IN occurs on endpoint 0 and is ACKed, USBADR will be loaded from the holding register.
Hardware will automatically clear this bit on the following conditions:
1) IN is ACKed to endpoint 0. (USBADR is updated from staging register).
2) OUT/SETUP occur to endpoint 0. (USBADR is not updated).
3) Device Reset occurs (USBADR is reset to 0).
NOTE: After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to program the USBADR field.
This mechanism will ensure this specification is met when the DCD can not write of the device address within 2ms from the SET_ADDRESS status phase.
If the DCD writes the USBADR with USBADRA=1 after the SET_ADDRESS data phase (before the prime of the status phase),
the USBADR will be programmed instantly at the correct time and meet the 2ms USB requirement.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERIODICLISTBASE</name>
          <description>Frame List Base Address Register</description>
          <alternateGroup>UNION_154</alternateGroup>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF000</resetMask>
          <fields>
            <field>
              <name>BASEADR</name>
              <description>BASEADR
Base Address (Low).
These bits correspond to memory address signals [31:12], respectively.
Only used by the host controller.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCLISTADDR</name>
          <description>Next Asynch. Address Register</description>
          <alternateGroup>UNION_158</alternateGroup>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFE0</resetMask>
          <fields>
            <field>
              <name>ASYBASE</name>
              <description>ASYBASE
Link Pointer Low (LPL).
These bits correspond to memory address signals [31:5], respectively. This field may only reference a
Queue Head (QH).
Only used by the host controller.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTLISTADDR</name>
          <description>Endpoint List Address Register</description>
          <alternateGroup>UNION_158</alternateGroup>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF800</resetMask>
          <fields>
            <field>
              <name>EPBASE</name>
              <description>EPBASE
Endpoint List Pointer(Low). These bits correspond to memory address signals [31:11], respectively.
This field will reference a list of up to 32 Queue Head (QH) (that is, one queue head per endpoint &amp; direction).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BURSTSIZE</name>
          <description>Programmable Burst Size Register</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TXPBURST</name>
              <description>TXPBURST
Programmable TX Burst Size.
Default value is determined by TXBURST bits in n_HWTXBUF.
This register represents the maximum length of a the burst in 32-bit words while moving data from system
memory to the USB bus.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPBURST</name>
              <description>RXPBURST
Programmable RX Burst Size.
Default value is determined by TXBURST bits in n_HWRXBUF.
This register represents the maximum length of a the burst in 32-bit words while moving data from the
USB bus to system memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXFILLTUNING</name>
          <description>TX FIFO Fill Tuning Register</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F1F7F</resetMask>
          <fields>
            <field>
              <name>TXFIFOTHRES</name>
              <description>TXFIFOTHRES
FIFO Burst Threshold. (Read/Write)
This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus.
The minimum value is 2 and this value should be a low as possible to maximize USB performance.
A higher value can be used in systems with unpredictable latency and/or insufficient bandwidth
where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory.
This value is ignored if the Stream Disable bit in USB_n_USBMODE register is set.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCHHEALTH</name>
              <description>TXSCHHEALTH
Scheduler Health Counter. (Read/Write To Clear)
Table continues on the next page
This register increments when the host controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES
before running out of time to send the packet before the next Start-Of-Frame.
This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH.
Writing to this register will clear the counter and this counter will max. at 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCHOH</name>
              <description>TXSCHOH
Scheduler Overhead. (Read/Write) [Default = 0]
This register adds an additional fixed offset to the schedule time estimator described above as Tff.
As an approximation, the value chosen for this register should limit the number of back-off events captured
in the TXSCHHEALTH to less than 10 per second in a highly utilized bus.
Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization.
The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode.
The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode.
Default value is '08h' for OTG controller core .</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTNAK</name>
          <description>Endpoint NAK Register</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPTN</name>
              <description>EPTN
TX Endpoint NAK - R/WC.
Each TX endpoint has 1 bit in this field. The bit is set when the
device sends a NAK handshake on a received IN token for the corresponding endpoint.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPRN</name>
              <description>EPRN
RX Endpoint NAK - R/WC.
Each RX endpoint has 1 bit in this field. The bit is set when the
device sends a NAK handshake on a received OUT or PING token for the corresponding endpoint.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTNAKEN</name>
          <description>Endpoint NAK Enable Register</description>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPTNE</name>
              <description>EPTNE
TX Endpoint NAK Enable - R/W.
Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this bit is set and the
corresponding TX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPRNE</name>
              <description>EPRNE
RX Endpoint NAK Enable - R/W.
Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this bit is set and the
corresponding RX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PORTSC1</name>
          <description>Port Status &amp; Control</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3DFF1FFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>STS
Serial Transceiver Select
1 Serial Interface Engine is selected
0 Parallel Interface signals is selected
Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals.
When this bit is set '1b', serial interface engine will be used instead of parallel interface signals.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PTW</name>
              <description>PTW
Parallel Transceiver Width
This bit has no effect if serial interface engine is used.
0 - Select the 8-bit UTMI interface [60MHz]
1 - Select the 16-bit UTMI interface [30MHz]</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSPD</name>
              <description>PSPD
Port Speed - Read Only.
This register field indicates the speed at which the port is operating.
00 - Full Speed
01 - Low Speed
10 - High Speed
11 - Undefined</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PFSC</name>
              <description>PFSC
Port Force Full Speed Connect - Read/Write. Default = 0b.
When this bit is set to '1b', the port will be forced to only connect at Full Speed, It disables the chirp
sequence that allows the port to identify itself as High Speed.
0 - Normal operation
1 - Forced to full speed</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHCD</name>
              <description>PHCD
PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write. Default = 0b.
When this bit is set to '1b', the PHY clock is disabled. Reading this bit will indicate the status of the PHY
clock.
NOTE: The PHY clock cannot be disabled if it is being used as the system clock.
In device mode, The PHY can be put into Low Power Suspend when the device is not running (USBCMD
Run/Stop=0b) or the host has signalled suspend (PORTSC1 SUSPEND=1b). PHY Low power suspend
will be cleared automatically when the host initials resume. Before forcing a resume from the device, the
device controller driver must clear this bit.
In host mode, the PHY can be put into Low Power Suspend when the downstream device has been put
into suspend mode or when no downstream device is connected. Low power suspend is completely
under the control of software.
0 - Enable PHY clock
1 - Disable PHY clock</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKOC</name>
              <description>WKOC
Wake on Over-current Enable (WKOC_E) - Read/Write. Default = 0b.
Writing this bit to a one enables the port to be sensitive to over-current conditions as wake-up events.
This field is zero if Port Power(PORTSC1) is zero.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDC</name>
              <description>WKDC
Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write. Default=0b. Writing this bit to a one enables
the port to be sensitive to device disconnects as wake-up events.
This field is zero if Port Power(PORTSC1) is zero or in device mode.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCN</name>
              <description>WKCN
Wake on Connect Enable (WKCNNT_E) - Read/Write. Default=0b.
Writing this bit to a one enables the port to be sensitive to device connects as wake-up events.
This field is zero if Port Power(PORTSC1) is zero or in device mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PTC</name>
              <description>PTC
Port Test Control - Read/Write. Default = 0000b.
Refer to Port Test Mode for the operational model for using these test modes and the USB Specification Revision 2.0, Chapter 7 for details on each test mode.
The FORCE_ENABLE_FS and FORCE ENABLE_LS are extensions to the test mode support specified in the EHCI specification.
Writing the PTC field to any of the FORCE_ENABLE_{HS/FS/LS} values will force the port into the connected and enabled state at the selected speed.
Writing the PTC field back to TEST_MODE_DISABLE will allow the port state machines to progress normally from that point.
NOTE: Low speed operations are not supported as a peripheral device.
Any other value than zero indicates that the port is operating in test mode.
Value Specific Test
0000 - TEST_MODE_DISABLE
0001 - J_STATE
0010 - K_STATE
0011 - SE0 (host) / NAK (device)
0100 - Packet
0101 - FORCE_ENABLE_HS
0110 - FORCE_ENABLE_FS
0111 - FORCE_ENABLE_LS
1000-1111 - Reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PP</name>
              <description>PP
Port Power (PP)-Read/Write or Read Only.
The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:
PPC
PP Operation
0
1b Read Only - Host controller does not have port power control switches. Each port is hard-wired to power.
1
1b/0b - Read/Write. OTG controller requires port power control switches. This bit represents the current setting of the switch (0=off, 1=on).
When power is not available on a port (that is, PP equals a 0), the port is non-functional and will not report attaches, detaches, etc.
When an over-current condition is detected on a powered port and PPC is a one,
the PP bit in each affected port may be transitional by the host controller driver from a one to a zero (removing power from the port).
This feature is implemented in all controller cores (PPC = 1).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LS</name>
              <description>LS
Line Status-Read Only. These bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal
lines.
In host mode, the use of linestate by the host controller driver is not necessary (unlike EHCI), because
the port controller state machine and the port routing manage the connection of LS and FS.
In device mode, the use of linestate by the device controller driver is not necessary.
The encoding of the bits are:
Bits [11:10] Meaning
00 - SE0
01 - K-state
10 - J-state
11 - Undefined</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HSP</name>
              <description>HSP
High-Speed Port - Read Only. Default = 0b.
When the bit is one, the host/device connected to the port is in high-speed mode and if set to zero, the
host/device connected to the port is not in a high-speed mode.
NOTE: HSP is redundant with PSPD(bit 27, 26) but remained for compatibility.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PR</name>
              <description>PR
Port Reset - Read/Write or Read Only. Default = 0b.
In Host Mode: Read/Write. 1=Port is in Reset. 0=Port is not in Reset. Default 0.
When software writes a one to this bit the bus-reset sequence as defined in the USB Specification Revision 2.0 is started.
This bit will automatically change to zero after the reset sequence is complete.
This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the reset duration is timed in the driver.
In Device Mode: This bit is a read only status bit. Device reset from the USB bus is also indicated in the USBSTS register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSP</name>
              <description>SUSP
Suspend - Read/Write or Read Only. Default = 0b.
1=Port in suspend state. 0=Port not in suspend state.
In Host Mode: Read/Write.
Port Enabled Bit and Suspend bit of this register define the port states as follows:
Bits [Port Enabled, Suspend] Port State
0x Disable
10 Enable
11 Suspend
When in suspend state, downstream propagation of data is blocked on this port, except for port reset.
The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1.
In the suspend state, the port is sensitive to resume detection.
Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB.
The host controller will unconditionally set this bit to zero when software sets the Force Port Resume bit to zero. The host controller ignores a write of zero to this bit.
If host software sets this bit to a one when the port is not enabled (that is, Port enabled bit is a zero) the results are undefined.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode: Read Only.
In device mode this bit is a read only status bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FPR</name>
              <description>FPR
Force Port Resume -Read/Write. 1= Resume detected/driven on port. 0=No resume (K-state) detected driven on port. Default = 0.
In Host Mode:
Software sets this bit to one to drive resume signaling. The Host Controller sets this bit to one if a J-to-K transition is detected while the port is in the Suspend state.
When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.
This bit will automatically change to zero after the resume sequence is complete.
This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the resume duration is timed in the driver.
Note that when the Host controller owns the port, the resume sequence follows the defined sequence documented in the USB Specification Revision 2.0.
The resume signaling (Full-speed 'K') is driven on the port as long as this bit remains a one. This bit will remain a one until the port has switched to the high-speed idle.
Writing a zero has no effect because the port controller will time the resume operation, clear the bit the port control state switches to HS or FS idle.
This field is zero if Port Power(PORTSC1) is zero in host mode.
This bit is not-EHCI compatible.
In Device mode:
After the device has been in Suspend State for 5ms or more, software must set this bit to one to drive resume signaling before clearing.
The Device Controller will set this bit to one if a J-to-K transition is detected while the port is in the Suspend state.
The bit will be cleared when the device returns to normal operation.
 Also, when this bit wil be cleared because a K-to-J transition detected, the Port Change Detect bit in the USBSTS register is also set to one.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCC</name>
              <description>OCC
Over-current Change-R/WC. Default=0.
This bit is set '1b' by hardware when there is a change to Over-current Active. Software can clear this bit by writing a one to this bit position.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCA</name>
              <description>OCA
Over-current Active-Read Only. Default 0.
This bit will automatically transition from one to zero when the over current condition is removed.
0 - This port does not have an over-current condition.
1 - This port currently has an over-current condition</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PEC</name>
              <description>PEC
Port Enable/Disable Change-R/WC. 1=Port enabled/disabled status has changed. 0=No change. Default = 0.
In Host Mode:
For the root hub, this bit is set to a one only when a port is disabled due to disconnect on the port or
due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification).
Software clears this by writing a one to it.
This field is zero if Port Power(PORTSC1) is zero.
In Device mode:
The device port is always enabled, so this bit is always '0b'.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE</name>
              <description>PE
Port Enabled/Disabled-Read/Write. 1=Enable. 0=Disable. Default 0.
In Host Mode:
Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field.
Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the host software.
Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller and bus events.
When the port is disabled, (0b) downstream propagation of data is blocked except for reset.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
The device port is always enabled, so this bit is always '1b'.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSC</name>
              <description>CSC
Connect Status Change-R/WC. 1 =Change in Current Connect Status. 0=No change. Default 0.
In Host Mode:
Indicates a change has occurred in the port's Current Connect Status.
The host/device controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change.
For example, the insertion status changes twice before system software has cleared the changed condition,
hub hardware will be 'setting' an already-set bit (that is, the bit will remain set). Software clears this bit by writing a one to it.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
This bit is undefined in device controller mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CCS</name>
              <description>CCS
Current Connect Status-Read Only.
In Host Mode:
1=Device is present on port. 0=No device is present. Default = 0.
This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
1=Attached. 0=Not Attached. Default=0.
A one indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the High Speed Port bit in this register.
A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register.
It does not state the device being disconnected or Suspended.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OTGSC</name>
          <description>On-The-Go Status &amp; control Register</description>
          <addressOffset>0x1a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07070723</resetMask>
          <fields>
            <field>
              <name>ASVIE</name>
              <description>ASVIE
A Session Valid Interrupt Enable - Read/Write.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVVIE</name>
              <description>AVVIE
A VBus Valid Interrupt Enable - Read/Write.
Setting this bit enables the A VBus valid interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDIE</name>
              <description>IDIE
USB ID Interrupt Enable - Read/Write.
Setting this bit enables the USB ID interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASVIS</name>
              <description>ASVIS
A Session Valid Interrupt Status - Read/Write to Clear.
This bit is set when VBus has either risen above or fallen below the A session valid threshold.
Software must write a one to clear this bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVVIS</name>
              <description>AVVIS
A VBus Valid Interrupt Status - Read/Write to Clear.
This bit is set when VBus has either risen above or fallen below the VBus valid threshold on an A device.
Software must write a one to clear this bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDIS</name>
              <description>IDIS
USB ID Interrupt Status - Read/Write.
This bit is set when a change on the ID input has been detected.
Software must write a one to clear this bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASV</name>
              <description>ASV
A Session Valid - Read Only.
Indicates VBus is above the A session valid threshold.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AVV</name>
              <description>AVV
A VBus Valid - Read Only.
Indicates VBus is above the A VBus valid threshold.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>ID
USB ID - Read Only.
0 = A device, 1 = B device</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDPU</name>
              <description>IDPU
ID Pullup - Read/Write
This bit provide control over the ID pull-up resistor; 0 = off, 1 = on [default]. When this bit is 0, the ID input
will not be sampled.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VC</name>
              <description>VC
VBUS Charge - Read/Write.
Setting this bit causes the VBus line to be charged. This is used for VBus pulsing during SRP.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VD</name>
              <description>VD
VBUS_Discharge - Read/Write.
Setting this bit causes VBus to discharge through a resistor.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBMODE</name>
          <description>USB Device Mode Register</description>
          <addressOffset>0x1a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>SDIS</name>
              <description>SDIS
Stream Disable Mode. (0 - Inactive [default]; 1 - Active)
Device Mode: Setting to a '1' disables double priming on both RX and TX for low bandwidth systems.
This mode ensures that when the RX and TX buffers are sufficient to contain an entire packet that the standard double buffering scheme is disabled to prevent overruns/underruns in bandwidth limited systems.
Note: In High Speed Mode, all packets received are responded to with a NYET handshake when stream disable is active.
Host Mode: Setting to a '1' ensures that overruns/underruns of the latency FIFO are eliminated for low bandwidth systems
where the RX and TX buffers are sufficient to contain the entire packet. Enabling stream disable also has the effect of ensuring the TX latency is filled to capacity before the packet is launched onto the USB.
NOTE: Time duration to pre-fill the FIFO becomes significant when stream disable is active. See TXFILLTUNING and TXTTFILLTUNING [MPH Only] to characterize the adjustments needed for
the scheduler when using this feature.
NOTE: The use of this feature substantially limits of the overall USB performance that can be achieved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLOM</name>
              <description>SLOM
Setup Lockout Mode. In device mode, this bit controls behavior of the setup lock mechanism. See Control Endpoint Operation Model .
0 - Setup Lockouts On (default);
1 - Setup Lockouts Off. DCD requires use of Setup Data Buffer Tripwire in USBCMD.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ES</name>
              <description>ES
Endian Select - Read/Write. This bit can change the byte alignment of the transfer buffers to match the
host microprocessor. The bit fields in the microprocessor interface and the data structures are unaffected
by the value of this bit because they are based upon the 32-bit word.
Bit Meaning
0 - Little Endian [Default]
1 - Big Endian</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CM</name>
              <description>CM
Controller Mode - R/WO. Controller mode is defaulted to the proper mode for host only and device only
implementations. For those designs that contain both host &amp; device capability, the controller defaults to
an idle state and needs to be initialized to the desired operating mode after reset. For combination host/
device controllers, this register can only be written once after reset. If it is necessary to switch modes,
software must reset the controller by writing to the RESET bit in the USBCMD register before
reprogramming this register.
For OTG controller core, reset value is '00b'.
00 - Idle [Default for combination host/device]
01 - Reserved
10 - Device Controller [Default for device only controller]
11 - Host Controller [Default for host only controller]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTSETUPSTAT</name>
          <description>Endpoint Setup Status Register</description>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ENDPTSETUPSTAT</name>
              <description>ENDPTSETUPSTAT
Setup Endpoint Status. For every setup transaction that is received, a corresponding bit in this register is set to one.
Software must clear or acknowledge the setup transfer by writing a one to a respective bit after it has read the setup data from Queue head.
The response to a setup packet as in the order of operations and total response time is crucial to limit bus time outs while the setup lock out mechanism is engaged.
This register is only used in device mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTPRIME</name>
          <description>Endpoint Prime Register</description>
          <addressOffset>0x1b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PETB</name>
              <description>PETB
Prime Endpoint Transmit Buffer - R/WS. For each endpoint a corresponding bit is used to request that a
buffer is prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction.
Software should write a one to the corresponding bit when posting a new transfer descriptor to an
endpoint queue head. Hardware automatically uses this bit to begin parsing for a new transfer descriptor
from the queue head and prepare a transmit buffer. Hardware clears this bit when the associated
endpoint(s) is (are) successfully primed.
NOTE: These bits are momentarily set by hardware during hardware re-priming operations when a dTD
is retired, and the dQH is updated.
PETB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERB</name>
              <description>PERB
Prime Endpoint Receive Buffer - R/WS. For each endpoint, a corresponding bit is used to request a buffer prepare for a receive operation for when a USB host initiates a USB OUT transaction.
Software should write a one to the corresponding bit whenever posting a new transfer descriptor to an endpoint queue head.
Hardware automatically uses this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer.
Hardware clears this bit when the associated endpoint(s) is (are) successfully primed.
NOTE: These bits are momentarily set by hardware during hardware re-priming operations when a dTD
is retired, and the dQH is updated.
PERB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTFLUSH</name>
          <description>Endpoint Flush Register</description>
          <addressOffset>0x1b4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FETB</name>
              <description>FETB
Flush Endpoint Transmit Buffer - R/WS. Writing one to a bit(s) in this register causes the associated endpoint(s) to clear any primed buffers.
If a packet is in progress for one of the associated endpoints, then that transfer continues until completion.
Hardware clears this register after the endpoint flush operation is successful.
FETB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FERB</name>
              <description>FERB
Flush Endpoint Receive Buffer - R/WS. Writing one to a bit(s) causes the associated endpoint(s) to clear any primed buffers.
 If a packet is in progress for one of the associated endpoints, then that transfer continues until completion.
Hardware clears this register after the endpoint flush operation is successful.
FERB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTSTAT</name>
          <description>Endpoint Status Register</description>
          <addressOffset>0x1b8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETBR</name>
              <description>ETBR
Endpoint Transmit Buffer Ready -- Read Only. One bit for each endpoint indicates status of the respective endpoint buffer.
This bit is set to one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register.
There is always a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready.
This delay time varies based upon the current USB traffic and the number of bits set in the ENDPRIME register.
Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.
NOTE: These bits are momentarily cleared by hardware during hardware endpoint re-priming operations when a dTD is retired, and the dQH is updated.
ETBR[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERBR</name>
              <description>ERBR
Endpoint Receive Buffer Ready -- Read Only. One bit for each endpoint indicates status of the respective
endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a
corresponding bit in the ENDPRIME register. There is always a delay between setting a bit in the
ENDPRIME register and endpoint indicating ready. This delay time varies based upon the current USB
traffic and the number of bits set in the ENDPRIME register. Buffer ready is cleared by USB reset, by the
USB DMA system, or through the ENDPTFLUSH register.
NOTE: These bits are momentarily cleared by hardware during hardware endpoint re-priming operations
when a dTD is retired, and the dQH is updated.
ERBR[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTCOMPLETE</name>
          <description>Endpoint Complete Register</description>
          <addressOffset>0x1bc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETCE</name>
              <description>ETCE
Endpoint Transmit Complete Event - R/WC. Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status.
If the corresponding IOC bit is set in the Transfer Descriptor, then this bit is set simultaneously with the USBINT . Writing one clears the corresponding bit in this register.
ETCE[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERCE</name>
              <description>ERCE
Endpoint Receive Complete Event - RW/C. Each bit indicates a received event (OUT/SETUP) occurred
and software should read the corresponding endpoint queue to determine the transfer status. If the
corresponding IOC bit is set in the Transfer Descriptor, then this bit is set simultaneously with the
USBINT . Writing one clears the corresponding bit in this register.
ERCE[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>ENDPTCTRL0,ENDPTCTRL1,ENDPTCTRL2,ENDPTCTRL3,ENDPTCTRL4,ENDPTCTRL5,ENDPTCTRL6,ENDPTCTRL7,ENDPTCTRL8,ENDPTCTRL9,ENDPTCTRL10,ENDPTCTRL11,ENDPTCTRL12,ENDPTCTRL13,ENDPTCTRL14,ENDPTCTRL15</dimIndex>
          <name>ENDPTCTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00CD00CD</resetMask>
          <fields>
            <field>
              <name>TXE</name>
              <description>TXE
TX Endpoint Enable
0 Disabled [Default]
1 Enabled
An Endpoint should be enabled only after it has been configured.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXR</name>
              <description>TXR
TX Data Toggle Reset (WS)
Write 1 - Reset PID Sequence
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order
to synchronize the data PID's between the Host and device.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXT</name>
              <description>TXT
TX Endpoint Type - Read/Write
00 Control
01 Isochronous
10 Bulk
11 Interrupt</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXS</name>
              <description>TXS
TX Endpoint Stall - Read/Write
0 End Point OK
1 End Point Stalled
This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured
as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared.
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host.
This control will continue to STALL until this bit is either cleared by software or automatically cleared as above for control endpoints.
NOTE: [CONTROL ENDPOINT TYPES ONLY]: there is a slight delay (50 clocks max) between the ENDPTSETUPSTAT begin cleared and hardware continuing to clear this bit.
In most systems, it is unlikely the DCD software will observe this delay. However, should the DCD observe that the stall bit is not set after writing a one to it then follow this procedure:
continually write this stall bit until it is set or until a new setup has been received by checking the associated endptsetupstat Bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXE</name>
              <description>RXE
RX Endpoint Enable
0 Disabled [Default]
1 Enabled
An Endpoint should be enabled only after it has been configured.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXR</name>
              <description>RXR
RX Data Toggle Reset (WS)
Write 1 - Reset PID Sequence
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order
to synchronize the data PID's between the host and device.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXT</name>
              <description>RXT
RX Endpoint Type - Read/Write
00 Control
01 Isochronous
10 Bulk
11 Interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXS</name>
              <description>RXS
RX Endpoint Stall - Read/Write
0 End Point OK. [Default]
1 End Point Stalled
This bit is set automatically upon receipt of a SETUP request if this Endpoint is configured as a Control
Endpointand this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit
is cleared.
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. This
control will continue to STALL until this bit is either cleared by software or automatically cleared as above
for control endpoints.
NOTE: [CONTROL ENDPOINT TYPES ONLY]: there is a slight delay (50 clocks max) between the
ENDPTSETUPSTAT begin cleared and hardware continuing to clear this bit. In most systems, it
is unlikely the DCD software will observe this delay. However, should the DCD observe that the
stall bit is not set after writing a one to it then follow this procedure: continually write this stall bit
until it is set or until a new setup has been received by checking the associated endptsetupstat
Bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OTG_CTRL0</name>
          <description>No description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x020B3F90</resetMask>
          <fields>
            <field>
              <name>OTG_WKDPDMCHG_EN</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTORESUME_EN</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_VBUS_WAKEUP_EN</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_ID_WAKEUP_EN</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_VBUS_SOURCE_SEL</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_UTMI_SUSPENDM_SW</name>
              <description>default 0 for naneng usbphy</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_UTMI_RESET_SW</name>
              <description>default 1 for naneng usbphy</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_WAKEUP_INT_ENABLE</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_POWER_MASK</name>
              <description>No description available</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_OVER_CUR_POL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_OVER_CUR_DIS</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SER_MODE_SUSPEND_EN</name>
              <description>for naneng usbphy, only switch to serial mode when suspend</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CTRL0</name>
          <description>No description available</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x02007007</resetMask>
          <fields>
            <field>
              <name>GPIO_ID_SEL_N</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SESS_VALID_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SESS_VALID_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CTRL1</name>
          <description>No description available</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00100002</resetMask>
          <fields>
            <field>
              <name>UTMI_CFG_RST_N</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_OTG_SUSPENDM</name>
              <description>OTG suspend, not utmi_suspendm</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOP_STATUS</name>
          <description>No description available</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>WAKEUP_INT_STATUS</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_STATUS</name>
          <description>No description available</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x800000F5</resetMask>
          <fields>
            <field>
              <name>UTMI_CLK_VALID</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINE_STATE</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_DISCONNECT</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_SESS_VALID</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TSW</name>
      <description>TSW</description>
      <groupName>TSW</groupName>
      <baseAddress>0xf1600000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x7fffc</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>LU_MAIN_CTRL</name>
          <description>LU_MAIN control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>BYP_EN</name>
              <description>MAC lookup bypass</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LU_MAIN_HITMEM</name>
          <description>LU_MAIN hit</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>CAMMEMCLR</name>
              <description>clear the cam memory</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HITMEMCLR</name>
              <description>clears the hit memory</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LU_MAIN_PARAM</name>
          <description>LU_MAIN parameter</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>NSTR</name>
              <description>number of supported streams</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDRW_ENTRY</name>
              <description>bit width of entry address vector</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LU_MAIN_BYPASS</name>
          <description>LU_MAIN bypass</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>HIT</name>
              <description>set hit bit to frame, only for debugging</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTAG</name>
              <description>set internal user tag field</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIT_VLAN</name>
              <description>mark frame to be vlan-tagged</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP</name>
              <description>mark frame to be dropped</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE</name>
              <description>number of configured buffer depth</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEST</name>
              <description>target destination ports of frame</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LU_MAIN_PCP_REMAP</name>
          <description>LU_MAIN PCP remap</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>PCP7</name>
              <description>queue value for PCP=7</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP6</name>
              <description>queue value for PCP=6</description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP5</name>
              <description>queue value for PCP=5</description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP4</name>
              <description>queue value for PCP=4</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP3</name>
              <description>queue value for PCP=3</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP2</name>
              <description>queue value for PCP=2</description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP1</name>
              <description>queue value for PCP=1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP0</name>
              <description>queue value for PCP=0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LU_MAIN_VERSION</name>
          <description>LU_MAIN version</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>VER_HI</name>
              <description>major version</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VER_LO</name>
              <description>minor version</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VER_REV</name>
              <description>revision number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LU_MAIN_INTF_ACTION</name>
          <description>LU_MAIN low word of action data for internal frames</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>UTAG</name>
              <description>TSN user sideband information from ALMEM</description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSEL</name>
              <description>Define the traffic queue selection:
00 – use PCP field of VLAN, untagged frames use PCP of PVID
01 – use PCP field with global remapping list
10 – reserved
11 – use value QUEUE of Action List</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP</name>
              <description>1 if frame should be dropped.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE</name>
              <description>Select the Priority Queue for TSN TX, only used if QSEL=11</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEST</name>
              <description>Select the destination ports of forwarded frame. It is coded in onehot/select way,
where 0 is always route to null. Every bit is mapped to a port.
00000 – to null (frame to clear)
00001 – to port 0 (CPU Port)
00010 – to port 1
00100 – to port 2
01000 – to port 3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LU_MAIN_BC_ACTION</name>
          <description>LU_MAIN low word of action data for broadcast frames</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>UTAG</name>
              <description>TSN user sideband information from ALMEM</description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSEL</name>
              <description>Define the traffic queue selection:
00 – use PCP field of VLAN, untagged frames use PCP of PVID
01 – use PCP field with global remapping list
10 – reserved
11 – use value QUEUE of Action List</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP</name>
              <description>1 if frame should be dropped.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE</name>
              <description>Select the Priority Queue for TSN TX, only used if QSEL=11</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEST</name>
              <description>Select the destination ports of forwarded frame. It is coded in onehot/select way,
where 0 is always route to null. Every bit is mapped to a port.
00000 – to null (frame to clear)
00001 – to port 0 (CPU Port)
00010 – to port 1
00100 – to port 2
01000 – to port 3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LU_MAIN_NN_ACTION</name>
          <description>LU_MAIN low word of  action data for unknown frames</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>UTAG</name>
              <description>TSN user sideband information from ALMEM</description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSEL</name>
              <description>Define the traffic queue selection:
00 – use PCP field of VLAN, untagged frames use PCP of PVID
01 – use PCP field with global remapping list
10 – reserved
11 – use value QUEUE of Action List</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP</name>
              <description>1 if frame should be dropped.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE</name>
              <description>Select the Priority Queue for TSN TX, only used if QSEL=11</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEST</name>
              <description>Select the destination ports of forwarded frame. It is coded in onehot/select way,
where 0 is always route to null. Every bit is mapped to a port.
00000 – to null (frame to clear)
00001 – to port 0 (CPU Port)
00010 – to port 1
00100 – to port 2
01000 – to port 3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_CAM_STS</name>
          <description>status register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>the controller is writing data and/or data is pending</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDY</name>
              <description>the new data is written to data register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_CAM_REQ_CNT</name>
          <description>request count</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>WRCNT</name>
              <description>number of streams in queue</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_CAM_FILLSTS</name>
          <description>fill status</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>FULL</name>
              <description>frame was dropped because the internal descriptor FIFO is full</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FD FIFO failure, internal controller lost synchronization</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_CAM_RESET</name>
          <description>reset</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>resets controller and clears all pending stream data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_CAM_PARAM</name>
          <description>parameter</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DEPTH</name>
              <description>number of configured buffer depth</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WORDLEN_BYTE</name>
              <description>number of configured 32bit words for this controller</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXI_CAM_REQDATA_0</name>
          <description>data0</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0301</resetMask>
          <fields>
            <field>
              <name>ENTRY_NUM</name>
              <description>entry number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE</name>
              <description>select between set, clear or clear all</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH</name>
              <description>CAM APB2AXIS channel selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXI_CAM_REQDATA_1</name>
          <description>data1</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DESTMAC_LO_PORT_VEC</name>
              <description>dest-mac[31:0] when CH=0；PORT_VEC when CH=1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXI_CAM_REQDATA_2</name>
          <description>data2</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID</name>
              <description>VLAN-ID value (12 bit) for the VLAN_ID table. Use the fefault VLAN-ID(VID=1), if setup an entry for non-VLAN traffic.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DESTMAC_HI</name>
              <description>dest-mac[47:32] when CH=0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_ALMEM_STS</name>
          <description>status register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>the controller is writing data and/or data is pending</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDY</name>
              <description>the new data is written to data register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_ALMEM_REQ_CNT</name>
          <description>request count</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>WRCNT</name>
              <description>number of streams in queue</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_ALMEM_FILLSTS</name>
          <description>fill status</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>FULL</name>
              <description>frame was dropped because the internal descriptor FIFO is full</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FD FIFO failure, internal controller lost synchronization</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_ALMEM_RESET</name>
          <description>reset</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>resets controller and clears all pending stream data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_ALMEM_PARAM</name>
          <description>parameter</description>
          <addressOffset>0x21c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DEPTH</name>
              <description>number of configured buffer depth</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WORDLEN_BYTE</name>
              <description>number of configured 32bit words for this controller</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_ALMEM_REQDATA_0</name>
          <description>data0</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>UTAG</name>
              <description>user sideband information</description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSEL</name>
              <description>define the traffic queue selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP</name>
              <description>frame should dropped</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE</name>
              <description>select the priority queue if qsel=11</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEST</name>
              <description>destination ports</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_ALMEM_REQDATA_1</name>
          <description>data1</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>WR_NRD</name>
              <description>1 for write and 0 for read</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP</name>
              <description>write response enable</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTRY_NUM</name>
              <description>define the entry number for reading and writing</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_ALMEM_STS</name>
          <description>status register</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>the controller is writing data and/or data is pending</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDY</name>
              <description>the new data is written to data register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_ALMEM_RESP_CNT</name>
          <description>response count</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RDCNT</name>
              <description>number of streams in queue</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_ALMEM_FILLSTS</name>
          <description>fill status</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>FULL</name>
              <description>FD FIFO full</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FD FIFO failure</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_ALMEM_RESET</name>
          <description>reset</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Resets controller and clears all pending stream data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_ALMEM_PARAM</name>
          <description>parameter</description>
          <addressOffset>0x29c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DEPTH</name>
              <description>number of configured buffer depth</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WORDLEN_BYTE</name>
              <description>number of configured 32bit for this controller</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_ALMEM_RESPDATA_0</name>
          <description>data0</description>
          <addressOffset>0x2a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>UTAG</name>
              <description>user sideband information</description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSEL</name>
              <description>define the traffic queue selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP</name>
              <description>frame should dropped</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE</name>
              <description>select the priority queue if qsel=11</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEST</name>
              <description>destination ports</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_ALMEM_RESPDATA_1</name>
          <description>data1</description>
          <addressOffset>0x2a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>WR_NRD</name>
              <description>1 for write and 0 for read</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP</name>
              <description>write response enable</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTRY_NUM</name>
              <description>define the entry number for reading and writing</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>HITMEM_REG_1,HITMEM_REG_2,HITMEM_REG_3,HITMEM_REG_4</dimIndex>
          <name>HITMEM[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HITMEM_REG</name>
              <description>Every bit represents a lookup entry starting with bit 0
as entry 0. The memory can be written and cleared by the host system via common memory-mapped
bus access.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_LOOKUP_STS</name>
          <description>status register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>the controller is writing data and/or data is pending</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDY</name>
              <description>the new data is written to data register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_LOOKUP_REQ_CNT</name>
          <description>response count</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>WRCNT</name>
              <description>number of streams in queue</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_LOOKUP_FILLSTS</name>
          <description>fill status</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>FULL</name>
              <description>FD FIFO full</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FD FIFO failure</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_LOOKUP_RESET</name>
          <description>reset</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Resets controller and clears all pending stream data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_LOOKUP_PARAM</name>
          <description>parameter</description>
          <addressOffset>0x101c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DEPTH</name>
              <description>number of configured buffer depth</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WORDLEN_BYTE</name>
              <description>number of configured 32bit for this controller</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_LOOKUP_REQDATA_0</name>
          <description>LOOKUP REQUEST Register REQ_DATA_0</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DESTMAC</name>
              <description>Holding the first four bytes of requested MAC address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_LOOKUP_REQDATA_1</name>
          <description>LOOKUP REQUEST Register REQ_DATA_1</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DESTMAC</name>
              <description>Holding the last two bytes of requested MAC address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>APB2AXIS_LOOKUP_REQDATA_3</name>
          <description>LOOKUP REQUEST Register REQ_DATA_2</description>
          <addressOffset>0x102c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>IS_VLAN</name>
              <description>Tell the LOOKUP module the requested traffic is VLAN tagged.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VLAN_TCI</name>
              <description>Set the requested traffic VLAN_TCI, if IS_VLAN=1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_LOOKUP_STS</name>
          <description>status register</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>the controller is writing data and/or data is pending</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDY</name>
              <description>the new data is written to data register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_LOOKUP_RESP_CNT</name>
          <description>response count</description>
          <addressOffset>0x1090</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RDCNT</name>
              <description>number of streams in queue</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_LOOKUP_FILLSTS</name>
          <description>fill status</description>
          <addressOffset>0x1094</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>FULL</name>
              <description>FD FIFO full</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FD FIFO failure</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_LOOKUP_RESET</name>
          <description>reset</description>
          <addressOffset>0x1098</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Resets controller and clears all pending stream data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_LOOKUP_PARAM</name>
          <description>parameter</description>
          <addressOffset>0x109c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DEPTH</name>
              <description>number of configured buffer depth</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WORDLEN_BYTE</name>
              <description>number of configured 32bit for this controller</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_LOOKUP_RESPDATA_0</name>
          <description>LOOKUP RESPONSE Data Register</description>
          <addressOffset>0x10a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>DROP_VLAN</name>
              <description>Used for statistics. Shows that drop occurs by VLAN-ID</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIT</name>
              <description>Is 1, if DESTMAC and VID hit an entry.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTAG</name>
              <description>TSN user sideband information from ALMEM.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIT_VLAN</name>
              <description>Is 1, if VID hit entry in VLAN_PORT table.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP</name>
              <description>Indicate that the frame should be dropped.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE</name>
              <description>TX traffic queue selection.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEST</name>
              <description>Forwarding ports from 0 to 15, Bit 0 is CPU port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AXIS2APB_LOOKUP_RESPDATA_1</name>
          <description>LOOKUP RESPONSE Data Register</description>
          <addressOffset>0x10a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ENTRY_NUM</name>
              <description>Entry number of ALMEM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_CSR_VERSION</name>
          <description>version register</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>VER_HI</name>
              <description>Major Version number of TSN-SW core.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VER_LO</name>
              <description>Minor Version number of TSN-SW core.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VER_REV</name>
              <description>Reversion number of TSN-SW core.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_CSR_PARAM</name>
          <description>Parameter Register</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>INCL_QCI</name>
              <description>Shows if QCI module is present.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INCL_CB0</name>
              <description>Shows if IP is configured with “lightweight” 802.1CB at CPU-Port.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TESTMODE</name>
              <description>Shows if IP is configured in TESTMODE.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TYPE</name>
              <description>Specify type of switch core</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NPORTS</name>
              <description>Number of TSN ports without counting internal CPU port. For TSN-SE, it returns always 2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_CSR_CONFIG</name>
          <description>Configuration Register</description>
          <addressOffset>0x2008</addressOffset>
          <size>32</size>
          <resetValue>0x00100000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>MSEC_CYCLES</name>
              <description>Number of SYS_CLK cycles during 1 ms. It is required to calculate a correct time</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_CSR_CB_PARAM</name>
          <description>CB Parameter Register</description>
          <addressOffset>0x200c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>SID_D</name>
              <description>Number of 802.1CB Stream Identification entries. 2^SID_D entries</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRER_D</name>
              <description>Number of 802.1CB Recovery Function entries. 2^FRER_D entries.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_CSR_QCI_CTRL_PARAM</name>
          <description>QCI Control Parameter Register</description>
          <addressOffset>0x2010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>QCI_GTD</name>
              <description>(Log) gate table depth. 2**GTD entries.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QCI_FMD</name>
              <description>(Log) flow meter depth. 2**FMD entries.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QCI_FTD</name>
              <description>(Log) filter table depth. 2**FTD entries.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_HWCFG</name>
          <description>PSPF General CTRAL</description>
          <addressOffset>0x2104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>FMD</name>
              <description>FMD – parameter</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GTD</name>
              <description>GTD – parameter</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FTD</name>
              <description>FTD – parameter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_FILTERSEL</name>
          <description>Filter select index</description>
          <addressOffset>0x2110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>INDEX</name>
              <description>Filter select index
Any written value larger than the maximum index
(2**FTD-1) will result in a read-back value of &lt;0&gt;.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_METERSEL</name>
          <description>Flowmeter select index</description>
          <addressOffset>0x2114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>INDEX</name>
              <description>Flowmeter select index
Any written value larger than the maximum index
(2**FMD-1) will result in a read-back value of &lt;0&gt;.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_GATESEL</name>
          <description>Gate select index</description>
          <addressOffset>0x2118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>INDEX</name>
              <description>Gate select index
Any written value larger than the maximum index
(2**GTD-1) will result in a read-back value of &lt;0&gt;.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_FCTRL</name>
          <description>FILTER SETTING</description>
          <addressOffset>0x2120</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENBLK</name>
              <description>Enable blocking of oversized frames
(802.1Qci – 8.6.5.1.1 (g))</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENFSZ</name>
              <description>0: No frame size check
1: Frame size checking, size defined by FSIZE.MXSZ
(802.1Qci – 8.6.5.1.1 (e.1))</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENFID</name>
              <description>0: No Flow Meter
1: Enable Flow Metering
(802.1Qci – 8.6.5.1.1 (e.2))</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENSID</name>
              <description>0: Filter match any SID value
1: Filter match SID value
(802.1Qci – 8.6.5.1.1 (b))</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENPCP</name>
              <description>0: Filter match any PCP value
1: Filter match PCP value
(802.1Qci – 8.6.5.1.1 (c))</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP</name>
              <description>Filter priority code point, if enabled by ENPCP</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FMD</name>
              <description>Associated Flow Meter – if enabled by ENFID</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GID</name>
              <description>Associated Gate</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SID</name>
              <description>Filter Stream ID – if enabled by ENSID</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_FSIZE</name>
          <description>No description available</description>
          <addressOffset>0x2124</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>BLK</name>
              <description>Stream blocked due to oversize frame.
Write &lt;1&gt; to clear.
(802.1Qci – 8.6.5.1.1 (h))</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MXSZ</name>
              <description>Maximum-SDU size in octets</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>6</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>CENTRAL_QCI_CNT0,CENTRAL_QCI_CNT1,CENTRAL_QCI_CNT2,CENTRAL_QCI_CNT3,CENTRAL_QCI_CNT4,CENTRAL_QCI_CNT5</dimIndex>
          <name>QCI_CNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2140</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Filter counter (see 802.1Qci 8.6.5.1.1 f)
CNT0: Frames that matched filter
CNT1: Frames that passed gate
CNT2: Frames that did not pass gate
CNT3: Frames that passed Maximum-SDU size check
CNT4: Frames that did not pass size check
CNT5: Frames discarded by Flow Meter operation
Counters starting at value &lt;0&gt; after reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_MCTRL</name>
          <description>Flow meter settings</description>
          <addressOffset>0x2160</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Flow Meter reset – self-resetting to &lt;0&gt;</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MAFR</name>
              <description>MarkAllFramesRed – cleared by RESET
(802.1Qci – 8.6.5.1.3 (j))</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAFREN</name>
              <description>MarkAllFramesRedEnable
(802.1Qci – 8.6.5.1.3 (i))</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DOY</name>
              <description>DropOnYellow
(802.1Qci – 8.6.5.1.3 (h))</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CM</name>
              <description>Color mode – functionally unused
(802.1Qci – 8.6.5.1.3 (g))</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CF</name>
              <description>Coupling flag
(802.1Qci – 8.6.5.1.3 (f))</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_CIR</name>
          <description>No description available</description>
          <addressOffset>0x2170</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>CIR</name>
              <description>Committed information rate – see Chapter 7.5.2.4.
(802.1Qci – 8.6.5.1.3 (b))</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_CBS</name>
          <description>No description available</description>
          <addressOffset>0x2174</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBS</name>
              <description>Committed burst size, in bits (not octets!)
(802.1Qci – 8.6.5.1.3 (c))</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_EIR</name>
          <description>No description available</description>
          <addressOffset>0x2178</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>EIR</name>
              <description>Excess information rate – see Chapter 7.5.2.4.
(802.1Qci – 8.6.5.1.3 (d))</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_EBS</name>
          <description>No description available</description>
          <addressOffset>0x217c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EBS</name>
              <description>Excess burst size, in bits (not octets)
(802.1Qci – 8.6.5.1.3 (e))</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_GCTRL</name>
          <description>Gate settings</description>
          <addressOffset>0x2180</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>IPV</name>
              <description>Administrative internal priority value specification
(802.1Qci – 8.6.5.1.2 (c))</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STATE</name>
              <description>Administrative stream gate state
(802.1Qci – 8.6.5.1.2 (b))</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CDOEE</name>
              <description>Gate – ClosedDueToOctetsExceededEnable
(802.1Qci – 8.6.5.1.2 (f))</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CDIRE</name>
              <description>Gate – ClosedDueToInvalidRxEnable
(802.1Qci – 8.6.5.1.2 (d))</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGCH</name>
              <description>Gate – change config (self-resetting to &lt;0&gt;)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Gate control – enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_GSTATUS</name>
          <description>No description available</description>
          <addressOffset>0x2184</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>IPV</name>
              <description>Operational internal priority value specification
(802.1Qci – 8.6.5.1.2 (c))</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>Operational stream gate state
(802.1Qci – 8.6.5.1.2 (b))</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CDOE</name>
              <description>Gate – ClosedDueToOctetsExceeded. Write &lt;1&gt; to
clear.
(802.1Qci – 8.6.5.1.2 (g))</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CDIR</name>
              <description>Gate – ClosedDueToInvalidRx. Write &lt;1&gt; to clear.
(802.1Qci – 8.6.5.1.2 (e))</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CFGP</name>
              <description>Configuration change pending</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFGERR</name>
              <description>Configuration change error. Write &lt;1&gt; to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_GLISTINDEX</name>
          <description>No description available</description>
          <addressOffset>0x2188</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>IDX</name>
              <description>Admin list pointer, select entry 0 – 15.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_LISTLEN</name>
          <description>No description available</description>
          <addressOffset>0x218c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F000F</resetMask>
          <fields>
            <field>
              <name>OLEN</name>
              <description>Operational list length</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALEN</name>
              <description>Administrative list length</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_ACYCLETM</name>
          <description>No description available</description>
          <addressOffset>0x2190</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACT</name>
              <description>Administrative cycle time length, nanoseconds.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_ABASETM_L</name>
          <description>No description available</description>
          <addressOffset>0x2194</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ABTL</name>
              <description>Administrative base time. Nanoseconds and seconds part. Cycle starts after becoming operational when time is reached by inputs &lt;rtc_sec&gt; and &lt;rtc_ns&gt;.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_ABASETM_H</name>
          <description>No description available</description>
          <addressOffset>0x2198</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ABTH</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_AENTRY_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x21a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATE</name>
              <description>AdminList – gate state (1: open)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPV</name>
              <description>AdminList – IPV</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCT</name>
              <description>AdminList – maximum octets (0 – disabled)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_AENTRY_AENTRY_IVAL</name>
          <description>No description available</description>
          <addressOffset>0x21a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IVAL</name>
              <description>AdminList – time interval in clock ticks</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_AENTRY_OCYCLETM</name>
          <description>No description available</description>
          <addressOffset>0x21a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OCT</name>
              <description>OperCycleTime in nanoseconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_AENTRY_OBASETM_L</name>
          <description>No description available</description>
          <addressOffset>0x21ac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OBTL</name>
              <description>OperBaseTime – nanoseconds and seconds. Constantly
updated – OperBaseTime + N * OperCycleTimt. Might
be non-normalized.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CENTRAL_QCI_AENTRY_OBASETM_H</name>
          <description>No description available</description>
          <addressOffset>0x21b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OBTH</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MM2S_DMA_CR</name>
          <description>mm2s control register</description>
          <addressOffset>0x4000</addressOffset>
          <size>32</size>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFF00000F</resetMask>
          <fields>
            <field>
              <name>MXLEN</name>
              <description>max axi burst size</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQEN</name>
              <description>interrupt request enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>do reset when active</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SOE</name>
              <description>stop on error flag</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RUN</name>
              <description>run command from queue to data mover</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MM2S_DMA_SR</name>
          <description>mm2s status</description>
          <addressOffset>0x4004</addressOffset>
          <size>32</size>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RBUFF</name>
              <description>response buffer full</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RBUFE</name>
              <description>response buffer empty</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CBUFF</name>
              <description>command buffer full</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CBUFE</name>
              <description>command buffer empty</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>interrupt request pending</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSET</name>
              <description>resetting status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>busy</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STOP</name>
              <description>mm2s is stopped</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MM2S_DMA_FILL</name>
          <description>mm2s dma fill status</description>
          <addressOffset>0x4008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFILL</name>
              <description>response buffer fill level</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFILL</name>
              <description>command buffer fill level</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MM2S_DMA_CFG</name>
          <description>mm2s dma configure</description>
          <addressOffset>0x401c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBUFD</name>
              <description>data buffer depth</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CBUFD</name>
              <description>command buffer depth</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENA64</name>
              <description>enable support for 64 bit addressing</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ASIZE</name>
              <description>axi data bus width</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VER</name>
              <description>ip version</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MM2S_ADDRLO</name>
          <description>mm2s axi address</description>
          <addressOffset>0x4020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRLO</name>
              <description>axi address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MM2S_LENGTH</name>
          <description>mm2s axi length</description>
          <addressOffset>0x4028</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>LENGTH</name>
              <description>transfer request length in bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MM2S_CTRL</name>
          <description>mm2s command control</description>
          <addressOffset>0x402c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>GO</name>
              <description>commit buffered descriptor to command queue</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NGENLAST</name>
              <description>no generation of TLAST</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>command id</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MM2S_RESP</name>
          <description>mm2s response buffer</description>
          <addressOffset>0x4030</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7F00FFFF</resetMask>
          <fields>
            <field>
              <name>LAST</name>
              <description>axi-stream with TLAST</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DECERR</name>
              <description>decode error</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVERR</name>
              <description>slave error</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>command ID feedback</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LENGTH</name>
              <description>requested length of tansfer in bytes from command</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S2MM_DMA_CR</name>
          <description>s2mm dma control</description>
          <addressOffset>0x4080</addressOffset>
          <size>32</size>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFF00000F</resetMask>
          <fields>
            <field>
              <name>MXLEN</name>
              <description>max axi burst size</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQEN</name>
              <description>interrupt request enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>do reset when writing 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SOE</name>
              <description>stop on error flag</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RUN</name>
              <description>run commands from queue to data mover</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S2MM_DMA_SR</name>
          <description>s2mm state</description>
          <addressOffset>0x4084</addressOffset>
          <size>32</size>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RBUFF</name>
              <description>response buffer full</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RBUFE</name>
              <description>response buffer empty</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CBUFF</name>
              <description>command buffer full</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CBUFE</name>
              <description>command buffer empty</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>interrupt request pending</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSET</name>
              <description>resetting status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>busy, issued command and outstanding response</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STOP</name>
              <description>s2mm is stopped</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S2MM_DMA_FILL</name>
          <description>s2mm buffer fill status</description>
          <addressOffset>0x4088</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFILL</name>
              <description>response buffer fill level</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFILL</name>
              <description>command buffer fill level</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S2MM_DMA_CFG</name>
          <description>s2mm dma config status</description>
          <addressOffset>0x409c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBUFD</name>
              <description>data buffer depth</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CBUFD</name>
              <description>command buffer depth</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENA64</name>
              <description>enabled support for 64 bit</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ASIZE</name>
              <description>axi data bus width</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VER</name>
              <description>IP version</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S2MM_ADDRLO</name>
          <description>s2mm axi address</description>
          <addressOffset>0x40a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRLO</name>
              <description>axi address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S2MM_LENGTH</name>
          <description>s2mm axi length</description>
          <addressOffset>0x40a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>LENGTH</name>
              <description>transfer request length in bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S2MM_CTRL</name>
          <description>s2mm command control</description>
          <addressOffset>0x40ac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000000F</resetMask>
          <fields>
            <field>
              <name>GO</name>
              <description>commit buffered descriptor to command queue</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>command id</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S2MM_RESP</name>
          <description>s2mm response buffer</description>
          <addressOffset>0x40b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7F00FFFF</resetMask>
          <fields>
            <field>
              <name>LAST</name>
              <description>axi-stream with last</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DECERR</name>
              <description>decode error</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVERR</name>
              <description>slave error</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>command ID feedback</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LENGTH</name>
              <description>received packet size when terminated by TLAST</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_TS_CTL</name>
          <description>timestamp control</description>
          <addressOffset>0x6000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F000010</resetMask>
          <fields>
            <field>
              <name>ATSEN</name>
              <description>auxiliay snapshot enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSFC</name>
              <description>auxiliary snapshot fifo clear</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TSTIG</name>
              <description>timestamp interrupt trigger enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS_TOD_SEC</name>
          <description>pps tod seconds</description>
          <addressOffset>0x6008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPS_TOD_SEC</name>
              <description>pps tod seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS_TOD_NS</name>
          <description>pps tod sun seconds</description>
          <addressOffset>0x600c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPS_TOD_NS</name>
              <description>pps tod sub seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_SCP_SEC0</name>
          <description>target time seconds</description>
          <addressOffset>0x601c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCP_SEC</name>
              <description>target time seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_SCP_NS0</name>
          <description>target time sub seconds</description>
          <addressOffset>0x6020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCP_NS</name>
              <description>target time sub seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_TMR_STS</name>
          <description>timer status</description>
          <addressOffset>0x6028</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F0F07FE</resetMask>
          <fields>
            <field>
              <name>RD_CNT</name>
              <description>fifo valid count</description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ATSSTM</name>
              <description>auxiliary fifo full error</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ATPORT</name>
              <description>auxiliary port</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PPS_TOD_INTR</name>
              <description>pps tod intrrupt</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TARGET_TIME3_CFG_ERR</name>
              <description>target time3 configure error</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TARGET_TIME3_REACH_INTR</name>
              <description>target time3 reached</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TARGET_TIME2_CFG_ERR</name>
              <description>target time2 configure error</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TARGET_TIME2_REACH_INTR</name>
              <description>target time2 reached</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TARGET_TIME1_CFG_ERR</name>
              <description>target time1 configure error</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TARGET_TIME1_REACH_INTR</name>
              <description>target time1 reached</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TARGET_TIME0_CFG_ERR</name>
              <description>target time0 configure error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PTP_FIFO_WR_INTR</name>
              <description>auxiliary timestamp trigger snapshot</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TARGET_TIME0_REACH_INTR</name>
              <description>target time0 reached</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS_CMD</name>
          <description>pps command control</description>
          <addressOffset>0x602c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x6767677F</resetMask>
          <fields>
            <field>
              <name>PPS_MODE3</name>
              <description>Target Time Register Mode for PPS3 Output</description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_CMD3</name>
              <description>pps3 command</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_MODE2</name>
              <description>Target Time Register Mode for PPS2 Output</description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_CMD2</name>
              <description>pps2 command</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_MODE1</name>
              <description>Target Time Register Mode for PPS1 Output</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_CMD1</name>
              <description>pps1 command</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_MODE0</name>
              <description>Target Time Register Mode for PPS0 Output</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_EN0</name>
              <description>flexible PPS0 output mode enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_CMD0</name>
              <description>pps0 command</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_ATSLO</name>
          <description>auxiliray read data sub seconds</description>
          <addressOffset>0x6030</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>STSLO</name>
              <description>auxiliary fifo read sub seconds info</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_ATSHI</name>
          <description>auxiliray read data seconds</description>
          <addressOffset>0x6034</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STSHI</name>
              <description>auxiliary fifo read  seconds info</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS0_INTERVAL</name>
          <description>pps0 interval configure</description>
          <addressOffset>0x6060</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPSINT</name>
              <description>PPS0 output signal interval</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS0_WIDTH</name>
          <description>pps0 width configure</description>
          <addressOffset>0x6064</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPS_WIDTH</name>
              <description>pps0 output signal width</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_SCP_SEC1</name>
          <description>target time seconds</description>
          <addressOffset>0x6080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCP_SEC</name>
              <description>target time seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_SCP_NS1</name>
          <description>target time sub seconds</description>
          <addressOffset>0x6084</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCP_NS</name>
              <description>target time sub seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS1_INTERVAL</name>
          <description>pps1 interval configure</description>
          <addressOffset>0x6088</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPSINT</name>
              <description>PPS1 output signal interval</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS1_WIDTH</name>
          <description>pps1 width configure</description>
          <addressOffset>0x608c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPS_WIDTH</name>
              <description>pps1 output signal width</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_SCP_SEC2</name>
          <description>target time seconds</description>
          <addressOffset>0x60a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCP_SEC</name>
              <description>target time seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_SCP_NS2</name>
          <description>target time sub seconds</description>
          <addressOffset>0x60a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCP_NS</name>
              <description>target time sub seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS2_INTERVAL</name>
          <description>pps2 interval configure</description>
          <addressOffset>0x60a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPSINT</name>
              <description>PPS2 output signal interval</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS2_WIDTH</name>
          <description>pps2 width configure</description>
          <addressOffset>0x60ac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPS_WIDTH</name>
              <description>pps2 output signal width</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_SCP_SEC3</name>
          <description>target time seconds</description>
          <addressOffset>0x60c0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCP_SEC</name>
              <description>target time seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_SCP_NS3</name>
          <description>target time sub seconds</description>
          <addressOffset>0x60c4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCP_NS</name>
              <description>target time sub seconds</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS3_INTERVAL</name>
          <description>pps3 interval configure</description>
          <addressOffset>0x60c8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPSINT</name>
              <description>PPS3 output signal interval</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS3_WIDTH</name>
          <description>pps3 width configure</description>
          <addressOffset>0x60cc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPS_WIDTH</name>
              <description>pps3 output signal width</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS_CTRL0</name>
          <description>pps control 0 register</description>
          <addressOffset>0x60e0</addressOffset>
          <size>32</size>
          <resetValue>0x0000000A</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>PPS_TOD_INTR_MSK</name>
              <description>pps tod interrupt enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TARGET_RAC_INTR_MSK</name>
              <description>target timmer interrupt mask</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_WR_INTR_MSK</name>
              <description>auxiliary snapshot fifo write interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_SEL</name>
              <description>timer selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTP_EVT_PPS_SEL</name>
          <description>No description available</description>
          <addressOffset>0x60e4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>PPS3_SEL</name>
              <description>pps selection for pps3</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS2_SEL</name>
              <description>pps selection for pps2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS1_SEL</name>
              <description>pps selection for pps1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS0_SEL</name>
              <description>pps selection for pps0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SOFT_RST_CTRL</name>
          <description>softer reset control</description>
          <addressOffset>0x60f0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000D3F</resetMask>
          <fields>
            <field>
              <name>TSN_CORE_RST</name>
              <description>tsn core reset control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PTP_EVT_RST</name>
              <description>ptp event module reset control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA0_RST</name>
              <description>dma0 reset control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT3_RX_RST</name>
              <description>port3 rx reset control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT3_TX_RST</name>
              <description>port3 tx reset control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT2_RX_RST</name>
              <description>port2 rx reset control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT2_TX_RST</name>
              <description>port2 tx reset control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT1_RX_RST</name>
              <description>port1 rx reset control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT1_TX_RST</name>
              <description>port1 tx reset control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_PORT_MAIN_TAGGING</name>
          <description>PVID Tagging Register</description>
          <addressOffset>0x10000</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>FORCE</name>
              <description>The VLAN-TAG with PVID will be inserted in every frame from Host as their first VLAN-TAG. This can be used for double tagging of tagged/trunk ports</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACCESS</name>
              <description>Every tagged frame not matching PVID is filtered out. Every untagged ingress  frame will be tagged with PVID. Every egress frame with PVID will be untagged</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCP</name>
              <description>VLAN-TCI: Priority Code Point, used when tagged.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEI</name>
              <description>VLAN-TCI: Drop Eligible Indicator, used when tagged.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PVID</name>
              <description>Native VLAN of Port. Untagged traffic will be tagged with the native VLAN-ID By default the Port uses VLAN 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_PORT_MAIN_ENNABLE</name>
          <description>Port Module Enable Register</description>
          <addressOffset>0x10004</addressOffset>
          <size>32</size>
          <resetValue>0x00000003</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>EN_SF</name>
              <description>only applicable for CPU-Port at egress: '1' to use S&amp;F FIFO and '0' disable S&amp;F FIFO. Changing during frame operation can lead to frame corruption</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_QCI</name>
              <description>if QCI is present at selected egress port, '1' to use QCI and '0' disable QCI. Changing during frame operation can lead to frame corruption.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_STMID_ESELECT</name>
          <description>Stream Identification</description>
          <addressOffset>0x12800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>ESEL</name>
              <description>Select entry. Selected entry mapped to 0x40 – 0x5C.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_STMID_CONTROL</name>
          <description>No description available</description>
          <addressOffset>0x12840</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>SID</name>
              <description>Stream ID – inserted to header on match</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQGEN</name>
              <description>Sequence number generation enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTCTL</name>
              <description>Active Destination MAC – control. See Table 6-6.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SMAC</name>
              <description>0: Lookup by Destination MAC 1: Lookup by Source MAC</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Lookup mode. 1:Priority – a frame must be untagged or priority tagged ; 2:Tagged – a frame must have a VLAN tag ; 3:All – a frame can be tagged or untagged</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Enable entry</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_STMID_SEQNO</name>
          <description>No description available</description>
          <addressOffset>0x12844</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>SEQNO</name>
              <description>Sequence number – next number when generating,any write access to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_STMID_MATCHCNT</name>
          <description>No description available</description>
          <addressOffset>0x12848</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Entry match counter – any write access to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_STMID_MACLO</name>
          <description>No description available</description>
          <addressOffset>0x12850</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MACL</name>
              <description>MAC-Address [31:0] used by lookup.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_STMID_MACHI</name>
          <description>No description available</description>
          <addressOffset>0x12854</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID</name>
              <description>VLAN ID used by lookup.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MATCH</name>
              <description>MAC-Address [47:31] used by lookup.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_STMID_AMACHI</name>
          <description>No description available</description>
          <addressOffset>0x1285c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APCP</name>
              <description>Active Destination MAC, PCP</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVID</name>
              <description>Active Destination MAC, VLAN ID</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMACH</name>
              <description>Active Destination MAC, MAC-Address [47:32]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_CONTROL</name>
          <description>Frame Replication and Elimination</description>
          <addressOffset>0x12a00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>LATER</name>
              <description>Latent error flag – write 1 to clear</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTENC</name>
              <description>R-TAG encoding enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_SIDSEL</name>
          <description>No description available</description>
          <addressOffset>0x12a04</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>SID</name>
              <description>Stream ID selection for host access to IRFUNC and SRFUNC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_IRFUNC</name>
          <description>No description available</description>
          <addressOffset>0x12a08</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>FEN</name>
              <description>Individual recovery function: FEN – enable function for stream SIDSEL.SID. FIDX – function index for stream SIDSEL.SID If function does not exists (FIDX &gt;= 2**FD), FEN will be set to 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIDX</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_SRFUNC</name>
          <description>No description available</description>
          <addressOffset>0x12a0c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>FEN</name>
              <description>Sequence recovery function: FEN – enable function for stream SIDSEL.SID. FIDX – function index for stream SIDSEL.SID If function does not exists (FIDX &gt;= 2**FD), FEN will be set to 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIDX</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_FSELECT</name>
          <description>No description available</description>
          <addressOffset>0x12a10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>FIDX</name>
              <description>Recovery function selection for host access at offset 0x140+</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_FCTRL</name>
          <description>No description available</description>
          <addressOffset>0x12a40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80FFFFFF</resetMask>
          <fields>
            <field>
              <name>FRSET</name>
              <description>Reset recovery function – self-resetting to 0</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PATHS</name>
              <description>Number of paths (used by latent error detection)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HLEN</name>
              <description>History length (used by Vector recovery algorithm)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALGO</name>
              <description>Recovery function algorithm: 0 – Vector recovery algorithm 1 – Match recovery algorithm</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LATEN</name>
              <description>Latent error detection enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IND</name>
              <description>Individual function (802.1CB 10.4.1.10)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TNS</name>
              <description>TakeNoSequence (802.1CB 10.4.1.9)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_RESETMSEC</name>
          <description>No description available</description>
          <addressOffset>0x12a44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>FSRMS</name>
              <description>frerSeqRcvyResetMSec (802.1CB 10.4.1.7)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_LatRsPeriod</name>
          <description>No description available</description>
          <addressOffset>0x12a48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>FLATR</name>
              <description>frerSeqRcvyLatentResetPeriod (802.1CB 10.4.1.12.4)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_LatTestPeriod</name>
          <description>No description available</description>
          <addressOffset>0x12a4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>FLATT</name>
              <description>frerSeqRcvyLatentErrorPeriod (802.1CB 10.4.1.12.2)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_LatErrDiffAlw</name>
          <description>No description available</description>
          <addressOffset>0x12a50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FDIFF</name>
              <description>frerSeqRcvyLatentErrorDifference (802.1CB 10.4.1.12.1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_EGRESS_FRER_LatErrCnt</name>
          <description>No description available</description>
          <addressOffset>0x12a54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LATERR</name>
              <description>Counter – latent error detect. Write any value to clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>CPU_PORT_EGRESS_FRER_CNT0,CPU_PORT_EGRESS_FRER_CNT1,CPU_PORT_EGRESS_FRER_CNT2,CPU_PORT_EGRESS_FRER_CNT3,CPU_PORT_EGRESS_FRER_CNT4,CPU_PORT_EGRESS_FRER_CNT5,CPU_PORT_EGRESS_FRER_CNT6,CPU_PORT_EGRESS_FRER_CNT7</dimIndex>
          <name>EGFRCNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x12a60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Frame counters</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_FDMEM_CNT_BYTE</name>
          <description>No description available</description>
          <addressOffset>0x14000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FDMEM_CNT_BYTE</name>
              <description>Number of bytes stored in frame drop FIFO</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_FDMEM_STS</name>
          <description>No description available</description>
          <addressOffset>0x14004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000F0F</resetMask>
          <fields>
            <field>
              <name>WAIT_FOR_LU</name>
              <description>FD FIFO waits for LookUp information.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WAIT_FOR_FRAME</name>
              <description>FD FIFO waits for more frame data.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>FD FIFO processes data.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>READY</name>
              <description>FD FIFO ready to work or working.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>FD FIFO full</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AMST_FULL</name>
              <description>FD FIFO almost full. Less than 1600 Byte left.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AMST_EMPTY</name>
              <description>FD FIFO almost empty. Few bytes in FIFO.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FD FIFO empty</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_ERROR_FLAG</name>
          <description>No description available</description>
          <addressOffset>0x14008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>LU_DESC_ERR</name>
              <description>LookUp Descriptor lost, because of unknown frame burst by MAC. If there is no  MAC mailfunction then this flag will never be raised. FDFIFO requires reset.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRFAIL_FULL</name>
              <description>Set if a frame is partially written into FIFO which had insufficient space. The frame is cut and frame error is set.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_NRDY</name>
              <description>Frame was dropped because the FIFO was not ready. That can typically happen after a reset of the FIFO</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_FULL_DESC</name>
              <description>Frame was dropped because the internal descriptor FIFO is full. Full by too many frames.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_FULL_MEM</name>
              <description>Frame was dropped because the FIFO is full. Full by too much data.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DESC_NRDY_ERR</name>
              <description>FD FIFO failure. Descriptor not received correctly.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DESC_SEQ_ERR</name>
              <description>FD FIFO failure. Internal controller lost synchronization.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_IE_ERROR_FLAG</name>
          <description>No description available</description>
          <addressOffset>0x1400c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>IE</name>
              <description>Interrupt enable of ERROR_FLAG.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_IN_CONFIG</name>
          <description>No description available</description>
          <addressOffset>0x14010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>NOCUT_ERROR</name>
              <description>FD_FIFO does not shorten frames which contain an error.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_OUT_CONFIG</name>
          <description>No description available</description>
          <addressOffset>0x14014</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF037F</resetMask>
          <fields>
            <field>
              <name>DROP_DEST</name>
              <description>Bit mapped Destination for dropped frames. Typically, frames are cleared at destination 0. Use another value to stream frames for analysis. Supports only max range of port[15:0].</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIRROR_TX_EN</name>
              <description>Incoming frames of this port will be mirrored to the given destination in MIRROR if their destination match with MIRROR_TX.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIRROR_RX_EN</name>
              <description>Incoming frames of this port will be mirrored to the given destination in MIRROR_RX.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CT_FPE_OVRD</name>
              <description>If any Store&amp;Forward option in RX_FDFIFO is set then this flag will still force preemptable traffic to be forwarded in Cut-Through mode. This is a useful option to save latency by double buffering if the used MAC/TSN-EP already does S&amp;F.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Disable input of FD FIFO. Take care that also descriptor generation of LookUp is disabled. Remaining frames should be cleared with DROP_ALL.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ALL</name>
              <description>Route all frames to DROP_DEST.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERROR_TO_CPU</name>
              <description>Send error frames to CPU.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIRROR_TO_CPU</name>
              <description>Duplicate frames to CPU.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NODROP_ERROR</name>
              <description>Do not drop frame errors.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_STORE_FW</name>
              <description>Switch between Cut-Through and Store&amp;Forward mode. 0 - Cut-Through 1 - Store&amp;Forward</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_RESET</name>
          <description>No description available</description>
          <addressOffset>0x14018</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SOFTRS</name>
              <description>Write 1 to reset FD controller and memory pointers. Register Map content remains untouched</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_PARAM</name>
          <description>No description available</description>
          <addressOffset>0x1401c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LU_FIFO_DEPTH</name>
              <description>Number of MAC lookup descriptors the FIFO can store.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FD_DESC_FIFO_DESC</name>
              <description>Number of FD descriptors the FIFO can store. Two descriptors need to be stored per frame.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FD_FIFO_DESC</name>
              <description>Number of words (4byte) the Frame Drop FIFO can store.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_STRFWD</name>
          <description>No description available</description>
          <addressOffset>0x14020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT</name>
              <description>If selected port is set then the frame is transmitted in Store &amp; Forward mode. This is necessary when the ingress rate of this port is slower than the egress rate of the transmitting port. In S&amp;F, the ingress module is able to drop frames with bad CRC.bit 0 - CPU-Port,
bit 1 - Port 1, …</description>
              <bitOffset>0</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_PORTMASK</name>
          <description>No description available</description>
          <addressOffset>0x14024</addressOffset>
          <size>32</size>
          <resetValue>0x001FFFFF</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT</name>
              <description>Port grouping via port mask. If the selected port is not set then the destination will be filtered out. This register allows the realization of port-based-VLAN (no VLAN tags required, only set it by ports).
bit 0 - CPU-Port,
bit 1 - Port 1, …</description>
              <bitOffset>0</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_MIRROR</name>
          <description>No description available</description>
          <addressOffset>0x14028</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT</name>
              <description>Mirror Port. If port mirroring is enabled TX/RX traffic will also be forwarded to this port.
bit 0 - CPU-Port,
bit 1 - Port 1, …</description>
              <bitOffset>0</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_RX_FDFIFO_MIRROR_TX</name>
          <description>No description available</description>
          <addressOffset>0x1402c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT</name>
              <description>Mirror Selection TX. The destination of the frame is compared with this vector. All matching TX probe ports will be mirrored to MIRROR. It is necessary to configure all ingress ports to mirror the complete TX traffic.
bit 0 - CPU-Port,
bit 1 - Port 1, …</description>
              <bitOffset>0</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_STMID_ESELECT</name>
          <description>Stream Identification</description>
          <addressOffset>0x14800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>ESEL</name>
              <description>Select entry. Selected entry mapped to 0x40 – 0x5C.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_STMID_CONTROL</name>
          <description>No description available</description>
          <addressOffset>0x14840</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>SID</name>
              <description>Stream ID – inserted to header on match</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQGEN</name>
              <description>Sequence number generation enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTCTL</name>
              <description>Active Destination MAC – control. See Table 6-6.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SMAC</name>
              <description>0: Lookup by Destination MAC 1: Lookup by Source MAC</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Lookup mode. 1:Priority – a frame must be untagged or priority tagged ; 2:Tagged – a frame must have a VLAN tag ; 3:All – a frame can be tagged or untagged</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Enable entry</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_STMID_SEQNO</name>
          <description>No description available</description>
          <addressOffset>0x14844</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>SEQNO</name>
              <description>Sequence number – next number when generating,any write access to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_STMID_MATCHCNT</name>
          <description>No description available</description>
          <addressOffset>0x14848</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Entry match counter – any write access to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_STMID_MACLO</name>
          <description>No description available</description>
          <addressOffset>0x14850</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MACL</name>
              <description>MAC-Address [31:0] used by lookup.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_STMID_MACHI</name>
          <description>No description available</description>
          <addressOffset>0x14854</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID</name>
              <description>VLAN ID used by lookup.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MATCH</name>
              <description>MAC-Address [47:31] used by lookup.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_STMID_AMACHI</name>
          <description>No description available</description>
          <addressOffset>0x1485c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APCP</name>
              <description>Active Destination MAC, PCP</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVID</name>
              <description>Active Destination MAC, VLAN ID</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMACH</name>
              <description>Active Destination MAC, MAC-Address [47:32]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_CONTROL</name>
          <description>Frame Replication and Elimination</description>
          <addressOffset>0x14a00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>LATER</name>
              <description>Latent error flag – write 1 to clear</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTENC</name>
              <description>R-TAG encoding enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_SIDSEL</name>
          <description>No description available</description>
          <addressOffset>0x14a04</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>SID</name>
              <description>Stream ID selection for host access to IRFUNC and SRFUNC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_IRFUNC</name>
          <description>No description available</description>
          <addressOffset>0x14a08</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>FEN</name>
              <description>Individual recovery function: FEN – enable function for stream SIDSEL.SID. FIDX – function index for stream SIDSEL.SID If function does not exists (FIDX &gt;= 2**FD), FEN will be set to 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIDX</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_SRFUNC</name>
          <description>No description available</description>
          <addressOffset>0x14a0c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>FEN</name>
              <description>Sequence recovery function: FEN – enable function for stream SIDSEL.SID. FIDX – function index for stream SIDSEL.SID If function does not exists (FIDX &gt;= 2**FD), FEN will be set to 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIDX</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_FSELECT</name>
          <description>No description available</description>
          <addressOffset>0x14a10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>FIDX</name>
              <description>Recovery function selection for host access at offset 0x140+</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_FCTRL</name>
          <description>No description available</description>
          <addressOffset>0x14a40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80FFFFFF</resetMask>
          <fields>
            <field>
              <name>FRSET</name>
              <description>Reset recovery function – self-resetting to 0</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PATHS</name>
              <description>Number of paths (used by latent error detection)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HLEN</name>
              <description>History length (used by Vector recovery algorithm)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALGO</name>
              <description>Recovery function algorithm: 0 – Vector recovery algorithm 1 – Match recovery algorithm</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LATEN</name>
              <description>Latent error detection enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IND</name>
              <description>Individual function (802.1CB 10.4.1.10)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TNS</name>
              <description>TakeNoSequence (802.1CB 10.4.1.9)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_RESETMSEC</name>
          <description>No description available</description>
          <addressOffset>0x14a44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>FSRMS</name>
              <description>frerSeqRcvyResetMSec (802.1CB 10.4.1.7)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_LatRsPeriod</name>
          <description>No description available</description>
          <addressOffset>0x14a48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>FLATR</name>
              <description>frerSeqRcvyLatentResetPeriod (802.1CB 10.4.1.12.4)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_LatTestPeriod</name>
          <description>No description available</description>
          <addressOffset>0x14a4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>FLATT</name>
              <description>frerSeqRcvyLatentErrorPeriod (802.1CB 10.4.1.12.2)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_LatErrDiffAlw</name>
          <description>No description available</description>
          <addressOffset>0x14a50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FDIFF</name>
              <description>frerSeqRcvyLatentErrorDifference (802.1CB 10.4.1.12.1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_IGRESS_FRER_LatErrCnt</name>
          <description>No description available</description>
          <addressOffset>0x14a54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LATERR</name>
              <description>Counter – latent error detect. Write any value to clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>CPU_PORT_IGRESS_FRER_CNT0,CPU_PORT_IGRESS_FRER_CNT1,CPU_PORT_IGRESS_FRER_CNT2,CPU_PORT_IGRESS_FRER_CNT3,CPU_PORT_IGRESS_FRER_CNT4,CPU_PORT_IGRESS_FRER_CNT5,CPU_PORT_IGRESS_FRER_CNT6,CPU_PORT_IGRESS_FRER_CNT7</dimIndex>
          <name>IGFRCNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x14a60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Frame counters</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x18004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Enables counter. If deasserted the counter process stops and the counters hold their value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RESET</name>
          <description>No description available</description>
          <addressOffset>0x18008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>RSRX</name>
              <description>Write '1' to reset all RX counters.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RSTX</name>
              <description>Write '1' to reset all TX counters</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RSALL</name>
              <description>Write '1' to reset all TX&amp;RX counters.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_PARAM</name>
          <description>No description available</description>
          <addressOffset>0x1800c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF7F</resetMask>
          <fields>
            <field>
              <name>RX_CNT_EN_VEC</name>
              <description>Vector of implemented RX counters. E.g. 0x000F means only the first 4 RX counter are available.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_CNT_EN_VEC</name>
              <description>Vector of implemented RX counters. E.g. 0x000F means only the first 4 RX counter are available.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNTW</name>
              <description>Vector of implemented RX counters. E.g. 0x000F means only the first 4 RX counter
are available.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_TX_COUNTER_TX_FGOOD</name>
          <description>No description available</description>
          <addressOffset>0x18010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_FGOOD</name>
              <description>Good transmitted Frames to TX TSN-EP.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_TX_COUNTER_TX_FERROR</name>
          <description>No description available</description>
          <addressOffset>0x18018</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_FERROR</name>
              <description>Transmitted Frames with Error to TX TSN-EP.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_TX_COUNTER_TX_DROP_OVFL</name>
          <description>No description available</description>
          <addressOffset>0x18020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DROP_OVFL</name>
              <description>Dropped frames by full queue of TSN-EP.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_FGOOD</name>
          <description>No description available</description>
          <addressOffset>0x18040</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_FGOOD</name>
              <description>Good received frame by ingress buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_FERROR</name>
          <description>No description available</description>
          <addressOffset>0x18048</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_FERROR</name>
              <description>Bad received frame by ingress buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_KNOWN</name>
          <description>No description available</description>
          <addressOffset>0x18050</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_KNOWN</name>
              <description>Number of frames passed ingress with hit by MAC Table. This includes Broadcast and non-relayed frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_UNKNOWN</name>
          <description>No description available</description>
          <addressOffset>0x18058</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_UNKNOWN</name>
              <description>Number of frames passed ingress without hit by MAC table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_UC</name>
          <description>No description available</description>
          <addressOffset>0x18060</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_UC</name>
              <description>Number of unicast frames</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_INTERN</name>
          <description>No description available</description>
          <addressOffset>0x18068</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_INTERN</name>
              <description>Number of non-relay frames</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_BC</name>
          <description>No description available</description>
          <addressOffset>0x18070</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_BC</name>
              <description>Number of Broadcast frames</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_MULTI</name>
          <description>No description available</description>
          <addressOffset>0x18078</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_MULTI</name>
              <description>Number of Multicast frames</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_VLAN</name>
          <description>No description available</description>
          <addressOffset>0x18080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_VLAN</name>
              <description>Number of VLAN tagged frames</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_DROP_OVFL</name>
          <description>No description available</description>
          <addressOffset>0x18088</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_DROP_OVFL</name>
              <description>Dropped frames by ingress overflow.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_DROP_LU</name>
          <description>No description available</description>
          <addressOffset>0x18090</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_DROP_LU</name>
              <description>Dropped frames by LookUp decision.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_DROP_ERR</name>
          <description>No description available</description>
          <addressOffset>0x18098</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_DROP_ERR</name>
              <description>Dropped frames with error by ingress. Possible in S&amp;F mode or when frame is queued in ingress.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_DROP_VLAN</name>
          <description>No description available</description>
          <addressOffset>0x180a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_DROP_VLAN</name>
              <description>Dropped frames by incompatible VLAN.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPU_PORT_MONITOR_RX_COUNTER_RX_FPE_FGOOD</name>
          <description>No description available</description>
          <addressOffset>0x180a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_FPE_FGOOD</name>
              <description>Number of preemptable frames. Subset of RX_FGOOD</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x20000</dimIncrement>
          <dimIndex>port1,port2,port3</dimIndex>
          <name>TSNPORT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20000</addressOffset>
          <cluster>
            <dim>2</dim>
            <dimIncrement>0x200</dimIncrement>
            <dimIndex>em1,pm1</dimIndex>
            <name>MAC[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <register>
              <name>MAC_VER</name>
              <description>No description available</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>VER_H</name>
                  <description>Major version number (higher part of the version)</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VER_L</name>
                  <description>Minor version number (lower part of the version)</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_MACADDR_L</name>
              <description>No description available</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MACADDR</name>
                  <description>MAC address
Lower bits of MAC address (31:0).
MACADDR only be modified if TX_EN=0 and RX_EN=0.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_MACADDR_H</name>
              <description>No description available</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x0001FFFF</resetMask>
              <fields>
                <field>
                  <name>PROMISC</name>
                  <description>0 – disabled
1 – enabled
If promiscuous mode is enabled, then reception of all frames independent from the
Ethernet destination address is enabled.
PROMISC can be changed at any time.</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MACADDR</name>
                  <description>MAC address (see Chapter 4.1)
Upper bits of MAC address (47:32).
MACADDR can only be modified if TX_EN=0 and RX_EN=0.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_MAC_CTRL</name>
              <description>No description available</description>
              <addressOffset>0xc</addressOffset>
              <size>32</size>
              <resetValue>0x00191930</resetValue>
              <resetMask>0x1F193F7F</resetMask>
              <fields>
                <field>
                  <name>FSTIM</name>
                  <description>Fault Stimulation
See Chapter 11.3, Table 11-1 for details.
FSTIM is write-locked if CSA=1.</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>5</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RCA</name>
                  <description>&lt;ref_clk&gt; active
0 – not active
1 – active
See chapter 11.2.3 for details.</description>
                  <bitOffset>20</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MCA</name>
                  <description>&lt;mii_clk&gt; active
0 – not active
1 – active
See chapter 11.2.3 for details.</description>
                  <bitOffset>19</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEN</name>
                  <description>Safety Enable
0 – disabled
1 – enabled
If enabled, then two instances of the logic core of LLEMAC-1G are compared at
runtime to each other.
SEN can only be changed if RX_EN and TX_EN can be read as 0. Deactivation delays
of RX_EN and TX_EN have to be considered. It is possible to change SEN together
with the activation of RX_EN and TX_EN.</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSA</name>
                  <description>Clock switching active (&lt;tx_clk&gt;)
0 – not active
1 – active
Switching of &lt;tx_clk&gt; is commanded if CLKSEL or FSTIM (see Table 11-1) are
written. Clock switching takes a few clock cycles and this is signaled with CSA=1.
When CSA=1 then CLKSEL and FSTIM are write-locked and cannot be changed.</description>
                  <bitOffset>13</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCE</name>
                  <description>&lt;ref_clk&gt; enable
0 – disabled
1 – enabled
RCE can only be modified if CLKSEL=111. See Chapter 7.3.3 for further details.</description>
                  <bitOffset>12</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MCE</name>
                  <description>&lt;mii_clk&gt; enable
0 – disabled
1 – enabled
MCE can only be modified if CLKSEL=111. See Chapter 7.3.3 for further details.</description>
                  <bitOffset>11</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLKSEL</name>
                  <description>TX path clock selector
000 – &lt;mii_clk&gt;
001 – &lt;ref_clk&gt; (recommended setting for this selection)
010 – &lt;ref_clk&gt; divided by 5
011 – &lt;ref_clk&gt; divided by 10
100 – &lt;ref_clk&gt; divided by 50
111 – &lt;ref_clk&gt; and enables modification of RCE and MCE
others – &lt;ref_clk&gt;
See Chapter 7 for further details.
CLKSEL is write-locked if CSA=1.</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>3</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHYSEL</name>
                  <description>Selection of the PHY (See Chapter 4.6.)
00 – MII
01 – GMII
10 – RGMII
11 – reserved
PHYSEL can only be changed if RX_EN=0 and TX_EN=0. Deactivation delays of
RX_EN and TX_EN have to be considered. PHYSEL can only be changed, if these
register bits can be read as 0. It is possible to change PHYSEL together with the
activation of RX_EN and TX_EN.
PHYSEL drives the output &lt;rx_physel&gt;.</description>
                  <bitOffset>5</bitOffset>
                  <bitWidth>2</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GMIIMODE</name>
                  <description>GMII mode / Ethernet speed selection (See Chapter 4.5.)
0 – MII: 10Mbit/s or 100Mbit/s
1 – GMII: 1GBit/s
GMIIMODE can only be changed if RX_EN=0 and TX_EN=0. Deactivation delays of
RX_EN and TX_EN have to be considered. GMIIMODE can only be changed, if these
register bits can be read as 0. It is possible to change GMIIMODE together with the
activation of RX_EN and TX_EN.
GMIIMODE drives the outputs &lt;tx_gmiimode&gt; and &lt;rx_gmiimode&gt;.</description>
                  <bitOffset>4</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>JUMBO</name>
                  <description>Jumbo frame support
0 – jumbo frames not supported
1 – jumbo frame supported (not recommended)
Jumbo frames are non-standard Ethernet frames with a size bigger than envelope
frames (which contain 1982 payload bytes). If jumbo frames are not supported, then
LLEMAC-1G generates the appropriate error signals (&lt;tx_gmii_er&gt; for the TX path
and &lt;rx_avst_err&gt; for the RX path).
Although jumbo frames typically contain up to 9000 bytes, the LLEMAC-1G can handle
an infinite frame size. The problem of jumbo frames is the necessary storage space in
transmission and reception buffers. LLEMAC-1G does not include storage buffers.
JUMBO can be activated or deactivated at any time. The new setting becomes valid
immediately after clock domain crossing.</description>
                  <bitOffset>3</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_EN</name>
                  <description>TX path enable
0 – transmission disabled - Avalon-ST READY for the TX path will be set to 0.
1 – transmission enabled
TX_EN can be activated or deactivated at any time. Deactivation may take some time.
If during deactivation there is a frame in transmission, then this frame will be
completed fist. Afterwards bit TX_EN can be read as 0.
After the transmission is disabled there may be pending frames left, waiting at the TX
stream interface.</description>
                  <bitOffset>2</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_EN</name>
                  <description>RX path enable
0 – reception disabled – no frames fed to Avalon-ST RX path
1 – reception enabled
RX_EN can be activated or deactivated at any time. Deactivation may take some time.
If during deactivation there is a frame in reception, then this frame will be completed
first. Afterwards bit RX_EN can be read as 0.</description>
                  <bitOffset>1</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESSTAT</name>
                  <description>Software reset of the statistic counters (see Table 3-8)
0 – no reset
1 – reset active
RESSTAT will be automatically set to 0 after the counters have been reset</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_TX_FRAMES</name>
              <description>No description available</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TX_FRAMES</name>
                  <description>Number of successfully transmitted frames.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_RX_FRAMES</name>
              <description>No description available</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RX_FRAMES</name>
                  <description>Number of successfully received frames.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_TX_OCTETS</name>
              <description>No description available</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TX_OCTETS</name>
                  <description>Number of successfully transmitted payload and padding octets.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_RX_OCTETS</name>
              <description>No description available</description>
              <addressOffset>0x1c</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RX_OCTETS</name>
                  <description>Number of successfully received payload and padding octets.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_MDIO_CFG</name>
              <description>No description available</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x000081FF</resetMask>
              <fields>
                <field>
                  <name>NPRE</name>
                  <description>No Preamble
With NPRE=1 the preamble generation is suppressed and frames are initiated with
Start of Frame pattern directly. Suitable in case that all connected PHYs accept
management frames without a preamble pattern. Recommended to be used if only
one PHY is connected.</description>
                  <bitOffset>15</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE</name>
                  <description>Enable the MDIO controller. If the controller is enabled then MDC will be toggled.
ENABLE can only be read as 1 if a valid MDC_CLKDIV value is set.</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDC_CLKDIV</name>
                  <description>Clock Divider to configure MDC clock frequency. Refer to 10.1 Clock Divider for more
details.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_MDIO_CTRL</name>
              <description>No description available</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xDF1F0101</resetMask>
              <fields>
                <field>
                  <name>OP</name>
                  <description>Opcode to determine transfer type
01 – Write Access
10 – Read Access</description>
                  <bitOffset>30</bitOffset>
                  <bitWidth>2</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHYAD</name>
                  <description>Management Frame PHY Address.</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>5</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGAD</name>
                  <description>Management Frame Register Address.</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>5</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INIT</name>
                  <description>INIT=1 results in a MDIO write/read transfer if READY=1. If READY=0 while a
transfer is already pending or if ENABLE=0 then settings INIT=1 has no effect and
the current transaction is withdrawn.</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>READY</name>
                  <description>READY=1 indicates a finished transfer and also shows that the controller is ready for a
new transfer. READY=1 is only possible if ENABLE=1.
If READY=1 is signaled after a read transfer, then RD_DATA is valid until a new
transfer is started.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_MDIO_RD_DATA</name>
              <description>No description available</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x0000FFFF</resetMask>
              <fields>
                <field>
                  <name>RD_DATA</name>
                  <description>Read Data is available if READY=1 after a transfer has been started. RD_DATA represents the content of the management data field of the read transfer.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_MDIO_WR_DATA</name>
              <description>No description available</description>
              <addressOffset>0x2c</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x0000FFFF</resetMask>
              <fields>
                <field>
                  <name>WR_DATA</name>
                  <description>Data is used for the management data field after a write transfer has been started</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MAC_IRQ_CTRL</name>
              <description>No description available</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <resetValue>0x0000000C</resetValue>
              <resetMask>0x00000F0D</resetMask>
              <fields>
                <field>
                  <name>CAIF</name>
                  <description>Clock activity interrupt flag
0 – no interrupt
1 – interrupt pending
See Chapter 11.2.3 for details.</description>
                  <bitOffset>11</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWIF</name>
                  <description>Safety warning interrupt flag
0 – no interrupt
1 – interrupt pending
See Chapter 11.2.2 for details</description>
                  <bitOffset>10</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SEIF</name>
                  <description>Safety Error Interrupt Flag
0 – no interrupt
1 – interrupt pending
If SEN=1 and if there is a mismatch between both instances of the logic core of
LLEMAC-1G then this results in SEIF=1, TX_EN=0 and RX_EN=0.</description>
                  <bitOffset>9</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDIF</name>
                  <description>MDIO Interrupt Flag
1 – A transfer has been finished
0 – No transfer done</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAIE</name>
                  <description>Clock activity interrupt enable
0 – CAIF disabled
1 – CAIF enabled</description>
                  <bitOffset>3</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWIE</name>
                  <description>Safety warning interrupt enable
0 – SWIF disabled
1 – SWIF enabled</description>
                  <bitOffset>2</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDIE</name>
                  <description>MDIO Interrupt Enable
0 – Disabled
1 – Enabled</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>RTC_CR</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000E</resetMask>
            <fields>
              <field>
                <name>TAIE</name>
                <description>Timer A interrupt enable: interrupt enabled when 1</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TAEN</name>
                <description>Timer A enable: timer enabled when 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ALIE</name>
                <description>Alarm interrupt enable: alarm interrupt enabled when 1</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_SR</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x804</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000A</resetMask>
            <fields>
              <field>
                <name>TAIS</name>
                <description>Timer A Interrupt Status: set at rising edge of “timer_clk_a”, write 1 to clear</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ALIS</name>
                <description>ALIS ro Alarm Interrupt Status: Always set while RTC-Time &gt;= Alarm-Time</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_CT_CURTIME_NS</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x810</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>CT_NS</name>
                <description>Local Time (nanosecond part): Update can be triggered by write access to this register. Value range from 0 – 999999999.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_CT_CURTIME_SEC</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x814</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CT_SEC</name>
                <description>Current Time (second part): Update can be triggered by write access to register CURTIME_NS.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_CT_TIMER_INCR</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x81c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NS</name>
                <description>Local time increment – nanoseconds (integer)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FNS</name>
                <description>Local time increment – fractional ns, unsigned, in (1 / 2^24) n</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_OFS_NS</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x820</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>OFS_NS</name>
                <description>Real Time Offset (nanoseconds part). Valid value range from 0 – 999999999.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_OFS_SL</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x824</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OFS_SL</name>
                <description>48 Bit Real Time Offset (seconds lo part)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_OFS_SH</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x828</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>OFS_SH</name>
                <description>48 Bit Real Time Offset (seconds hi part)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_OFS_CH</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x82c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEXT</name>
                <description>Real Time Offset Change – sign extension of SFNS (Bit 23)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SFNS</name>
                <description>Real Time Offset Change in fractional nanoseconds, signed value; value range from -2^23 / 2^24 to (2^23-1) / 2^24 nanoseconds.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_ALARM_NS</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x830</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>AL_NS</name>
                <description>Alarm Time (nanoseconds part). Valid value range from 0 – 999999999.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_ALARM_SL</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x834</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AL_SL</name>
                <description>Alarm Time (seconds lo part)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_ALARM_SH</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x838</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>AL_SH</name>
                <description>Alarm Time (seconds hi part)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RTC_TIMER_A_PERIOD</name>
            <description>ONLY IN PORT1</description>
            <addressOffset>0x840</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x1FFFFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD_NS</name>
                <description>Timer A Period in ns. This is the period of the timer until the next event, but the half-period of the signal “timer_a_clk”.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>29</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_CR</name>
            <description>No description available</description>
            <addressOffset>0x1004</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x001F1F07</resetMask>
            <fields>
              <field>
                <name>TMR_ALD</name>
                <description>Timer Auto Load: automatic reloading of timer when reaching 0. Done flag stays set after countdown. Used for periodic events, when following event shall not be delayed by host interaction.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TMR_EN</name>
                <description>Timer Enable: every bit corresponds to Timer 0 – 4</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TMRIE</name>
                <description>Timer Interrupt Enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RXIE</name>
                <description>Rx Interrupt Enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TXIE</name>
                <description>Tx Interrupt Enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_SR</name>
            <description>No description available</description>
            <addressOffset>0x1008</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00001F07</resetMask>
            <fields>
              <field>
                <name>TMR_DN</name>
                <description>Timer Done: 1 when timer reached 0</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TMRIS</name>
                <description>Timer Interrupt Status: OR’ed (TMR_DN AND TMR_EN) flags. 1 when timer is enabled and countdown is done</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RXIS</name>
                <description>Rx Interrupt Status, RX buffer data available equal to PTP_RX_STS.AV)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXIS</name>
                <description>Tx Done Interrupt Status: OR’ed PTP_TX_DONE</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_PTP_TX_STS</name>
            <description>No description available</description>
            <addressOffset>0x1010</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>STS</name>
                <description>Transmission status of PTP TX bin n (bit 0 – 7 correspond to tx bin 0 – 7). 1: transmission pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_PTP_TX_DONE</name>
            <description>No description available</description>
            <addressOffset>0x1014</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DONE</name>
                <description>Transmission done status of PTP TX bin n (bit 0 – 7 correspond to tx bin 0 – 7). 1: transmission done.
Writing a ‘1’ clears corresponding bit..</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_PTP_TX_TRIG</name>
            <description>No description available</description>
            <addressOffset>0x1018</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>TRIG</name>
                <description>Trigger PTP TX bin n (bit 0 – 7 correspond to tx bin 0 –7). Writing ‘1’ will trigger transmission. Corresponding bit PTP_TX_STS.STS(n) will be set immediately.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_PTP_RX_STS</name>
            <description>No description available</description>
            <addressOffset>0x101c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xC0000007</resetMask>
            <fields>
              <field>
                <name>OV</name>
                <description>FIFO overflow flag. PTP frame has been received and there was no free buffer available. Data has been lost.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AV_NXT</name>
                <description>Read access: buffer data available – reading data from RX_BUF is valid.
Write access: switch to next RX buffer – shall only be done when buffer not empty (AV=1). Use field RX_SEL as indication when rx buffer switch has been done.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_SEL</name>
                <description>Current selected RX buffer for reading (0-7). Can be used to determine when RX buffer has been switched after setting PTP_RX_STS.NXT</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>5</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>TSYN_TMR0,TSYN_TMR1,TSYN_TMR2,TSYN_TMR3,TSYN_TMR4</dimIndex>
            <name>TSYNTMR[%s]</name>
            <description>no description available</description>
            <addressOffset>0x1020</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period in ticks, ticks based on register HCLKDIV and host clock &lt;sys_clk&gt;.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_HCLKDIV</name>
            <description>No description available</description>
            <addressOffset>0x103c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period in host clocks &lt;sys_clk&gt;. Host clock shall be scaled to ticks of 1/1024th second. Ticks are used by timer TMR0 – TMR4.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_RXBUF_RX_FRAME_LENGTH_BYTES</name>
            <description>No description available</description>
            <addressOffset>0x1600</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000FFF</resetMask>
            <fields>
              <field>
                <name>RX_FRAME_LENGTH_BYTES</name>
                <description>RX frame length bytes [11:0]</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_RXBUF_RX_TIME_STAMP_L</name>
            <description>No description available</description>
            <addressOffset>0x1608</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_TIMESTAMP_LOW</name>
                <description>RX Timestamp [31:0]</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSYN_RXBUF_RX_TIME_STAMP_H</name>
            <description>No description available</description>
            <addressOffset>0x160c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_TIMESTAMP_HIGH</name>
                <description>RX Timestamp [63:32]</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>60</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>TSYN_RXBUF_DATA_WORD0,TSYN_RXBUF_DATA_WORD1,TSYN_RXBUF_DATA_WORD2,TSYN_RXBUF_DATA_WORD3,TSYN_RXBUF_DATA_WORD4,TSYN_RXBUF_DATA_WORD5,TSYN_RXBUF_DATA_WORD6,TSYN_RXBUF_DATA_WORD7,TSYN_RXBUF_DATA_WORD8,TSYN_RXBUF_DATA_WORD9,TSYN_RXBUF_DATA_WORD10,TSYN_RXBUF_DATA_WORD11,TSYN_RXBUF_DATA_WORD12,TSYN_RXBUF_DATA_WORD13,TSYN_RXBUF_DATA_WORD14,TSYN_RXBUF_DATA_WORD15,TSYN_RXBUF_DATA_WORD16,TSYN_RXBUF_DATA_WORD17,TSYN_RXBUF_DATA_WORD18,TSYN_RXBUF_DATA_WORD19,TSYN_RXBUF_DATA_WORD20,TSYN_RXBUF_DATA_WORD21,TSYN_RXBUF_DATA_WORD22,TSYN_RXBUF_DATA_WORD23,TSYN_RXBUF_DATA_WORD24,TSYN_RXBUF_DATA_WORD25,TSYN_RXBUF_DATA_WORD26,TSYN_RXBUF_DATA_WORD27,TSYN_RXBUF_DATA_WORD28,TSYN_RXBUF_DATA_WORD29,TSYN_RXBUF_DATA_WORD30,TSYN_RXBUF_DATA_WORD31,TSYN_RXBUF_DATA_WORD32,TSYN_RXBUF_DATA_WORD33,TSYN_RXBUF_DATA_WORD34,TSYN_RXBUF_DATA_WORD35,TSYN_RXBUF_DATA_WORD36,TSYN_RXBUF_DATA_WORD37,TSYN_RXBUF_DATA_WORD38,TSYN_RXBUF_DATA_WORD39,TSYN_RXBUF_DATA_WORD40,TSYN_RXBUF_DATA_WORD41,TSYN_RXBUF_DATA_WORD42,TSYN_RXBUF_DATA_WORD43,TSYN_RXBUF_DATA_WORD44,TSYN_RXBUF_DATA_WORD45,TSYN_RXBUF_DATA_WORD46,TSYN_RXBUF_DATA_WORD47,TSYN_RXBUF_DATA_WORD48,TSYN_RXBUF_DATA_WORD49,TSYN_RXBUF_DATA_WORD50,TSYN_RXBUF_DATA_WORD51,TSYN_RXBUF_DATA_WORD52,TSYN_RXBUF_DATA_WORD53,TSYN_RXBUF_DATA_WORD54,TSYN_RXBUF_DATA_WORD55,TSYN_RXBUF_DATA_WORD56,TSYN_RXBUF_DATA_WORD57,TSYN_RXBUF_DATA_WORD58,TSYN_RXBUF_DATA_WORD59</dimIndex>
            <name>RXDATA[%s]</name>
            <description>no description available</description>
            <addressOffset>0x1610</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RXBUF_DATA_WORD</name>
                <description>RXBUF_DATA_WORD</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>8</dim>
            <dimIncrement>0x100</dimIncrement>
            <dimIndex>tx0,tx1,tx2,tx3,tx4,tx5,tx6,tx7</dimIndex>
            <name>BIN[%s]</name>
            <description>no description available</description>
            <addressOffset>0x1800</addressOffset>
            <register>
              <dim>60</dim>
              <dimIncrement>0x4</dimIncrement>
              <dimIndex>TSYN_TXBUF_BIN0_DATA_WORD0,TSYN_TXBUF_BIN0_DATA_WORD1,TSYN_TXBUF_BIN0_DATA_WORD2,TSYN_TXBUF_BIN0_DATA_WORD3,TSYN_TXBUF_BIN0_DATA_WORD4,TSYN_TXBUF_BIN0_DATA_WORD5,TSYN_TXBUF_BIN0_DATA_WORD6,TSYN_TXBUF_BIN0_DATA_WORD7,TSYN_TXBUF_BIN0_DATA_WORD8,TSYN_TXBUF_BIN0_DATA_WORD9,TSYN_TXBUF_BIN0_DATA_WORD10,TSYN_TXBUF_BIN0_DATA_WORD11,TSYN_TXBUF_BIN0_DATA_WORD12,TSYN_TXBUF_BIN0_DATA_WORD13,TSYN_TXBUF_BIN0_DATA_WORD14,TSYN_TXBUF_BIN0_DATA_WORD15,TSYN_TXBUF_BIN0_DATA_WORD16,TSYN_TXBUF_BIN0_DATA_WORD17,TSYN_TXBUF_BIN0_DATA_WORD18,TSYN_TXBUF_BIN0_DATA_WORD19,TSYN_TXBUF_BIN0_DATA_WORD20,TSYN_TXBUF_BIN0_DATA_WORD21,TSYN_TXBUF_BIN0_DATA_WORD22,TSYN_TXBUF_BIN0_DATA_WORD23,TSYN_TXBUF_BIN0_DATA_WORD24,TSYN_TXBUF_BIN0_DATA_WORD25,TSYN_TXBUF_BIN0_DATA_WORD26,TSYN_TXBUF_BIN0_DATA_WORD27,TSYN_TXBUF_BIN0_DATA_WORD28,TSYN_TXBUF_BIN0_DATA_WORD29,TSYN_TXBUF_BIN0_DATA_WORD30,TSYN_TXBUF_BIN0_DATA_WORD31,TSYN_TXBUF_BIN0_DATA_WORD32,TSYN_TXBUF_BIN0_DATA_WORD33,TSYN_TXBUF_BIN0_DATA_WORD34,TSYN_TXBUF_BIN0_DATA_WORD35,TSYN_TXBUF_BIN0_DATA_WORD36,TSYN_TXBUF_BIN0_DATA_WORD37,TSYN_TXBUF_BIN0_DATA_WORD38,TSYN_TXBUF_BIN0_DATA_WORD39,TSYN_TXBUF_BIN0_DATA_WORD40,TSYN_TXBUF_BIN0_DATA_WORD41,TSYN_TXBUF_BIN0_DATA_WORD42,TSYN_TXBUF_BIN0_DATA_WORD43,TSYN_TXBUF_BIN0_DATA_WORD44,TSYN_TXBUF_BIN0_DATA_WORD45,TSYN_TXBUF_BIN0_DATA_WORD46,TSYN_TXBUF_BIN0_DATA_WORD47,TSYN_TXBUF_BIN0_DATA_WORD48,TSYN_TXBUF_BIN0_DATA_WORD49,TSYN_TXBUF_BIN0_DATA_WORD50,TSYN_TXBUF_BIN0_DATA_WORD51,TSYN_TXBUF_BIN0_DATA_WORD52,TSYN_TXBUF_BIN0_DATA_WORD53,TSYN_TXBUF_BIN0_DATA_WORD54,TSYN_TXBUF_BIN0_DATA_WORD55,TSYN_TXBUF_BIN0_DATA_WORD56,TSYN_TXBUF_BIN0_DATA_WORD57,TSYN_TXBUF_BIN0_DATA_WORD58,TSYN_TXBUF_BIN0_DATA_WORD59</dimIndex>
              <name>TXDATA[%s]</name>
              <description>no description available</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TXBUF_BIN0_DATA_WORD0</name>
                  <description>TXBUF_BIN0_DATA_WORD0</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSYN_TXBUF_BIN0_TQUE_AND_TX_LEN</name>
              <description>No description available</description>
              <addressOffset>0xf0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x070000FF</resetMask>
              <fields>
                <field>
                  <name>TXBUF_BIN0_TQUE</name>
                  <description>TXBUF_BIN0_TQUE</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>3</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXBUF_BIN0_TX_LEN</name>
                  <description>TXBUF_BIN0_TX_LEN</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSYN_TXBUF_BIN0_TX_TIMESTAMP_L</name>
              <description>No description available</description>
              <addressOffset>0xf8</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TXBUF_BIN0_TX_TIMESTAMP_L</name>
                  <description>TXBUF_BIN0_TX_TIMESTAMP_L</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSYN_TXBUF_BIN0_TX_TIMESTAMP_H</name>
              <description>No description available</description>
              <addressOffset>0xfc</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TXBUF_BIN0_TX_TIMESTAMP_H</name>
                  <description>TXBUF_BIN0TX_TIMESTAMP_H</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>TSN_SHAPER_HWCFG1</name>
            <description>No description available</description>
            <addressOffset>0x2004</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LWIDTH</name>
                <description>Scheduler list address width (IP core parameter LWIDTH)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TQC</name>
                <description>Traffic queue count (IP core parameter TQC)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TQD</name>
                <description>Traffic queue depth (IP core parameter TQD)</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DW</name>
                <description>Traffic queue data width (Bytes); fixed to value 4 within
IP core</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TQAV</name>
            <description>No description available</description>
            <addressOffset>0x200c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>AVIE</name>
                <description>Traffic queue interrupt enable on buffer space available,
one bit per traffic queue
Bit[i] = 0: no interrupt
Bit[i] = 1: interrupt, when AVAIL[i]=1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AVAIL</name>
                <description>Traffic queue buffer space available for complete packet of size MaxSDU (register MXSDUi)
Bit[i] = 1: space available
Bit[i] = 0: no space available or TQ not implemented (I &gt;= TQC)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TQEM</name>
            <description>No description available</description>
            <addressOffset>0x2010</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>EMPTY</name>
                <description>Traffic queue empty
Bit[i] = 1: traffic queue i is empty</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_FPST</name>
            <description>No description available</description>
            <addressOffset>0x2014</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>TABLE</name>
                <description>Frame Preemption Status Table,
Bit[i] = 1: Preemptable traffic in TQ[i], otherwise
Express traffic (default)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_MMCT</name>
            <description>No description available</description>
            <addressOffset>0x2018</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>RQREL</name>
                <description>Request HOLD-Signal release operation. Will be automatically set to &lt;0&gt;</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RQHLD</name>
                <description>Request HOLD-Signal hold operation. Will be automatically set to &lt;0&gt;.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_HOLDADV</name>
            <description>No description available</description>
            <addressOffset>0x201c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>holdAdvance time for TAS operation Set-And-Hold-MAC in &lt;sys_clk&gt; cycles</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>TSN_SHAPER_MXSDU0,TSN_SHAPER_MXSDU1,TSN_SHAPER_MXSDU2,TSN_SHAPER_MXSDU3,TSN_SHAPER_MXSDU4,TSN_SHAPER_MXSDU5,TSN_SHAPER_MXSDU6,TSN_SHAPER_MXSDU7</dimIndex>
            <name>MXSDU[%s]</name>
            <description>no description available</description>
            <addressOffset>0x2100</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>SDU</name>
                <description>Maximum SDU size for traffic queue n (n = 0 – 7)Returns 0 when n &gt; TQC. Value is size in words (32 bit word size).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>TSN_SHAPER_TXSEL0,TSN_SHAPER_TXSEL1,TSN_SHAPER_TXSEL2,TSN_SHAPER_TXSEL3,TSN_SHAPER_TXSEL4,TSN_SHAPER_TXSEL5,TSN_SHAPER_TXSEL6,TSN_SHAPER_TXSEL7</dimIndex>
            <name>TXSEL[%s]</name>
            <description>no description available</description>
            <addressOffset>0x2120</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CBS_EN</name>
                <description>CBS enable traffic queue n (n = 0 – 7). Returns 0 when n &gt; TQC. Must be 0 when changing register IDSLPi.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>TSN_SHAPER_IDSEL0,TSN_SHAPER_IDSEL1,TSN_SHAPER_IDSEL2,TSN_SHAPER_IDSEL3,TSN_SHAPER_IDSEL04,TSN_SHAPER_IDSEL5,TSN_SHAPER_IDSEL6,TSN_SHAPER_IDSEL7</dimIndex>
            <name>IDSEL[%s]</name>
            <description>no description available</description>
            <addressOffset>0x2140</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>INT</name>
                <description>CBS idle slope for traffic queue n (n = 0 – 7). Returns
0 when n &gt; TQC. The register must only be written
when TXSELi.CBE_EN=0.
The idle slope value is defined as (INT + FRACT /
65536). The idle slope is set in bits per tick related to
&lt;tx_clk&gt;.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FRACT</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT1_QCH0_CFG</name>
            <description>qch channel0 control</description>
            <addressOffset>0x2800</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00177FF1</resetMask>
            <fields>
              <field>
                <name>CQF_IN_ERR</name>
                <description>qch queue in error</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CQF_NUM</name>
                <description>qch queue destination buffer select</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TAS_GPIO_SEL</name>
                <description>tas_gpio select</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AXIS_QCH_EN</name>
                <description>qch queue in select</description>
                <bitOffset>4</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CQF_EN</name>
                <description>qch enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT1_QCH1_CFG</name>
            <description>qch channel1 control</description>
            <addressOffset>0x2804</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00177FF1</resetMask>
            <fields>
              <field>
                <name>CQF_IN_ERR</name>
                <description>qch queue in error</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CQF_NUM</name>
                <description>qch queue destination buffer select</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TAS_GPIO_SEL</name>
                <description>tas_gpio select</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AXIS_QCH_EN</name>
                <description>qch queue in select</description>
                <bitOffset>4</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CQF_EN</name>
                <description>qch enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT1_QCH2_CFG</name>
            <description>qch channel2 control</description>
            <addressOffset>0x2808</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00177FF1</resetMask>
            <fields>
              <field>
                <name>CQF_IN_ERR</name>
                <description>qch queue in error</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CQF_NUM</name>
                <description>qch queue destination buffer select</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TAS_GPIO_SEL</name>
                <description>tas_gpio select</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AXIS_QCH_EN</name>
                <description>qch queue in select</description>
                <bitOffset>4</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CQF_EN</name>
                <description>qch enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT1_QCH3_CFG</name>
            <description>qch channel3 control</description>
            <addressOffset>0x280c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00177FF1</resetMask>
            <fields>
              <field>
                <name>CQF_IN_ERR</name>
                <description>qch queue in error</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CQF_NUM</name>
                <description>qch queue destination buffer select</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TAS_GPIO_SEL</name>
                <description>tas_gpio select</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AXIS_QCH_EN</name>
                <description>qch queue in select</description>
                <bitOffset>4</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CQF_EN</name>
                <description>qch enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT1_QCH_ERR_CFG</name>
            <description>qch clear</description>
            <addressOffset>0x2810</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FF07</resetMask>
            <fields>
              <field>
                <name>CQF_QUE_ERR</name>
                <description>que gate error for each cqf</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CQF_NUM_CFG_ERR</name>
                <description>cqf_num config error</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>AXIS_QCH_CFG_ERR</name>
                <description>axis_qch_en config error</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CQF_CLR_CTRL</name>
                <description>enable cqf buffer auto clear when error</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TAS_CRSR</name>
            <description>No description available</description>
            <addressOffset>0x3000</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFF0F</resetMask>
            <fields>
              <field>
                <name>ADMINGS</name>
                <description>Admin gate states, fixed 0xFF. Gate states when TAS is disabled.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OPERGS</name>
                <description>Operational gate states of TQ[i] (i = 0 – TQC-1)
Bit[i]=0 – Gate is closed; no start of frame TX possible
Bit[i]=1 – Gate is open</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TAS_GPIO_STA</name>
                <description>operational tas gpio gate status of TQ[i]</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CFGPEND</name>
                <description>Configuration change is pending – Admin basetime not yet reached.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CFGERR</name>
                <description>Configuration error.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CFGCHG</name>
                <description>Switch configuration; Bit is automatically reset to 0;
Setting Bit=1 triggers configuration change event.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN</name>
                <description>Enable time aware scheduling.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TAS_ACYCLETM</name>
            <description>No description available</description>
            <addressOffset>0x3004</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>CTIME</name>
                <description>Admin cycletime in nanoseconds.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TAS_ABASETM_L</name>
            <description>No description available</description>
            <addressOffset>0x3008</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>BASETM_L</name>
                <description>Admin basetime – nanoseconds and seconds part.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TAS_ABASETM_H</name>
            <description>No description available</description>
            <addressOffset>0x300c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BASETM_H</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TAS_LISTLEN</name>
            <description>No description available</description>
            <addressOffset>0x3010</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00FF00FF</resetMask>
            <fields>
              <field>
                <name>OLISTLEN</name>
                <description>Oper list length.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ALISTLEN</name>
                <description>Admin list length.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TAS_OCYCLETM</name>
            <description>No description available</description>
            <addressOffset>0x3014</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>CTIME</name>
                <description>Operational cycletime in nanoseconds</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TAS_OBASETM_L</name>
            <description>No description available</description>
            <addressOffset>0x3018</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BASETM_L</name>
                <description>Operational basetime – nanoseconds and seconds part. The operational basetime might occasionally have a non-normalized value (ns &gt;= 10^9) for one clock cycle.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_SHAPER_TAS_OBASETM_H</name>
            <description>No description available</description>
            <addressOffset>0x301c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BASETM_H</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>TSN_SHAPER_MXTK0,TSN_SHAPER_MXTK1,TSN_SHAPER_MXTK2,TSN_SHAPER_MXTK3,TSN_SHAPER_MXTK4,TSN_SHAPER_MXTK5,TSN_SHAPER_MXTK6,TSN_SHAPER_MXTK7</dimIndex>
            <name>MXTK[%s]</name>
            <description>no description available</description>
            <addressOffset>0x3020</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>TICK</name>
                <description>Maximum SDU size in clock ticks. MXTKi is only supported when TQC &gt; i, otherwise read-only with value 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>TSN_SHAPER_TXOV0,TSN_SHAPER_TXOV1,TSN_SHAPER_TXOV2,TSN_SHAPER_TXOV3,TSN_SHAPER_TXOV4,TSN_SHAPER_TXOV5,TSN_SHAPER_TXOV6,TSN_SHAPER_TXOV7</dimIndex>
            <name>TXOV[%s]</name>
            <description>no description available</description>
            <addressOffset>0x3040</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Transmission overrun counter; increments on transmission when gate is closed; any write access will clear register to 0. TXOVi is only supported when TQC &gt; i.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>256</dim>
            <dimIncrement>0x8</dimIncrement>
            <dimIndex>ent0,ent1,ent2,ent3,ent4,ent5,ent6,ent7,ent8,ent9,ent10,ent11,ent12,ent13,ent14,ent15,ent16,ent17,ent18,ent19,ent20,ent21,ent22,ent23,ent24,ent25,ent26,ent27,ent28,ent29,ent30,ent31,ent32,ent33,ent34,ent35,ent36,ent37,ent38,ent39,ent40,ent41,ent42,ent43,ent44,ent45,ent46,ent47,ent48,ent49,ent50,ent51,ent52,ent53,ent54,ent55,ent56,ent57,ent58,ent59,ent60,ent61,ent62,ent63,ent64,ent65,ent66,ent67,ent68,ent69,ent70,ent71,ent72,ent73,ent74,ent75,ent76,ent77,ent78,ent79,ent80,ent81,ent82,ent83,ent84,ent85,ent86,ent87,ent88,ent89,ent90,ent91,ent92,ent93,ent94,ent95,ent96,ent97,ent98,ent99,ent100,ent101,ent102,ent103,ent104,ent105,ent106,ent107,ent108,ent109,ent110,ent111,ent112,ent113,ent114,ent115,ent116,ent117,ent118,ent119,ent120,ent121,ent122,ent123,ent124,ent125,ent126,ent127,ent128,ent129,ent130,ent131,ent132,ent133,ent134,ent135,ent136,ent137,ent138,ent139,ent140,ent141,ent142,ent143,ent144,ent145,ent146,ent147,ent148,ent149,ent150,ent151,ent152,ent153,ent154,ent155,ent156,ent157,ent158,ent159,ent160,ent161,ent162,ent163,ent164,ent165,ent166,ent167,ent168,ent169,ent170,ent171,ent172,ent173,ent174,ent175,ent176,ent177,ent178,ent179,ent180,ent181,ent182,ent183,ent184,ent185,ent186,ent187,ent188,ent189,ent190,ent191,ent192,ent193,ent194,ent195,ent196,ent197,ent198,ent199,ent200,ent201,ent202,ent203,ent204,ent205,ent206,ent207,ent208,ent209,ent210,ent211,ent212,ent213,ent214,ent215,ent216,ent217,ent218,ent219,ent220,ent221,ent222,ent223,ent224,ent225,ent226,ent227,ent228,ent229,ent230,ent231,ent232,ent233,ent234,ent235,ent236,ent237,ent238,ent239,ent240,ent241,ent242,ent243,ent244,ent245,ent246,ent247,ent248,ent249,ent250,ent251,ent252,ent253,ent254,ent255</dimIndex>
            <name>SHACL[%s]</name>
            <description>no description available</description>
            <addressOffset>0x3800</addressOffset>
            <register>
              <name>TSN_SHAPER_ACLIST_ENTRY0_L</name>
              <description>No description available</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x0003FFFF</resetMask>
              <fields>
                <field>
                  <name>TAS_GPIO</name>
                  <description>gate states for qch and ptp event source</description>
                  <bitOffset>10</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP</name>
                  <description>gate operation:
0 – SetGateStates
1 – Set-And-Hold-MAC
2 – Set-And-Release-MAC
3 – undefined</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>2</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATE</name>
                  <description>gate state vector;
1 – Gate is open</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSN_SHAPER_ACLIST_ENTRY0_H</name>
              <description>No description available</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIME</name>
                  <description>Time interval, entry execution in in host clock ticks (&lt;sys_clk&gt;)</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>TSN_EP_VER</name>
            <description>No description available</description>
            <addressOffset>0xf000</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF00FF</resetMask>
            <fields>
              <field>
                <name>VER_HI</name>
                <description>major version number</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>VER_LO</name>
                <description>minor version number</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>VER_REV</name>
                <description>revision number</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_CTRL</name>
            <description>No description available</description>
            <addressOffset>0xf004</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xC0000001</resetMask>
            <fields>
              <field>
                <name>FILTDIS</name>
                <description>Disable filtering of PTP frames (Ethertype = 0x88F7)</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PTP_1S_EN</name>
                <description>Enable PTPv2 1-step synchronization suppor</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IE_TSF</name>
                <description>TxTimestampFifo interrupt enable; interrupt will be set when IE_TSF=&lt;1&gt; and TSF_SR.USED&gt;0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_TXUF</name>
            <description>No description available</description>
            <addressOffset>0xf010</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>TX buffer underflow counter; incremented when any MAC runs out of data during transmission. The counter is cleared at any write access. The counter is shared by pMAC and eMAC. If underflow event occurs at the same time for pMAC and eMAC, it will be counted as one event.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_IPCFG</name>
            <description>No description available</description>
            <addressOffset>0xf014</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFC000000</resetMask>
            <fields>
              <field>
                <name>INCL_RTC</name>
                <description>IP core parameter “INCL_RTC”</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INCL_SHAP</name>
                <description>IP core parameter “INCL_SHAPER”</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INCL_FPE</name>
                <description>IP core parameter “INCL_FPE”</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INCL_TSF</name>
                <description>IP core parameter “INCL_TSF”</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INCL_TSYNC</name>
                <description>IP core parameter “INCL_TSYNC”</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INCL_1STEP</name>
                <description>IP core parameter “INCL_1STEP”</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_TSF_D0</name>
            <description>No description available</description>
            <addressOffset>0xf020</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSF_NS</name>
                <description>Tx-Timestamp-Fifo, lower 32 bit part of local time (&lt;curtime&gt;) at the start of transmission of the packet. Usually nanoseconds part when used with included RTC.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_TSF_D1</name>
            <description>No description available</description>
            <addressOffset>0xf024</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSF_SEC</name>
                <description>Tx-Timestamp-Fifo, upper 32 bit part of the local time (&lt;curtime&gt;) at the start of the transmission of the packet. Usually seconds part when used with included RTC.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_TSF_D2</name>
            <description>No description available</description>
            <addressOffset>0xf028</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xE0000007</resetMask>
            <fields>
              <field>
                <name>TSF_TQ</name>
                <description>Tx-Timestamp-Fifo, traffic queue &lt;tx_tqueue&gt; of sent packet</description>
                <bitOffset>29</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TSF_USR</name>
                <description>Tx-Timestamp-Fifo, user sideband &lt;tx_tuser&gt; of sent packet; Note: any read to register will remove actual value from FIFO</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_TSF_SR</name>
            <description>No description available</description>
            <addressOffset>0xf02c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x800000FF</resetMask>
            <fields>
              <field>
                <name>TSF_OV</name>
                <description>Overflow of Tx-Timestamp-Fifo. At least one transmitted packet has been sent and timestamp was not stored; write bit to clear flag</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TSF_USED</name>
                <description>Tx-Timestamp-Fifo currently used entries counter; reading of TSF_Dx is only valid if field value &gt; 0. Any read from TSF_D2 will decrement counter (unless already 0).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_MMS_CTRL</name>
            <description>No description available</description>
            <addressOffset>0xf030</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>STATSEL</name>
                <description>MMS statistic counter selection, value can be read in register
MMS_STAT
&lt;000&gt;: Frame reassembly error counter (802.3br, 30.14.1.8)
&lt;001&gt;: Frames rejected due to wrong SMD (802.3br, 30.14.1.9)
&lt;010&gt;: Frame assembly ok counter (802.3br, 30.14.1.10)
&lt;011&gt;: Fragment rx counter (802.3br, 30.14.1.11)
&lt;100&gt;: Fragment tx counter (802.3br, 30.14.1.12)
&lt;101&gt;: Hold request counter (802.3br, 30.14.1.13)
otherwise: &lt;0&gt;</description>
                <bitOffset>5</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAGSZ</name>
                <description>Minimum non-final fragment size: 64 x (1 + FRAGSZ) – 4 octets</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DISV</name>
                <description>Disable verification</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LINK</name>
                <description>Link error</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN</name>
                <description>Enable preemption</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_MMS_STS</name>
            <description>No description available</description>
            <addressOffset>0xf034</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000007</resetMask>
            <fields>
              <field>
                <name>VFAIL</name>
                <description>802.3br verification state failure; verification is done when any bit VFAIL or VOK is &lt;1&gt;</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>VOK</name>
                <description>802.3br verification state ok; verification is done when any bit VFAIL or VOK is &lt;1&gt;</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HLD</name>
                <description>HOLD-Signal</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_MMS_VTIME</name>
            <description>No description available</description>
            <addressOffset>0xf038</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VTIME</name>
                <description>802.3br verification timeout counter in &lt;sys_clk&gt; cycles. Must be set by software in range of 1ms to 128ms.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_MMS_STAT</name>
            <description>No description available</description>
            <addressOffset>0xf03c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>Statistic counter of MMS, selected by MMS_CTRL.STATSEL,any write access will clear selected counter</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_PTP_UPTM_NS</name>
            <description>No description available</description>
            <addressOffset>0xf040</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UPTM_NS</name>
                <description>PTP SYNC frame “upstreamTxTime” in format “seconds.nanoseconds” as potentially received by another TSN-EP port. The correction field of a transmitted PTP SYNC frame is modified by (egressTimestamp –upstreamTxTime), relative to the LocalClock. The “rateRatio” to the Grandmaster Clock is not taken into account.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_PTP_UPTM_S</name>
            <description>No description available</description>
            <addressOffset>0xf044</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UPTM_NS</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TSN_EP_PTP_SR</name>
            <description>No description available</description>
            <addressOffset>0xf048</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>MEAS_NS</name>
                <description>Measured value of the deviation of the early timestamping for PTP frames. This value is informational only. The deviation is already included to the corrected “correctionField”.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_CTRL_PORT_MAIN_TAGGING</name>
            <description>PVID Tagging Register</description>
            <addressOffset>0x10000</addressOffset>
            <size>32</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0x0003FFFF</resetMask>
            <fields>
              <field>
                <name>FORCE</name>
                <description>The VLAN-TAG with PVID will be inserted in every frame from Host as their first VLAN-TAG. This can be used for double tagging of tagged/trunk ports</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACCESS</name>
                <description>Every tagged frame not matching PVID is filtered out. Every untagged ingress  frame will be tagged with PVID. Every egress frame with PVID will be untagged</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PCP</name>
                <description>VLAN-TCI: Priority Code Point, used when tagged.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEI</name>
                <description>VLAN-TCI: Drop Eligible Indicator, used when tagged.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PVID</name>
                <description>Native VLAN of Port. Untagged traffic will be tagged with the native VLAN-ID By default the Port uses VLAN 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_CTRL_PORT_MAIN_ENNABLE</name>
            <description>Port Module Enable Register</description>
            <addressOffset>0x10004</addressOffset>
            <size>32</size>
            <resetValue>0x00000003</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>EN_SF</name>
                <description>only applicable for CPU-Port at egress: '1' to use S&amp;F FIFO and '0' disable S&amp;F FIFO. Changing during frame operation can lead to frame corruption</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN_QCI</name>
                <description>if QCI is present at selected egress port, '1' to use QCI and '0' disable QCI. Changing during frame operation can lead to frame corruption.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_CTRL_EGRESS_ECSR_QDROP</name>
            <description>No description available</description>
            <addressOffset>0x12000</addressOffset>
            <size>32</size>
            <resetValue>0x0001FFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIS_VEC</name>
                <description>disable drop for each queue when queue not free</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN_VEC</name>
                <description>Enable/Disable drop in egress when TSN queue not free.
1 - drop enabled
0 - drop disabled
TSN-SW:
bit[i] - from Port[i]</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>2</dim>
            <dimIncrement>0x100</dimIncrement>
            <dimIndex>e1,p1</dimIndex>
            <name>RXFIFO[%s]</name>
            <description>no description available</description>
            <addressOffset>0x14000</addressOffset>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_FDMEM_CNT_BYTE</name>
              <description>No description available</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>FDMEM_CNT_BYTE</name>
                  <description>Number of bytes stored in frame drop FIFO</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_FDMEM_STS</name>
              <description>No description available</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x00000F0F</resetMask>
              <fields>
                <field>
                  <name>WAIT_FOR_LU</name>
                  <description>FD FIFO waits for LookUp information.</description>
                  <bitOffset>11</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WAIT_FOR_FRAME</name>
                  <description>FD FIFO waits for more frame data.</description>
                  <bitOffset>10</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BUSY</name>
                  <description>FD FIFO processes data.</description>
                  <bitOffset>9</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>READY</name>
                  <description>FD FIFO ready to work or working.</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FULL</name>
                  <description>FD FIFO full</description>
                  <bitOffset>3</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AMST_FULL</name>
                  <description>FD FIFO almost full. Less than 1600 Byte left.</description>
                  <bitOffset>2</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AMST_EMPTY</name>
                  <description>FD FIFO almost empty. Few bytes in FIFO.</description>
                  <bitOffset>1</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EMPTY</name>
                  <description>FD FIFO empty</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_ERROR_FLAG</name>
              <description>No description available</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x0000007F</resetMask>
              <fields>
                <field>
                  <name>LU_DESC_ERR</name>
                  <description>LookUp Descriptor lost, because of unknown frame burst by MAC. If there is no  MAC mailfunction then this flag will never be raised. FDFIFO requires reset.</description>
                  <bitOffset>6</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WRFAIL_FULL</name>
                  <description>Set if a frame is partially written into FIFO which had insufficient space. The frame is cut and frame error is set.</description>
                  <bitOffset>5</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DROP_NRDY</name>
                  <description>Frame was dropped because the FIFO was not ready. That can typically happen after a reset of the FIFO</description>
                  <bitOffset>4</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DROP_FULL_DESC</name>
                  <description>Frame was dropped because the internal descriptor FIFO is full. Full by too many frames.</description>
                  <bitOffset>3</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DROP_FULL_MEM</name>
                  <description>Frame was dropped because the FIFO is full. Full by too much data.</description>
                  <bitOffset>2</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESC_NRDY_ERR</name>
                  <description>FD FIFO failure. Descriptor not received correctly.</description>
                  <bitOffset>1</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESC_SEQ_ERR</name>
                  <description>FD FIFO failure. Internal controller lost synchronization.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_IE_ERROR_FLAG</name>
              <description>No description available</description>
              <addressOffset>0xc</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x0000007F</resetMask>
              <fields>
                <field>
                  <name>IE</name>
                  <description>Interrupt enable of ERROR_FLAG.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>7</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_IN_CONFIG</name>
              <description>No description available</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x00000001</resetMask>
              <fields>
                <field>
                  <name>NOCUT_ERROR</name>
                  <description>FD_FIFO does not shorten frames which contain an error.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_OUT_CONFIG</name>
              <description>No description available</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFF037F</resetMask>
              <fields>
                <field>
                  <name>DROP_DEST</name>
                  <description>Bit mapped Destination for dropped frames. Typically, frames are cleared at destination 0. Use another value to stream frames for analysis. Supports only max range of port[15:0].</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MIRROR_TX_EN</name>
                  <description>Incoming frames of this port will be mirrored to the given destination in MIRROR if their destination match with MIRROR_TX.</description>
                  <bitOffset>9</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MIRROR_RX_EN</name>
                  <description>Incoming frames of this port will be mirrored to the given destination in MIRROR_RX.</description>
                  <bitOffset>8</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CT_FPE_OVRD</name>
                  <description>If any Store&amp;Forward option in RX_FDFIFO is set then this flag will still force preemptable traffic to be forwarded in Cut-Through mode. This is a useful option to save latency by double buffering if the used MAC/TSN-EP already does S&amp;F.</description>
                  <bitOffset>6</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE</name>
                  <description>Disable input of FD FIFO. Take care that also descriptor generation of LookUp is disabled. Remaining frames should be cleared with DROP_ALL.</description>
                  <bitOffset>5</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DROP_ALL</name>
                  <description>Route all frames to DROP_DEST.</description>
                  <bitOffset>4</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ERROR_TO_CPU</name>
                  <description>Send error frames to CPU.</description>
                  <bitOffset>3</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MIRROR_TO_CPU</name>
                  <description>Duplicate frames to CPU.</description>
                  <bitOffset>2</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NODROP_ERROR</name>
                  <description>Do not drop frame errors.</description>
                  <bitOffset>1</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MODE_STORE_FW</name>
                  <description>Switch between Cut-Through and Store&amp;Forward mode. 0 - Cut-Through 1 - Store&amp;Forward</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_RESET</name>
              <description>No description available</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x00000001</resetMask>
              <fields>
                <field>
                  <name>SOFTRS</name>
                  <description>Write 1 to reset FD controller and memory pointers. Register Map content remains untouched</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>1</bitWidth>
                  <access>write-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_PARAM</name>
              <description>No description available</description>
              <addressOffset>0x1c</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LU_FIFO_DEPTH</name>
                  <description>Number of MAC lookup descriptors the FIFO can store.</description>
                  <bitOffset>24</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FD_DESC_FIFO_DESC</name>
                  <description>Number of FD descriptors the FIFO can store. Two descriptors need to be stored per frame.</description>
                  <bitOffset>16</bitOffset>
                  <bitWidth>8</bitWidth>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FD_FIFO_DESC</name>
                  <description>Number of words (4byte) the Frame Drop FIFO can store.</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>16</bitWidth>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_STRFWD</name>
              <description>No description available</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x01FFFFFF</resetMask>
              <fields>
                <field>
                  <name>PORT</name>
                  <description>If selected port is set then the frame is transmitted in Store &amp; Forward mode. This is necessary when the ingress rate of this port is slower than the egress rate of the transmitting port. In S&amp;F, the ingress module is able to drop frames with bad CRC.bit 0 - CPU-Port,
bit 1 - Port 1, …</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>25</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_PORTMASK</name>
              <description>No description available</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <resetValue>0x001FFFFF</resetValue>
              <resetMask>0x01FFFFFF</resetMask>
              <fields>
                <field>
                  <name>PORT</name>
                  <description>Port grouping via port mask. If the selected port is not set then the destination will be filtered out. This register allows the realization of port-based-VLAN (no VLAN tags required, only set it by ports).
bit 0 - CPU-Port,
bit 1 - Port 1, …</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>25</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_MIRROR</name>
              <description>No description available</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x01FFFFFF</resetMask>
              <fields>
                <field>
                  <name>PORT</name>
                  <description>Mirror Port. If port mirroring is enabled TX/RX traffic will also be forwarded to this port.
bit 0 - CPU-Port,
bit 1 - Port 1, …</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>25</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SW_CTRL_IGRESS_RX_FDFIFO_E_MIRROR_TX</name>
              <description>No description available</description>
              <addressOffset>0x2c</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0x01FFFFFF</resetMask>
              <fields>
                <field>
                  <name>PORT</name>
                  <description>Mirror Selection TX. The destination of the frame is compared with this vector. All matching TX probe ports will be mirrored to MIRROR. It is necessary to configure all ingress ports to mirror the complete TX traffic.
bit 0 - CPU-Port,
bit 1 - Port 1, …</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>25</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>SW_CTRL_MONITOR_CTRL</name>
            <description>No description available</description>
            <addressOffset>0x18004</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Enables counter. If deasserted the counter process stops and the counters hold their value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_CTRL_MONITOR_RESET</name>
            <description>No description available</description>
            <addressOffset>0x18008</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000007</resetMask>
            <fields>
              <field>
                <name>RSRX</name>
                <description>Write '1' to reset all RX counters.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>RSTX</name>
                <description>Write '1' to reset all TX counters</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>RSALL</name>
                <description>Write '1' to reset all TX&amp;RX counters.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_CTRL_MONITOR_PARAM</name>
            <description>No description available</description>
            <addressOffset>0x1800c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFF7F</resetMask>
            <fields>
              <field>
                <name>RX_CNT_EN_VEC</name>
                <description>Vector of implemented RX counters. E.g. 0x000F means only the first 4 RX counter are available.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_CNT_EN_VEC</name>
                <description>Vector of implemented RX counters. E.g. 0x000F means only the first 4 RX counter are available.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CNTW</name>
                <description>Vector of implemented RX counters. E.g. 0x000F means only the first 4 RX counter
are available.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_TX_COUNTER_TX_FGOOD</name>
            <description>No description available</description>
            <addressOffset>0x18010</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TX_FGOOD</name>
                <description>Good transmitted Frames to TX TSN-EP.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_TX_COUNTER_TX_FERROR</name>
            <description>No description available</description>
            <addressOffset>0x18018</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TX_FERROR</name>
                <description>Transmitted Frames with Error to TX TSN-EP.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_TX_COUNTER_TX_DROP_OVFL</name>
            <description>No description available</description>
            <addressOffset>0x18020</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TX_DROP_OVFL</name>
                <description>Dropped frames by full queue of TSN-EP.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_FGOOD</name>
            <description>No description available</description>
            <addressOffset>0x18040</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_FGOOD</name>
                <description>Good received frame by ingress buffer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_FERROR</name>
            <description>No description available</description>
            <addressOffset>0x18048</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_FERROR</name>
                <description>Bad received frame by ingress buffer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_KNOWN</name>
            <description>No description available</description>
            <addressOffset>0x18050</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_KNOWN</name>
                <description>Number of frames passed ingress with hit by MAC Table. This includes Broadcast and non-relayed frames.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_UNKNOWN</name>
            <description>No description available</description>
            <addressOffset>0x18058</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_UNKNOWN</name>
                <description>Number of frames passed ingress without hit by MAC table.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_UC</name>
            <description>No description available</description>
            <addressOffset>0x18060</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_UC</name>
                <description>Number of unicast frames</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_INTERN</name>
            <description>No description available</description>
            <addressOffset>0x18068</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_INTERN</name>
                <description>Number of non-relay frames</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_BC</name>
            <description>No description available</description>
            <addressOffset>0x18070</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_BC</name>
                <description>Number of Broadcast frames</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_MULTI</name>
            <description>No description available</description>
            <addressOffset>0x18078</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_MULTI</name>
                <description>Number of Multicast frames</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_VLAN</name>
            <description>No description available</description>
            <addressOffset>0x18080</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_VLAN</name>
                <description>Number of VLAN tagged frames</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_DROP_OVFL</name>
            <description>No description available</description>
            <addressOffset>0x18088</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_DROP_OVFL</name>
                <description>Dropped frames by ingress overflow.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_DROP_LU</name>
            <description>No description available</description>
            <addressOffset>0x18090</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_DROP_LU</name>
                <description>Dropped frames by LookUp decision.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_DROP_ERR</name>
            <description>No description available</description>
            <addressOffset>0x18098</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_DROP_ERR</name>
                <description>Dropped frames with error by ingress. Possible in S&amp;F mode or when frame is queued in ingress.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_DROP_VLAN</name>
            <description>No description available</description>
            <addressOffset>0x180a0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_DROP_VLAN</name>
                <description>Dropped frames by incompatible VLAN.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONITOR_RX_COUNTER_RX_FPE_FGOOD</name>
            <description>No description available</description>
            <addressOffset>0x180a8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RX_FPE_FGOOD</name>
                <description>Number of preemptable frames. Subset of RX_FGOOD</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPR_CTRL0</name>
            <description>control register0</description>
            <addressOffset>0x1c000</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00003F3F</resetMask>
            <fields>
              <field>
                <name>RXCLK_DLY_SEL</name>
                <description>delay value of rxclk_delay_chain</description>
                <bitOffset>8</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TXCLK_DLY_SEL</name>
                <description>delay value of txclk_delay_chain</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPR_CTRL2</name>
            <description>control register2</description>
            <addressOffset>0x1c008</addressOffset>
            <size>32</size>
            <resetValue>0x00010000</resetValue>
            <resetMask>0x0038E400</resetMask>
            <fields>
              <field>
                <name>MAC_SPEED</name>
                <description>mac speed</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAD_OE_ETH_REFCLK</name>
                <description>refclock output enable when rmii</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PHY_INTF_SEL</name>
                <description>phy interface select</description>
                <bitOffset>13</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RMII_TXCLK_SEL</name>
                <description>txclk select control for RMII</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>ESC</name>
      <description>ESC</description>
      <groupName>ESC</groupName>
      <baseAddress>0xf1700000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1f0a4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TYPE</name>
          <description>Type of EtherCAT controller</description>
          <addressOffset>0x0</addressOffset>
          <size>8</size>
          <resetValue>0xA2</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TYPE</name>
              <description>Controller type</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REVISION</name>
          <description>Revision of EtherCAT controller</description>
          <addressOffset>0x1</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>X</name>
              <description>major version X</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUILD</name>
          <description>Build of EtherCAT controller</description>
          <addressOffset>0x2</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BUILD</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>Y</name>
              <description>minor version Y</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>Z</name>
              <description>maintenance version Z</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FMMU_NUM</name>
          <description>FMMU supported</description>
          <addressOffset>0x4</addressOffset>
          <size>8</size>
          <resetValue>0x08</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>NUM</name>
              <description>Number of supported FMMU channels (or entities)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYNCM_NUM</name>
          <description>SyncManagers supported</description>
          <addressOffset>0x5</addressOffset>
          <size>8</size>
          <resetValue>0x08</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>NUM</name>
              <description>Number of supported SyncManager channels (or entities)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_SIZE</name>
          <description>RAM Size</description>
          <addressOffset>0x6</addressOffset>
          <size>8</size>
          <resetValue>0x3C</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SIZE</name>
              <description>Process Data RAM size supported in KByte</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PORT_DESC</name>
          <description>Port Descriptor</description>
          <addressOffset>0x7</addressOffset>
          <size>8</size>
          <resetValue>0x3F</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PORT3</name>
              <description>Port configuration:
00:Not implemented
01:Not configured (SII EEPROM)
10:EBUS
11:MII/RMII/RGMII</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PORT2</name>
              <description>Port configuration:
00:Not implemented
01:Not configured (SII EEPROM)
10:EBUS
11:MII/RMII/RGMII</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PORT1</name>
              <description>Port configuration:
00:Not implemented
01:Not configured (SII EEPROM)
10:EBUS
11:MII/RMII/RGMII</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PORT0</name>
              <description>Port configuration:
00:Not implemented
01:Not configured (SII EEPROM)
10:EBUS
11:MII/RMII/RGMII</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FEATURE</name>
          <description>ESC Feature supported</description>
          <addressOffset>0x8</addressOffset>
          <size>16</size>
          <resetValue>0x008C</resetValue>
          <resetMask>0x0FCD</resetMask>
          <fields>
            <field>
              <name>FFSC</name>
              <description>Fixed FMMU/SyncManager configuration:
0:Variable configuration
1:Fixed configuration (refer to documentation of supporting ESCs)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RWC</name>
              <description>EtherCAT read/write command support(BRW,APRW,FPRW):
0:Supported
1:Not supported</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LRW</name>
              <description>EtherCAT LRW command support:
0:Supported
1:Not supported</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EDSA</name>
              <description>Enhanced DC SYNC Activation:
0:Not available
1:Available
Note:This feature refers to registers 0x981[7:3] and 0x0984</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SHFE</name>
              <description>Seperate Handling of FCS Errors:
0:Not supported
1:Supported, frames with wrong FCS and additional nibble will be counted separately in Forwarded RX Error Counter</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ELDM</name>
              <description>Enhanced Link Detection MII:
0:Not available
1:Available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCW</name>
              <description>Distributed Clocks width:
0:32 bit
1:64 bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DC</name>
              <description>Distributed Clocks:
0:Not available
1:Available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FMMU</name>
              <description>FMMU Operation:
0:Bit oriented
1:Byte oriented</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATION_ADDR</name>
          <description>Configured Station Address</description>
          <addressOffset>0x10</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address used for node addressing
(FPRD/FPWR/FPRW/FRMW commands)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATION_ALS</name>
          <description>Configured Station Alias</description>
          <addressOffset>0x12</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Alias Address used for node addressing
(FPRD/FPWR/FPRW/FRMW commands).
The use of this alias is activated by Register
DL Control Bit 0x0100[24].
NOTE:EEPROM value is only transferred into this
register at first EEPROM load after power-on or
reset.
ESC20 exception:EEPROM value is transferred
into this register after each EEPROM reload
command.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_WEN</name>
          <description>Register Write Enable</description>
          <addressOffset>0x20</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>If register write protection is enabled, this
register has to be written in the same
Ethernet frame (value does not matter)
before other writes to this station are allowed.
This bit is self-clearing at the beginning of the
next frame (SOF), or if Register Write
Protection is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_WP</name>
          <description>Register Write Protection</description>
          <addressOffset>0x21</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>WP</name>
              <description>Register write protection:
0:Protection disabled
1:Protection enabled
Registers 0x0000:0x0F7F are write-protected,
except for 0x0020 and 0x0030</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESC_WEN</name>
          <description>ESC Write Enable</description>
          <addressOffset>0x30</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>If ESC write protection is enabled, this
register has to be written in the same
Ethernet frame (value does not matter)
before other writes to this station are allowed.
This bit is self-clearing at the beginning of the
next frame (SOF), or if ESC Write Protection
is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESC_WP</name>
          <description>ESC Write Protection</description>
          <addressOffset>0x31</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>WP</name>
              <description>Write protect:
0:Protection disabled
1:Protection enabled
All areas are write-protected, except for 0x0030.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESC_RST_ECAT</name>
          <description>ESC Reset ECAT</description>
          <addressOffset>0x40</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x03</resetMask>
          <fields>
            <field>
              <name>PR</name>
              <description>Progress of the reset procedure:
00:initial/reset state
01:after writing 0x52 ('R'), when previous
state was 00
10:after writing 0x45 ('E'), when previous
state was 01
11:after writing 0x53 ('S'), when previous
state was 10.
This value must not be observed
because the ESC enters reset when this
state is reached, resulting in state 00</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESC_RST_PDI</name>
          <description>ESC Reset PDI</description>
          <addressOffset>0x41</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RST</name>
              <description>A reset is asserted after writing the reset
sequence 0x52 ('R'), 0x45 ('E') and 0x53 ('S')
in this register with 3 consecutive commands.
Any other command which does not continue
the sequence by writing the next expected
value will cancel the reset procedure</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESC_DL_CTRL</name>
          <description>ESC DL Control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0107FF03</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>Station alias:
0:Ignore Station Alias
1:Alias can be used for all configured
address comm</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RFS</name>
              <description>RX FIFO Size (ESC delays start of
forwarding until FIFO is at least half full).
RX FIFO Size/RX delay reduction** :
Value:EBUS:MII:
0:-50 ns -40 ns (-80 ns***)
1:-40 ns -40 ns (-80 ns***)
2:-30 ns -40 ns
3:-20 ns -40 ns
4:-10 ns no change
5:no change no change
6:no change no change
7:default default
NOTE:EEPROM value is only taken over at first
EEPROM load after power-on or reset</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP3</name>
              <description>Loop Port 3:
00:Auto
01:Auto Close
10:Open
11:Closed</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP2</name>
              <description>Loop Port 2:
00:Auto
01:Auto Close
10:Open
11:Closed</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP1</name>
              <description>Loop Port 1:
00:Auto
01:Auto Close
10:Open
11:Closed</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP0</name>
              <description>Loop Port 0:
00:Auto
01:Auto Close
10:Open
11:Closed
NOTE:
Loop open means sending/receiving over this port
is enabled, loop closed means sending/receiving
is disabled and frames are forwarded to the next
open port internally.
Auto:loop closed at link down, opened at link up
Auto Close:loop closed at link down, opened with
writing 01 again after link up (or receiving a valid
Ethernet frame at the closed port)
Open:loop open regardless of link state
Closed:loop closed regardless of link state</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TU</name>
              <description>Temporary use of settings in
0x0100:0x0103[8:15]:
0:permanent use
1:use for about 1 second, then revert to
previous settings</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FR</name>
              <description>Forwarding rule:
0:Forward non-EtherCAT frames:
EtherCAT frames are processed,
non-EtherCAT frames are forwarded
without processing or modification.
The source MAC address is not
changed for any frame.
1:Destroy non-EtherCAT frames:
EtherCAT frames are processed, non-EtherCAT frames are destroyed.
The source MAC address is changed by
the Processing Unit for every frame
(SOURCE_MAC[1] is set</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHYSICAL_RW_OFFSET</name>
          <description>Physical Read/Write Offset</description>
          <addressOffset>0x108</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>This register is used for ReadWrite
commands in Device Addressing mode
(FPRW, APRW, BRW).
The internal read address is directly taken
from the offset address field of the EtherCAT
datagram header, while the internal write
address is calculated by adding the Physical
Read/Write Offset value to the offset address
field.
Internal read address = ADR,
internal write address = ADR + R/W-Offset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESC_DL_STAT</name>
          <description>ESC DL Status</description>
          <addressOffset>0x110</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFF7</resetMask>
          <fields>
            <field>
              <name>CP3</name>
              <description>Communication on Port 3:
0:No stable communication
1:Communication established</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP3</name>
              <description>Loop Port 3:
0:Open
1:Closed</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CP2</name>
              <description>Communication on Port 2:
0:No stable communication
1:Communication established</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP2</name>
              <description>Loop Port 2:
0:Open
1:Closed</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CP1</name>
              <description>Communication on Port 1:
0:No stable communication
1:Communication established</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP1</name>
              <description>Loop Port 1:
0:Open
1:Closed</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CP0</name>
              <description>Communication on Port 0:
0:No stable communication
1:Communication established</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP0</name>
              <description>Loop Port 0:
0:Open
1:Closed</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PLP3</name>
              <description>Physical link on Port 3:
0:No link
1:Link detected</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PLP2</name>
              <description>Physical link on Port 2:
0:No link
1:Link detected</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PLP1</name>
              <description>Physical link on Port 1:
0:No link
1:Link detected</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PLP0</name>
              <description>Physical link on Port 0:
0:No link
1:Link detected</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ELD</name>
              <description>Enhanced Link detection:
0:Deactivated for all ports
1:Activated for at least one port
NOTE:EEPROM value is only transferred into this
register at first EEPROM load after power-on or
reset</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDS</name>
              <description>PDI Watchdog Status:
0:Watchdog expired
1:Watchdog reloaded</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EPLC</name>
              <description>PDI operational/EEPROM loaded correctly:
0:EEPROM not loaded, PDI not
operational (no access to Process Data
RAM)
1:EEPROM loaded correctly, PDI
operational (access to Process Data
RAM)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AL_CTRL</name>
          <description>AL Control</description>
          <addressOffset>0x120</addressOffset>
          <size>16</size>
          <resetValue>0x0001</resetValue>
          <resetMask>0x003F</resetMask>
          <fields>
            <field>
              <name>DI</name>
              <description>Device Identification:
0:No request
1:Device Identification request</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EIA</name>
              <description>Error Ind Ack:
0:No Ack of Error Ind in AL status register
1:Ack of Error Ind in AL status register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IST</name>
              <description>Initiate State Transition of the Device State
Machine:
1:Request Init State
3:Request Bootstrap State
2:Request Pre-Operational State
4:Request Safe-Operational State
8:Request Operational State</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AL_STAT</name>
          <description>AL Status</description>
          <addressOffset>0x130</addressOffset>
          <size>16</size>
          <resetValue>0x0001</resetValue>
          <resetMask>0x003F</resetMask>
          <fields>
            <field>
              <name>DI</name>
              <description>Device Identification:
0:Device Identification not valid
1:Device Identification loaded</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Error Ind:
0:Device is in State as requested or Flag
cleared by command
1:Device has not entered requested State
or changed State as result of a local
action</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AS</name>
              <description>Actual State of the Device State Machine:
1:Init State
3:Bootstrap State
2:Pre-Operational State
4:Safe-Operational State
8:Operational State</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AL_STAT_CODE</name>
          <description>AL Status Code</description>
          <addressOffset>0x134</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CODE</name>
              <description>AL Status Code</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RUN_LED_OVRD</name>
          <description>RUN LED Override</description>
          <addressOffset>0x138</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>EN_OVRD</name>
              <description>Enable Override:
0:Override disabled
1:Override enabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED_CODE</name>
              <description>LED code:
0x0:Off
0x1:Flash 1x
0x2-0xC:Flash 2x – 12x
0xD:Blinking
0xE:Flickering
0xF:On</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERR_LED_OVRD</name>
          <description>ERR LED Override</description>
          <addressOffset>0x139</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>EN_OVRD</name>
              <description>Enable Override:
0:Override disabled
1:Override enabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED_CODE</name>
              <description>LED code:
0x0:Off
0x1-0xC:Flash 1x – 12x
0xD:Blinking
0xE:Flickering
0xF:On</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_CTRL</name>
          <description>PDI Control</description>
          <addressOffset>0x140</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PDI</name>
              <description>Process data interface:
0x00:Interface deactivated (no PDI)
0x01:4 Digital Input
0x02:4 Digital Output
0x03:2 Digital Input and 2 Digital Output
0x04:Digital I/O
0x05:SPI Slave
0x06:Oversampling I/O
0x07:EtherCAT Bridge (port 3)
0x08:16 Bit asynchronous Microcontroller
interface
0x09:8 Bit asynchronous Microcontroller
interface
0x0A:16 Bit synchronous Microcontroller
interface
0x0B:8 Bit synchronous Microcontroller
interface
0x10:32 Digital Input and 0 Digital Output
0x11:24 Digital Input and 8 Digital Output
0x12:16 Digital Input and 16 Digital Output
0x13:8 Digital Input and 24 Digital Output
0x14:0 Digital Input and 32 Digital Output
0x80:On-chip bus
Others:Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESC_CFG</name>
          <description>ESC Configuration</description>
          <addressOffset>0x141</addressOffset>
          <size>8</size>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ELP3</name>
              <description>Enhanced Link port 3:
0:disabled (if bit 1=0)
1:enabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ELP2</name>
              <description>Enhanced Link port 2:
0:disabled (if bit 1=0)
1:enabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ELP1</name>
              <description>Enhanced Link port 1:
0:disabled (if bit 1=0)
1:enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ELP0</name>
              <description>Enhanced Link port 0:
0:disabled (if bit 1=0)
1:enabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CDLIU</name>
              <description>Distributed Clocks Latch In Unit:
0:disabled (power saving)
1:enabled</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCSOU</name>
              <description>Distributed Clocks SYNC Out Unit:
0:disabled (power saving)
1:enabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ELDAP</name>
              <description>Enhanced Link detection all ports:
0:disabled (if bits [7:4]=0)
1:enabled at all ports (overrides bits [7:4])</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DEV_EMU</name>
              <description>Device emulation (control of AL status):
0:AL status register has to be set by PDI
1:AL status register will be set to value
written to AL control register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_INFO</name>
          <description>PDI Information</description>
          <addressOffset>0x14e</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x000F</resetMask>
          <fields>
            <field>
              <name>PDICN</name>
              <description>PDI configuration invalid:
0:PDI configuration ok
1:PDI configuration invalid</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDIA</name>
              <description>PDI active:
0:PDI not active
1:PDI active</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECLFE</name>
              <description>ESC configuration area loaded from
EEPROM:
0:not loaded
1:loaded</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PFABW</name>
              <description>DI function acknowledge by write:
0:Disabled
1:Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_CFG</name>
          <description>PDI Configuration</description>
          <addressOffset>0x150</addressOffset>
          <size>8</size>
          <resetValue>0x84</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>BUS</name>
              <description>On-chip bus:
000:Intel® Avalon®
001:AXI®
010:Xilinx® PLB v4.6
100:Xilinx OPB
others:reserved</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK</name>
              <description>On-chip bus clock:
0:asynchronous
1-31:synchronous multiplication factor
(N * 25 MHz)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_SL_CFG</name>
          <description>PDI Sync/Latch[1:0] Configuration</description>
          <addressOffset>0x151</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SYNC1_MAER</name>
              <description>SYNC1 mapped to AL Event Request
register 0x0220[3]:
0:Disabled
1:Enabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC1_CFG</name>
              <description>SYNC1/LATCH1 configuration*:
0:LATCH1 input
1:SYNC1 output</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC1_ODP</name>
              <description>SYNC1 output driver/polarity:
00:Push-Pull active low
01:Open Drain (active low)
10:Push-Pull active high
11:Open Source (active high)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC0_MAER</name>
              <description>SYNC0 mapped to AL Event Request
register 0x0220[2]:
0:Disabled
1:Enabled</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC0_CFG</name>
              <description>SYNC0/LATCH0 configuration*:
0:LATCH0 Input
1:SYNC0 Output</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC0_ODP</name>
              <description>SYNC0 output driver/polarity:
00:Push-Pull active low
01:Open Drain (active low)
10:Push-Pull active high
11:Open Source (active high)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_EXT_CFG</name>
          <description>PDI Extended Configuration</description>
          <addressOffset>0x152</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x0703</resetMask>
          <fields>
            <field>
              <name>OCBST</name>
              <description>On-chip bus sub-type for AXI:
000:AXI3
001:AXI4
010:AXI4 LITE
others:reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RPS</name>
              <description>Read prefetch size (in cycles of PDI width):
0:4 cycles
1:1 cycle (typical)
2:2 cycles
3:Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECAT_EVT_MSK</name>
          <description>ECAT Event Mask</description>
          <addressOffset>0x200</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>ECAT Event masking of the ECAT Event
Request Events for mapping into ECAT event
field of EtherCAT frames:
0:Corresponding ECAT Event Request
register bit is not mapped
1:Corresponding ECAT Event Request
register bit is mapped</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_AL_EVT_MSK</name>
          <description>PDI AL Event Mask</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>AL Event masking of the AL Event Request
register Events for mapping to PDI IRQ
signal:
0:Corresponding AL Event Request
register bit is not mapped
1:Corresponding AL Event Request
register bit is mapped</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECAT_EVT_REQ</name>
          <description>ECAT Event Request</description>
          <addressOffset>0x210</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x0FFD</resetMask>
          <fields>
            <field>
              <name>MV</name>
              <description>Mirrors values of each SyncManager Status:
0:No Sync Channel 0 event
1:Sync Channel 0 event pending
0:No Sync Channel 1 event
1:Sync Channel 1 event pending
…
0:No Sync Channel 7 event
1:Sync Channel 7 event pending</description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALS_EVT</name>
              <description>AL Status event:
0:No change in AL Status
1:AL Status change
(Bit is cleared by reading out AL Status
0x0130:0x0131 from ECAT)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DLS_EVT</name>
              <description>DL Status event:
0:No change in DL Status
1:DL Status change
(Bit is cleared by reading out DL Status
0x0110:0x0111 from ECAT)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCL_EVT</name>
              <description>DC Latch event:
0:No change on DC Latch Inputs
1:At least one change on DC Latch Inputs
(Bit is cleared by reading DC Latch event
times from ECAT for ECAT-controlled Latch
Units, so that Latch 0/1 Status
0x09AE:0x09AF indicates no event)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AL_EVT_REQ</name>
          <description>AL Event Request</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFF7F</resetMask>
          <fields>
            <field>
              <name>SM_INT</name>
              <description>SyncManager interrupts (SyncManager
register offset 0x5, bit [0] or [1]):
0:No SyncManager 0 interrupt
1:SyncManager 0 interrupt pending
0:No SyncManager 1 interrupt
1:SyncManager 1 interrupt pending
…
0:No SyncManager 15 interrupt
1:SyncManager 15 interrupt pending</description>
              <bitOffset>8</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDG_PD</name>
              <description>Watchdog Process Data:
0:Has not expired
1:Has expired
(Bit is cleared by reading Watchdog Status
Process Data 0x0440 from PDI)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EE_EMU</name>
              <description>EEPROM Emulation:
0:No command pending
1:EEPROM command pending
(Bit is cleared by acknowledging the
command in EEPROM Control/Status
register 0x0502:0x0503[10:8] from PDI)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SM_ACT</name>
              <description>SyncManager activation register
(SyncManager register offset 0x6) changed:
0:No change in any SyncManager
1:At least one SyncManager changed
(Bit is cleared by reading SyncManager
Activation registers 0x0806 etc. from PDI)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ST_DC_SYNC1</name>
              <description>State of DC SYNC1 (if register
0x0151[7]=1):
(Bit is cleared by reading of SYNC1 status
0x098F from PDI, use only in Acknowledge
mode)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ST_DC_SYNC0</name>
              <description>State of DC SYNC0 (if register
0x0151[3]=1):
(Bit is cleared by reading SYNC0 status
0x098E from PDI, use only in Acknowledge
mode)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCL_EVT</name>
              <description>DC Latch event:
0:No change on DC Latch Inputs
1:At least one change on DC Latch Inputs
(Bit is cleared by reading DC Latch event
times from PDI, so that Latch 0/1 Status
0x09AE:0x09AF indicates no event. Available
if Latch Unit is PDI-controlled)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALC_EVT</name>
              <description>AL Control event:
0:No AL Control Register change
1:AL Control Register has been written3
(Bit is cleared by reading AL Control register
0x0120:0x0121 from PDI)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x2</dimIncrement>
          <dimIndex>PORT0,PORT1,PORT2,PORT3</dimIndex>
          <name>RX_ERR_CNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x300</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RX_ERR</name>
              <description>RX Error counter of Port y (counting is
stopped when 0xFF is reached).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IVD_FRM</name>
              <description>Invalid frame counter of Port y (counting is
stopped when 0xFF is reached).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x1</dimIncrement>
          <dimIndex>PORT0,PORT1,PORT2,PORT3</dimIndex>
          <name>FWD_RX_ERR_CNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x308</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ERR_CNT</name>
              <description>Forwarded error counter of Port y (counting is
stopped when 0xFF is reached).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECAT_PU_ERR_CNT</name>
          <description>ECAT Processing Unit Error Counter</description>
          <addressOffset>0x30c</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>ECAT Processing Unit error counter
(counting is stopped when 0xFF is reached).
Counts errors of frames passing the
Processing Unit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_ERR_CNT</name>
          <description>PDI Error Counter</description>
          <addressOffset>0x30d</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>PDI Error counter (counting is stopped when
0xFF is reached). Counts if a PDI access has
an interface error.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x1</dimIncrement>
          <dimIndex>PORT0,PORT1,PORT2,PORT3</dimIndex>
          <name>LOST_LINK_CNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x310</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Lost Link counter of Port y (counting is
stopped when 0xff is reached). Counts only if
port is open and loop is Auto.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDG_DIV</name>
          <description>Watchdog Divider</description>
          <addressOffset>0x400</addressOffset>
          <size>16</size>
          <resetValue>0x09C2</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Watchdog divider:Number of 25 MHz tics
(minus 2) that represent the basic watchdog
increment. (Default value is 100µs = 2498)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDG_TIME_PDI</name>
          <description>Watchdog Time PDI</description>
          <addressOffset>0x410</addressOffset>
          <size>16</size>
          <resetValue>0x03E8</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>Watchdog Time PDI:number of basic
watchdog increments
(Default value with Watchdog divider 100µs
means 100ms Watchdog)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDG_TIME_PDAT</name>
          <description>Watchdog Time Process Data</description>
          <addressOffset>0x420</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>Watchdog Time Process Data:number of
basic watchdog increments
(Default value with Watchdog divider 100µs
means 100ms Watchdog)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDG_STAT_PDAT</name>
          <description>Watchdog Status Process Data</description>
          <addressOffset>0x440</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x0001</resetMask>
          <fields>
            <field>
              <name>ST</name>
              <description>Watchdog Status of Process Data (triggered
by SyncManagers)
0:Watchdog Process Data expired
1:Watchdog Process Data is active or
disabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDG_CNT_PDAT</name>
          <description>Watchdog Counter Process Data</description>
          <addressOffset>0x442</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Watchdog Counter Process Data (counting is
stopped when 0xFF is reached). Counts if
Process Data Watchdog expires.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDG_CNT_PDI</name>
          <description>Watchdog Counter PDI</description>
          <addressOffset>0x443</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Watchdog PDI counter (counting is stopped
when 0xFF is reached). Counts if PDI
Watchdog expires.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EEPROM_CFG</name>
          <description>EEPROM Configuration</description>
          <addressOffset>0x500</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x03</resetMask>
          <fields>
            <field>
              <name>FORCE_ECAT</name>
              <description>Force ECAT access:
0:Do not change Bit 0x0501[0]
1:Reset Bit 0x0501[0] to 0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDI</name>
              <description>EEPROM control is offered to PDI:
0:no
1:yes (PDI has EEPROM control)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EEPROM_PDI_ACC_STAT</name>
          <description>EEPROM PDI Access State</description>
          <addressOffset>0x501</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>ACCESS</name>
              <description>Access to EEPROM:
0:PDI releases EEPROM access
1:PDI takes EEPROM access (PDI has
EEPROM control)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EEPROM_CTRL_STAT</name>
          <description>EEPROM Control/Status</description>
          <addressOffset>0x502</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFE1</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Busy:
0:EEPROM Interface is idle
1:EEPROM Interface is busy</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_WEN</name>
              <description>Error Write Enable*3
:
0:No error
1:Write Command without Write enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_ACK_CMD</name>
              <description>Error Acknowledge/Command*3
:
0:No error
1:Missing EEPROM acknowledge or invalid
command
EEPROM emulation only:PDI writes 1 if a temporary
failure has occurred.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EE_LDS</name>
              <description>EEPROM loading status:
0:EEPROM loaded, device information ok
1:EEPROM not loaded, device information not
available (EEPROM loading in progress or
finished with a failure)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CKSM_ERR</name>
              <description>Checksum Error in ESC Configuration Area:
0:Checksum ok
1:Checksum error
EEPROM emulation for IP Core only:PDI writes 1 if a
CRC failure has occurred for a reload command.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD</name>
              <description>Command register*2:
Write:Initiate command.
Read:Currently executed command
Commands:
000:No command/EEPROM idle (clear error bits)
001:Read
010:Write
100:Reload
Others:Reserved/invalid commands (do not issue)
EEPROM emulation only:after execution, PDI writes
command value to indicate operation is ready.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EE_ALGM</name>
              <description>Selected EEPROM Algorithm:
0:1 address byte (1Kbit – 16Kbit EEPROMs)
1:2 address bytes (32Kbit – 4 Mbit EEPROMs)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_RD_BYTE</name>
              <description>Supported number of EEPROM read bytes:
0:4 Bytes
1:8 Bytes</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EE_EMU</name>
              <description>EPROM emulation:
0:Normal operation (I²C interface used)
1:PDI emulates EEPROM (I²C not used)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECAT_WEN</name>
              <description>ECAT write enable*2
:
0:Write requests are disabled
1:Write requests are enabled
This bit is always 1 if PDI has EEPROM control.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EEPROM_ADDR</name>
          <description>EEPROM Address</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>EEPROM Address
0:First word (= 16 bit)
1:Second word
…
Actually used EEPROM Address bits:
[9-0] : EEPROM size up to 16 Kbit
[17-0] : EEPROM size 32 Kbit – 4 Mbit
[31-0] : EEPROM Emulation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EEPROM_DATA</name>
          <description>EEPROM Data</description>
          <addressOffset>0x508</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HI</name>
              <description>EEPROM Read data (data read from
EEPROM, higher bytes)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>48</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LO</name>
              <description>EEPROM Write data (data to be written to
EEPROM) or
EEPROM Read data (data read from
EEPROM, lower bytes)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MII_MNG_CS</name>
          <description>MII Management Control/Status</description>
          <addressOffset>0x510</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xE3FF</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Busy:
0:MII Management Interface is idle
1:MII Management Interface is busy</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_ERR</name>
              <description>Command error:
0:Last Command was successful
1:Invalid command or write command
without Write Enable
Cleared by executing a valid command or by
writing “00” to Command register bits [9:8].</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_ERR</name>
              <description>Read error:
0:No read error
1:Read error occurred (PHY or register
not available)
Cleared by writing to register 0x0511</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD</name>
              <description>Command register*:
Write:Initiate command.
Read:Currently executed command
00:No command/MI idle (clear error bits)
01:Read
10:Write
Others:Reserved/invalid command (do not
issue)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_ADDR</name>
              <description>PHY address of port 0
(this is equal to the PHY address offset, if the
PHY addresses are consecutive)
IP Core since V3.0.0/3.00c:
Translation 0x0512[7]=0:
Register 0x0510[7:3] shows PHY address of
port 0
Translation 0x0512[7]=1:
Register 0x0510[7:3] shows the PHY address
which will be used for port 0-3 as requested
by 0x0512[4:0] (valid values 0-3)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LINK_DC</name>
              <description>MI link detection and configuration:
0:Disabled for all ports
1:Enabled for at least one MII port, refer
to PHY Port Status (0x0518 ff.) for
details</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDI</name>
              <description>Management Interface can be controlled by
PDI (registers 0x0516-0x0517):
0:Only ECAT control
1:PDI control possible</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WEN</name>
              <description>Write enable*:
0:Write disabled
1:Write enabled
This bit is always 1 if PDI has MI control.
ET1100-0000/-0001 exception:
Bit is not always 1 if PDI has MI control, and
bit is writable by PDI.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_ADDR</name>
          <description>PHY Address</description>
          <addressOffset>0x512</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x9F</resetMask>
          <fields>
            <field>
              <name>SHOW</name>
              <description>Target PHY Address translation:
0:Enabled
1:Disabled
Refer to 0x0512[4:0] and 0x0510[7:3] for
details.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR</name>
              <description>Target PHY Address
Translation 0x0512[7]=0:
0-3:Target PHY Addresses 0-3 are used
to access the PHYs at port 0-3, when
the PHY addresses are properly
configured
4-31:The configured PHY address of port 0
(PHY address offset) is added to the
Target PHY Address values 4-31
when accessing a PHY
Translation 0x0512[7]=1:
0-31:Target PHY Addresses is used when
accessing a PHY without translation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_REG_ADDR</name>
          <description>PHY Register Address</description>
          <addressOffset>0x513</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of PHY Register that shall be
read/written</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_DATA</name>
          <description>PHY Data</description>
          <addressOffset>0x514</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>PHY Read/Write Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MIIM_ECAT_ACC_STAT</name>
          <description>MII Management ECAT Access State</description>
          <addressOffset>0x516</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>ACC</name>
              <description>Access to MII management:
0:ECAT enables PDI takeover of MII
management interface
1:ECAT claims exclusive access to MII
management interface</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MIIM_PDI_ACC_STAT</name>
          <description>MII Management PDI Access State</description>
          <addressOffset>0x517</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x03</resetMask>
          <fields>
            <field>
              <name>FORCE</name>
              <description>Force PDI Access State:
0:Do not change Bit 0x0517[0]
1:Reset Bit 0x0517[0] to 0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACC</name>
              <description>Access to MII management:
0:ECAT has access to MII management
1:PDI has access to MII management</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x1</dimIncrement>
          <dimIndex>PORT0,PORT1,PORT2,PORT3</dimIndex>
          <name>PHY_STAT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x518</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>PCU</name>
              <description>PHY configuration updated:
0:No update
1:PHY configuration was updated
Cleared by writing any value to at least one
of the PHY Port y Status registers.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPE</name>
              <description>Link partner error:
0:No error detected
1:Link partner error</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RE</name>
              <description>Read error:
0:No read error occurred
1:A read error has occurred
Cleared by writing any value to at least one
of the PHY Port y Status registers.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSE</name>
              <description>Link status error:
0:No error
1:Link error, link inhibited</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LS</name>
              <description>Link status (100 Mbit/s, Full Duplex, Auto
negotiation):
0:No link
1:Link detected</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PLS</name>
              <description>Physical link status (PHY status register 1.2):
0:No physical link
1:Physical link detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>FMMU[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <register>
            <name>LOGIC_START_ADDR</name>
            <description>Logical Start Address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Logical start address within the EtherCAT
Address Space.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LENGTH</name>
            <description>Length</description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>OFFSET</name>
                <description>Offset from the first logical FMMU byte to the
last FMMU byte + 1 (e.g., if two bytes are
used, then this parameter shall contain 2)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOGIC_START_BIT</name>
            <description>Logical Start Bit</description>
            <addressOffset>0x6</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0x07</resetMask>
            <fields>
              <field>
                <name>START</name>
                <description>Logical starting bit that shall be mapped (bits
are counted from least significant bit 0 to
most significant bit 7)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOGIC_STOP_BIT</name>
            <description>Logical Stop Bit</description>
            <addressOffset>0x7</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0x07</resetMask>
            <fields>
              <field>
                <name>STOP</name>
                <description>Last logical bit that shall be mapped (bits are
counted from least significant bit 0 to most
significant bit 7)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PHYSICAL_START_ADDR</name>
            <description>Physical Start Address</description>
            <addressOffset>0x8</addressOffset>
            <size>16</size>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Physical Start Address (mapped to logical
Start address)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PHYSICAL_START_BIT</name>
            <description>Physical Start Bit</description>
            <addressOffset>0xa</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0x07</resetMask>
            <fields>
              <field>
                <name>START</name>
                <description>Physical starting bit as target of logical start
bit mapping (bits are counted from least
significant bit 0 to most significant bit 7)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TYPE</name>
            <description>Type</description>
            <addressOffset>0xb</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0x03</resetMask>
            <fields>
              <field>
                <name>MAP_WR</name>
                <description>0:Ignore mapping for write accesses
1:Use mapping for write accesses</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MAP_RD</name>
                <description>0:Ignore mapping for read accesses
1:Use mapping for read accesses</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ACTIVATE</name>
            <description>Activate</description>
            <addressOffset>0xc</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0x01</resetMask>
            <fields>
              <field>
                <name>ACT</name>
                <description>0:FMMU deactivated
1:FMMU activated. FMMU checks
logically addressed blocks to be
mapped according to configured
mapping</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>SYNCM[%s]</name>
          <description>no description available</description>
          <addressOffset>0x800</addressOffset>
          <register>
            <name>PHYSICAL_START_ADDR</name>
            <description>Physical Start Address</description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>First byte that will be handled by
SyncManager</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LENGTH</name>
            <description>Length</description>
            <addressOffset>0x2</addressOffset>
            <size>16</size>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>LEN</name>
                <description>Number of bytes assigned to SyncManager
(shall be greater than 1, otherwise
SyncManager is not activated. If set to 1, only
Watchdog Trigger is generated if configured)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONTROL</name>
            <description>Control</description>
            <addressOffset>0x4</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>WDG_TRG_EN</name>
                <description>Watchdog Trigger Enable:
0:Disabled
1:Enabled</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INT_AL</name>
                <description>Interrupt in AL Event Request Register:
0:Disabled
1:Enabled</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INT_ECAT</name>
                <description>Interrupt in ECAT Event Request Register:
0:Disabled
1:Enabled</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIR</name>
                <description>Direction:
00:Read:ECAT read access, PDI write
access.
01:Write:ECAT write access, PDI read
access.
10:Reserved
11:Reserved</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OP_MODE</name>
                <description>Operation Mode:
00:Buffered (3 buffer mode)
01:Reserved
10:Mailbox (Single buffer mode)
11:Reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x5</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0xFB</resetMask>
            <fields>
              <field>
                <name>WB_INUSE</name>
                <description>Write buffer in use (opened)</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RB_INUSE</name>
                <description>Read buffer in use (opened)</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BUF_MODE</name>
                <description>Buffered mode:buffer status (last written
buffer):
00:1
st buffer
01:2
nd buffer
10:3
rd buffer
11:(no buffer written)
Mailbox mode:reserved</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MBX_MODE</name>
                <description>Mailbox mode:mailbox status:
0:Mailbox empty
1:Mailbox full
Buffered mode:reserved</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INT_RD</name>
                <description>Interrupt Read:
1:Interrupt after buffer was completely and
successfully read
0:Interrupt cleared after first byte of buffer
was written
NOTE:This interrupt is signalled to the writing
side if enabled in the SM Control register</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INT_WR</name>
                <description>Interrupt Write:
1:Interrupt after buffer was completely and
successfully written
0:Interrupt cleared after first byte of buffer
was read
NOTE:This interrupt is signalled to the reading
side if enabled in the SM Control register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ACTIVATE</name>
            <description>Activate</description>
            <addressOffset>0x6</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0xC3</resetMask>
            <fields>
              <field>
                <name>LATCH_PDI</name>
                <description>Latch Event PDI:
0:No
1:Generate Latch events when PDI issues
a buffer exchange or when PDI
accesses buffer start address</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LATCH_ECAT</name>
                <description>Latch Event ECAT:
0:No
1:Generate Latch event when EtherCAT
master issues a buffer exchange</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REPEAT</name>
                <description>Repeat Request:
A toggle of Repeat Request means that a
mailbox retry is needed (primarily used in
conjunction with ECAT Read Mailbox)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EN</name>
                <description>SyncManager Enable/Disable:
0:Disable:Access to Memory without
SyncManager control
1:Enable:SyncManager is active and
controls Memory area set in
configuration</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDI_CTRL</name>
            <description>PDI Control</description>
            <addressOffset>0x7</addressOffset>
            <size>8</size>
            <resetValue>0x00</resetValue>
            <resetMask>0x03</resetMask>
            <fields>
              <field>
                <name>REPEAT_ACK</name>
                <description>Repeat Ack:
If this is set to the same value as that set by
Repeat Request, the PDI acknowledges the
execution of a previous set Repeat request.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEACT</name>
                <description>Deactivate SyncManager:
Read:
0:Normal operation, SyncManager
activated.
1:SyncManager deactivated and reset.
SyncManager locks access to Memory
area.
Write:
0:Activate SyncManager
1:Request SyncManager deactivation
NOTE:Writing 1 is delayed until the end of the
frame, which is currently processed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PORT0,PORT1,PORT2,PORT3</dimIndex>
          <name>RCV_TIME[%s]</name>
          <description>no description available</description>
          <addressOffset>0x900</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LT</name>
              <description>Local time at the beginning of the last receive
frame containing a write access to register
0x0900.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REQ</name>
              <description>Write:
A write access to register 0x0900 with
BWR or FPWR latches the local time at
the beginning of the receive frame (start
first bit of preamble) at each port.
Write (ESC20, ET1200 exception):
A write access latches the local time at
the beginning of the receive frame at
port 0. It enables the time stamping at
the other ports.
Read:
Local time at the beginning of the last
receive frame containing a write access
to this register.
NOTE:FPWR requires an address match for
accessing this register like any FPWR command.
All write commands with address match will
increment the working counter (e.g., APWR), but
they will not trigger receive time latching.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_TIME</name>
          <description>System Time</description>
          <addressOffset>0x910</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ST</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RCVT_ECAT_PU</name>
          <description>Receive Time ECAT Processing Unit</description>
          <addressOffset>0x918</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LT</name>
              <description>Local time at the beginning of a frame (start
first bit of preamble) received at the ECAT
Processing Unit containing a write access to
register 0x0900
NOTE:E.g., if port 0 is open, this register reflects
the Receive Time Port 0 as a 64 Bit value.
Any valid EtherCAT write access to register
0x0900 triggers latching, not only BWR/FPWR
commands as with register 0x0900.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_TIME_OFFSET</name>
          <description>System Time Offset</description>
          <addressOffset>0x920</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Difference between local time and System
Time. Offset is added to the local time.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_TIME_DELAY</name>
          <description>System Time Delay</description>
          <addressOffset>0x928</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLY</name>
              <description>Delay between Reference Clock and the
ESC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_TIME_DIFF</name>
          <description>System Time Difference</description>
          <addressOffset>0x92c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIFF</name>
              <description>0:Local copy of System Time less than
received System Time
1:Local copy of System Time greater than
or equal to received System Time</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM</name>
              <description>Mean difference between local copy of
System Time and received System Time
values
Difference = Received System Time –
local copy of System Time</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPD_CNT_START</name>
          <description>Speed Counter Start</description>
          <addressOffset>0x930</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x7FFF</resetMask>
          <fields>
            <field>
              <name>BW</name>
              <description>Bandwidth for adjustment of local copy of
System Time (larger values → smaller
bandwidth and smoother adjustment)
A write access resets System Time
Difference (0x092C:0x092F) and Speed
Counter Diff (0x0932:0x0933).
Valid values:0x0080 to 0x3FFF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPD_CNT_DIFF</name>
          <description>Speed Counter Diff</description>
          <addressOffset>0x932</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DIFF</name>
              <description>Representation of the deviation between
local clock period and Reference Clock's
clock period (representation:two's
complement)
Range:±(Speed Counter Start – 0x7F)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_TIME_DIFF_FD</name>
          <description>System Time Difference Filter Depth</description>
          <addressOffset>0x934</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x0F</resetMask>
          <fields>
            <field>
              <name>DEPTH</name>
              <description>Filter depth for averaging the received
System Time deviation
IP Core since V2.2.0/V2.02a:
A write access resets System Time
Difference (0x092C:0x092F)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPD_CNT_FD</name>
          <description>Speed Counter Filter Depth</description>
          <addressOffset>0x935</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x0F</resetMask>
          <fields>
            <field>
              <name>DEPTH</name>
              <description>Filter depth for averaging the clock period
deviation
IP Core since V2.2.0/V2.02a:
A write access resets the internal speed
counter filter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RCV_TIME_LM</name>
          <description>Receive Time Latch Mode</description>
          <addressOffset>0x936</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>LATCH_MODE</name>
              <description>Receive Time Latch Mode:
0:Forwarding mode (used if frames are
entering the ESC at port 0 first):
Receive time stamps of ports 1-3 are
enabled after the write access to
0x0900, so the following frame at ports
1-3 will be time stamped (this is typically
the write frame to 0x0900 coming back
from the network behind the ESC).
1:Reverse mode (used if frames are
entering ESC at port 1-3 first):
Receive time stamps of ports 1-3 are
immediately taken over from the internal
hidden time stamp registers, so the
previous frame entering the ESC at
ports 1-3 will be time stamped when the
write frame to 0x0900 enters port 0 (the
previous frame at ports 1-3 is typically
the write frame to 0x0900 coming from
the master, which will enable time
stamp</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CYC_UNIT_CTRL</name>
          <description>Cyclic Unit Control</description>
          <addressOffset>0x980</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x31</resetMask>
          <fields>
            <field>
              <name>LATCHI1</name>
              <description>Latch In unit 1:
0:ECAT-controlled
1:PDI-controlled
NOTE:Latch interrupt is routed to ECAT/PDI
depending on this setting</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LATCHI0</name>
              <description>Latch In unit 0:
0:ECAT-controlled
1:PDI-controlled
NOTE:Latch interrupt is routed to ECAT/PDI
depending on this setting.
Always 1 (PDI-controlled) if System Time is PDIcontrolled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNCO</name>
              <description>Cyclic Unit and SYNC0 out unit control:
0:ECAT-controlled
1:PDI-controlled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYNCO_ACT</name>
          <description>SYNC Out Unit Activation</description>
          <addressOffset>0x981</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SSDP</name>
              <description>SyncSignal debug pulse (Vasily bit):
0:Deactivated
1:Immediately generate one ping only on
SYNC0-1 according to 0x0981[2:1 for
debugging
This bit is self-clearing, always read 0.
All pulses are generated at the same time,
the cycle time is ignored. The configured
pulse length is used.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NFC</name>
              <description>Near future configuration (approx.):
0:½ DC width future (231 ns or 263 ns)
1:~2.1 sec. future (231 ns)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STPC</name>
              <description>Start Time plausibility check:
0:Disabled. SyncSignal generation if Start
Time is reached.
1:Immediate SyncSignal generation if
Start Time is outside near future (see
0x0981[6])</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT</name>
              <description>Extension of Start Time Cyclic Operation
(0x0990:0x0993):
0:No extension
1:Extend 32 bit written Start Time to 64 bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AC</name>
              <description>Auto-activation by writing Start Time Cyclic
Operation (0x0990:0x0997):
0:Disabled
1:Auto-activation enabled. 0x0981[0] is
set automatically after Start Time is
written.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC1_GEN</name>
              <description>SYNC1 generation:
0:Deactivated
1:SYNC1 pulse is generated</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC0_GEN</name>
              <description>SYNC0 generation:
0:Deactivated
1:SYNC0 pulse is generated</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOUA</name>
              <description>Sync Out Unit activation:
0:Deactivated
1:Activated</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PULSE_LEN</name>
          <description>Pulse Length of SyncSignals</description>
          <addressOffset>0x982</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>LEN</name>
              <description>Pulse length of SyncSignals (in Units of
10ns)
0:Acknowledge mode:SyncSignal will be
cleared by reading SYNC[1:0] Status
register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_STAT</name>
          <description>Activation Status</description>
          <addressOffset>0x984</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x07</resetMask>
          <fields>
            <field>
              <name>CHK_RSLT</name>
              <description>Start Time Cyclic Operation (0x0990:0x0997)
plausibility check result when Sync Out Unit
was activated:
0:Start Time was within near future
1:Start Time was out of near future
(0x0981[6])</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC1</name>
              <description>SYNC1 activation state:
0:First SYNC1 pulse is not pending
1:First SYNC1 pulse is pending</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC0</name>
              <description>SYNC0 activation state:
0:First SYNC0 pulse is not pending
1:First SYNC0 pulse is pending</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYNC0_STAT</name>
          <description>SYNC0 Status</description>
          <addressOffset>0x98e</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>SYNC0 state for Acknowledge mode.
SYNC0 in Acknowledge mode is cleared by
reading this register from PDI, use only in
Acknowledge mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYNC1_STAT</name>
          <description>SYNC1 Status</description>
          <addressOffset>0x98f</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x01</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>SYNC1 state for Acknowledge mode.
SYNC1 in Acknowledge mode is cleared by
reading this register from PDI, use only in
Acknowledge mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>START_TIME_CO</name>
          <description>Start Time Cyclic Operation</description>
          <addressOffset>0x990</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ST</name>
              <description>Write:Start time (System time) of cyclic
operation in ns
Read:System time of next SYNC0 pulse in
ns</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NXT_SYNC1_PULSE</name>
          <description>Next SYNC1 Pulse</description>
          <addressOffset>0x998</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>System time of next SYNC1 pulse in ns</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYNC0_CYC_TIME</name>
          <description>SYNC0 Cycle Time</description>
          <addressOffset>0x9a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYC</name>
              <description>Time between two consecutive SYNC0
pulses in ns.
0:Single shot mode, generate only one
SYNC0 pulse.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYNC1_CYC_TIME</name>
          <description>SYNC1 Cycle Time</description>
          <addressOffset>0x9a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYC</name>
              <description>Time between SYNC0 pulse and SYNC1
pulse in ns</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATCH0_CTRL</name>
          <description>Latch0 Control</description>
          <addressOffset>0x9a8</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x03</resetMask>
          <fields>
            <field>
              <name>NEG_EDGE</name>
              <description>Latch0 negative edge:
0:Continuous Latch active
1:Single event (only first event active)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_EDGE</name>
              <description>Latch0 positive edge:
0:Continuous Latch active
1:Single event (only first event active)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATCH1_CTRL</name>
          <description>Latch1 Control</description>
          <addressOffset>0x9a9</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x03</resetMask>
          <fields>
            <field>
              <name>NEG_EDGE</name>
              <description>Latch1 negative edge:
0:Continuous Latch active
1:Single event (only first event active)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_EDGE</name>
              <description>Latch1 positive edge:
0:Continuous Latch active
1:Single event (only first event active)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATCH0_STAT</name>
          <description>Latch0 Status</description>
          <addressOffset>0x9ae</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x07</resetMask>
          <fields>
            <field>
              <name>PIN_STAT</name>
              <description>Latch0 pin state</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NEG_EDGE</name>
              <description>Event Latch0 negative edge.
0:Negative edge not detected or
continuous mode
1:Negative edge detected in single event
mode only.
Flag cleared by reading out Latch0 Time
Negative Edge.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>POS_EDGE</name>
              <description>Event Latch0 positive edge.
0:Positive edge not detected or
continuous mode
1:Positive edge detected in single event
mode only.
Flag cleared by reading out Latch0 Time
Positive Edge.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATCH1_STAT</name>
          <description>Latch1 Status</description>
          <addressOffset>0x9af</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x07</resetMask>
          <fields>
            <field>
              <name>PIN_STAT</name>
              <description>Latch1 pin state</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NEG_EDGE</name>
              <description>Event Latch1 negative edge.
0:Negative edge not detected or
continuous mode
1:Negative edge detected in single event
mode only.
Flag cleared by reading out Latch1 Time
Negative Edge.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>POS_EDGE</name>
              <description>Event Latch1 positive edge.
0:Positive edge not detected or
continuous mode
1:Positive edge detected in single event
mode only.
Flag cleared by reading out Latch1 Time
Positive Edge.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATCH0_TIME_PE</name>
          <description>Latch0 Time Positive Edge</description>
          <addressOffset>0x9b0</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>System time at the positive edge of the
Latch0 signal.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATCH0_TIME_NE</name>
          <description>Latch0 Time Negative Edge</description>
          <addressOffset>0x9b8</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>System time at the negative edge of the
Latch0 signal.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATCH1_TIME_PE</name>
          <description>Latch1 Time Positive Edge</description>
          <addressOffset>0x9c0</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>System time at the positive edge of the
Latch1 signal.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LATCH1_TIME_NE</name>
          <description>Latch1 Time Negative Edge</description>
          <addressOffset>0x9c8</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>System time at the negative edge of the
Latch1 signal.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECAT_BUF_CET</name>
          <description>EtherCAT Buffer Change Event Time</description>
          <addressOffset>0x9f0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>Local time at the beginning of the frame
which causes at least one SyncManager to
assert an ECAT event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_BUF_SET</name>
          <description>PDI Buffer Start Event Time</description>
          <addressOffset>0x9f8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>Local time when at least one SyncManager
asserts a PDI buffer start event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDI_BUF_CET</name>
          <description>PDI Buffer Change Event Time</description>
          <addressOffset>0x9fc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIME</name>
              <description>Local time when at least one SyncManager
asserts a PDI buffer change event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID</name>
          <description>Product ID</description>
          <addressOffset>0xe00</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID</name>
              <description>Product ID</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VID</name>
          <description>Vendor ID</description>
          <addressOffset>0xe08</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0x00000000FFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID</name>
              <description>Vendor ID:
[23-0] Company
[31-24] Department
NOTE:Test Vendor IDs have [31:28]=0xE</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIO_OUT_DATA</name>
          <description>Digital I/O Output Data</description>
          <addressOffset>0xf00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OD</name>
              <description>Output Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPO</name>
          <description>General Purpose Outputs</description>
          <addressOffset>0xf10</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPOD</name>
              <description>General Purpose Output Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPI</name>
          <description>General Purpose Inputs</description>
          <addressOffset>0xf18</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000000000</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPID</name>
              <description>General Purpose Input Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE0</name>
          <description>User Ram Byte 0</description>
          <addressOffset>0xf80</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EXTF</name>
              <description>Number of extended feature bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE1</name>
          <description>User Ram Byte 1</description>
          <addressOffset>0xf81</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRWO</name>
              <description>Physical Read/Write Offset (0x0108:0x0109)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AEMW</name>
              <description>AL Event Mask writable (0x0204:0x0207)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPO</name>
              <description>General Purpose Outputs (0x0F10:0x0F17)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPI</name>
              <description>General Purpose Inputs (0x0F18:0x0F1F)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSA</name>
              <description>Configured Station Alias (0x0012:0x0013)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EIM</name>
              <description>ECAT Interrupt Mask (0x0200:0x0201)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALSCR</name>
              <description>AL Status Code Register (0x0134:0x0135)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EDLCR</name>
              <description>Extended DL Control Register (0x0102:0x0103)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE2</name>
          <description>User Ram Byte 2</description>
          <addressOffset>0xf82</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xEF</resetMask>
          <fields>
            <field>
              <name>ESCFG</name>
              <description>EEPROM Size configurable (0x0502[7]):
0:EEPROM Size fixed to sizes up to 16 Kbit
1:EEPROM Size configurable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPUPEC</name>
              <description>ECAT Processing Unit/PDI Error Counter
(0x030C:0x030D)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCSMET</name>
              <description>DC SyncManager Event Times (0x09F0:0x09FF)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Reset (0x0040:0x0041)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WP</name>
              <description>Write Protection (0x0020:0x0031)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDGCNT</name>
              <description>Watchdog counters (0x0442:0x0443)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDW</name>
              <description>Watchdog divider writable (0x0400:0x0401) and
Watchdog PDI (0x0410:0x0411)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE3</name>
          <description>User Ram Byte 3</description>
          <addressOffset>0xf83</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xF8</resetMask>
          <fields>
            <field>
              <name>RLED</name>
              <description>Run LED (DEV_STATE LED)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELDE</name>
              <description>Enhanced Link Detection EBUS</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELDM</name>
              <description>Enhanced Link Detection MII</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MMI</name>
              <description>MII Management Interface (0x0510:0x0515)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LLC</name>
              <description>Lost Link Counter (0x0310:0x0313)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE4</name>
          <description>User Ram Byte 4</description>
          <addressOffset>0xf84</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xE9</resetMask>
          <fields>
            <field>
              <name>LDCM</name>
              <description>Link detection and configuration by MI</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTLC</name>
              <description>DC Time loop control assigned to PDI</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSOU</name>
              <description>DC Sync Out Unit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLIU</name>
              <description>DC Latch In Unit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LALED</name>
              <description>Link/Activity LED</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE5</name>
          <description>User Ram Byte 5</description>
          <addressOffset>0xf85</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x27</resetMask>
          <fields>
            <field>
              <name>DDIOR</name>
              <description>Disable Digital I/O register (0x0F00:0x0F03)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EEU</name>
              <description>EEPROM emulation by µController</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATS</name>
              <description>Automatic TX shift</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCPP</name>
              <description>MI control by PDI possible</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE6</name>
          <description>User Ram Byte 6</description>
          <addressOffset>0xf86</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x04</resetMask>
          <fields>
            <field>
              <name>RELEDOR</name>
              <description>RUN/ERR LED Override (0x0138:0x0139)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE7</name>
          <description>User Ram Byte 7</description>
          <addressOffset>0xf87</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xC8</resetMask>
          <fields>
            <field>
              <name>DCST</name>
              <description>DC System Time (0x0910:0x0936)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRT</name>
              <description>DC Receive Times (0x0900:0x090F)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCS1D</name>
              <description>DC Sync1 disable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE8</name>
          <description>User Ram Byte 8</description>
          <addressOffset>0xf88</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x3D</resetMask>
          <fields>
            <field>
              <name>PPDI</name>
              <description>PLB PDI</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPDI</name>
              <description>OPB PDI</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APDI</name>
              <description>Avalon PDI</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDICEC</name>
              <description>PDI clears error counter</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC64</name>
              <description>DC 64 bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE9</name>
          <description>User Ram Byte 9</description>
          <addressOffset>0xf89</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x80</resetMask>
          <fields>
            <field>
              <name>DR</name>
              <description>Direct RESET</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE10</name>
          <description>User Ram Byte 10</description>
          <addressOffset>0xf8a</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xCC</resetMask>
          <fields>
            <field>
              <name>PDIIR</name>
              <description>PDI Information register (0x014E:0x014F)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDIFA</name>
              <description>PDI function acknowledge by PDI write</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APDI</name>
              <description>AXI PDI</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCL1D</name>
              <description>DC Latch1 disable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE11</name>
          <description>User Ram Byte 11</description>
          <addressOffset>0xf8b</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x08</resetMask>
          <fields>
            <field>
              <name>LEDTST</name>
              <description>LED test</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE14</name>
          <description>User Ram Byte 14</description>
          <addressOffset>0xf8e</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0xC0</resetMask>
          <fields>
            <field>
              <name>DIOBS</name>
              <description>Digital I/O PDI byte size</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE15</name>
          <description>User Ram Byte 15</description>
          <addressOffset>0xf8f</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x1C</resetMask>
          <fields>
            <field>
              <name>AUCPDI</name>
              <description>Asynchronous µC PDI</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSPDI</name>
              <description>SPI Slave PDI</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIOPDI</name>
              <description>Digital I/O PDI</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USER_RAM_BYTE19</name>
          <description>User Ram Byte 19</description>
          <addressOffset>0xf93</addressOffset>
          <size>8</size>
          <resetValue>0x00</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SCP</name>
              <description>Security CPLD protection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII</name>
              <description>RMII</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>URGP</name>
              <description>Use RGMII GTX_CLK phase shifted clock input</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIA</name>
              <description>CLK_PDI_EXT is asynchronous</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPARO</name>
              <description>Individual PHY address read out (0x0510[7:3])</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RGMII</name>
              <description>RGMII</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDRAM</name>
          <description>Process Data Ram</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Input Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDRAM_ALS</name>
          <description>Process Data Ram Alias</description>
          <addressOffset>0x10000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_CFG0</name>
          <description>General Purpose Configure 0</description>
          <addressOffset>0x1f000</addressOffset>
          <size>32</size>
          <resetValue>0x00001000</resetValue>
          <resetMask>0x00003009</resetMask>
          <fields>
            <field>
              <name>CLK100_EN</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EEPROM_EMU</name>
              <description>1 is EEPROM emulation mode (default)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SCLK_EN</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROM_SIZE</name>
              <description>Sets EEPROM size:
0:up to 16 kbit EEPROM
1:32 kbit-4Mbit EEPROM</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_CFG1</name>
          <description>General Purpose Configure 1</description>
          <addressOffset>0x1f004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xE00033C0</resetMask>
          <fields>
            <field>
              <name>SYNC1_IRQ_EN</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC0_IRQ_EN</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTO_IRQ_EN</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC1_DMA_EN</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC0_DMA_EN</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LATCH1_FROM_IO</name>
              <description>0:from NTM</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LATCH0_FROM_IO</name>
              <description>0:from TRIGGER_MUX</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTO_OVRD</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTO_OVRD_ENJ</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_CFG2</name>
          <description>General Purpose Configure 2</description>
          <addressOffset>0x1f008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x33300000</resetMask>
          <fields>
            <field>
              <name>NMII_LINK2_FROM_IO</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMII_LINK2_GPR</name>
              <description>No description available</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMII_LINK1_FROM_IO</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMII_LINK1_GPR</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMII_LINK0_FROM_IO</name>
              <description>No description available</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMII_LINK0_GPR</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CFG0</name>
          <description>PHY Configure 0</description>
          <addressOffset>0x1f010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x40808080</resetMask>
          <fields>
            <field>
              <name>MAC_SPEED</name>
              <description>1:100M</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT2_RMII_EN</name>
              <description>No description available</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT1_RMII_EN</name>
              <description>No description available</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT0_RMII_EN</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CFG1</name>
          <description>PHY Configure 1</description>
          <addressOffset>0x1f014</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>RMII_REFCLK_SEL</name>
              <description>0:use RXCK as 50M refclk. 1:use TXCK as 50M refclk</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REFCK_25M_INV</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII_P2_RXCK_REFCLK_OE</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII_P1_RXCK_REFCLK_OE</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII_P0_RXCK_REFCLK_OE</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REFCK_25M_OE</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII_P2_TXCK_REFCLK_OE</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII_P1_TXCK_REFCLK_OE</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII_P0_TXCK_REFCLK_OE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_CTRL</name>
          <description>GPIO Output Enable</description>
          <addressOffset>0x1f020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0003F1F</resetMask>
          <fields>
            <field>
              <name>SW_LATCH_GPI</name>
              <description>if gpi_trig_sel is set to 4'b1001, setting this bit will latch GPI to gpi_reg0/1</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SW_LATCH_GPO</name>
              <description>if gpo_trig_sel is set to 4'b1001, setting this bit will latch GPO to gpo_reg0/1</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPI_OVERRIDE_EN</name>
              <description>set this bit will use GPI from the software register gpi_override0/1
clr to use GPI from pad directly</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPI_TRIG_EN</name>
              <description>use gpi_trig_sel can select the trigger event to latch GPI signal(from reg or pad)
set to use triggered signal;
clr to use signals direclty(from reg or pad)
assign pdi_gpi = gpi_trig_en ? gpi_reg :
               (gpi_override_en ? gpi_override :pad_di_ecat_gpi);</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPI_TRIG_SEL</name>
              <description>select the trigger signal to latch GPI.
0000: SOF;  0001: EOF;  0010: pos of  SYNC0;  0011: pos of SYNC1;
0100: pos of LATCH0;   0101: pos of LATCH1;   0110: neg of LATCH0;   0111: neg of LATCH1
1000: wdog trigger;   1001: sw set gpio_ctrl[31];   others no trigger</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPO_TRIG_EN</name>
              <description>use gpo_trig_sel can select the trigger event to latch GPO signal(from core)
set to use triggered signal;
clr to use GPO signals direclty(from reg or pad)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPO_TRIG_SEL</name>
              <description>select the trigger signal to latch GPO.
0000: SOF;  0001: EOF;  0010: pos of  SYNC0;  0011: pos of SYNC1;
0100: pos of LATCH0;   0101: pos of LATCH1;   0110: neg of LATCH0;   0111: neg of LATCH1
1000: wdog trigger;   1001: sw set gpio_ctrl[30];   others no trigger</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPI_OVERRIDE0</name>
          <description>GPI low word Override value</description>
          <addressOffset>0x1f030</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR_OVERRIDE_LOW</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPI_OVERRIDE1</name>
          <description>GPI high word Override value</description>
          <addressOffset>0x1f034</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR_OVERRIDE_HIGH</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPO_REG0</name>
          <description>GPO low word read value</description>
          <addressOffset>0x1f038</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPO_REG1</name>
          <description>GPO high word read value</description>
          <addressOffset>0x1f03c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPI_REG0</name>
          <description>GPI low word read value</description>
          <addressOffset>0x1f040</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPI_REG1</name>
          <description>GPI high word read value</description>
          <addressOffset>0x1f044</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_STATUS</name>
          <description>global status register</description>
          <addressOffset>0x1f060</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF037F</resetMask>
          <fields>
            <field>
              <name>NLINK2_PADSEL</name>
              <description>No description available</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NLINK1_PADSEL</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NLINK0_PADSEL</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDI_SOF</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDI_EOF</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDI_WD_TRIGGER</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDI_WD_STATE</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC_OUT1</name>
              <description>No description available</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC_OUT0</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LED_STATE_RUN</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LED_ERR</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LED_RUN</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DEV_STATE</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LINK_ACT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>9</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>CTR0,CTR1,CTR2,CTR3,CTR4,CTR5,CTR6,CTR7,CTR8</dimIndex>
          <name>IO_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1f080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>INVERT</name>
              <description>1:invert the IO</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FUNC_ALT</name>
              <description>IO usage:
0:NMII_LINK0
1:NMII_LINK1
2:NMII_LINK2
3:LINK_ACT0
4:LINK_ACT1
5:LINK_ACT2
6:LED_RUN
7:LED_ERR
8:RESET_OUT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FEMC</name>
      <description>FEMC</description>
      <groupName>FEMC</groupName>
      <baseAddress>0xf300c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x154</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFF0007</resetMask>
          <fields>
            <field>
              <name>BTO</name>
              <description>Bus timeout cycles
AXI Bus timeout cycle is as following (255*(2^BTO)):
00000b - 255*1
00001-11110b - 255*2 - 255*2^30
11111b - 255*2^31</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTO</name>
              <description>Command Execution timeout cycles
When Command Execution time exceed this timeout cycles, IPCMDERR or AXICMDERR interrupt is
generated. When CTO is set to zero, timeout cycle is 256*1024 cycle. otherwisee timeout cycle is
CTO*1024 cycle.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DQS</name>
              <description>DQS (read strobe) mode
0b - Dummy read strobe loopbacked internally
1b - Dummy read strobe loopbacked from DQS pad</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS</name>
              <description>Module Disable
0b - Module enabled
1b - Module disabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RST</name>
              <description>Software Reset
Reset all internal logic in SEMC except configuration register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IOCTRL</name>
          <description>IO Mux Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000F0</resetMask>
          <fields>
            <field>
              <name>IO_CSX</name>
              <description>IO_CSX output selection
0001b - SDRAM CS1
0110b - SRAM CE#</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BMW0</name>
          <description>Bus (AXI) Weight Control Register 0</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>RWS</name>
              <description>Weight of slave hit with Read/Write Switch. This weight score is valid when queue command's slave is
same as current executing command with read/write operation switch.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SH</name>
              <description>Weight of Slave Hit without read/write switch. This weight score is valid when queue command's slave is
same as current executing command without read/write operation switch.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AGE</name>
              <description>Weight of AGE calculation. Each command in queue has an age signal to indicate its wait period. It is
multiplied by WAGE to get weight score.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QOS</name>
              <description>Weight of QOS calculation. AXI bus access has AxQOS signal set, which is used as a priority indicator
for the associated write or read transaction. A higher value indicates a higher priority transaction. AxQOS
is multiplied by WQOS to get weight score.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BMW1</name>
          <description>Bus (AXI) Weight Control Register 1</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BR</name>
              <description>Weight of Bank Rotation. This weight score is valid when queue command's bank is not same as current
executing command.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWS</name>
              <description>Weight of slave hit with Read/Write Switch. This weight score is valid when queue command's slave is
same as current executing command with read/write operation switch.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PH</name>
              <description>Weight of Slave Hit without read/write switch. This weight score is valid when queue command's slave is
same as current executing command without read/write operation switch.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AGE</name>
              <description>Weight of AGE calculation. Each command in queue has an age signal to indicate its wait period. It is
multiplied by WAGE to get weight score.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QOS</name>
              <description>Weight of QOS calculation. AXI bus access has AxQOS signal set, which is used as a priority indicator
for the associated write or read transaction. A higher value indicates a higher priority transaction. AxQOS
is multiplied by WQOS to get weight score.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>3</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>BASE0,BASE1,rsv2,rsv3,rsv4,rsv5,BASE6</dimIndex>
          <name>BR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF03F</resetMask>
          <fields>
            <field>
              <name>BASE</name>
              <description>Base Address
This field determines high position 20 bits of SoC level Base Address. SoC level Base Address low
position 12 bits are all zero.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIZE</name>
              <description>Memory size
00000b - 4KB
00001b - 8KB
00010b - 16KB
00011b - 32KB
00100b - 64KB
00101b - 128KB
00110b - 256KB
00111b - 512KB
01000b - 1MB
01001b - 2MB
01010b - 4MB
01011b - 8MB
01100b - 16MB
01101b - 32MB
01110b - 64MB
01111b - 128MB
10000b - 256MB
10001b - 512MB
10010b - 1GB
10011b - 2GB
10100-11111b - 4GB</description>
              <bitOffset>1</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VLD</name>
              <description>Valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTEN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>AXIBUSERR</name>
              <description>AXI BUS error interrupt enable
0b - Interrupt is disabled
1b - Interrupt is enabled</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AXICMDERR</name>
              <description>AXI command error interrupt enable
0b - Interrupt is disabled
1b - Interrupt is enabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPCMDERR</name>
              <description>IP command error interrupt enable
0b - Interrupt is disabled
1b - Interrupt is enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPCMDDONE</name>
              <description>IP command done interrupt enable
0b - Interrupt is disabled
1b - Interrupt is enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>AXIBUSERR</name>
              <description>AXI bus error interrupt
AXI Bus error interrupt is generated in following cases:
• AXI address is invalid
• AXI 8-bit or 16-bit WRAP write/read</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AXICMDERR</name>
              <description>AXI command error interrupt
AXI command error interrupt is generated when AXI command execution timeout.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IPCMDERR</name>
              <description>IP command error done interrupt
IP command error interrupt is generated in following case:
• IP Command Address target invalid device space
• IP Command Code unsupported
• IP Command triggered when previous command</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IPCMDDONE</name>
              <description>IP command normal done interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDRCTRL0</name>
          <description>SDRAM Control Register 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00004FFB</resetMask>
          <fields>
            <field>
              <name>BANK2</name>
              <description>2 Bank selection bit
0b - SDRAM device has 4 banks.
1b - SDRAM device has 2 banks.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAS</name>
              <description>CAS Latency
00b - 1
01b - 1
10b - 2
11b - 3</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COL</name>
              <description>Column address bit number
00b - 12 bit
01b - 11 bit
10b - 10 bit
11b - 9 bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COL8</name>
              <description>Column 8 selection bit
0b - Column address bit number is decided by COL field.
1b - Column address bit number is 8. COL field is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BURSTLEN</name>
              <description>Burst Length
000b - 1
001b - 2
010b - 4
011b - 8
100b - 8
101b - 8
110b - 8
111b - 8</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIGHBAND</name>
              <description>high band select
0: use data[15:0] for 16bit SDRAM;
1: use data[31:16] for 16bit SDRAM;
only used when Port Size is 16bit(PORTSZ=01b)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORTSZ</name>
              <description>Port Size
00b - 8bit
01b - 16bit
10b - 32bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDRCTRL1</name>
          <description>SDRAM Control Register 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>ACT2PRE</name>
              <description>ACT to Precharge minimum time
It is promised ACT2PRE+1 clock cycles delay between ACTIVE command to PRECHARGE/PRECHARGE_ALL command.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CKEOFF</name>
              <description>CKE OFF minimum time
It is promised clock suspend last at leat CKEOFF+1 clock cycles.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRC</name>
              <description>Write recovery time
It is promised WRC+1 clock cycles delay between WRITE command to PRECHARGE/PRECHARGE_ALL command. This could help to meet tWR timing requirement by SDRAM device.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFRC</name>
              <description>Refresh recovery time
It is promised RFRC+1 clock cycles delay between REFRESH command to ACTIVE command. Thiscould help to meet tRFC timing requirement by SDRAM device.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT2RW</name>
              <description>ACT to Read/Write wait time
It is promised ACT2RW+1 clock cycles delay between ACTIVE command to READ/WRITE command.This could help to meet tRCD timing requirement by SDRAM device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRE2ACT</name>
              <description>PRECHARGE to ACT/Refresh wait time
It is promised PRE2ACT+1 clock cycles delay between PRECHARGE/PRECHARGE_ALL commandto ACTIVE/REFRESH command. This could help to meet tRP timing requirement by SDRAM device.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDRCTRL2</name>
          <description>SDRAM Control Register 2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ITO</name>
              <description>SDRAM Idle timeout
It closes all opened pages if the SDRAM idle time lasts more than idle timeout period. SDRAM is
considered idle when there is no AXI Bus transfer and no SDRAM command pending.
00000000b - IDLE timeout period is 256*Prescale period.
00000001-11111111b - IDLE timeout period is ITO*Prescale period.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT2ACT</name>
              <description>ACT to ACT wait time
It is promised ACT2ACT+1 clock cycles delay between ACTIVE command to ACTIVE command. This
could help to meet tRRD timing requirement by SDRAM device.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF2REF</name>
              <description>Refresh to Refresh wait time
It is promised REF2REF+1 clock cycles delay between REFRESH command to REFRESH command.
This could help to meet tRFC timing requirement by SDRAM device.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRRC</name>
              <description>Self Refresh Recovery time
It is promised SRRC+1 clock cycles delay between Self-REFRESH command to any command.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDRCTRL3</name>
          <description>SDRAM Control Register 3</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>UT</name>
              <description>Refresh urgent threshold
Internal refresh request is generated on every Refresh period. Before internal request timer count up to
urgent request threshold, the refresh request is considered as normal refresh request. Normal refresh
request is handled in lower priority than any pending AXI command or IP command to SDRAM device.
When internal request timer count up to this urgent threshold, refresh request is considered as urgent
refresh request. Urgent refresh request is handled in higher priority than any pending AXI command or IP
command to SDRAM device.
NOTE: When urgent threshold is no less than refresh period, refresh request is always considered as
urgent refresh request.
Refresh urgent threshold is as follwoing:
00000000b - 256*Prescaler period
00000001-11111111b - UT*Prescaler period</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RT</name>
              <description>Refresh timer period
Refresh timer period is as following:
00000000b - 256*Prescaler period
00000001-11111111b - RT*Prescaler period</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESCALE</name>
              <description>Prescaler timer period
Prescaler timer period is as following:
00000000b - 256*16 clock cycles
00000001-11111111b - PRESCALE*16 clock cycles</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REBL</name>
              <description>Refresh burst length
It could send multiple Auto-Refresh command in one burst when REBL is set to non-zero. The
number of Auto-Refresh command cycle sent to all SDRAM device in one refresh period is as following.
000b - 1
001b - 2
010b - 3
011b - 4
100b - 5
101b - 6
110b - 7
111b - 8</description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REN</name>
              <description>Refresh enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRCTRL0</name>
          <description>SRAM control register 0</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000F01</resetMask>
          <fields>
            <field>
              <name>ADVH</name>
              <description>ADV hold state
0b - ADV is high during address hold state
1b - ADV is low during address hold state</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADVP</name>
              <description>ADV polarity
0b - ADV is active low
1b - ADV is active high</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADM</name>
              <description>address data mode
00b - address and data MUX mode
11b - address and data non-MUX mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORTSZ</name>
              <description>port size
0b - 8bit
1b - 16bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRCTRL1</name>
          <description>SRAM control register 1</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OEH</name>
              <description>OE high time, is OEH+1 clock cycles</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OEL</name>
              <description>OE low time, is OEL+1 clock cycles</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WEH</name>
              <description>WE high time, is WEH+1 clock cycles</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WEL</name>
              <description>WE low time, is WEL+1 clock cycles</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AH</name>
              <description>Address hold time, is AH+1 clock cycles</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AS</name>
              <description>Address setup time, is AS+1 clock cycles</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CEH</name>
              <description>Chip enable hold time, is CEH+1 clock cycles</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CES</name>
              <description>Chip enable setup time, is CES+1 clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SADDR</name>
          <description>IP Command Control Register 0</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>Slave address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATSZ</name>
          <description>IP Command Control Register 1</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>DATSZ</name>
              <description>Data Size in Byte
When IP command is not a write/read operation, DATSZ field would be ignored.
000b - 4
001b - 1
010b - 2
011b - 3
100b - 4
101b - 4
110b - 4
111b - 4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BYTEMSK</name>
          <description>IP Command Control Register 2</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>BM3</name>
              <description>Byte Mask for Byte 3 (IPTXD bit 31:24)
0b - Byte Unmasked
1b - Byte Masked</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BM2</name>
              <description>Byte Mask for Byte 2 (IPTXD bit 23:16)
0b - Byte Unmasked
1b - Byte Masked</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BM1</name>
              <description>Byte Mask for Byte 1 (IPTXD bit 15:8)
0b - Byte Unmasked
1b - Byte Masked</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BM0</name>
              <description>Byte Mask for Byte 0 (IPTXD bit 7:0)
0b - Byte Unmasked
1b - Byte Masked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IPCMD</name>
          <description>IP Command Register</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>This field should be written with 0x5AA5 when trigging an IP command for all device types. The memory
device is selected by BRx settings and IPCR0 registers.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CMD</name>
              <description>SDRAM Commands:
• 0x8: READ
• 0x9: WRITE
• 0xA: MODESET
• 0xB: ACTIVE
• 0xC: AUTO REFRESH
• 0xD: SELF REFRESH
• 0xE: PRECHARGE
• 0xF: PRECHARGE ALL
• Others: RSVD
NOTE: SELF REFRESH is sent to all SDRAM devices because they shared same CLK pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IPTX</name>
          <description>TX DATA Register</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAT</name>
              <description>Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IPRX</name>
          <description>RX DATA Register</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAT</name>
              <description>Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT0</name>
          <description>Status Register 0</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>IDLE</name>
              <description>Indicating whether it is in IDLE state.
When IDLE=1, it is in IDLE state. There is no pending AXI command in internal queue and no
pending device access.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLYCFG</name>
          <description>Delay Line Config Register</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000203F</resetMask>
          <fields>
            <field>
              <name>OE</name>
              <description>delay clock output enable, should be set after setting DLYEN and DLYSEL</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLYSEL</name>
              <description>delay line select, 0 for 1 cell, 31 for all 32 cells</description>
              <bitOffset>1</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLYEN</name>
              <description>delay line enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FFA</name>
      <description>FFA</description>
      <groupName>FFA</groupName>
      <baseAddress>0xf3108000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>No description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>software reset the module if asserted to be 1.
EN is only active after this bit is zero.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Asserted to enable the module</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>No description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>FP_NAN</name>
              <description>Ored together by ( FP_ST[IN_NAN] &amp; FP_CTRL[IN_NAN_IE] ) | ( FP_ST[COEF_NAN] &amp; FP_CTRL[COEF_NAN_IE] )</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FP_SAT</name>
              <description>Ored together by ( FP_ST[IN_SAT] &amp; FP_CTRL[IN_SAT_IE] ) | ( FP_ST[COEF_SAT] &amp; FP_CTRL[COEF_SAT_IE] )</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIR_OV</name>
              <description>FIR Overflow err</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FFT_OV</name>
              <description>FFT Overflow Err</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WR_ERR</name>
              <description>AXI Data Write Error</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RD_NXT_ERR</name>
              <description>AXI Read Bus Error for NXT DATA</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RD_ERR</name>
              <description>AXI Data Read Error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NXT_CMD_RD_DONE</name>
              <description>Indicate that next command sequence is already read into the module.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OP_CMD_DONE</name>
              <description>Indicate that operation cmd is done, and data are available in system memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>No description available</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRSV1</name>
              <description>Reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIR_OV</name>
              <description>FIR Overflow err</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FFT_OV</name>
              <description>FFT Overflow Err</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_ERR</name>
              <description>Enable Data Write Error interrupt</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_NXT_ERR</name>
              <description>Enable Read Bus Error for NXT DATA interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_ERR</name>
              <description>Enable Data Read Error interrupt</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NXT_CMD_RD_DONE</name>
              <description>Indicate that next command sequence is already read into the module.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_CMD_DONE</name>
              <description>Indicate that operation cmd is done, and data are available in system memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FP_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xBFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IN_SAT_IE</name>
              <description>IN_SAT interrupt enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_SAT_IE</name>
              <description>COEF_SAT interrupt enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_NAN_IE</name>
              <description>IN_NAN interrupt enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_NAN_IE</name>
              <description>COEF_NAN interrupt enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXP_ST_SEL</name>
              <description>2'b00: exp for input data
2'b01: exp for output data
2'b10: exp for coef data</description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_BIAS_EXP</name>
              <description>Asserted to use biased exp as exp input and exp output</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_MAX</name>
              <description>The coef max exp for float. When used as float input, this field must be configured. The absolute value of coefficients should be smalller than pow(2, (COEF_MAX+1)). So this suggested value is (ceil(log2(fabs(coef[])))-1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_MAX</name>
              <description>The output max exp for float. When used as float output, this field must be configured. The absolute value of output data should be smalller than pow(2, (OUT_MAX+1)). So this suggested value is (ceil(log2(fabs(out[])))-1).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_MAX</name>
              <description>The input max exp for float. When used as float input, this field must be configured. The absolute value of input data should be smalller than pow(2, (IN_MAX+1)). So this suggested value is (ceil(log2(fabs(in[])))-1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FP_ST</name>
          <description>No description available</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xB800FFFF</resetMask>
          <fields>
            <field>
              <name>IN_SAT</name>
              <description>the float input is saturated when converted from float to fix due to small FLT_CTRL[IN_MAX].</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>COEF_SAT</name>
              <description>the float coef is saturated when converted from float to fix due to small FLT_CTRL[COEF_MAX].</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IN_NAN</name>
              <description>IN_NAN found</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>COEF_NAN</name>
              <description>COEF_NAN found</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EXP_MAX</name>
              <description>The max exp for float</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EXP_MIN</name>
              <description>The min exp for float</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NXT_ADDR</name>
              <description>The address for the next command.
It will be processed after CUR_CMD is executed and done..</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NXT_EN</name>
              <description>Whether NXT_CMD is enabled.
Asserted to enable the NXT_CMD when CUR_CMD is done, or CUR_CMD is not enabled..</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Whether CUR_CMD is enabled.
Asserted to enable the CUR_CMD</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_CMD</name>
          <description>No description available</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFEFF</resetMask>
          <fields>
            <field>
              <name>CONJ_C</name>
              <description>asserted to have conjuate value for coefs in computation</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD</name>
              <description>The Command Used:
0: FIR
2: FFT
Others: Reserved</description>
              <bitOffset>18</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTD_TYPE</name>
              <description>Output data type:
0:Real Q31, 1:Real Q15, 2:Complex Q31, 3:Complex Q15
4:complex sp float 5: real sp float</description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_TYPE</name>
              <description>Coef data type (used for FIR):
0:Real Q31, 1:Real Q15, 2:Complex Q31, 3:Complex Q15
4:complex sp float 5: real sp float</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IND_TYPE</name>
              <description>Input data type:
0:Real Q31, 1:Real Q15, 2:Complex Q31, 3:Complex Q15
4:complex sp float 5: real sp float</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NXT_CMD_LEN</name>
              <description>The length of nxt commands in 32-bit words</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG0</name>
          <description>No description available</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_MISC</name>
          <description>No description available</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>FIR_COEF_TAPS</name>
              <description>Length of FIR coefs （max 256）</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FFT_MISC</name>
          <description>No description available</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>FFT_LEN</name>
              <description>FFT length
0:8,
...,
n:2^(3+n)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IFFT</name>
              <description>Asserted to indicate IFFT</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMP_BLK</name>
              <description>Memory block for indata. Should be assigned as 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IND_BLK</name>
              <description>Memory block for indata. Should be assigned as 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG1</name>
          <description>No description available</description>
          <alternateGroup>UNION_2C</alternateGroup>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_MISC1</name>
          <description>No description available</description>
          <alternateGroup>UNION_2C</alternateGroup>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>OUTD_MEM_BLK</name>
              <description>Should be assigned as 0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_MEM_BLK</name>
              <description>Should be assigned as 1</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IND_MEM_BLK</name>
              <description>Should be assigned as 2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIR_DATA_TAPS</name>
              <description>The input data data length</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG2</name>
          <description>No description available</description>
          <alternateGroup>UNION_30</alternateGroup>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FFT_INRBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_30</alternateGroup>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The input (real) data buffer pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG3</name>
          <description>No description available</description>
          <alternateGroup>UNION_34</alternateGroup>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_INBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_34</alternateGroup>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The input data buffer pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG4</name>
          <description>No description available</description>
          <alternateGroup>UNION_38</alternateGroup>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_COEFBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_38</alternateGroup>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The coef buf pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FFT_OUTRBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_38</alternateGroup>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The output (real) data buffer pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG5</name>
          <description>No description available</description>
          <alternateGroup>UNION_3C</alternateGroup>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_OUTBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_3C</alternateGroup>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The output data buffer pointer. The length of the output buffer should be （FIR_DATA_TAPS - FIR_COEF_TAPS + 1）</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG6</name>
          <description>No description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG7</name>
          <description>No description available</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDP</name>
      <description>SDP</description>
      <groupName>SDP</groupName>
      <baseAddress>0xf3140000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x60</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SDPCR</name>
          <description>SDP control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xFFFE0101</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>soft reset.
Write 1 then 0, to reset the SDP block.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKGAT</name>
              <description>Clock Gate for the SDP main logic.
Write to 1 will clock gate for most logic of the SDP block, dynamic power saving when not use SDP block.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIPDIS</name>
              <description>Cipher Disable, read the info, whether the CIPHER features is besing disable in this chip or not.
1, Cipher is disabled in this chip.
0, Cipher is enabled in this chip.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HASDIS</name>
              <description>HASH Disable, read the info, whether the HASH features is besing disable in this chip or not.
1, HASH is disabled in this chip.
0, HASH is enabled in this chip.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CIPHEN</name>
              <description>Cipher Enablement, controlled by SW.
1, Cipher is Enabled.
0, Cipher is Disabled.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASHEN</name>
              <description>HASH Enablement, controlled by SW.
1, HASH is Enabled.
0, HASH is Disabled.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCPEN</name>
              <description>Memory Copy Enablement, controlled by SW.
1, Memory copy is Enabled.
0, Memory copy is Disabled.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFEN</name>
              <description>Constant Fill to memory, controlled by SW.
1, Constant fill is Enabled.
0, Constant fill is Disabled.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRPDI</name>
              <description>Decryption Disable bit, Write to 1 to disable the decryption.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSTPKT0IRQ</name>
              <description>Test purpose for interrupt when Packet counter reachs "0", but CHAIN=1 in the current packet.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDSCEN</name>
              <description>when set to "1", the 1st data packet descriptor loacted in the register(CMDPTR, NPKTPTR, ...)
when set to "0", the 1st data packet descriptor loacted in the memeory(pointed by CMDPTR)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enablement, controlled by SW.
1, SDP interrupt is enabled.
0, SDP interrupt is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODCTRL</name>
          <description>Mod control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF7FF</resetMask>
          <fields>
            <field>
              <name>AESALG</name>
              <description>AES algorithem selection.
0x0 = AES 128;
0x1 = AES 256;
0x8 = SM4；
Others, reserved.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESMOD</name>
              <description>AES mode selection.
0x0 = ECB;
0x1 = CBC;
Others, reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESKS</name>
              <description>AES Key Selection.
These regisgers are being used to select the AES key that stored in the 16x128 key ram of the SDP, or select the key from the OTP. Detail as following:
0x00: key from the 16x128, this is the key read address, valid for AES128; AES256 will use 128 bit from this address and 128 bit key from next address as 256 bit AES key.
0x01: key from the 16x128, this is the key read address, valid for AES128, not valid for AES286.
....
0x0E: key from the 16x128, this is the key read address, valid for AES128; AES256 will use 128 from this add and 128 from next add for the AES key.
0x0F: key from the 16x128, this is the key read address, valid for AES128, not valid for AES286.
0x20: kman_sk0[127:0] from the key manager for AES128; AES256 will use kman_sk0[255:0] as AES key.
0x21: kman_sk0[255:128] from the key manager for AES128; not valid for AES256.
0x22: kman_sk1[127:0] from the key manager for AES128; AES256 will use kman_sk1[255:0] as AES key.
0x23: kman_sk1[255:128] from the key manager for AES128; not valid for AES256.
0x24: kman_sk2[127:0] from the key manager for AES128; AES256 will use kman_sk2[255:0] as AES key.
0x25: kman_sk2[255:128] from the key manager for AES128; not valid for AES256.
0x26: kman_sk3[127:0] from the key manager for AES128; AES256 will use kman_sk3[255:0] as AES key.
0x27: kman_sk3[255:128] from the key manager for AES128; not valid for AES256.
0x30: exip0_key[127:0] from OTP for AES128; AES256 will use exip0_key[255:0] as AES key.
0x31: exip0_key[255:128] from OTP for AES128; not valid for AES256.
0x32: exip1_key[127:0] from OTP for AES128; AES256 will use exip1_key[255:0] as AES key.
0x33: exip1_key[255:128] from OTP for AES128; not valid for AES256.
Other values, reserved.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESDIR</name>
              <description>AES direction
1x1, AES Decryption
1x0, AES Encryption.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASALG</name>
              <description>HASH Algorithem selection.
0x0 SHA1 —
0x1 CRC32 —
0x2 SHA256 —</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASCHK</name>
              <description>HASH Check Enable Bit.
1x1, HASH check need, hash result will compare with the HASHRSLT 0-7 registers;
1x0, HASH check is not enabled, HASHRSLT0-7 store the HASH result.
For SHA1, will use HASHRSLT0-3 words, and HASH 256 will use HASH0-7 words.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASOUT</name>
              <description>When hashing is enabled, this bit controls the input or output data of the AES engine is hashed.
0 INPUT HASH
1 OUTPUT HASH</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DINSWP</name>
              <description>Decide whether the SDP byteswaps the input data (big-endian data);
When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUTSWP</name>
              <description>Decide whether the SDP byteswaps the output data (big-endian data); When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEYSWP</name>
              <description>Decide whether the SDP byteswaps the Key (big-endian data).
When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTCNT</name>
          <description>packet counter registers.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTVAL</name>
              <description>This read-only field shows the current (instantaneous) value of the packet counter</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNTINCR</name>
              <description>The value written to this field is added to the spacket count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Registers</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>packet tag.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>interrupt Request, requested when error happen, or when packet processing done, packet counter reach to zero.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CHN1PKT0</name>
              <description>the chain buffer "chain" bit is "1", while packet counter is "0", now, waiting for new buffer data.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AESBSY</name>
              <description>AES Busy</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HASBSY</name>
              <description>Hashing Busy</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PKTCNT0</name>
              <description>Packet Counter registers reachs to ZERO now.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PKTDON</name>
              <description>Packet processing done, will trigger this itnerrrupt when the "PKTINT" bit set in the packet control word.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRSET</name>
              <description>Working mode setup error.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRPKT</name>
              <description>Packet head access error, or status update error.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRSRC</name>
              <description>Source Buffer Access Error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRDST</name>
              <description>Destination Buffer Error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRHAS</name>
              <description>Hashing Check Error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRCHAIN</name>
              <description>buffer chain error happen when packet's CHAIN bit=0, but the Packet counter is still not zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEYADDR</name>
          <description>Key Address</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INDEX</name>
              <description>To write a key to the SDP KEY RAM, the software must first write the desired key index/subword to this register.
Key index pointer. The valid indices are 0-[number_keys].
In the SDP, there is a 16x128 key ram can store 16 AES128 keys or 8 AES 256 Keys; this index is for addressing the 16 128-bit key addresses.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUBWRD</name>
              <description>Key subword pointer. The valid indices are 0-3. After each write to the key data register, this field
increments; To write a key, the software must first write the desired key index/subword to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEYDAT</name>
          <description>Key Data</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEYDAT</name>
              <description>This register provides the write access to the key/key subword specified by the key index register.
Writing this location updates the selected subword for the key located at the index
specified by the key index register. The write also triggers the SUBWORD field of the
KEY register to increment to the next higher word in the key</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>CIPHIV0,CIPHIV1,CIPHIV2,CIPHIV3</dimIndex>
          <name>CIPHIV[%s]</name>
          <description>no description available</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CIPHIV</name>
              <description>cipher initialization vector.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>HASWRD0,HASWRD1,HASWRD2,HASWRD3,HASWRD4,HASWRD5,HASWRD6,HASWRD7</dimIndex>
          <name>HASWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASWRD</name>
              <description>Hash Data Word x - HASH result bit; will store the expected hash result bit if hash check enabled; when hash check is not enabled,  the hash engine will store the final hash result[31:0] here.
If CRC mode enabled, this work store the CRC expected result if the check enabled, or store the final calcuated CRC result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDPTR</name>
          <description>Command Pointer</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMDPTR</name>
              <description>current command addresses the register points to the multiword
descriptor that is to be executed (or is currently being executed)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPKTPTR</name>
          <description>Next Packet Address Pointer</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NPKTPTR</name>
              <description>Next Packet Address Pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTCTL</name>
          <description>Packet Control Registers</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTTAG</name>
              <description>packet tag</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIPHIV</name>
              <description>Load Initial Vector for the AES in this packet.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASFNL</name>
              <description>Hash Termination packet</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASINI</name>
              <description>Hash Initialization packat</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAIN</name>
              <description>whether the next command pointer register must be loaded into the channel's current descriptor
pointer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRSEMA</name>
              <description>whether the channel's semaphore must be decremented at the end of the current operation.
When the semaphore reaches a value of zero, no more operations are issued from the channel.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PKTINT</name>
              <description>Reflects whether the channel must issue an interrupt upon the completion of the packet</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTSRC</name>
          <description>Packet Memory Source Address</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTSRC</name>
              <description>Packet Memory Source Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTDST</name>
          <description>Packet Memory Destination Address</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTDST</name>
              <description>Packet Memory Destination Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTBUF</name>
          <description>Packet buffer size.</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTBUF</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PSEC</name>
      <description>PSEC</description>
      <groupName>PSEC</groupName>
      <baseAddress>0xf3144000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECURE_STATE</name>
          <description>Secure state</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000300F0</resetMask>
          <fields>
            <field>
              <name>ALLOW_NSC</name>
              <description>Non-secure state allow
0: system is not healthy to enter non-secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter non-secure state</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALLOW_SEC</name>
              <description>Secure state allow
0: system is not healthy to enter secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter secure state</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_FAIL</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in fail state
1: secure state is in fail state</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_NSC</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in non-secure state
1: secure state is in non-secure state</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_SEC</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in secure state
1: secure state is in secure state</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_INS</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in inspect state
1: secure state is in inspect state</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_STATE_CONFIG</name>
          <description>secure state configuration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000009</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Lock bit of allow restart setting, once locked, lock bit itself and configuration register will keep value until next reset
0: not locked, register can be modified
1: register locked, write access to the register is ignored</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALLOW_RESTART</name>
              <description>allow secure state restart from fail state
0: restart is not allowed, only hardware reset can recover secure state
1: software is allowed to switch to inspect state from fail state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VIOLATION_CONFIG</name>
          <description>Security violation config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESCALATE_CONFIG</name>
          <description>Escalate behavior on security event</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVENT</name>
          <description>Event and escalate status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF000C</resetMask>
          <fields>
            <field>
              <name>EVENT</name>
              <description>local event statue, each bit represents one security event</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_ESC_NSC</name>
              <description>PMIC is escalating non-secure event</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_ESC_SEC</name>
              <description>PMIC is escalting secure event</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFECYCLE</name>
          <description>Lifecycle</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>LIFECYCLE</name>
              <description>lifecycle status,
bit7: lifecycle_debate,
bit6: lifecycle_scribe,
bit5: lifecycle_no_ret,
bit4: lifecycle_return,
bit3: lifecycle_secure,
bit2: lifecycle_nonsec,
bit1: lifecycle_create,
bit0: lifecycle_unknow</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMON</name>
      <description>PMON</description>
      <groupName>PMON</groupName>
      <baseAddress>0xf3148000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>glitch0,glitch1,clock0,clock1</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Glitch and clock monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000011</resetMask>
            <fields>
              <field>
                <name>ACTIVE</name>
                <description>select glitch works in active mode or passve mode.
0: passive mode, depends on power glitch destroy DFF value
1: active mode, check glitch by DFF chain</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable glitch detector
0: detector disabled
1: detector enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Glitch and clock monitor status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag for glitch detected, write 1 to clear this flag
0: glitch not detected
1: glitch detected</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>IRQ_FLAG</name>
          <description>No description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>interrupt flag, each bit represents for one monitor, write 1 to clear interrupt flag
0: no monitor interrupt
1: monitor interrupt happened</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ_ENABLE</name>
          <description>No description available</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>interrupt enable, each bit represents for one monitor
0: monitor interrupt disabled
1: monitor interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RNG</name>
      <description>RNG</description>
      <groupName>RNG</groupName>
      <baseAddress>0xf314c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CMD</name>
          <description>Command Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>Soft Reset, Perform a software reset of the RNG This bit is self-clearing.
0 Do not perform a software reset.
1 Software reset</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRERR</name>
              <description>Clear the Error, clear the errors in the ESR register and the RNG interrupt. This bit is self-clearing.
0 Do not clear the errors and the interrupt.
1 Clear the errors and the interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRINT</name>
              <description>Clear the Interrupt, clear the RNG interrupt if an error is not present. This bit is self-clearing.
0 Do not clear the interrupt.
1 Clear the interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GENSD</name>
              <description>Generate Seed, when both ST and GS triggered, ST first and GS next.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLFCHK</name>
              <description>Self Test, when both ST and GS triggered, ST first and GS next.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MIRQERR</name>
              <description>Mask Interrupt Request for Error</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIRQDN</name>
              <description>Mask Interrupt Request for Done Event, asks the interrupts generated upon the completion of the seed and self-test modes. The status of these jobs can be viewed by:
• Reading the STA and viewing the seed done and the self-test done bits (STA[SDN, STDN]).
• Viewing the RNG_CMD for the generate-seed or the self-test bits (CMD[GS,ST]) being set, indicating that the operation is still taking place.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTRSD</name>
              <description>Auto Reseed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FUFMOD</name>
              <description>FIFO underflow response mode
00 Return all zeros and set the ESR[FUFE].
01 Return all zeros and set the ESR[FUFE].
10 Generate the bus transfer error
11 Generate the interrupt and return all zeros (overrides the CTRL[MASKERR]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCPF</name>
              <description>Self Check Pass Fail</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FUNCERR</name>
              <description>Error was detected, check ESR register for details</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FSIZE</name>
              <description>Fifo Size, it is 5 in this design.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRNNU</name>
              <description>Fifo Level, Indicates the number of random words currently in the output FIFO</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NSDDN</name>
              <description>New seed done.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FSDDN</name>
              <description>1st Seed done
When "1", Indicates that the RNG generated the first seed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCDN</name>
              <description>Self Check Done
Indicates whether Self Test is done or not. Can be cleared by the hardware reset or a new self test is
initiated by setting the CMD[ST].
0 Self test not completed
1 Completed a self test since the last reset.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RSDREQ</name>
              <description>Reseed needed
Indicates that the RNG needs to be reseeded. This is done by setting the CMD[GS], or
automatically if the CTRL[ARS] is set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE</name>
              <description>Idle, the RNG is in the idle mode, and internal clocks are disabled, in this mode, access to the FIFO is allowed. Once the FIFO is empty, the RNGB fills the FIFO and then enters idle mode again.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>when 1, means the RNG engine is busy for seeding or random number generation, self test and so on.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERR</name>
          <description>Error Registers</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF3F</resetMask>
          <fields>
            <field>
              <name>FUFE</name>
              <description>FIFO access error(underflow)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCKERR</name>
              <description>Self-test error
Indicates that the RNG failed the most recent self test. This bit is sticky and can only be reset by a
hardware reset or by writing 1 to the CMD[CE]</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FO2B</name>
          <description>FIFO out to bus/cpu</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FO2B</name>
              <description>SW read the FIFO output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>FO2S0,FO2S1,FO2S2,FO2S3,FO2S4,FO2S5,FO2S6,FO2S7</dimIndex>
          <name>R2SK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FO2S0</name>
              <description>FIFO out to KMAN, will be SDP engine key.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>KEYM</name>
      <description>KEYM</description>
      <groupName>KEYM</groupName>
      <baseAddress>0xf3154000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x50</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SFK0,SFK1,SFK2,SFK3,SFK4,SFK5,SFK6,SFK7</dimIndex>
          <name>SOFTMKEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>software symmetric key
key will be scambled to 4 variants for software to use, and replicable on same chip.
scramble keys are chip different, and not replicable on different chip
must be write sequencely from 0 - 7, otherwise key value will be treated as all 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SPK0,SPK1,SPK2,SPK3,SPK4,SPK5,SPK6,SPK7</dimIndex>
          <name>SOFTPKEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>software asymmetric key
key is derived from scrambles of fuse private key, software input key, SRK, and system security status.
This key os read once, sencondary read will read out 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEC_KEY_CTL</name>
          <description>secure key generation</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80011117</resetMask>
          <fields>
            <field>
              <name>LOCK_SEC_CTL</name>
              <description>block secure state key setting being changed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SK_VAL</name>
              <description>session key valid
0: session key is all 0's and not usable
1: session key is valid</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SMK_SEL</name>
              <description>software symmetric key selection
0: use origin value in software symmetric key
1: use scramble version of software symmetric key</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMK_SEL</name>
              <description>batt symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FMK_SEL</name>
              <description>fuse symmetric key selection
0: use scramble version of fuse symmetric key
1: use alnertave scramble of fuse symmetric key</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_SEL</name>
              <description>secure symmtric key synthesize setting, key is a XOR of following
bit0: fuse mk, 0: not selected, 1:selected
bit1: zmk from batt, 0: not selected, 1:selected
bit2: software key 0: not selected, 1:selected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NSC_KEY_CTL</name>
          <description>non-secure key generation</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80011117</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC_CTL</name>
              <description>block non-secure state key setting being changed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SK_VAL</name>
              <description>session key valid
0: session key is all 0's and not usable
1: session key is valid</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SMK_SEL</name>
              <description>software symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMK_SEL</name>
              <description>batt symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FMK_SEL</name>
              <description>fuse symmetric key selection
0: use scramble version of fuse symmetric key
1: use origin value in fuse symmetric key</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_SEL</name>
              <description>non-secure symmtric key synthesize setting, key is a XOR of following
bit0: fuse mk, 0: not selected, 1:selected
bit1: zmk from batt, 0: not selected, 1:selected
bit2: software key 0: not selected, 1:selected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RNG</name>
          <description>Random number interface behavior</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>BLOCK_RNG_XOR</name>
              <description>block RNG_XOR bit from changing, if this bit is written to 1, it will hold 1 until next reset
0: RNG_XOR can be changed by software
1: RNG_XOR ignore software change from software</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RNG_XOR</name>
              <description>control how SFK is accepted from random number generator
0: SFK value replaced by random number input
1: SFK value exclusive or with random number input,this help generate random number using 2 rings inside RNG</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>READ_CONTROL</name>
          <description>key read out control</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>BLOCK_PK_READ</name>
              <description>asymmetric key readout control, if this bit is written to 1, it will hold 1 until next reset
0: key can be read out
1: key cannot be read out</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK_SMK_READ</name>
              <description>symmetric key readout control, if this bit is written to 1, it will hold 1 until next reset
0: key can be read out
1: key cannot be read out</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>OTP</name>
      <description>OTP</description>
      <groupName>OTP</groupName>
      <baseAddress>0xf3158000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xc08</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>128</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SHADOW000,SHADOW001,SHADOW002,SHADOW003,SHADOW004,SHADOW005,SHADOW006,SHADOW007,SHADOW008,SHADOW009,SHADOW010,SHADOW011,SHADOW012,SHADOW013,SHADOW014,SHADOW015,SHADOW016,SHADOW017,SHADOW018,SHADOW019,SHADOW020,SHADOW021,SHADOW022,SHADOW023,SHADOW024,SHADOW025,SHADOW026,SHADOW027,SHADOW028,SHADOW029,SHADOW030,SHADOW031,SHADOW032,SHADOW033,SHADOW034,SHADOW035,SHADOW036,SHADOW037,SHADOW038,SHADOW039,SHADOW040,SHADOW041,SHADOW042,SHADOW043,SHADOW044,SHADOW045,SHADOW046,SHADOW047,SHADOW048,SHADOW049,SHADOW050,SHADOW051,SHADOW052,SHADOW053,SHADOW054,SHADOW055,SHADOW056,SHADOW057,SHADOW058,SHADOW059,SHADOW060,SHADOW061,SHADOW062,SHADOW063,SHADOW064,SHADOW065,SHADOW066,SHADOW067,SHADOW068,SHADOW069,SHADOW070,SHADOW071,SHADOW072,SHADOW073,SHADOW074,SHADOW075,SHADOW076,SHADOW077,SHADOW078,SHADOW079,SHADOW080,SHADOW081,SHADOW082,SHADOW083,SHADOW084,SHADOW085,SHADOW086,SHADOW087,SHADOW088,SHADOW089,SHADOW090,SHADOW091,SHADOW092,SHADOW093,SHADOW094,SHADOW095,SHADOW096,SHADOW097,SHADOW098,SHADOW099,SHADOW100,SHADOW101,SHADOW102,SHADOW103,SHADOW104,SHADOW105,SHADOW106,SHADOW107,SHADOW108,SHADOW109,SHADOW110,SHADOW111,SHADOW112,SHADOW113,SHADOW114,SHADOW115,SHADOW116,SHADOW117,SHADOW118,SHADOW119,SHADOW120,SHADOW121,SHADOW122,SHADOW123,SHADOW124,SHADOW125,SHADOW126,SHADOW127</dimIndex>
          <name>SHADOW[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW</name>
              <description>shadow register of fuse for pmic area
for PMIC, index valid for 0-15, for SOC index valid for 16-128</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOCK00,LOCK01,LOCK02,LOCK03,LOCK04,LOCK05,LOCK06,LOCK07</dimIndex>
          <name>SHADOW_LOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock for pmic part shadow registers, 2 bits per 32 bit word, lock behavior is different between different fuse types
00: not locked
01: soft locked
10: not locked, and cannot lock in furture
11: double locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>128</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>FUSE000,FUSE001,FUSE002,FUSE003,FUSE004,FUSE005,FUSE006,FUSE007,FUSE008,FUSE009,FUSE010,FUSE011,FUSE012,FUSE013,FUSE014,FUSE015,FUSE016,FUSE017,FUSE018,FUSE019,FUSE020,FUSE021,FUSE022,FUSE023,FUSE024,FUSE025,FUSE026,FUSE027,FUSE028,FUSE029,FUSE030,FUSE031,FUSE032,FUSE033,FUSE034,FUSE035,FUSE036,FUSE037,FUSE038,FUSE039,FUSE040,FUSE041,FUSE042,FUSE043,FUSE044,FUSE045,FUSE046,FUSE047,FUSE048,FUSE049,FUSE050,FUSE051,FUSE052,FUSE053,FUSE054,FUSE055,FUSE056,FUSE057,FUSE058,FUSE059,FUSE060,FUSE061,FUSE062,FUSE063,FUSE064,FUSE065,FUSE066,FUSE067,FUSE068,FUSE069,FUSE070,FUSE071,FUSE072,FUSE073,FUSE074,FUSE075,FUSE076,FUSE077,FUSE078,FUSE079,FUSE080,FUSE081,FUSE082,FUSE083,FUSE084,FUSE085,FUSE086,FUSE087,FUSE088,FUSE089,FUSE090,FUSE091,FUSE092,FUSE093,FUSE094,FUSE095,FUSE096,FUSE097,FUSE098,FUSE099,FUSE100,FUSE101,FUSE102,FUSE103,FUSE104,FUSE105,FUSE106,FUSE107,FUSE108,FUSE109,FUSE110,FUSE111,FUSE112,FUSE113,FUSE114,FUSE115,FUSE116,FUSE117,FUSE118,FUSE119,FUSE120,FUSE121,FUSE122,FUSE123,FUSE124,FUSE125,FUSE126,FUSE127</dimIndex>
          <name>FUSE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUSE</name>
              <description>fuse array, valid in PMIC part only
read operation will read out value in fuse array
write operation will update fuse array value(please make sure fuse is unlocked and  2.5V power is ready)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOCK00,LOCK01,LOCK02,LOCK03,LOCK04,LOCK05,LOCK06,LOCK07</dimIndex>
          <name>FUSE_LOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock for fuse array, 2 bits per 32 bit word, lock behavior is different between different fuse types
00: not locked
01: soft locked
10: not locked, and cannot lock in furture
11: double locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLOCK</name>
          <description>UNLOCK</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>unlock word for fuse array operation
write "OPEN" to unlock fuse array, write any other value will lock write to fuse.
Please make sure 24M crystal is running and 2.5V LDO working properly</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <description>DATA</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data register for non-blocking access
this register hold dat read from fuse array or data to by programmed to fuse array</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDR</name>
          <description>ADDR</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>word address to be read or write</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>CMD</description>
          <addressOffset>0x80c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>command to access fure array
"BLOW" will update fuse word at ADDR to value hold in DATA
"READ" will fetch fuse value in at ADDR to DATA register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD_REQ</name>
          <description>LOAD Request</description>
          <addressOffset>0xa00</addressOffset>
          <size>32</size>
          <resetValue>0x00000007</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>REQUEST</name>
              <description>reload request for 4 regions
bit0: region0
bit1: region1
bit2: region2
bit3: region3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD_COMP</name>
          <description>LOAD complete</description>
          <addressOffset>0xa04</addressOffset>
          <size>32</size>
          <resetValue>0x00000007</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>COMPLETE</name>
              <description>reload complete sign for 4 regions
bit0: region 0
bit1: region1
bit2: region2
bit3: region3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOAD_REGION0,LOAD_REGION1,LOAD_REGION2,LOAD_REGION3</dimIndex>
          <name>REGION[%s]</name>
          <description>no description available</description>
          <addressOffset>0xa20</addressOffset>
          <size>32</size>
          <resetValue>0x00000800</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>STOP</name>
              <description>stop address of load region, fuse word at end address will NOT be reloaded
region0: fixed at 8
region1: fixed at 16
region2: fixed at 0,
region3: usrer configurable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>start address of load region,  fuse word at start address will be reloaded
region0: fixed at 0
region1: fixed at 8
region2: fixed at 16,
region3: usrer configurable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_FLAG</name>
          <description>interrupt flag</description>
          <addressOffset>0xc00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>WRITE</name>
              <description>fuse write flag, write 1 to clear
0: fuse is not written or writing
1: value in DATA register is programmed into fuse</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ</name>
              <description>fuse read flag, write 1 to clear
0: fuse is not read or reading
1: fuse value is put in DATA register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOAD</name>
              <description>fuse load flag, write 1 to clear
0: fuse is not loaded or loading
1: fuse loaded</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>interrupt enable</description>
          <addressOffset>0xc04</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>WRITE</name>
              <description>fuse write interrupt enable
0: fuse write interrupt is not enable
1: fuse write interrupt is enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ</name>
              <description>fuse read interrupt enable
0: fuse read interrupt is not enable
1: fuse read interrupt is enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOAD</name>
              <description>fuse load interrupt enable
0: fuse load interrupt is not enable
1: fuse load interrupt is enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYSCTL</name>
      <description>SYSCTL</description>
      <groupName>SYSCTL</groupName>
      <baseAddress>0xf4000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>228</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>cpu0,cpx0,rsv2,rsv3,rsv4,rsv5,rsv6,rsv7,cpu1,cpx1,rsv10,rsv11,rsv12,rsv13,rsv14,rsv15,rsv16,rsv17,rsv18,rsv19,rsv20,pow_cpu0,pow_cpu1,pow_otn,rst_soc,rst_cpu0,rst_cpu1,rst_otn,rsv28,rsv29,rsv30,rsv31,clk_src_xtal,clk_src_pll0,clk_src_clk0_pll0,clk_src_clk1_pll0,clk_src_pll1,clk_src_clk0_pll1,clk_src_clk1_pll1,clk_src_clk2_pll1,clk_src_pll2,clk_src_clk0_pll2,clk_src_clk1_pll2,clk_src_pll0_ref,clk_src_pll1_ref,clk_src_pll2_ref,rsv46,rsv47,rsv48,rsv49,rsv50,rsv51,rsv52,rsv53,rsv54,rsv55,rsv56,rsv57,rsv58,rsv59,rsv60,rsv61,rsv62,rsv63,clk_top_cpu0,clk_top_mct0,clk_top_cpu1,clk_top_mct1,clk_top_ahb0,clk_top_axif,clk_top_axis,clk_top_axic,clk_top_axin,clk_top_tmr0,clk_top_tmr1,clk_top_tmr2,clk_top_tmr3,clk_top_tmr4,clk_top_tmr5,clk_top_tmr6,clk_top_tmr7,clk_top_i2c0,clk_top_i2c1,clk_top_i2c2,clk_top_i2c3,clk_top_i2c4,clk_top_i2c5,clk_top_i2c6,clk_top_i2c7,clk_top_spi0,clk_top_spi1,clk_top_spi2,clk_top_spi3,clk_top_spi4,clk_top_spi5,clk_top_spi6,clk_top_spi7,clk_top_urt0,clk_top_urt1,clk_top_urt2,clk_top_urt3,clk_top_urt4,clk_top_urt5,clk_top_urt6,clk_top_urt7,clk_top_urt8,clk_top_urt9,clk_top_urt10,clk_top_urt11,clk_top_urt12,clk_top_urt13,clk_top_urt14,clk_top_urt15,clk_top_ana0,clk_top_ana1,clk_top_ana2,clk_top_ana3,clk_top_aud0,clk_top_aud1,clk_top_can0,clk_top_can1,clk_top_can2,clk_top_can3,clk_top_can4,clk_top_can5,clk_top_can6,clk_top_can7,clk_top_xpi0,clk_top_femc,clk_top_eth0,clk_top_ptp0,clk_top_ref0,clk_top_ref1,clk_top_ntm0,clk_top_tsw1,clk_top_tsw2,clk_top_tsw3,clk_top_adc0,clk_top_adc1,clk_top_adc2,clk_top_adc3,clk_top_i2s0,clk_top_i2s1,rsv143,rsv144,rsv145,rsv146,rsv147,rsv148,rsv149,rsv150,rsv151,rsv152,rsv153,rsv154,rsv155,rsv156,rsv157,rsv158,rsv159,rsv160,rsv161,rsv162,rsv163,rsv164,rsv165,rsv166,rsv167,rsv168,rsv169,rsv170,rsv171,rsv172,rsv173,rsv174,rsv175,rsv176,rsv177,rsv178,rsv179,rsv180,rsv181,rsv182,rsv183,rsv184,rsv185,rsv186,rsv187,rsv188,rsv189,rsv190,rsv191,rsv192,rsv193,rsv194,rsv195,rsv196,rsv197,rsv198,rsv199,rsv200,rsv201,rsv202,rsv203,rsv204,rsv205,rsv206,rsv207,rsv208,rsv209,rsv210,rsv211,rsv212,rsv213,rsv214,rsv215,rsv216,rsv217,rsv218,rsv219,rsv220,rsv221,rsv222,rsv223,rsv224,rsv225,rsv226,rsv227,rsv228,rsv229,rsv230,rsv231,rsv232,rsv233,rsv234,rsv235,rsv236,rsv237,rsv238,rsv239,rsv240,rsv241,rsv242,rsv243,rsv244,rsv245,rsv246,rsv247,rsv248,rsv249,rsv250,rsv251,rsv252,rsv253,rsv254,rsv255,ahbp,axis,axic,axin,rom0,lmm0,mct0,lmm1,mct1,tmr0,tmr1,tmr2,tmr3,tmr4,tmr5,tmr6,tmr7,i2c0,i2c1,i2c2,i2c3,i2c4,i2c5,i2c6,i2c7,spi0,spi1,spi2,spi3,spi4,spi5,spi6,spi7,urt0,urt1,urt2,urt3,urt4,urt5,urt6,urt7,urt8,urt9,urt10,urt11,urt12,urt13,urt14,urt15,crc0,tsns,wdg0,wdg1,wdg2,wdg3,mbx0,mbx1,gpio,ppi0,hdma,lobs,adc0,adc1,adc2,adc3,cmp0,cmp1,cmp2,cmp3,i2s0,i2s1,pdm0,clsd,can0,can1,can2,can3,can4,can5,can6,can7,ptpc,qei0,qei1,qei2,qei3,qeo0,qeo1,qeo2,qeo3,pwm0,pwm1,pwm2,pwm3,rdc0,rdc1,sdm0,sdm1,plb0,sei0,mtg0,mtg1,vsc0,vsc1,clc0,clc1,emds,rng0,sdp0,pka0,kman,xpi0,femc,ram0,ram1,xdma,ffa0,eth0,usb0,ntm0,ref0,ref1,tsw0,esc0</dimIndex>
          <name>RESOURCE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0000003</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any nodes
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: no change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODE</name>
              <description>resource work mode
0:auto turn on and off as system required(recommended)
1:always on
2:always off
3:reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>link0,link1,link2,link3</dimIndex>
          <name>GROUP0[%s]</name>
          <description>no description available</description>
          <addressOffset>0x800</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Group setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: peripheral is not needed
1: periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Group setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: add periphera into this group，periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Group setting</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: delete periphera in this group，periphera is not needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Group setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: toggle the result that whether periphera is needed before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>link0,link1,link2,link3</dimIndex>
          <name>GROUP1[%s]</name>
          <description>no description available</description>
          <addressOffset>0x840</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Group setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: peripheral is not needed
1: periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Group setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: add periphera into this group，periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Group setting</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: delete periphera in this group，periphera is not needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Group setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: toggle the result that whether periphera is needed before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>cpu0,cpu1</dimIndex>
          <name>AFFILIATE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x900</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
bit0: cpu0 depends on group0
bit1: cpu0 depends on group1
bit2: cpu0 depends on group2
bit3: cpu0 depends on group3</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0，each bit represents a group
0: no effect
1: the group is assigned to CPU0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
0: no effect
1: the group is not assigned to CPU0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Affiliate of Group</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
0: no effect
1: toggle the result that whether the group is assigned to CPU0 before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>cpu0,cpu1</dimIndex>
          <name>RETENTION[%s]</name>
          <description>no description available</description>
          <addressOffset>0x920</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Retention Contol</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007FFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
bit00: soc_mem is kept on while cpu0 stop
bit01: soc_ctx is kept on while cpu0 stop
bit02: cpu0_mem is kept on while cpu0 stop
bit03: cpu0_ctx is kept on while cpu0 stop
bit04: cpu1_mem is kept on while cpu0 stop
bit05: cpu1_ctx is kept on while cpu0 stop
bit06: otn_mem is kept on while cpu0 stop
bit07: otn_ctx is kept on while cpu0 stop
bit08: xtal_hold is kept on while cpu0 stop
bit09: pll0_hold is kept on while cpu0 stop
bit10: pll1_hold is kept on while cpu0 stop
bit11: pll2_hold is kept on while cpu0 stop</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Retention Contol</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007FFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: keep</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Retention Contol</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007FFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: no keep</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Retention Contol</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007FFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: toggle the result that whether the resource is kept on while CPU0 stop before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>cpu0,cpu1,otn</dimIndex>
          <name>POWER[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <register>
            <name>status</name>
            <description>Power Setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xC0001100</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag represents power cycle happened from last clear of this bit
0: power domain did not edurance power cycle since last clear of this bit
1: power domain enduranced power cycle since last clear of this bit</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLAG_WAKE</name>
                <description>flag represents wakeup power cycle happened from last clear of this bit
0: power domain did not edurance wakeup power cycle since last clear of this bit
1: power domain enduranced wakeup power cycle since last clear of this bit</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LF_DISABLE</name>
                <description>low fanout power switch disable
0: low fanout power switches are turned on
1: low fanout power switches are truned off</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LF_ACK</name>
                <description>low fanout power switch feedback
0: low fanout power switches are turned on
1: low fanout power switches are truned off</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>lf_wait</name>
            <description>Power Setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x000000FF</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>WAIT</name>
                <description>wait time for low fan out power switch turn on, default value is 255
0: 0 clock cycle
1: 1 clock cycles
. . .
clock cycles count on 24MHz</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>off_wait</name>
            <description>Power Setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x0000000F</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>WAIT</name>
                <description>wait time for power switch turn off, default value is 15
0: 0 clock cycle
1: 1 clock cycles
. . .
clock cycles count on 24MHz</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>soc,cpu0,cpu1,otn</dimIndex>
          <name>RESET[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1400</addressOffset>
          <register>
            <name>control</name>
            <description>Reset Setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xC0000011</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag represents reset happened from last clear of this bit
0: domain did not edurance reset cycle since last clear of this bit
1:  domain enduranced reset cycle since last clear of this bit</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLAG_WAKE</name>
                <description>flag represents wakeup reset happened from last clear of this bit
0: domain did not edurance wakeup reset cycle since last clear of this bit
1:  domain enduranced wakeup reset cycle since last clear of this bit</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HOLD</name>
                <description>perform reset and hold in reset, until ths bit cleared by software
0: reset is released for function
1: reset is assert and hold</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET</name>
                <description>perform reset and release imediately
0: reset is released
1 reset is asserted and will release automaticly</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>config</name>
            <description>Reset Setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00402003</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>PRE_WAIT</name>
                <description>wait cycle numbers before assert reset
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RSTCLK_NUM</name>
                <description>reset clock number(must be even number)
0: 0 cycle
1: 0 cycles
2: 2 cycles
3: 2 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POST_WAIT</name>
                <description>time guard band for  reset release
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>counter</name>
            <description>Reset Setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>self clear trigger counter, reset triggered when counter value is 1, write 0 will cancel reset
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>73</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_cpu0,clk_top_mct0,clk_top_cpu1,clk_top_mct1,clk_top_ahb0,clk_top_axif,clk_top_axis,clk_top_axic,clk_top_axin,clk_top_tmr0,clk_top_tmr1,clk_top_tmr2,clk_top_tmr3,clk_top_tmr4,clk_top_tmr5,clk_top_tmr6,clk_top_tmr7,clk_top_i2c0,clk_top_i2c1,clk_top_i2c2,clk_top_i2c3,clk_top_i2c4,clk_top_i2c5,clk_top_i2c6,clk_top_i2c7,clk_top_spi0,clk_top_spi1,clk_top_spi2,clk_top_spi3,clk_top_spi4,clk_top_spi5,clk_top_spi6,clk_top_spi7,clk_top_urt0,clk_top_urt1,clk_top_urt2,clk_top_urt3,clk_top_urt4,clk_top_urt5,clk_top_urt6,clk_top_urt7,clk_top_urt8,clk_top_urt9,clk_top_urt10,clk_top_urt11,clk_top_urt12,clk_top_urt13,clk_top_urt14,clk_top_urt15,clk_top_ana0,clk_top_ana1,clk_top_ana2,clk_top_ana3,clk_top_aud0,clk_top_aud1,clk_top_can0,clk_top_can1,clk_top_can2,clk_top_can3,clk_top_can4,clk_top_can5,clk_top_can6,clk_top_can7,clk_top_xpi0,clk_top_femc,clk_top_eth0,clk_top_ptp0,clk_top_ntm0,clk_top_ref0,clk_top_ref1,clk_top_tsw1,clk_top_tsw2,clk_top_tsw3</dimIndex>
          <name>CLOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD00007FF</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux in clock component
0:osc0_clk0
1:pll0_clk0
2:pll0_clk1
3:pll1_clk0
4:pll1_clk1
5:pll1_clk2
6:pll2_clk0
7:pll2_clk1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV</name>
              <description>clock divider
0: divider by 1
1: divider by 2
2: divider by 3
. . .
255: divider by 256</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_adc0,clk_top_adc1,clk_top_adc2,clk_top_adc3</dimIndex>
          <name>ADCCLK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD0000100</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux
0: ana clock N
1: ahb0 clock</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_i2s0,clk_top_i2s1</dimIndex>
          <name>I2SCLK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD0000100</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux
0: aud clock N
1: aud clock 0 for others , aud clock 1 for i2s0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>global00</name>
          <description>Clock senario</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>MUX</name>
              <description>global clock override request
bit0: override to preset0
bit1: override to preset1
bit2: override to preset2
bit3: override to preset3
bit4: override to preset4
bit5: override to preset5
bit6: override to preset6
bit7: override to preset7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>slice0,slice1,slice2,slice3</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2400</addressOffset>
          <register>
            <name>control</name>
            <description>Clock measure and monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x89FFD7FF</resetMask>
            <fields>
              <field>
                <name>VALID</name>
                <description>result is ready for read
0: not ready
1: result is ready</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV_BUSY</name>
                <description>divider is applying new setting</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OUTEN</name>
                <description>enable clock output</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV</name>
                <description>output divider</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HIGH</name>
                <description>clock frequency higher than upper limit</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOW</name>
                <description>clock frequency lower than lower limit</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>START</name>
                <description>start measurement</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>work mode,
0: register value will be compared to measurement
1: upper and lower value will be recordered in register</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACCURACY</name>
                <description>measurement accuracy,
0: resolution is 1kHz
1: resolution is 1Hz</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REFERENCE</name>
                <description>refrence clock selection,
0: 32k
1: 24M</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SELECTION</name>
                <description>clock measurement selection</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>current</name>
            <description>Clock measure result</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>self updating measure result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>low_limit</name>
            <description>Clock lower limit</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>lower frequency</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>high_limit</name>
            <description>Clock upper limit</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>upper frequency</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x400</dimIncrement>
          <dimIndex>cpu0,cpu1</dimIndex>
          <name>CPU[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2800</addressOffset>
          <register>
            <name>LP</name>
            <description>CPU0 LP control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00001000</resetValue>
            <resetMask>0xFF013703</resetMask>
            <fields>
              <field>
                <name>WAKE_CNT</name>
                <description>CPU0 wake up counter, counter satuated at 255, write 0x00 to clear</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HALT</name>
                <description>halt request for CPU0,
0: CPU0 will start to execute after reset or receive wakeup request
1: CPU0 will not start after reset, or wakeup after WFI</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WAKE</name>
                <description>CPU0 is waking up
0: CPU0 wake up not asserted
1: CPU0 wake up asserted</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXEC</name>
                <description>CPU0 is executing
0: CPU0 is not executing
1: CPU0 is executing</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WAKE_FLAG</name>
                <description>CPU0 wakeup flag, indicate a wakeup event got active, write 1 to clear this bit
0: CPU0 wakeup not happened
1: CPU0 wake up happened</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEEP_FLAG</name>
                <description>CPU0 sleep flag, indicate a sleep event got active, write 1 to clear this bit
0: CPU0 sleep not happened
1: CPU0 sleep happened</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_FLAG</name>
                <description>CPU0 reset flag, indicate a reset event got active, write 1 to clear this bit
0: CPU0 reset not happened
1: CPU0 reset happened</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Low power mode, system behavior after WFI
00: CPU clock stop after WFI
01: System enter low power mode after WFI
10: Keep running after WFI
11: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>CPU0 Lock GPR</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFE</resetMask>
            <fields>
              <field>
                <name>GPR</name>
                <description>Lock bit for CPU_DATA0 to CPU_DATA13, once set, this bit will not clear untile next reset</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock bit for CPU_LOCK</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>14</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>GPR0,GPR1,GPR2,GPR3,GPR4,GPR5,GPR6,GPR7,GPR8,GPR9,GPR10,GPR11,GPR12,GPR13</dimIndex>
            <name>GPR[%s]</name>
            <description>no description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPR</name>
                <description>register for software to handle resume, can save resume address or status</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>6</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>STATUS0,STATUS1,STATUS2,STATUS3,STATUS4,STATUS5</dimIndex>
            <name>WAKEUP_STATUS[%s]</name>
            <description>no description available</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STATUS</name>
                <description>IRQ values</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>6</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>ENABLE0,ENABLE1,ENABLE2,ENABLE3,ENABLE4,ENABLE5</dimIndex>
            <name>WAKEUP_ENABLE[%s]</name>
            <description>no description available</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>IRQ wakeup enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>IOC</name>
      <description>IOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf4040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xf40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>488</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>pa00,pa01,pa02,pa03,pa04,pa05,pa06,pa07,pa08,pa09,pa10,pa11,pa12,pa13,pa14,pa15,pa16,pa17,pa18,pa19,pa20,pa21,pa22,pa23,pa24,pa25,pa26,pa27,pa28,pa29,pa30,pa31,pb00,pb01,pb02,pb03,pb04,pb05,pb06,pb07,pb08,pb09,pb10,pb11,pb12,pb13,pb14,pb15,pb16,pb17,pb18,pb19,pb20,pb21,pb22,pb23,pb24,pb25,pb26,pb27,pb28,pb29,pb30,pb31,pc00,pc01,pc02,pc03,pc04,pc05,pc06,pc07,pc08,pc09,pc10,pc11,pc12,pc13,pc14,pc15,pc16,pc17,pc18,pc19,pc20,pc21,pc22,pc23,pc24,pc25,pc26,pc27,pc28,pc29,pc30,pc31,pd00,pd01,pd02,pd03,pd04,pd05,pd06,pd07,pd08,pd09,pd10,pd11,pd12,pd13,pd14,pd15,pd16,pd17,pd18,pd19,pd20,pd21,pd22,pd23,pd24,pd25,pd26,pd27,pd28,pd29,pd30,pd31,pe00,pe01,pe02,pe03,pe04,pe05,pe06,pe07,pe08,pe09,pe10,pe11,pe12,pe13,pe14,pe15,pe16,pe17,pe18,pe19,pe20,pe21,pe22,pe23,pe24,pe25,pe26,pe27,pe28,pe29,pe30,pe31,pf00,pf01,pf02,pf03,pf04,pf05,pf06,pf07,pf08,pf09,pf10,pf11,pf12,pf13,pf14,pf15,pf16,pf17,pf18,pf19,pf20,pf21,pf22,pf23,pf24,pf25,pf26,pf27,pf28,pf29,pf30,pf31,rsv192,rsv193,rsv194,rsv195,rsv196,rsv197,rsv198,rsv199,rsv200,rsv201,rsv202,rsv203,rsv204,rsv205,rsv206,rsv207,rsv208,rsv209,rsv210,rsv211,rsv212,rsv213,rsv214,rsv215,rsv216,rsv217,rsv218,rsv219,rsv220,rsv221,rsv222,rsv223,rsv224,rsv225,rsv226,rsv227,rsv228,rsv229,rsv230,rsv231,rsv232,rsv233,rsv234,rsv235,rsv236,rsv237,rsv238,rsv239,rsv240,rsv241,rsv242,rsv243,rsv244,rsv245,rsv246,rsv247,rsv248,rsv249,rsv250,rsv251,rsv252,rsv253,rsv254,rsv255,rsv256,rsv257,rsv258,rsv259,rsv260,rsv261,rsv262,rsv263,rsv264,rsv265,rsv266,rsv267,rsv268,rsv269,rsv270,rsv271,rsv272,rsv273,rsv274,rsv275,rsv276,rsv277,rsv278,rsv279,rsv280,rsv281,rsv282,rsv283,rsv284,rsv285,rsv286,rsv287,rsv288,rsv289,rsv290,rsv291,rsv292,rsv293,rsv294,rsv295,rsv296,rsv297,rsv298,rsv299,rsv300,rsv301,rsv302,rsv303,rsv304,rsv305,rsv306,rsv307,rsv308,rsv309,rsv310,rsv311,rsv312,rsv313,rsv314,rsv315,rsv316,rsv317,rsv318,rsv319,rsv320,rsv321,rsv322,rsv323,rsv324,rsv325,rsv326,rsv327,rsv328,rsv329,rsv330,rsv331,rsv332,rsv333,rsv334,rsv335,rsv336,rsv337,rsv338,rsv339,rsv340,rsv341,rsv342,rsv343,rsv344,rsv345,rsv346,rsv347,rsv348,rsv349,rsv350,rsv351,pv00,pv01,pv02,pv03,pv04,pv05,pv06,pv07,pv08,pv09,pv10,pv11,pv12,pv13,pv14,pv15,rsv368,rsv369,rsv370,rsv371,rsv372,rsv373,rsv374,rsv375,rsv376,rsv377,rsv378,rsv379,rsv380,rsv381,rsv382,rsv383,pw00,pw01,pw02,pw03,pw04,pw05,pw06,pw07,pw08,pw09,pw10,pw11,pw12,pw13,pw14,pw15,pw16,pw17,pw18,pw19,pw20,pw21,pw22,pw23,rsv408,rsv409,rsv410,rsv411,rsv412,rsv413,rsv414,rsv415,px00,px01,px02,px03,px04,px05,px06,px07,rsv424,rsv425,rsv426,rsv427,rsv428,rsv429,rsv430,rsv431,rsv432,rsv433,rsv434,rsv435,rsv436,rsv437,rsv438,rsv439,rsv440,rsv441,rsv442,rsv443,rsv444,rsv445,rsv446,rsv447,py00,py01,py02,py03,py04,py05,py06,py07,rsv456,rsv457,rsv458,rsv459,rsv460,rsv461,rsv462,rsv463,rsv464,rsv465,rsv466,rsv467,rsv468,rsv469,rsv470,rsv471,rsv472,rsv473,rsv474,rsv475,rsv476,rsv477,rsv478,rsv479,pz00,pz01,pz02,pz03,pz04,pz05,pz06,pz07</dimIndex>
          <name>PAD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>FUNC_CTL</name>
            <description>ALT SELECT</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0001011F</resetMask>
            <fields>
              <field>
                <name>LOOP_BACK</name>
                <description>force input on
0: disable
1: enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ANALOG</name>
                <description>select analog pin in pad
0: disable
1: enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ALT_SELECT</name>
                <description>alt select
0: ALT0
1: ALT1
...
31:ALT31</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PAD_CTL</name>
            <description>PAD SETTINGS</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x01010056</resetValue>
            <resetMask>0x01370177</resetMask>
            <fields>
              <field>
                <name>HYS</name>
                <description>schmitt trigger enable
0: disable
1: enable</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRS</name>
                <description>select pull up/down internal resistance strength:
For pull down, only have 100 Kohm resistance
For pull up:
00: 100 KOhm
01: 47 KOhm
10: 22 KOhm
11: 22 KOhm</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PS</name>
                <description>pull select
0: pull down
1: pull up</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PE</name>
                <description>pull enable
0: pull disable
1: pull enable</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>KE</name>
                <description>keeper capability enable
0: keeper disable
1: keeper enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD</name>
                <description>open drain
0: open drain disable
1: open drain enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SR</name>
                <description>slew rate
0: Slow slew rate
1: Fast slew rate</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPD</name>
                <description>additional 2-bit slew rate to select IO cell operation frequency range with reduced switching noise
00: Slow frequency slew rate(50Mhz)
01: Medium frequency slew rate(100 Mhz)
10: Fast frequency slew rate(150 Mhz)
11: Max frequency slew rate(200Mhz)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DS</name>
                <description>drive strength
1.8V Mode:
000: 260 Ohm
001: 260 Ohm
010: 130 Ohm
011: 88 Ohm
100: 65 Ohm
101: 52 Ohm
110: 43 Ohm
111: 37 Ohm
3.3V Mode:
000: 157 Ohm
001: 157 Ohm
010: 78 Ohm
011: 53 Ohm
100: 39 Ohm
101: 32 Ohm
110: 26 Ohm
111: 23 Ohm</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="IOC">
      <name>PIOC</name>
      <description>PIOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf4118000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="IOC">
      <name>BIOC</name>
      <description>BIOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf4210000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PLLCTLV2</name>
      <description>PLLCTLV2</description>
      <groupName>PLLCTLV2</groupName>
      <baseAddress>0xf40c0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x200</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>XTAL</name>
          <description>OSC configuration</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0xB00FFFFF</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Busy flag
0: Oscillator is working or shutdown
1: Oscillator is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESPONSE</name>
              <description>Crystal oscillator status
0: Oscillator is not stable
1: Oscillator is stable for use</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Crystal oscillator enable status
0: Oscillator is off
1: Oscillator is on</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RAMP_TIME</name>
              <description>Rampup time of XTAL oscillator in cycles of RC24M clock
0: 0 cycle
1: 1 cycle
2: 2 cycle
1048575: 1048575 cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>pll0,pll1,pll2</dimIndex>
          <name>PLL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x80</addressOffset>
          <register>
            <name>MFI</name>
            <description>PLL0 multiple register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000010</resetValue>
            <resetMask>0xB000007F</resetMask>
            <fields>
              <field>
                <name>BUSY</name>
                <description>Busy flag
0: PLL is stable or shutdown
1: PLL is changing status</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>PLL status
0: PLL is not stable
1: PLL is stable for use</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>PLL enable status
0: PLL is off
1: PLL is on</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MFI</name>
                <description>loop back divider of PLL, support from 13 to 42, f=fref*(mfi + mfn/mfd)
0-15: invalid
16: divide by 16
17: divide by17
. . .
42: divide by 42
43~:invalid</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MFN</name>
            <description>PLL0 fraction numerator register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x09896800</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>MFN</name>
                <description>Numeratorof fractional part,f=fref*(mfi + mfn/mfd). This field supports changing while running.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MFD</name>
            <description>PLL0 fraction demoninator register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x0E4E1C00</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>MFD</name>
                <description>Demoninator of fraction part,f=fref*(mfi + mfn/mfd).  This field should not be changed during PLL enabled.  If changed, change will take efftect when PLL re-enabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SS_STEP</name>
            <description>PLL0 spread spectrum step register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>STEP</name>
                <description>Step of spread spectrum modulator.
This register should not be changed during PLL and spread spectrum enabled.  If changed, new value will take effect when PLL disabled or spread spectrum disabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SS_STOP</name>
            <description>PLL0 spread spectrum stop register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>STOP</name>
                <description>Stop point of spread spectrum modulator
This register should not be changed during PLL and spread spectrum enabled.  If changed, new value will take effect when PLL disabled or spread spectrum disabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>PLL0 confguration register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000101</resetMask>
            <fields>
              <field>
                <name>SPREAD</name>
                <description>Enable spread spectrum function.  This field supports changing during PLL running.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REFSEL</name>
                <description>Select reference clock, This filed support changing while running, but application must take frequency error and jitter into consideration.  And if MFN changed before reference switch, application need make sure time is enough for MFN updating.
0: XTAL24M
1: IRC24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCKTIME</name>
            <description>PLL0 lock time register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x000009C4</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>LOCKTIME</name>
                <description>Lock time of PLL in 24M clock cycles, typical value is 2500.  If MFI changed during PLL startup, PLL lock time may be longer than this setting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STEPTIME</name>
            <description>PLL0 step time register</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x000009C4</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>STEPTIME</name>
                <description>Step time for MFI on-the-fly change in 24M clock cycles, typical value is 2500.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADVANCED</name>
            <description>PLL0 advance configuration register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x11000000</resetMask>
            <fields>
              <field>
                <name>SLOW</name>
                <description>Use slow lock flow, PLL lock expendite is disabled.  This mode might be stabler. And software need config LOCKTIME field accordingly.
0: fast lock enabled, lock time is 100us
1: fast lock disabled, lock time is 400us</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DITHER</name>
                <description>Enable dither function</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>3</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>DIV0,DIV1,DIV2</dimIndex>
            <name>DIV[%s]</name>
            <description>no description available</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xB000003F</resetMask>
            <fields>
              <field>
                <name>BUSY</name>
                <description>Busy flag
0: divider is working
1: divider is changing status</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>Divider response status
0: Divider is not stable
1: Divider is stable for use</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Divider enable status
0: Divider is off
1: Divider is on</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIV</name>
                <description>Divider factor, divider factor is DIV/5 + 1
0: divide by 1
1: divide by 1.2
2: divide by 1.4
. . .
63: divide by 13.6</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PPOR</name>
      <description>PPOR</description>
      <groupName>PPOR</groupName>
      <baseAddress>0xf4100000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RESET_FLAG</name>
          <description>flag indicate reset source</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>reset reason of last hard reset, write 1 to clear each bit
0: brownout
1: temperature
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_STATUS</name>
          <description>reset source status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>current status of reset sources
0: brownout
1: temperature
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_HOLD</name>
          <description>reset hold attribute</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HOLD</name>
              <description>hold arrtibute, when set, SOC keep in reset status until reset source release, or, reset will be released after SOC enter reset status
0: brownout
1: temperature
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_ENABLE</name>
          <description>reset source enable</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>enable of reset sources
0: brownout
1: temperature
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_TYPE</name>
          <description>reset type triggered by reset</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TYPE</name>
              <description>reset type of reset sources, 0 for cold reset, all system control setting cleared except debug/fuse/ioc; 1 for hot reset, keep system control setting and debug/fuse/ioc setting,  only clear some subsystem
0: brownout
1: temperature
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SOFTWARE_RESET</name>
          <description>Software reset counter</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>counter decrease in 24MHz and stop at 0, trigger reset when value reach 2, software can write 0 to cancel reset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PCFG</name>
      <description>PCFG</description>
      <groupName>PCFG</groupName>
      <baseAddress>0xf4104000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x70</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BANDGAP</name>
          <description>BANGGAP control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00101010</resetValue>
          <resetMask>0x801F1F1F</resetMask>
          <fields>
            <field>
              <name>VBG_TRIMMED</name>
              <description>Bandgap trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: bandgap is not trimmed
1: bandgap is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_1P0_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P65_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P50_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDO1P1</name>
          <description>1V LDO config</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0000044C</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>VOLT</name>
              <description>LDO output voltage in mV,  value valid through 700-1320, , step 20mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1320mV.
700: 700mV
720: 720mV
. . .
1320:1320mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDO2P5</name>
          <description>2.5V LDO config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x000009C4</resetValue>
          <resetMask>0x10010FFF</resetMask>
          <fields>
            <field>
              <name>READY</name>
              <description>Ready flag, will set 1ms after enabled or voltage change
0: LDO is not ready for use
1: LDO is ready</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>LDO enable
0: turn off LDO
1: turn on LDO</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VOLT</name>
              <description>LDO output voltage in mV,  value valid through 2125-2900, step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 2900mV.
2125: 2125mV
2150: 2150mV
. . .
2900:2900mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_MODE</name>
          <description>DCDC mode select</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0001047E</resetValue>
          <resetMask>0x10070FFF</resetMask>
          <fields>
            <field>
              <name>READY</name>
              <description>Ready flag
0: DCDC is applying new change
1: DCDC is ready</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODE</name>
              <description>DCDC work mode
XX0: trun off
001: basic mode
011: generic mode
101: automatic mode
111: expert mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VOLT</name>
              <description>DCDC voltage in mV in normal mode,  value valid through 600-1375, , step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1375mV.
600: 600mV
625: 625mV
. . .
1375:1375mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_LPMODE</name>
          <description>DCDC low power mode</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000384</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>STBY_VOLT</name>
              <description>DCDC voltage in mV in standby mode,  ,  value valid through 600-1375, , step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1375mV.
600: 600mV
625: 625mV
. . .
1375:1375mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_PROT</name>
          <description>DCDC protection</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x11018191</resetMask>
          <fields>
            <field>
              <name>ILIMIT_LP</name>
              <description>over current setting for low power mode
0:250mA
1:200mA</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLOAD_LP</name>
              <description>over current in low power mode
0: current is below setting
1: overcurrent happened in low power mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>POWER_LOSS_FLAG</name>
              <description>power loss
0: input power is good
1: input power is too low</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_OVERVOLTAGE</name>
              <description>ouput over voltage protection
0: protection enabled, DCDC will shut down is output voltage is unexpected high
1: protection disabled, DCDC continue to adjust output voltage</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERVOLT_FLAG</name>
              <description>output over voltage flag
0: output is normal
1: output is unexpected high</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_SHORT</name>
              <description>disable output short circuit protection
0: short circuits protection enabled, DCDC shut down if short circuit on ouput detected
1: short circuit protection disabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHORT_CURRENT</name>
              <description>short circuit current setting
0: 2.0A,
1: 1.3A</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHORT_FLAG</name>
              <description>short circuit flag
0: current is within limit
1: short circuits detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_CURRENT</name>
          <description>DCDC current estimation</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000811F</resetMask>
          <fields>
            <field>
              <name>ESTI_EN</name>
              <description>enable current measure</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Current level valid
0: data is invalid
1: data is valid</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEVEL</name>
              <description>DCDC current level, current level is num * 50mA</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_ADVMODE</name>
          <description>DCDC advance setting</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x03120040</resetValue>
          <resetMask>0x073F007F</resetMask>
          <fields>
            <field>
              <name>EN_RCSCALE</name>
              <description>Enable RC scale</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_C</name>
              <description>Loop C number</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_R</name>
              <description>Loop R number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_FF_DET</name>
              <description>enable feed forward detect
0: feed forward detect is disabled
1: feed forward detect is enabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_FF_LOOP</name>
              <description>enable feed forward loop
0: feed forward loop is disabled
1: feed forward loop is enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_AUTOLP</name>
              <description>enable auto enter low power mode
0: do not enter low power mode
1: enter low power mode if current is detected low</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DCM_EXIT</name>
              <description>avoid over voltage
0: stay in DCM mode when voltage excess
1: change to CCM mode when voltage excess</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_SKIP</name>
              <description>enable skip on narrow pulse
0: do not skip narrow pulse
1: skip narrow pulse</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_IDLE</name>
              <description>enable skip when voltage is higher than threshold
0: do not skip
1: skip if voltage is excess</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DCM</name>
              <description>DCM mode
0: CCM mode
1: DCM mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_ADVPARAM</name>
          <description>DCDC advance parameter</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00006E1C</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>MIN_DUT</name>
              <description>minimum duty cycle</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_DUT</name>
              <description>maximum duty cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_MISC</name>
          <description>DCDC misc parameter</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00070100</resetValue>
          <resetMask>0x13170317</resetMask>
          <fields>
            <field>
              <name>EN_HYST</name>
              <description>hysteres enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_SIGN</name>
              <description>hysteres sign</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_THRS</name>
              <description>hysteres threshold</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RC_SCALE</name>
              <description>Loop RC scale threshold</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_FF</name>
              <description>Loop feed forward number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OL_THRE</name>
              <description>overload for threshold for lod power mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OL_HYST</name>
              <description>current hysteres range
0: 12.5mV
1: 25mV</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY</name>
              <description>enable delay
0: delay disabled,
1: delay enabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>clock selection
0: select DCDC internal oscillator
1: select RC24M oscillator</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_STEP</name>
              <description>enable stepping in voltage change
0: stepping disabled,
1: steping enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_DEBUG</name>
          <description>DCDC Debug</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00005DBF</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>UPDATE_TIME</name>
              <description>DCDC voltage change time in 24M clock cycles, default value is 1mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_START_TIME</name>
          <description>DCDC ramp time</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0001193F</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>START_TIME</name>
              <description>Start delay for DCDC to turn on, in 24M clock cycles, default value is 3mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_RESUME_TIME</name>
          <description>DCDC resume time</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00008C9F</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>RESUME_TIME</name>
              <description>Resume delay for DCDC to recover from low power mode, in 24M clock cycles, default value is 1.5mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POWER_TRAP</name>
          <description>SOC power trap</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80010001</resetMask>
          <fields>
            <field>
              <name>TRIGGERED</name>
              <description>Low power trap status, thit bit will set when power related low power flow triggered, write 1 to clear this flag.
0: low power trap is not triggered
1: low power trap triggered</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RETENTION</name>
              <description>DCDC enter standby mode, which will reduce voltage for memory content retention
0: Shutdown DCDC
1: reduce DCDC voltage</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRAP</name>
              <description>Enable trap of SOC power supply, trap is used to hold SOC in low power mode for DCDC to enter further low power mode, this bit will self-clear when power related low pwer flow triggered
0: trap not enabled, pmic side low power function disabled
1: trap enabled, STOP operation leads to PMIC low power flow if SOC is not retentioned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKE_CAUSE</name>
          <description>Wake up source</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAUSE</name>
              <description>wake up cause, each bit represents one wake up source, write 1 to clear the register bit
0: wake up source is not active during last wakeup
1: wake up source is active furing last wakeup
bit 0: pmic_enable
bit 7: UART interrupt
bit 8: TMR interrupt
bit 9: WDG interrupt
bit10: GPIO in PMIC interrupt
bit16: batt security interrupt
bit17:batt gpio interrupt
bit19:rtc interrupt
bit31: pin wakeup</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKE_MASK</name>
          <description>Wake up mask</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>mask for wake up sources, each bit represents one wakeup source
0: allow source to wake up system
1: disallow source to wakeup system
bit 0: pmic_enable
bit 7: UART interrupt
bit 8: TMR interrupt
bit 9: WDG interrupt
bit10: GPIO in PMIC interrupt
bit16: batt security interrupt
bit17:batt gpio interrupt
bit19:rtc interrupt
bit31: pin wakeup</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCG_CTRL</name>
          <description>Clock gate control in PMIC</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCG</name>
              <description>control whether clock being gated during PMIC low power flow, 2 bits for each peripheral
00,01: reserved
10: clock is always off
11: clock is always on
bit6-7:gpio
bit8-9:ioc
bit10-11: timer
bit12-13:wdog
bit14-15:uart</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RC24M</name>
          <description>RC 24M config</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000310</resetValue>
          <resetMask>0x8000071F</resetMask>
          <fields>
            <field>
              <name>RC_TRIMMED</name>
              <description>RC24M trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: RC is not trimmed
1: RC is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_C</name>
              <description>Coarse trim for RC24M, bigger value means faster</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_F</name>
              <description>Fine trim for RC24M, bigger value means faster</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RC24M_TRACK</name>
          <description>RC 24M track mode</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010011</resetMask>
          <fields>
            <field>
              <name>SEL24M</name>
              <description>Select track reference
0: select 32K as reference
1: select 24M XTAL as reference</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RETURN</name>
              <description>Retrun default value when XTAL loss
0: remain last tracking value
1: switch to default value</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRACK</name>
              <description>track mode
0: RC24M free running
1: track RC24M to external XTAL</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRACK_TARGET</name>
          <description>RC 24M track target</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRE_DIV</name>
              <description>Divider for reference source</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TARGET</name>
              <description>Target frequency multiplier of divided source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>RC 24M track status</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0011871F</resetMask>
          <fields>
            <field>
              <name>SEL32K</name>
              <description>track is using XTAL32K
0: track is not using XTAL32K
1: track is using XTAL32K</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEL24M</name>
              <description>track is using XTAL24M
0: track is not using XTAL24M
1: track is using XTAL24M</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EN_TRIM</name>
              <description>default value takes effect
0: default value is invalid
1: default value is valid</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIM_C</name>
              <description>default coarse trim value</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIM_F</name>
              <description>default fine trim value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDGO</name>
      <description>PDGO</description>
      <groupName>PDGO</groupName>
      <baseAddress>0xf4134000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x714</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DGO_TURNOFF</name>
          <description>trunoff control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>trunoff counter, counter stops when it counts down to 0, the trunoff occurs when the counter value is 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_RC32K_CFG</name>
          <description>RC32K CLOCK</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80C001FF</resetMask>
          <fields>
            <field>
              <name>IRC_TRIMMED</name>
              <description>IRC32K trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: irc is not trimmed
1: irc is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEX7_TRIM</name>
              <description>IRC32K bit 7</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEX6_TRIM</name>
              <description>IRC32K bit 6</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_TRIM</name>
              <description>capacitor trim bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_GPR00</name>
          <description>Generic control 0</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_GPR01</name>
          <description>Generic control 1</description>
          <addressOffset>0x604</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_GPR02</name>
          <description>Generic control 2</description>
          <addressOffset>0x608</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_GPR03</name>
          <description>Generic control 3</description>
          <addressOffset>0x60c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_CTR0</name>
          <description>control register 0</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010000</resetMask>
          <fields>
            <field>
              <name>RETENTION</name>
              <description>dgo register status retenion</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_CTR1</name>
          <description>control register 1</description>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80010001</resetMask>
          <fields>
            <field>
              <name>AOTO_SYS_WAKEUP</name>
              <description>software wakeup： 0 : wakeup once； 1：auto wakeup Continuously</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_EN</name>
              <description>permit wakeup pin or software wakeup</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIN_WAKEUP_STATUS</name>
              <description>wakeup pin status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_CTR2</name>
          <description>control register 2</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01010000</resetMask>
          <fields>
            <field>
              <name>RESETN_PULLUP_DISABLE</name>
              <description>resetn pin pull up disable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_PULLDN_DISABLE</name>
              <description>wakeup pin pull down disable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_CTR3</name>
          <description>control register 3</description>
          <addressOffset>0x70c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_COUNTER</name>
              <description>software wakeup counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGO_CTR4</name>
          <description>control register 4</description>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>BANDGAP_LESS_POWER</name>
              <description>Banggap work in power save mode, banggap function normally
0: banggap works in high performance mode
1: banggap works in power saving mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BANDGAP_LP_MODE</name>
              <description>Banggap work in low power mode, banggap function limited
0: banggap works in normal mode
1: banggap works in low power mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PGPR0</name>
      <description>PGPR0</description>
      <groupName>PGPR</groupName>
      <baseAddress>0xf4138000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PMIC_GPR00</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR01</name>
          <description>Generic control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR02</name>
          <description>Generic control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR03</name>
          <description>Generic control</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR04</name>
          <description>Generic control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR05</name>
          <description>Generic control</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR06</name>
          <description>Generic control</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR07</name>
          <description>Generic control</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR08</name>
          <description>Generic control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR09</name>
          <description>Generic control</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR10</name>
          <description>Generic control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR11</name>
          <description>Generic control</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR12</name>
          <description>Generic control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR13</name>
          <description>Generic control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR14</name>
          <description>Generic control</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR15</name>
          <description>Generic control</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="PGPR0">
      <name>PGPR1</name>
      <description>PGPR1</description>
      <groupName>PGPR</groupName>
      <baseAddress>0xf413c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>BACC</name>
      <description>BACC</description>
      <groupName>BACC</groupName>
      <baseAddress>0xf4200000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Access timing for access</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3000FFFF</resetMask>
          <fields>
            <field>
              <name>FAST_WRITE</name>
              <description>Use fast write
0: Write normally
1: boost write</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_READ</name>
              <description>Use fast read
0: Read normally
1: boost read</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMING</name>
              <description>Time in APB clock cycles, for battery timing penerate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRE_TIME</name>
          <description>Timing gap before rising edge</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>PRE_RATIO</name>
              <description>Ratio of guard band before rising edge
0: 0
1: 1/32768 of low level width
2: 1/16384 of low level width
14: 1/4 of low level width
15: 1/2 of low level width</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRE_OFFSET</name>
              <description>guard band before rising edge
this value will be added to ratio number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POST_TIME</name>
          <description>Timing gap after rising edge</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>POST_RATIO</name>
              <description>Ratio of guard band after rising edge
0: 0
1: 1/32768 of high level width
2: 1/16384 of high level width
14: 1/4 of high level width
15: 1/2 of high level width</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POST_OFFSET</name>
              <description>guard band after rising edge
this value will be added to ratio number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BPOR</name>
      <description>BPOR</description>
      <groupName>BPOR</groupName>
      <baseAddress>0xf4204000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>POR_CONFIG</name>
          <description>Power on reset config</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RETENTION</name>
              <description>retention battery domain setting
0: battery reset on reset pin reset happen
1: battery domain retention when reset pin reset happen</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BCFG</name>
      <description>BCFG</description>
      <groupName>BCFG</groupName>
      <baseAddress>0xf4208000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>VBG_CFG</name>
          <description>Bandgap config</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x811F1F1F</resetMask>
          <fields>
            <field>
              <name>VBG_TRIMMED</name>
              <description>Bandgap trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: bandgap is not trimmed
1: bandgap is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_SAVE</name>
              <description>Bandgap works in power save mode
0: not in power save mode
1: bandgap work in power save mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_1P0</name>
              <description>Bandgap 1.0V output trim</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P65</name>
              <description>Bandgap 0.65V output trim</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P50</name>
              <description>Bandgap 0.50V output trim</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRC32K_CFG</name>
          <description>On-chip 32k oscillator config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80C001FF</resetMask>
          <fields>
            <field>
              <name>IRC_TRIMMED</name>
              <description>IRC32K trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: irc is not trimmed
1: irc is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEX7_TRIM</name>
              <description>IRC32K bit 7</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEX6_TRIM</name>
              <description>IRC32K bit 6</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_TRIM</name>
              <description>capacitor trim bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XTAL32K_CFG</name>
          <description>XTAL 32K config</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001313</resetMask>
          <fields>
            <field>
              <name>HYST_EN</name>
              <description>crystal 32k hysteres enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GMSEL</name>
              <description>crystal 32k gm selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG</name>
              <description>crystal 32k config</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMP</name>
              <description>crystal 32k amplifier</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CFG</name>
          <description>Clock config</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x10010010</resetMask>
          <fields>
            <field>
              <name>XTAL_SEL</name>
              <description>crystal selected</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>KEEP_IRC</name>
              <description>force irc32k run</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_XTAL</name>
              <description>force switch to crystal</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BGPR0</name>
      <description>BGPR0</description>
      <groupName>BGPR</groupName>
      <baseAddress>0xf4218000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>GPR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="BGPR0">
      <name>BGPR1</name>
      <description>BGPR1</description>
      <groupName>BGPR</groupName>
      <baseAddress>0xf4220000</baseAddress>
    </peripheral>
    <peripheral>
      <name>BSEC</name>
      <description>BSEC</description>
      <groupName>BSEC</groupName>
      <baseAddress>0xf4240000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECURE_STATE</name>
          <description>Secure state</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003000F</resetMask>
          <fields>
            <field>
              <name>ALLOW_NSC</name>
              <description>Non-secure state allow
0: system is not healthy to enter non-secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter non-secure state</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALLOW_SEC</name>
              <description>Secure state allow
0: system is not healthy to enter secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter secure state</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_FAIL</name>
              <description>BATT secure state one hot indicator
0: secure state is not in fail state
1: secure state is in fail state</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_NSC</name>
              <description>BATT secure state one hot indicator
0: secure state is not in non-secure state
1: secure state is in non-secure state</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_SEC</name>
              <description>BATT secure state one hot indicator
0: secure state is not in secure state
1: secure state is in secure state</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_INS</name>
              <description>BATT secure state one hot indicator
0: secure state is not in inspect state
1: secure state is in inspect state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_STATE_CONFIG</name>
          <description>secure state configuration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000009</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Lock bit of allow restart setting, once locked, lock bit itself and configuration register will keep value until next reset
0: not locked, register can be modified
1: register locked, write access to the register is ignored</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALLOW_RESTART</name>
              <description>allow secure state restart from fail state
0: restart is not allowed, only hardware reset can recover secure state
1: software is allowed to switch to inspect state from fail state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VIOLATION_CONFIG</name>
          <description>Security violation config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESCALATE_CONFIG</name>
          <description>Escalate behavior on security event</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVENT</name>
          <description>Event and escalate status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>EVENT</name>
              <description>local event statue, each bit represents one security event</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_ESC_NSC</name>
              <description>BATT is escalating non-secure event</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_ESC_SEC</name>
              <description>BATT is escalting ssecure event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC</description>
      <groupName>RTC</groupName>
      <baseAddress>0xf4244000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECOND</name>
          <description>Second counter</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SECOND</name>
              <description>second counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SUBSEC</name>
          <description>Sub-second counter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBSEC</name>
              <description>sub second counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEC_SNAP</name>
          <description>Second counter snap shot</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC_SNAP</name>
              <description>second snap shot, write to take snap shot</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SUB_SNAP</name>
          <description>Sub-second counter snap shot</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUB_SNAP</name>
              <description>sub second snap shot, write to take snap shot</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM0</name>
          <description>RTC alarm0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALARM</name>
              <description>Alarm time for second counter, on each alarm match, alarm increase ALARM0_INC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM0_INC</name>
          <description>Alarm0 incremental</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCREASE</name>
              <description>adder when ARLAM0 happen, helps to create periodical alarm</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM1</name>
          <description>RTC alarm1</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALARM</name>
              <description>Alarm time for second counter, on each alarm match, alarm increase ALARM0_INC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM1_INC</name>
          <description>Alarm1 incremental</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCREASE</name>
              <description>adder when ARLAM0 happen, helps to create periodical alarm</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM_FLAG</name>
          <description>RTC alarm flag</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>alarm1 happen</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM0</name>
              <description>alarm0 happen</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM_EN</name>
          <description>RTC alarm enable</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>ENABLE1</name>
              <description>alarm1 mask
0: alarm1 disabled
1: alarm1 enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE0</name>
              <description>alarm0 mask
0: alarm0 disabled
1: alarm0 enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BKEY</name>
      <description>BKEY</description>
      <groupName>BKEY</groupName>
      <baseAddress>0xf4248000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>KEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
            <name>DATA[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>security key data</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>KEY0,KEY1</dimIndex>
          <name>ECC[%s]</name>
          <description>no description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>WLOCK</name>
              <description>write lock to key0
0: write enable
1: write ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLOCK</name>
              <description>read lock to key0
0: key read enable
1: key always read as 0</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC</name>
              <description>Parity check bits for key0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SELECT</name>
          <description>Key selection</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SELECT</name>
              <description>select key, key0 treated as secure key, in non-scure mode, only key1 can be selected
0: select key0 in secure mode, key1 in non-secure mode
1: select key1 in secure or nonsecure mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BMON</name>
      <description>BMON</description>
      <groupName>BMON</groupName>
      <baseAddress>0xf424c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>glitch0,clock0</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Glitch and clock monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000011</resetMask>
            <fields>
              <field>
                <name>ACTIVE</name>
                <description>select glitch works in active mode or passve mode.
0: passive mode, depends on power glitch destroy DFF value
1: active mode, check glitch by DFF chain</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable glitch detector
0: detector disabled
1: detector enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Glitch and clock monitor status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag for glitch detected, write 1 to clear this flag
0: glitch not detected
1: glitch detected</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TAMP</name>
      <description>TAMP</description>
      <groupName>TAMP</groupName>
      <baseAddress>0xf4250000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x88</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>tamp0,tamp1,tamp2,tamp3</dimIndex>
          <name>TAMP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Tamper n control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x801F03F7</resetMask>
            <fields>
              <field>
                <name>LOCK</name>
                <description>lock tamper setting
0: tamper setting can be changed
1: tamper setting will last to next battery domain power cycle</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS</name>
                <description>bypass tamper violation filter
0: filter applied
1: filter not used</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER</name>
                <description>filter length
0: 1 cycle
1: 2 cycle
15: 65526 cycle</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>VALUE</name>
                <description>pin value for passive tamper</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPEED</name>
                <description>tamper speed selection, (2^SPEED) changes per second
0: 1 shift per second
1: 2 shifts per second
. . .
15: 32768 shifts per second</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RECOVER</name>
                <description>tamper will recover itself if tamper LFSR goes wrong
0: tamper will not recover
1: tamper will recover</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE</name>
                <description>select active or passive tamper
0: passive tamper
1: active tamper</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable tamper
0: tamper disableed
1: tamper enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POLY</name>
            <description>Tamper n Polynomial of LFSR</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POLY</name>
                <description>tamper LFSR polyminal, this is a write once register, once write content is locked, and readout value is "1"</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LFSR</name>
            <description>Tamper n LFSR shift register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LFSR</name>
                <description>LFSR for active tamper, write only register, always read 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>TAMP_FLAG</name>
          <description>Tamper flag</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>tamper flag, each bit represents one tamper pin, write 1 to clear the flag
Note, clear can only be cleared when tamper disappeared</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ_EN</name>
          <description>Tamper interrupt enable</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000FFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock bit for IRQ enable
0: enable bits can be changed
1: enable bits hold until next battery domain power cycle</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ_EN</name>
              <description>interrupt enable, each bit represents one tamper pin
0: interrupt disabled
1: interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MONO</name>
      <description>MONO</description>
      <groupName>MONO</groupName>
      <baseAddress>0xf4254000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MONOL</name>
          <description>Low part of monotonic counter</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>low part of monotonica counter, write to this counter will cause counter increase by 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONOH</name>
          <description>High part of monotonic counter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPOCH</name>
              <description>Fuse value for high part of monotonica</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER</name>
              <description>high part of monotonica counter, write to this counter will cause counter increase by 1 if low part overflow</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
