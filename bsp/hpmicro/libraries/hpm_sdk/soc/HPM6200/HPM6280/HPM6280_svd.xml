<?xml version="1.0" encoding="UTF-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>HPMICRO</vendor>
  <name>HPM6280</name>
  <series>HPM6200</series>
  <version>1.0</version>
  <description>HPM6200 device</description>
  <licenseText>
    /*
 * Copyright (c) 2021-2024 HPMicro
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

  </licenseText>
  <cpu>
    <name>other</name>
    <revision>r0p0</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>7</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>

  <!-- Default Properties -->
  <addressUnitBits>8</addressUnitBits> <!-- byte addressable memory -->
  <width>32</width> <!-- bus width is 32 bits -->
  <size>32</size>          <!-- this is the default size (number of bits) of all peripherals and register that do not define "size" themselves -->
  <access>read-write</access>  <!-- default access permission for all subsequent registers -->
  <resetValue>0x0</resetValue>  <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>  <!-- by default all 32Bits of the registers are used -->

  <!-- peripherals -->
  <peripherals>
    <peripheral>
      <name>FGPIO</name>
      <description>FGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xc0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>DI[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO input value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INPUT</name>
                <description>GPIO input bus value, each bit represents a bus bit
0: low level presents on chip pin
1: high level presents on chip pin</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>DO[%s]</name>
          <description>no description available</description>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO output value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO output set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO output clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO output toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>OE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO direction value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO direction set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO direction clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO direction toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>IF[%s]</name>
          <description>no description available</description>
          <addressOffset>0x300</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt flag value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_FLAG</name>
                <description>GPIO interrupt flag, write 1 to clear this flag
0: no irq
1: irq pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>IE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt enable value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt enable set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt enable clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt enable toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>PL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x500</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt polarity value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt polarity set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt polarity clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt polarity toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>TP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt type value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt type set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt type clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt type toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>AS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x700</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt asynchronous value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt asynchronous set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt asynchronous clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt asynchronous toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>GPIO0</name>
      <description>GPIO0</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf0000000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>GPIO1</name>
      <description>GPIO1</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf0004000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>PGPIO</name>
      <description>PGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf40dc000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>BGPIO</name>
      <description>BGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf5014000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PLIC</name>
      <description>PLIC</description>
      <groupName>PLIC</groupName>
      <baseAddress>0xe4000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x202000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>feature</name>
          <description>Feature enable register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>VECTORED</name>
              <description>Vector mode enable
0: Disabled
1: Enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPT</name>
              <description>Preemptive priority interrupt enable
0: Disabled
1: Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>127</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PRIORITY1,PRIORITY2,PRIORITY3,PRIORITY4,PRIORITY5,PRIORITY6,PRIORITY7,PRIORITY8,PRIORITY9,PRIORITY10,PRIORITY11,PRIORITY12,PRIORITY13,PRIORITY14,PRIORITY15,PRIORITY16,PRIORITY17,PRIORITY18,PRIORITY19,PRIORITY20,PRIORITY21,PRIORITY22,PRIORITY23,PRIORITY24,PRIORITY25,PRIORITY26,PRIORITY27,PRIORITY28,PRIORITY29,PRIORITY30,PRIORITY31,PRIORITY32,PRIORITY33,PRIORITY34,PRIORITY35,PRIORITY36,PRIORITY37,PRIORITY38,PRIORITY39,PRIORITY40,PRIORITY41,PRIORITY42,PRIORITY43,PRIORITY44,PRIORITY45,PRIORITY46,PRIORITY47,PRIORITY48,PRIORITY49,PRIORITY50,PRIORITY51,PRIORITY52,PRIORITY53,PRIORITY54,PRIORITY55,PRIORITY56,PRIORITY57,PRIORITY58,PRIORITY59,PRIORITY60,PRIORITY61,PRIORITY62,PRIORITY63,PRIORITY64,PRIORITY65,PRIORITY66,PRIORITY67,PRIORITY68,PRIORITY69,PRIORITY70,PRIORITY71,PRIORITY72,PRIORITY73,PRIORITY74,PRIORITY75,PRIORITY76,PRIORITY77,PRIORITY78,PRIORITY79,PRIORITY80,PRIORITY81,PRIORITY82,PRIORITY83,PRIORITY84,PRIORITY85,PRIORITY86,PRIORITY87,PRIORITY88,PRIORITY89,PRIORITY90,PRIORITY91,PRIORITY92,PRIORITY93,PRIORITY94,PRIORITY95,PRIORITY96,PRIORITY97,PRIORITY98,PRIORITY99,PRIORITY100,PRIORITY101,PRIORITY102,PRIORITY103,PRIORITY104,PRIORITY105,PRIORITY106,PRIORITY107,PRIORITY108,PRIORITY109,PRIORITY110,PRIORITY111,PRIORITY112,PRIORITY113,PRIORITY114,PRIORITY115,PRIORITY116,PRIORITY117,PRIORITY118,PRIORITY119,PRIORITY120,PRIORITY121,PRIORITY122,PRIORITY123,PRIORITY124,PRIORITY125,PRIORITY126,PRIORITY127</dimIndex>
          <name>PRIORITY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIORITY</name>
              <description>Interrupt source priority. The valid range of this field is 0-7.
0: Never interrupt
1-7: Interrupt source priority. The larger the value, the higher the priority.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PENDING0,PENDING1,PENDING2,PENDING3</dimIndex>
          <name>PENDING[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>The interrupt pending status of inpterrupt sources. Every interrupt source occupies 1 bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TRIGGER0,TRIGGER1,TRIGGER2,TRIGGER3</dimIndex>
          <name>TRIGGER[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>The interrupt trigger type of interrupt sources. Every interrupt source occupies 1 bit.
0: Level-triggered interrupt
1: Edge-triggered interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NUMBER</name>
          <description>Number of supported interrupt sources and targets</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_TARGET</name>
              <description>The number of supported targets</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_INTERRUPT</name>
              <description>The number of supported interrupt sources</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INFO</name>
          <description>Version and the maximum priority</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_PRIORITY</name>
              <description>The maximum priority supported</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION</name>
              <description>The version of the PLIC design</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>target0,target1</dimIndex>
          <name>TARGETINT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2000</addressOffset>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>INTEN0,INTEN1,INTEN2,INTEN3</dimIndex>
            <name>INTEN[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INTERRUPT</name>
                <description>The interrupt enable bit for interrupt. Every interrupt source occupies 1 bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x1000</dimIncrement>
          <dimIndex>target0,target1</dimIndex>
          <name>TARGETCONFIG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200000</addressOffset>
          <register>
            <name>THRESHOLD</name>
            <description>Target0 priority threshold</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>THRESHOLD</name>
                <description>Interrupt priority threshold.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLAIM</name>
            <description>Target claim and complete</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>INTERRUPT_ID</name>
                <description>On reads, indicating the interrupt source that has being claimed. On writes, indicating the interrupt source that has been handled (completed).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PPS</name>
            <description>Preempted priority stack</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIORITY_PREEMPTED</name>
                <description>Each bit indicates if the corresponding priority level has been preempted by a higher-priority interrupt.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MCHTMR</name>
      <description>MCHTMR</description>
      <groupName>MCHTMR</groupName>
      <baseAddress>0xe6000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MTIME</name>
          <description>Machine Time</description>
          <addressOffset>0x0</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000020210</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTIME</name>
              <description>Machine time</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MTIMECMP</name>
          <description>Machine Time Compare</description>
          <addressOffset>0x8</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000020210</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTIMECMP</name>
              <description>Machine time compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PLICSW</name>
      <description>PLICSW</description>
      <groupName>PLICSW</groupName>
      <baseAddress>0xe6400000</baseAddress>
      <addressBlock>
        <offset>0x1000</offset>
        <size>0x1ff008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PENDING</name>
          <description>Pending status</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000002</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>writing 1 to trigger software interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTEN</name>
          <description>Interrupt enable</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>enable software interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLAIM</name>
          <description>Claim and complete.</description>
          <addressOffset>0x200004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_ID</name>
              <description>On reads, indicating the interrupt source that has being claimed. On writes, indicating the interrupt source that has been handled (completed).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOM</name>
      <description>GPIOM</description>
      <groupName>GPIOM</groupName>
      <baseAddress>0xf0008000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>ASSIGN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <dim>32</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>PIN00,PIN01,PIN02,PIN03,PIN04,PIN05,PIN06,PIN07,PIN08,PIN09,PIN10,PIN11,PIN12,PIN13,PIN14,PIN15,PIN16,PIN17,PIN18,PIN19,PIN20,PIN21,PIN22,PIN23,PIN24,PIN25,PIN26,PIN27,PIN28,PIN29,PIN30,PIN31</dimIndex>
            <name>PIN[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x80000F03</resetMask>
            <fields>
              <field>
                <name>LOCK</name>
                <description>lock fields in this register, lock can only be cleared by soc reset
0: fields can be changed
1: fields locked to current value, not changeable</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HIDE</name>
                <description>pin value visibility to gpios,
bit0: 1, invisible to soc gpio0; 0: visible to soc gpio0
bit1: 1, invisible to soc gpio1; 0: visible to soc gpio1
bit2: 1, invisible to cpu0 fast gpio; 0: visible to cpu0 fast gpio
bit3: 1, invisible to cpu1 fast gpio; 0: visible to cpu1 fast gpio</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SELECT</name>
                <description>select which gpio controls chip pin,
0: soc gpio0;
1: soc gpio1;
2: cpu0 fastgpio
3: cpu1 fast gpio</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC0</name>
      <description>ADC0</description>
      <groupName>ADC16</groupName>
      <baseAddress>0xf0010000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1464</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>12</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>trg0a,trg0b,trg0c,trg1a,trg1b,trg1c,trg2a,trg2b,trg2c,trg3a,trg3b,trg3c</dimIndex>
          <name>CONFIG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF3F3F7F</resetMask>
          <fields>
            <field>
              <name>TRIG_LEN</name>
              <description>length for current trigger, can up to 4 conversions for one trigger, from 0 to 3</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>INTEN3</name>
              <description>interrupt enable for 4th conversion</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN3</name>
              <description>channel number for 4th conversion</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN2</name>
              <description>interrupt enable for 3rd conversion</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN2</name>
              <description>channel number for 3rd conversion</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN1</name>
              <description>interrupt enable for 2nd conversion</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN1</name>
              <description>channel number for 2nd conversion</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE_EN</name>
              <description>preemption queue enable control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN0</name>
              <description>interrupt enable for 1st conversion</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN0</name>
              <description>channel number for 1st conversion</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trg_dma_addr</name>
          <description>No description available</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>TRG_DMA_ADDR</name>
              <description>buffer start address for trigger queue, 192byte total, 16 bytes for each trigger (4 bytes for each conversion)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trg_sw_sta</name>
          <description>No description available</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>TRG_SW_STA</name>
              <description>SW trigger start bit, HW will clear it after all conversions(up to 4) finished. SW should make sure it's 0 before set it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_INDEX</name>
              <description>which trigger for the SW trigger
0 for trig0a, 1 for trig0b…
3 for trig1a, …11 for trig3c</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>BUS_RESULT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>set after conversion finished if wait_dis is set, cleared after software read.
The first time read with 0 will trigger one new conversion.
If SW read other channel when one channel conversion is in progress, it will not trigger new conversion at other channel, and will get old result with valid 0, also with read_cflct interrupt status bit set.
the result may not realtime if software read once and wait  long time to read again</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT</name>
              <description>read this register will trigger one adc conversion.
If wait_dis bit is set, SW will get the latest conversion result(not current one) with valid bit is 0, SW need polling valid bit till it's set to get current result
If wait_dis bit is 0, SW can get the current conversion result with holding the bus, valid bit is always set at this mode. this is not recommended if channel sample time is too long</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>buf_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>WAIT_DIS</name>
              <description>set to disable read waiting, get result immediately but maybe not current conversion result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000F1F</resetMask>
          <fields>
            <field>
              <name>CYCLE</name>
              <description>current dma write cycle bit</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEQ_LEN</name>
              <description>sequence queue length, 0 for one, 0xF for 16</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESTART_EN</name>
              <description>if set together with cont_en, HW will continue process the whole queue after trigger once.
If cont_en is 0, this bit is not used</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONT_EN</name>
              <description>if set, HW will continue process the queue till end(seq_len) after trigger once</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_TRIG</name>
              <description>SW trigger, pulse signal, cleared by HW one cycle later</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SW_TRIG_EN</name>
              <description>set to enable SW trigger</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HW_TRIG_EN</name>
              <description>set to enable external HW trigger, only trigger on posedge</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_dma_addr</name>
          <description>No description available</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>TAR_ADDR</name>
              <description>dma target address, should be 4-byte aligned</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_dma_cfg</name>
          <description>No description available</description>
          <addressOffset>0x80c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF3FFF</resetMask>
          <fields>
            <field>
              <name>STOP_POS</name>
              <description>if stop_en is set, SW is responsible to update this field to the next read point, HW should not write data to this point since it's not read out by SW yet</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RST</name>
              <description>set this bit will reset HW dma write pointer to seq_dma_addr, and set HW cycle bit to 1. dma is halted if this bit is set.
SW should clear all cycle bit in buffer to 0 before clear dma_rst</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_EN</name>
              <description>set to stop dma if reach the stop_pos</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_LEN</name>
              <description>dma buffer length, after write to (tar_addr[31:2]+buf_len)*4, the next dma address will be tar_addr[31:2]*4
0 for 4byte;
0xFFF for 16kbyte.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>cfg0,cfg1,cfg2,cfg3,cfg4,cfg5,cfg6,cfg7,cfg8,cfg9,cfg10,cfg11,cfg12,cfg13,cfg14,cfg15</dimIndex>
          <name>SEQ_QUE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SEQ_INT_EN</name>
              <description>interrupt enable for current conversion</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN_NUM_4_0</name>
              <description>channel number for current conversion</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>PRD_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0xc00</addressOffset>
          <register>
            <name>prd_cfg</name>
            <description>No description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00001FFF</resetMask>
            <fields>
              <field>
                <name>PRESCALE</name>
                <description>0: 1xclock, 1: 2x, 2: 4x, 3: 8x,…,15: 32768x,…,31: 2Gx</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRD</name>
                <description>conver period, with prescale.
Set to 0 means disable current channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>prd_thshd_cfg</name>
            <description>No description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>THSHDH</name>
                <description>threshold high, assert interrupt(if enabled) if result exceed high or low.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THSHDL</name>
                <description>threshold low</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>prd_result</name>
            <description>No description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CHAN_RESULT</name>
                <description>adc convert result, update after each valid conversion.
it may be updated period according to config, also may be updated due to other queue convert the same channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>SAMPLE_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_CLOCK_NUMBER_SHIFT</name>
              <description>shift for sample clock number</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_CLOCK_NUMBER</name>
              <description>sample clock number, base on clock_period, default one period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>conv_cfg1</name>
          <description>No description available</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>CONVERT_CLOCK_NUMBER</name>
              <description>convert clock numbers, set to 21 (0x15) for 16bit mode, which means convert need 21 adc clock cycles(based on clock after divider);
user can use small value to get faster conversion, but less accuracy, need to config cov_end_cnt at adc16_config1 also.
Ex: use 200MHz bus clock for adc, set sample_clock_number to 4, sample_clock_number_shift to 0, covert_clk_number to 21 for 16bit mode, clock_divder to 3, then each ADC conversion(plus sample) need 25 cycles(50MHz).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_DIVIDER</name>
              <description>clock_period, N half clock cycle per half adc cycle
0 for same adc_clk and bus_clk,
1 for 1:2,
2 for 1:3,
...
15 for 1:16
Note: set to 2 can genenerate 66.7MHz adc_clk at 200MHz bus_clk</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xA0000001</resetMask>
          <fields>
            <field>
              <name>SEL_SYNC_AHB</name>
              <description>set to 1 will enable sync AHB bus, to get better bus performance.
Adc_clk must to be set to same as bus clock at this mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_AHB_EN</name>
              <description>set to 1 to enable ADC DMA to write data to soc memory bus, for trig queue and seq queue;</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT3_REALTIME</name>
              <description>set to enable trg queue stop other queues</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_sts</name>
          <description>No description available</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE0FFFF</resetMask>
          <fields>
            <field>
              <name>TRIG_CMPT</name>
              <description>interrupt for one trigger conversion complete if enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_CFLCT</name>
              <description>read conflict interrupt, set if wait_dis is set, one conversion is in progress, SW read another channel</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_SW_CFLCT</name>
              <description>sequence queue conflict interrupt, set if HW or SW trigger received during conversion</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_DMAABT</name>
              <description>dma abort interrupt, set if seqence dma write pointer reachs sw read pointer if stop_en is set</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CMPT</name>
              <description>the whole sequence complete interrupt</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CVC</name>
              <description>one conversion complete in seq_queue if related seq_int_en is set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_FIFO_FULL</name>
              <description>DMA fifo full interrupt, user need to check clock frequency if it's set.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHB_ERR</name>
              <description>set if got hresp=1, generally caused by wrong trg_dma_addr or seq_dma_addr</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDOG</name>
              <description>set if one chanel watch dog event triggered</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_en</name>
          <description>No description available</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE0FFFF</resetMask>
          <fields>
            <field>
              <name>TRIG_CMPT</name>
              <description>interrupt for one trigger conversion complete if enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_CFLCT</name>
              <description>read conflict interrupt, set if wait_dis is set, one conversion is in progress, SW read another channel</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_SW_CFLCT</name>
              <description>sequence queue conflict interrupt, set if HW or SW trigger received during conversion</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_DMAABT</name>
              <description>dma abort interrupt, set if seqence dma write pointer reachs sw read pointer if stop_en is set</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CMPT</name>
              <description>the whole sequence complete interrupt</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CVC</name>
              <description>one conversion complete in seq_queue if related seq_int_en is set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_FIFO_FULL</name>
              <description>DMA fifo full interrupt, user need to check clock frequency if it's set.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHB_ERR</name>
              <description>set if got hresp=1, generally caused by wrong trg_dma_addr or seq_dma_addr</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDOG</name>
              <description>set if one chanel watch dog event triggered</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ana_ctrl0</name>
          <description>No description available</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001004</resetMask>
          <fields>
            <field>
              <name>ADC_CLK_ON</name>
              <description>set to enable adc clock to analog, Software should set this bit before access to any adc16_* register.
MUST set clock_period to 0 or 1 for adc16 reg access</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STARTCAL</name>
              <description>set to start the offset calibration cycle (Active H). user need to clear it after setting it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ana_status</name>
          <description>No description available</description>
          <addressOffset>0x1210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000080</resetMask>
          <fields>
            <field>
              <name>CALON</name>
              <description>Indicates if the ADC is in calibration mode (Active H).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>34</dim>
          <dimIncrement>0x2</dimIncrement>
          <dimIndex>adc16_para00,adc16_para01,adc16_para02,adc16_para03,adc16_para04,adc16_para05,adc16_para06,adc16_para07,adc16_para08,adc16_para09,adc16_para10,adc16_para11,adc16_para12,adc16_para13,adc16_para14,adc16_para15,adc16_para16,adc16_para17,adc16_para18,adc16_para19,adc16_para20,adc16_para21,adc16_para22,adc16_para23,adc16_para24,adc16_para25,adc16_para26,adc16_para27,adc16_para28,adc16_para29,adc16_para30,adc16_para31,adc16_para32,adc16_para33</dimIndex>
          <name>ADC16_PARAMS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1400</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PARAM_VAL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc16_config0</name>
          <description>No description available</description>
          <addressOffset>0x1444</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01F07FFF</resetMask>
          <fields>
            <field>
              <name>REG_EN</name>
              <description>set to enable regulator</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BANDGAP_EN</name>
              <description>set to enable bandgap. user should set reg_en and bandgap_en before use adc16.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_AVG_CFG</name>
              <description>for average the calibration result.
0- 1 loop;   1- 2 loops;   2- 4 loops;   3- 8 loops;
4- 16 loops;  5-32 loops;   others reserved</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPT_EN</name>
              <description>set to enable preemption feature</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONV_PARAM</name>
              <description>conversion parameter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc16_config1</name>
          <description>No description available</description>
          <addressOffset>0x1460</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001F00</resetMask>
          <fields>
            <field>
              <name>COV_END_CNT</name>
              <description>used for faster conversion, user can change it to get higher convert speed(but less accuracy).
should set to (21-convert_clock_number+1).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="ADC0">
      <name>ADC1</name>
      <description>ADC1</description>
      <groupName>ADC16</groupName>
      <baseAddress>0xf0014000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ADC0">
      <name>ADC2</name>
      <description>ADC2</description>
      <groupName>ADC16</groupName>
      <baseAddress>0xf0018000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SDM</name>
      <description>SDM</description>
      <groupName>SDM</groupName>
      <baseAddress>0xf001c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x110</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>SDM control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFE</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>software reset the module if asserted to be1’b1.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHMD</name>
              <description>Channel Rcv mode
Bits[2:0] for Ch0.
Bits[5:3] for Ch1
Bits[8:6] for Ch2
Bits[11:9] for Ch3
3'b000: Capture at posedge of MCLK
3'b001: Capture at both posedge and negedge of MCLK
3'b010: Manchestor Mode
3'b011: Capture at negedge of MCLK
3'b100: Capture at every other posedge of MCLK
3'b101: Capture at every other negedge of MCLK
Others: Undefined</description>
              <bitOffset>14</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_MCLK</name>
              <description>Asserted to double sync the mclk input pin before its usage inside the module</description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_MDAT</name>
              <description>Asserted to double sync the mdat input pin before its usage inside the module</description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_EN</name>
              <description>Channel Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>Interrupt enable register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3DRY</name>
              <description>Ch3 Data Ready interrupt enable.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2DRY</name>
              <description>Ch2 Data Ready interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1DRY</name>
              <description>Ch1 Data Ready interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0DRY</name>
              <description>Ch0 Data Ready interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3ERR</name>
              <description>Ch3 Error interrupt enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2ERR</name>
              <description>Ch2 Error interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1ERR</name>
              <description>Ch1 Error interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0ERR</name>
              <description>Ch0 Error interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status Registers</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3DRY</name>
              <description>Ch3 Data Ready.
De-assert this bit by reading the data (or data fifo) registers.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH2DRY</name>
              <description>Ch2 Data Ready</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH1DRY</name>
              <description>Ch1 Data Ready</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0DRY</name>
              <description>Ch0 Data Ready</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH3ERR</name>
              <description>Ch3 Error.
ORed together by channel related error signals and corresponding error interrupt enable signals.
De-assert this bit by write-1-clear the corresponding error status bits in the channel status registers.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH2ERR</name>
              <description>Ch2 Error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH1ERR</name>
              <description>Ch1 Error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0ERR</name>
              <description>Ch0 Error</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>CH[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <register>
            <name>SDFIFOCTRL</name>
            <description>Data FIFO Path Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF01F4</resetMask>
            <fields>
              <field>
                <name>GATE_SAMPLES</name>
                <description>The number-1-3 of input PDM bit samples to be gated when CIC_GATE_EN=1. Max 255. So the minimum gated samples is 4 samples when GATE_SAMPLES=0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THRSH</name>
                <description>FIFO threshold (0,..,16) (fillings &gt; threshold, then gen int)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>D_RDY_INT_EN</name>
                <description>FIFO data ready interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDCTRLP</name>
            <description>Data Path Control Primary Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MANCH_THR</name>
                <description>Manchester Decoding threshold. 3/4 of PERIOD_MCLK[7:0]</description>
                <bitOffset>25</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDOG_THR</name>
                <description>Watch dog threshold for channel failure of CLK halting</description>
                <bitOffset>17</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AF_IE</name>
                <description>Acknowledge feedback interrupt enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DFFOVIE</name>
                <description>Ch Data FIFO overflow interrupt enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSATIE</name>
                <description>Ch CIC Data Saturation Interrupt Enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIE</name>
                <description>Ch Data Ready Interrupt Enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCSEL</name>
                <description>Select the PWM SYNC Source</description>
                <bitOffset>7</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FFSYNCCLREN</name>
                <description>Auto clear FIFO when a new SDSYNC event is found. Only valid when WTSYNCEN=1</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WTSYNACLR</name>
                <description>1: Asserted to Auto clear WTSYNFLG when the SDFFINT is gen
0: WTSYNFLG should be cleared manually by WTSYNMCLR</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WTSYNMCLR</name>
                <description>1: Manually clear WTSYNFLG. Auto-clear.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WTSYNCEN</name>
                <description>1: Start to store data only after PWM SYNC event
0: Start to store data whenever enabled</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>D32</name>
                <description>1:32 bit data
0:16 bit data</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DR_OPT</name>
                <description>1: Use Data FIFO Ready as data ready when fifo fillings are greater than the threshold
0: Use Data Reg Ready as data ready</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN</name>
                <description>Data Path Enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDCTRLE</name>
            <description>Data Path Control Extra Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFE77FFFF</resetMask>
            <fields>
              <field>
                <name>CIC_GATE_TYPE</name>
                <description>1: the gate cycle is determined by SDFIFOCTRLn[GATE_SAMPLES].
0: the gate cycle is determined by the CIC decimation counter, and the minimal gated off PDM bits are determined by SDFIFOCTRLn[GATE_SAMPLES], and at the same time, to keep alignment with normal PCM sampling time.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_GATE_POL</name>
                <description>1: When mask signal is 1, pause the CIC stage at he rising edge of mask signal.
0: When mask signal is 0, pause the CIC stage at he falling edge of mask signal.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_GATE_SEL</name>
                <description>Select the mask signal for CIC gate signal.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_GATE_EN</name>
                <description>1: the CIC stage can be paused by the mask input.
0: the CIC stage won't be paused by the mask input.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMESTAMP_TYPE</name>
                <description>1. Use the time (when the data is calculated out) - delta_time_of_filter_span as the timestamp.
0: Use the time when the data is calculated out.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DFIFO_S_T</name>
                <description>1: the output of SDFIFO is data and timestamp interleaved. First is data.
0: the output of SDFIFO is data only</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_S_T</name>
                <description>"1: the read output of SData is data and timestamp interleaved. First is data.
0: the read output of SData is data only"</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SGD_ORDR</name>
                <description>CIC order
0: SYNC1
1: SYNC2
2: SYNC3
3: FAST_SYNC</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PWMSYNC</name>
                <description>Asserted to double sync the PWM trigger signal</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_SCL</name>
                <description>CIC shift control</description>
                <bitOffset>11</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_DEC_RATIO</name>
                <description>CIC decimation ratio. 0 means div-by-256</description>
                <bitOffset>3</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IGN_INI_SAMPLES</name>
                <description>NotZero: Don't store the first samples that are not accurate
Zero: Store all samples</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDST</name>
            <description>Data Path Status</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF8033FF</resetMask>
            <fields>
              <field>
                <name>PERIOD_MCLK</name>
                <description>maxim of mclk spacing in cycles, using edges of mclk signal.  In manchester coding mode, it is just the period of MCLK. In other modes, it is almost the half period.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SDATA_D0_T1</name>
                <description>1: next readout is timestamp
0: next readout is data</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SDFIFO_D0_T1</name>
                <description>1: next readout is timestamp
0: next readout is data</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_DR</name>
                <description>FIFO data ready</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>AF</name>
                <description>Achnowledge flag</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DOV_ERR</name>
                <description>Data FIFO Overflow Error. Error flag.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DSAT_ERR</name>
                <description>CIC out Data saturation err. Error flag.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>WTSYNFLG</name>
                <description>Wait-for-sync event found</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FILL</name>
                <description>Data FIFO Fillings</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDATA</name>
            <description>Data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Data</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SDFIFO</name>
            <description>FIFO Data</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>FIFO Data</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCAMP</name>
            <description>instant Amplitude Results</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>instant Amplitude Results</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCHTL</name>
            <description>Amplitude Threshold for High Limit</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Amplitude Threshold for High Limit</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCHTLZ</name>
            <description>Amplitude Threshold for zero crossing</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Amplitude Threshold for zero crossing</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCLLT</name>
            <description>Amplitude Threshold for low limit</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Amplitude Threshold for low limit</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCCTRL</name>
            <description>Amplitude Path Control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFC01FF</resetMask>
            <fields>
              <field>
                <name>HZ_EN</name>
                <description>Zero Crossing Enable</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MF_IE</name>
                <description>Module failure Interrupt enable</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HL_IE</name>
                <description>HLT Interrupt Enable</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LL_IE</name>
                <description>LLT interrupt Enable</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SGD_ORDR</name>
                <description>CIC order
0: SYNC1
1: SYNC2
2: SYNC3
3: FAST_SYNC</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CIC_DEC_RATIO</name>
                <description>CIC decimation ratio. 0 means div-by-32</description>
                <bitOffset>4</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IGN_INI_SAMPLES</name>
                <description>NotZero: Ignore the first samples that are not accurate
Zero: Use all samples</description>
                <bitOffset>1</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN</name>
                <description>Amplitude Path Enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCST</name>
            <description>Amplitude Path Status</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HZ</name>
                <description>Amplitude rising above HZ event found.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MF</name>
                <description>power modulator Failure found. MCLK not found. Error flag.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMPH</name>
                <description>HLT out of range. Error flag.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMPL</name>
                <description>LLT out of range. Error flag.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>ACMP</name>
      <description>ACMP</description>
      <groupName>ACMP</groupName>
      <baseAddress>0xf0020000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x80</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3</dimIndex>
          <name>CHANNEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>cfg</name>
            <description>Configure Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF7FFFFF</resetMask>
            <fields>
              <field>
                <name>HYST</name>
                <description>This bitfield configure the comparator hysteresis.
00: Hysteresis level 0
01: Hysteresis level 1
10: Hysteresis level 2
11: Hysteresis level 3</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACEN</name>
                <description>This bit enable the comparator internal DAC
0: DAC disabled
1: DAC enabled</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HPMODE</name>
                <description>This bit enable the comparator high performance mode.
0: HP mode disabled
1: HP mode enabled</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPEN</name>
                <description>This bit enable the comparator.
0: ACMP disabled
1: ACMP enabled</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MINSEL</name>
                <description>PIN select, from pad_ai_acmp[7:1] and dac_out</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PINSEL</name>
                <description>MIN select, from pad_ai_acmp[7:1] and dac_out</description>
                <bitOffset>20</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPOEN</name>
                <description>This bit enable the comparator output on pad.
0: ACMP output disabled
1: ACMP output enabled</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLTBYPS</name>
                <description>This bit bypass the comparator output digital filter.
0: The ACMP output need pass digital filter
1: The ACMP output digital filter is bypassed.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WINEN</name>
                <description>This bit enable the comparator window mode.
0: Window mode is disabled
1: Window mode is enabled</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OPOL</name>
                <description>The output polarity control bit.
0: The ACMP output remain un-changed.
1: The ACMP output is inverted.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLTMODE</name>
                <description>This bitfield define the ACMP output digital filter mode:
000-bypass
100-change immediately;
101-change after filter;
110-stalbe low;
111-stable high</description>
                <bitOffset>13</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCEN</name>
                <description>This bit enable the comparator output synchronization.
0: ACMP output not synchronized with ACMP clock.
1: ACMP output synchronized with ACMP clock.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLTLEN</name>
                <description>This bitfield define the ACMP output digital filter length. The unit is ACMP clock cycle.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>daccfg</name>
            <description>DAC configure register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DACCFG</name>
                <description>8bit DAC digital value output to analog block</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>sr</name>
            <description>Status register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>FEDGF</name>
                <description>Output falling edge flag. Write 1 to clear this flag.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REDGF</name>
                <description>Output rising edge flag. Write 1 to clear this flag.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>irqen</name>
            <description>Interrupt request enable register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>FEDGEN</name>
                <description>Output falling edge flag interrupt enable bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REDGEN</name>
                <description>Output rising edge flag interrupt enable bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>dmaen</name>
            <description>DMA request enable register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>FEDGEN</name>
                <description>Output falling edge flag DMA request enable bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REDGEN</name>
                <description>Output rising edge flag DMA request enable bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>DAC0</name>
      <description>DAC0</description>
      <groupName>DAC</groupName>
      <baseAddress>0xf0024000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>cfg0</name>
          <description>No description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF03FF</resetMask>
          <fields>
            <field>
              <name>SW_DAC_DATA</name>
              <description>dac data used in direct mode(dac_mode==2'b10)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_AHB_EN</name>
              <description>set to enable internal DMA, it will read one burst if enough space in FIFO.
Should only be used in buffer mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SYNC_MODE</name>
              <description>1: sync dac clock and ahb clock.
  all HW trigger signals are pulse in sync mode, can get faster response;
0: async dac clock and ahb_clock
  all HW trigger signals should be level and should be more than one dac clock cycle,  used to get accurate output frequency(which may not be divided from AHB clock)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TRIG_MODE</name>
              <description>0: single mode, one trigger pulse will send one 12bit data to DAC analog;
1: continual mode, if trigger signal(either  or HW) is set, DAC will send data if FIFO is not empty, if trigger signal is clear, DAC will stop send data.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HW_TRIG_EN</name>
              <description>set to use trigger signal from trigger_mux, user should config it to pulse in single mode, and level in continual mode</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DAC_MODE</name>
              <description>00: direct mode, DAC output the fixed configured data(from sw_dac_data)
01: step mode, DAC output from start_point to end point, with configured step, can step up or step down
10: buffer mode,  read data from buffer, then output to analog, internal DMA will load next burst if enough space in local FIFO;
11: trigger mode,  DAC output from external trigger signals
Note:
Trigger mode is not supported in hpm63xx and hpm62xx families.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BUF_DATA_MODE</name>
              <description>data structure for buffer mode,
0: each 32-bit data contains 2 points, b11:0 for first, b27:16 for second.
1: each 32-bit data contains 1 point, b11:0 for first</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HBURST_CFG</name>
              <description>DAC support following fixed burst only
000-SINGLE;  011-INCR4;  101: INCR8
others are reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cfg1</name>
          <description>No description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00010000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>ANA_CLK_EN</name>
              <description>set to enable analog clock(divided by ana_div_cfg)
need to be set in direct mode and trigger mode</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_DIV_CFG</name>
              <description>clock divider config for ana_clk to dac analog;
00:  div2
01:  div4
10:  div6
11:  div8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_CFG</name>
              <description>step mode and buffer mode:
  defines how many clk_dac cycles to change data to analog, should configured to less than 1MHz data rate.
Direct mode and trigger mode:
  defines how many clk_dac cycles to accpet the input data, dac will not accept new written data or trigger data before the clock cycles passed. should configured to less than 1MHz.
Note:
For direct mode and trigger mode, this config is not supported in hpm63xx and hpm62xx families.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cfg2</name>
          <description>No description available</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DMA_RST1</name>
              <description>set to reset dma read pointer to buf1_start_addr;
if set both dma_rst0&amp;dma_rst1, will set to buf0_start_addr
user can set fifo_clr bit when use dma_rst*</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_RST0</name>
              <description>set to reset dma read pointer to buf0_start_addr</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFO_CLR</name>
              <description>set to clear FIFO content(set both read/write pointer to 0)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BUF_SW_TRIG</name>
              <description>software trigger for buffer mode,
W1C in single mode.
RW in continual mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STEP_SW_TRIG3</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STEP_SW_TRIG2</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STEP_SW_TRIG1</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STEP_SW_TRIG0</name>
              <description>software trigger0 for step mode,
W1C in single mode.
RW in continual mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>step0,step1,step2,step3</dimIndex>
          <name>STEP_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ROUND_MODE</name>
              <description>0: stop at end point;
1: reload start point, step again</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UP_DOWN</name>
              <description>0 for up, 1 for down</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>END_POINT</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STEP_NUM</name>
              <description>output data change step_num each DAC clock cycle.
Ex: if step_num=3, output data sequence is 0,3,6,9
NOTE:  user should make sure end_point can be reached if step_num is not 1
if step_num is 0, output data will always at start point</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START_POINT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>buf0,buf1</dimIndex>
          <name>BUF_ADDR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFD</resetMask>
          <fields>
            <field>
              <name>BUF_START_ADDR</name>
              <description>buffer start address, should be 4-byte aligned
AHB burst can't cross 1K-byte boundary, user should config the address/length/burst to avoid such issue.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_STOP</name>
              <description>set to stop read point at end of bufffer0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>buf_length</name>
          <description>No description available</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUF1_LEN</name>
              <description>buffer length, 1 indicate one 32bit date, 256K-byte max for one buffer</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF0_LEN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts</name>
          <description>No description available</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>STEP_CMPT</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AHB_ERROR</name>
              <description>set if hresp==2'b01(ERROR)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFO_EMPTY</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BUF1_CMPT</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BUF0_CMPT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_en</name>
          <description>No description available</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>STEP_CMPT</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHB_ERROR</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_EMPTY</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF1_CMPT</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF0_CMPT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dma_en</name>
          <description>No description available</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000013</resetMask>
          <fields>
            <field>
              <name>STEP_CMPT</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF1_CMPT</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF0_CMPT</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ana_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000030</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>DAC12BIT_LP_MODE</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_CONFIG</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CALI_DELTA_V_CFG</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_CALI_GM</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC12BIT_EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cfg0_bak</name>
          <description>No description available</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF03FF</resetMask>
          <fields>
            <field>
              <name>SW_DAC_DATA</name>
              <description>dac data used in direct mode(dac_mode==2'b10)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_AHB_EN</name>
              <description>set to enable internal DMA, it will read one burst if enough space in FIFO.
Should only be used in buffer mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_MODE</name>
              <description>1: sync dac clock and ahb clock.
  all HW trigger signals are pulse in sync mode, can get faster response;
0: async dac clock and ahb_clock
  all HW trigger signals should be level and should be more than one dac clock cycle,  used to get accurate output frequency(which may not be divided from AHB clock)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_MODE</name>
              <description>0: single mode, one trigger pulse will send one 12bit data to DAC analog;
1: continual mode, if trigger signal(either  or HW) is set, DAC will send data if FIFO is not empty, if trigger signal is clear, DAC will stop send data.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HW_TRIG_EN</name>
              <description>set to use trigger signal from trigger_mux, user should config it to pulse in single mode, and level in continual mode</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_MODE</name>
              <description>00: direct mode, DAC output the fixed configured data(from sw_dac_data)
01: step mode, DAC output from start_point to end point, with configured step, can step up or step down
10: buffer mode,  read data from buffer, then output to analog, internal DMA will load next burst if enough space in local FIFO;</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_DATA_MODE</name>
              <description>data structure for buffer mode,
0: each 32-bit data contains 2 points, b11:0 for first, b27:16 for second.
1: each 32-bit data contains 1 point, b11:0 for first</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HBURST_CFG</name>
              <description>DAC support following fixed burst only
000-SINGLE;  011-INCR4;  101: INCR8
others are reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>status0</name>
          <description>No description available</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFF80</resetMask>
          <fields>
            <field>
              <name>CUR_BUF_OFFSET</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CUR_BUF_INDEX</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DAC0">
      <name>DAC1</name>
      <description>DAC1</description>
      <groupName>DAC</groupName>
      <baseAddress>0xf0028000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI0</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0030000</baseAddress>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x70</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TransFmt</name>
          <description>Transfer Format Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00020780</resetValue>
          <resetMask>0xFFFF1F9F</resetMask>
          <fields>
            <field>
              <name>ADDRLEN</name>
              <description>Address length in bytes
0x0: 1 byte
0x1: 2 bytes
0x2: 3 bytes
0x3: 4 bytes</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATALEN</name>
              <description>The length of each data unit in bits
The actual bit number of a data unit is (DataLen + 1)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAMERGE</name>
              <description>Enable Data Merge mode, which does automatic data split on write and data coalescing on read.
This bit only takes effect when DataLen = 0x7. Under Data Merge mode, each write to the Data Register will transmit all fourbytes of the write data; each read from the Data Register will retrieve four bytes of received data as a single word data.
When Data Merge mode is disabled, only the least (DataLen+1) significient bits of the Data Register are valid for read/write operations; no automatic data split/coalescing will be performed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSIBIDIR</name>
              <description>Bi-directional MOSI in regular (single) mode
0x0: MOSI is uni-directional signal in regular mode.
0x1: MOSI is bi-directional signal in regular mode. This bi-directional signal replaces the two</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Transfer data with the least significant bit first
0x0: Most significant bit first
0x1: Least significant bit first</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVMODE</name>
              <description>SPI Master/Slave mode selection
0x0: Master mode
0x1: Slave mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>SPI Clock Polarity
0x0: SCLK is LOW in the idle states
0x1: SCLK is HIGH in the idle states</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>SPI Clock Phase
0x0: Sampling data at odd SCLK edges
0x1: Sampling data at even SCLK edges</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TransCtrl</name>
          <description>Transfer Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLVDATAONLY</name>
              <description>Data-only mode (slave mode only)
0x0: Disable the data-only mode
0x1: Enable the data-only mode
Note: This mode only works in the uni-directional regular (single) mode so MOSIBiDir, DualQuad and TransMode should be set to 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDEN</name>
              <description>SPI command phase enable (Master mode only)
0x0: Disable the command phase
0x1: Enable the command phase</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDREN</name>
              <description>SPI address phase enable (Master mode only)
0x0: Disable the address phase
0x1: Enable the address phase</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRFMT</name>
              <description>SPI address phase format (Master mode only)
0x0: Address phase is the regular (single) mode
0x1: The format of the address phase is the same as the data phase (DualQuad).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMODE</name>
              <description>Transfer mode
The transfer sequence could be
0x0: Write and read at the same time
0x1: Write only
0x2: Read only
0x3: Write, Read
0x4: Read, Write
0x5: Write, Dummy, Read
0x6: Read, Dummy, Write
0x7: None Data (must enable CmdEn or AddrEn in master mode)
0x8: Dummy, Write
0x9: Dummy, Read
0xa~0xf: Reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALQUAD</name>
              <description>SPI data phase format
0x0: Regular (Single) mode
0x1: Dual I/O mode
0x2: Quad I/O mode
0x3: Reserved</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOKENEN</name>
              <description>Token transfer enable (Master mode only)
Append a one-byte special token following the address phase for SPI read transfers. The value of the special token should be selected in TokenValue.
0x0: Disable the one-byte special token
0x1: Enable the one-byte special token</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRTRANCNT</name>
              <description>Transfer count for write data
WrTranCnt indicates the number of units of data to be transmitted to the SPI bus from the Data Register. The actual transfer count is (WrTranCnt+1).
WrTranCnt only takes effect when TransMode is 0, 1, 3, 4, 5, 6 or 8.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must be equal to RdTranCnt.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOKENVALUE</name>
              <description>Token value (Master mode only)
The value of the one-byte special token following the address phase for SPI read transfers.
0x0: token value = 0x00
0x1: token value = 0x69</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DUMMYCNT</name>
              <description>Dummy data count. The actual dummy count is (DummyCnt +1).
The number of dummy cycles on the SPI interface will be (DummyCnt+1)* ((DataLen+1)/SPI IO width)
The Data pins are put into the high impedance during the dummy data phase.
DummyCnt is only used for TransMode 5, 6, 8 and 9, which has dummy data phases.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDTRANCNT</name>
              <description>Transfer count for read data
RdTranCnt indicates the number of units of data to be received from SPI bus and stored to the Data Register. The actual received count is (RdTranCnt+1).
RdTransCnt only takes effect when TransMode is 0, 2, 3, 4, 5, 6 or 9.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must equal RdTranCnt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cmd</name>
          <description>Command Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>SPI Command</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Addr</name>
          <description>Address Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>SPI Address
(Master mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Data</name>
          <description>Data Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data to transmit or the received data
For writes, data is enqueued to the TX FIFO. The least significant byte is always transmitted first. If the TX FIFO is full and the SPIActive bit of the status register is 1, the ready signal hready/pready will be deasserted to insert wait states to the transfer.
For reads, data is read and dequeued from the RX FIFO. The least significant byte is the first received byte. If the RX FIFO is empty and the SPIActive bit of the status register is 1, the ready signal hready/pready will be deasserted to insert wait states to the transfer.
The FIFOs decouple the speed of the SPI transfers and the software鈥檚 generation/consumption of data. When the TX FIFO is empty, SPI transfers will hold until more data is written to the TX FIFO; when the RX FIFO is full, SPI transfers will hold until there is more room in the RX FIFO.
If more data is written to the TX FIFO than the write transfer count (WrTranCnt), the remaining data will stay in the TX FIFO for the next transfer or until the TX FIFO is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Ctrl</name>
          <description>Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFF1F</resetMask>
          <fields>
            <field>
              <name>TXTHRES</name>
              <description>Transmit (TX) FIFO Threshold
The TXFIFOInt interrupt or DMA request would be issued to replenish the TX FIFO when the TX data count is less than or equal to the TX FIFO threshold.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHRES</name>
              <description>Receive (RX) FIFO Threshold
The RXFIFOInt interrupt or DMA request would be issued for consuming the RX FIFO when the RX data count is more than or equal to the RX FIFO threshold.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMAEN</name>
              <description>TX DMA enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMAEN</name>
              <description>RX DMA enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFORST</name>
              <description>Transmit FIFO reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFORST</name>
              <description>Receive FIFO reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIRST</name>
              <description>SPI reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Status</name>
          <description>Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x33FFFF01</resetMask>
          <fields>
            <field>
              <name>TXNUM_7_6</name>
              <description>Number of valid entries in the Transmit FIFO</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNUM_7_6</name>
              <description>Number of valid entries in the Receive FIFO</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Full flag</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Empty flag</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXNUM_5_0</name>
              <description>Number of valid entries in the Transmit FIFO</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Full flag</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Empty flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNUM_5_0</name>
              <description>Number of valid entries in the Receive FIFO</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SPIACTIVE</name>
              <description>SPI register programming is in progress.
In master mode, SPIActive becomes 1 after the SPI command register is written and becomes 0 after the transfer is finished.
In slave mode, SPIActive becomes 1 after the SPI CS signal is asserted and becomes 0 after the SPI CS signal is deasserted.
Note that due to clock synchronization, it may take at most two spi_clock cycles for SPIActive to change when the corresponding condition happens.
Note this bit stays 0 when Direct IO Control or the memory-mapped interface is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntrEn</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SLVCMDEN</name>
              <description>Enable the Slave Command Interrupt.
Control whether interrupts are triggered whenever slave commands are received.
(Slave mode only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENDINTEN</name>
              <description>Enable the End of SPI Transfer interrupt.
Control whether interrupts are triggered when SPI transfers end.
(In slave mode, end of read status transaction doesn鈥檛 trigger this interrupt.)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFOINTEN</name>
              <description>Enable the SPI Transmit FIFO Threshold interrupt.
Control whether interrupts are triggered when the valid entries are less than or equal to the TX FIFO threshold.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFOINTEN</name>
              <description>Enable the SPI Receive FIFO Threshold interrupt.
Control whether interrupts are triggered when the valid entries are greater than or equal to the RX FIFO threshold.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFOURINTEN</name>
              <description>Enable the SPI Transmit FIFO Underrun interrupt.
Control whether interrupts are triggered when the Transmit FIFO run out of data.
(Slave mode only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFOORINTEN</name>
              <description>Enable the SPI Receive FIFO Overrun interrupt.
Control whether interrupts are triggered when the Receive FIFO overflows.
(Slave mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntrSt</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SLVCMDINT</name>
              <description>Slave Command Interrupt.
This bit is set when Slave Command interrupts occur.
(Slave mode only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ENDINT</name>
              <description>End of SPI Transfer interrupt.
This bit is set when End of SPI Transfer interrupts occur.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFIFOINT</name>
              <description>TX FIFO Threshold interrupt.
This bit is set when TX FIFO Threshold interrupts occur.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXFIFOINT</name>
              <description>RX FIFO Threshold interrupt.
This bit is set when RX FIFO Threshold interrupts occur.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFIFOURINT</name>
              <description>TX FIFO Underrun interrupt.
This bit is set when TX FIFO Underrun interrupts occur.
(Slave mode only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXFIFOORINT</name>
              <description>RX FIFO Overrun interrupt.
This bit is set when RX FIFO Overrun interrupts occur.
(Slave mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Timing</name>
          <description>Interface Timing Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>CS2SCLK</name>
              <description>The minimum time between the edges of SPI CS and the edges of SCLK.
SCLK_period * (CS2SCLK + 1) / 2</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSHT</name>
              <description>The minimum time that SPI CS should stay HIGH.
SCLK_period * (CSHT + 1) / 2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_DIV</name>
              <description>The clock frequency ratio between the clock source and SPI interface SCLK.
SCLK_period = ((SCLK_DIV + 1) * 2) * (Period of the SPI clock source)
The SCLK_DIV value 0xff is a special value which indicates that the SCLK frequency should be the same as the spi_clock frequency.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvSt</name>
          <description>Slave Status Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>UNDERRUN</name>
              <description>Data underrun occurs in the last transaction</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Data overrun occurs in the last transaction</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READY</name>
              <description>Set this bit to indicate that the ATCSPI200 is ready for data transaction.
When an SPI transaction other than slave status-reading command ends, this bit will be cleared to 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USR_STATUS</name>
              <description>User defined status flags</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvDataCnt</name>
          <description>Slave Data Count Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FF03FF</resetMask>
          <fields>
            <field>
              <name>WCNT</name>
              <description>Slave transmitted data count</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RCNT</name>
              <description>Slave received data count</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Config</name>
          <description>Configuration Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00004311</resetValue>
          <resetMask>0x000043FF</resetMask>
          <fields>
            <field>
              <name>SLAVE</name>
              <description>Support for SPI Slave mode</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QUADSPI</name>
              <description>Support for Quad I/O SPI</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DUALSPI</name>
              <description>Support for Dual I/O SPI</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFIFOSIZE</name>
              <description>Depth of TX FIFO
0x0: 2 words
0x1: 4 words
0x2: 8 words
0x3: 16 words
0x4: 32 words
0x5: 64 words
0x6: 128 words</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFIFOSIZE</name>
              <description>Depth of RX FIFO
0x0: 2 words
0x1: 4 words
0x2: 8 words
0x3: 16 words
0x4: 32 words
0x5: 64 words
0x6: 128 words</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI1</name>
      <description>SPI1</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0034000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI2</name>
      <description>SPI2</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0038000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI3</name>
      <description>SPI3</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf003c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART0</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0040000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x3c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IDLE_CFG</name>
          <description>Idle Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>RX_IDLE_COND</name>
              <description>IDLE Detection Condition
0 - Treat as idle if RX pin is logic one
1 - Treat as idle if UART state machine state is idle</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_IDLE_EN</name>
              <description>UART Idle Detect Enable
0 - Disable
1 - Enable
it should be enabled if enable address match feature</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_IDLE_THR</name>
              <description>Threshold for UART Receive Idle detection (in terms of bits)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cfg</name>
          <description>Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOSIZE</name>
              <description>The depth of RXFIFO and TXFIFO
0: 16-byte FIFO
1: 32-byte FIFO
2: 64-byte FIFO
3: 128-byte FIFO</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSCR</name>
          <description>Over Sample Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>OSC</name>
              <description>Over-sample control
The value must be an even number; any odd value
writes to this field will be converted to an even value.
OSC=0: reserved
OSC&lt;=8: The over-sample ratio is 8
8 &lt; OSC&lt; 32: The over sample ratio is OSC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RBR</name>
          <description>Receiver Buffer Register (when DLAB = 0)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive data read port</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>THR</name>
          <description>Transmitter Holding Register (when DLAB = 0)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit data write port</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL</name>
          <description>Divisor Latch LSB (when DLAB = 1)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLL</name>
              <description>Least significant byte of the Divisor Latch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <description>Interrupt Enable Register (when DLAB = 0)</description>
          <alternateGroup>UNION_24</alternateGroup>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000000F</resetMask>
          <fields>
            <field>
              <name>ERXIDLE</name>
              <description>Enable Receive Idle interrupt
0 - Disable Idle interrupt
1 - Enable Idle interrupt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMSI</name>
              <description>Enable modem status interrupt
The interrupt asserts when the status of one of the
following occurs:
The status of modem_rin, modem_dcdn,
modem_dsrn or modem_ctsn (If the auto-cts mode is
disabled) has been changed.
If the auto-cts mode is enabled (MCR bit4 (AFE) = 1),
modem_ctsn would be used to control the transmitter.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELSI</name>
              <description>Enable receiver line status interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHEI</name>
              <description>Enable transmitter holding register interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERBI</name>
              <description>Enable received data available interrupt and the
character timeout interrupt
0: Disable
1: Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLM</name>
          <description>Divisor Latch MSB (when DLAB = 1)</description>
          <alternateGroup>UNION_24</alternateGroup>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLM</name>
              <description>Most significant byte of the Divisor Latch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IIR</name>
          <description>Interrupt Identification Register</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x800000CF</resetMask>
          <fields>
            <field>
              <name>RXIDLE_FLAG</name>
              <description>UART IDLE Flag
0 - UART is busy
1 - UART is idle
NOTE: when write one to clear this bit, avoid changging FCR register since it's same address as IIR</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOED</name>
              <description>FIFOs enabled
These two bits are 1 when bit 0 of the FIFO Control
Register (FIFOE) is set to 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRID</name>
              <description>Interrupt ID, see IIR2 for detail decoding</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FCR</name>
          <description>FIFO Control Register</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RFIFOT</name>
              <description>Receiver FIFO trigger level</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFIFOT</name>
              <description>Transmitter FIFO trigger level</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMAE</name>
              <description>DMA enable
0: Disable
1: Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFIFORST</name>
              <description>Transmitter FIFO reset
Write 1 to clear all bytes in the TXFIFO and resets its
counter. The Transmitter Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFIFORST</name>
              <description>Receiver FIFO reset
Write 1 to clear all bytes in the RXFIFO and resets its
counter. The Receiver Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOE</name>
              <description>FIFO enable
Write 1 to enable both the transmitter and receiver
FIFOs.
The FIFOs are reset when the value of this bit toggles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <description>Line Control Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLAB</name>
              <description>Divisor latch access bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BC</name>
              <description>Break control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPS</name>
              <description>Stick parity
1: Parity bit is constant 0 or 1, depending on bit4 (EPS).
0: Disable the sticky bit parity.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPS</name>
              <description>Even parity select
1: Even parity (an even number of logic-1 is in the data
and parity bits)
0: Old parity.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEN</name>
              <description>Parity enable
When this bit is set, a parity bit is generated in
transmitted data before the first STOP bit and the parity
bit would be checked for the received data.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STB</name>
              <description>Number of STOP bits
0: 1 bits
1: The number of STOP bit is based on the WLS setting
When WLS = 0, STOP bit is 1.5 bits
When WLS = 1, 2, 3, STOP bit is 2 bits</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WLS</name>
              <description>Word length setting
0: 5 bits
1: 6 bits
2: 7 bits
3: 8 bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCR</name>
          <description>Modem Control Register (</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000032</resetMask>
          <fields>
            <field>
              <name>AFE</name>
              <description>Auto flow control enable
0: Disable
1: The auto-CTS and auto-RTS setting is based on the
RTS bit setting:
When RTS = 0, auto-CTS only
When RTS = 1, auto-CTS and auto-RTS</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOP</name>
              <description>Enable loopback mode
0: Disable
1: Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS</name>
              <description>Request to send
This bit controls the modem_rtsn output.
0: The modem_rtsn output signal will be driven HIGH
1: The modem_rtsn output signal will be driven LOW</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LSR</name>
          <description>Line Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>ERRF</name>
              <description>Error in RXFIFO
In the FIFO mode, this bit is set when there is at least
one parity error, framing error, or line break
associated with data in the RXFIFO. It is cleared when
this register is read and there is no more error for the
rest of data in the RXFIFO.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TEMT</name>
              <description>Transmitter empty
This bit is 1 when the THR (TXFIFO in the FIFO
mode) and the Transmitter Shift Register (TSR) are
both empty. Otherwise, it is zero.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE</name>
              <description>Transmitter Holding Register empty
This bit is 1 when the THR (TXFIFO in the FIFO
mode) is empty. Otherwise, it is zero.
If the THRE interrupt is enabled, an interrupt is
triggered when THRE becomes 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LBREAK</name>
              <description>Line break
This bit is set when the uart_sin input signal was held
LOWfor longer than the time for a full-word
transmission. A full-word transmission is the
transmission of the START, data, parity, and STOP
bits. It is cleared when this register is read.
In the FIFO mode, this bit indicates the line break for
the received data at the top of the RXFIFO.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FE</name>
              <description>Framing error
This bit is set when the received STOP bit is not
HIGH. It is cleared when this register is read.
In the FIFO mode, this bit indicates the framing error
for the received data at the top of the RXFIFO.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PE</name>
              <description>Parity error
This bit is set when the received parity does not match
with the parity selected in the LCR[5:4]. It is cleared
when this register is read.
In the FIFO mode, this bit indicates the parity error
for the received data at the top of the RXFIFO.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OE</name>
              <description>Overrun error
This bit indicates that data in the Receiver Buffer
Register (RBR) is overrun.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DR</name>
              <description>Data ready.
This bit is set when there are incoming received data
in the Receiver Buffer Register (RBR). It is cleared
when all of the received data are read.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSR</name>
          <description>Modem Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>CTS</name>
              <description>Clear to send
0: The modem_ctsn input signal is HIGH.
1: The modem_ctsn input signal is LOW.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCTS</name>
              <description>Delta clear to send
This bit is set when the state of the modem_ctsn input
signal has been changed since the last time this
register is read.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR</name>
          <description>GPR Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>A one-byte storage register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART1</name>
      <description>UART1</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0044000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART2</name>
      <description>UART2</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0048000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART3</name>
      <description>UART3</description>
      <groupName>UART</groupName>
      <baseAddress>0xf004c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART4</name>
      <description>UART4</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0050000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART5</name>
      <description>UART5</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0054000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART6</name>
      <description>UART6</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0058000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART7</name>
      <description>UART7</description>
      <groupName>UART</groupName>
      <baseAddress>0xf005c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>PUART</name>
      <description>PUART</description>
      <groupName>UART</groupName>
      <baseAddress>0xf40e4000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MCAN0</name>
      <description>MCAN0</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0080000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x29fc</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ENDN</name>
          <description>endian register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x87654321</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVT</name>
              <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBTP</name>
          <description>data bit timing and prescaler, writeable when CCCR.CCE and CCCR.INT are set</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000A33</resetValue>
          <resetMask>0x009F1FFF</resetMask>
          <fields>
            <field>
              <name>TDC</name>
              <description>transmitter delay compensation enable
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBRP</name>
              <description>Data Bit Rate Prescaler
The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit Rate Prescaler are 0 to 31.
When TDC = ‘1’, the range is limited to 0,1. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTSEG1</name>
              <description>Data time segment before sample point
Valid values are 0 to 31. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTSEG2</name>
              <description>Data time segment after sample point
Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSJW</name>
              <description>Data (Re)Synchronization Jump Width
Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST</name>
          <description>test register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F3FF0</resetMask>
          <fields>
            <field>
              <name>SVAL</name>
              <description>Started Valid
0= Value of TXBNS not valid
1= Value of TXBNS valid</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXBNS</name>
              <description>Tx Buffer Number Started
Tx Buffer number of message whose transmission was started last. Valid when SVAL is set. Valid values are 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PVAL</name>
              <description>Prepared Valid
0= Value of TXBNP not valid
1= Value of TXBNP valid</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXBNP</name>
              <description>Tx Buffer Number Prepared
Tx Buffer number of message that is ready for transmission. Valid when PVAL is set.Valid values are 0 to 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receive Pin
Monitors the actual value of pin m_can_rx
0= The CAN bus is dominant (m_can_rx = ‘0’)
1= The CAN bus is recessive (m_can_rx = ‘1’)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Control of Transmit Pin
00 Reset value, m_can_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_can_tx
10 Dominant (‘0’) level at pin m_can_tx
11 Recessive (‘1’) at pin m_can_tx</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LBCK</name>
              <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RWD</name>
          <description>ram watchdog</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>WDV</name>
              <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDC</name>
              <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of “00” the counter is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCCR</name>
          <description>CC control register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>NISO</name>
              <description>Non ISO Operation
If this bit is set, the M_CAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0
Note: When the generic parameter iso_only_g is set to ‘1’ in hardware synthesis, this bit becomes reserved and is read as ‘0’. The M_CAN always operates with the CAN FD frame format according to ISO 11898-1:2015.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXP</name>
              <description>Transmit Pause
If this bit is set, the M_CAN pauses for two CAN bit times before starting the next transmission after
itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFBI</name>
              <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PXHD</name>
              <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled
Note: When protocol exception handling is disabled, the M_CAN will transmit an error frame when it detects a protocol exception condition.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WMM</name>
              <description>Wide Message Marker
Enables the use of 16-bit Wide Message Markers. When 16-bit Wide Message Markers are used (WMM = ‘1’), 16-bit internal timestamping is disabled for the Tx Event FIFO.
0= 8-bit Message Marker used
1= 16-bit Message Marker used, replacing 16-bit timestamps in Tx Event FIFO</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTSU</name>
              <description>Use Timestamping Unit
When UTSU is set, 16-bit Wide Message Markers are also enabled regardless of the value of WMM.
0= Internal time stamping
1= External time stamping by TSU
Note: When generic parameter connected_tsu_g = ‘0’, there is no TSU connected to the M_CAN.
In this case bit UTSU is fixed to zero by synthesis.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRSE</name>
              <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled
Note: When CAN FD operation is disabled FDOE = ‘0’, BRSE is not evaluated.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FDOE</name>
              <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST</name>
              <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAR</name>
              <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MON</name>
              <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to ‘1’. The bit can be reset by the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR</name>
              <description>Clock Stop Request
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after all pending transfer requests have been completed and the CAN bus reached idle.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSA</name>
              <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_CAN may be set in power down by stopping m_can_hclk and m_can_cclk</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ASM</name>
              <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to ‘1’. The bit can be reset by the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CCE</name>
              <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = ‘1’)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Initialization
0= Normal Operation
1= Initialization is started</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NBTP</name>
          <description>nominal bit timing and prescaler register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x06000A03</resetValue>
          <resetMask>0xFFFFFF7F</resetMask>
          <fields>
            <field>
              <name>NSJW</name>
              <description>Nominal (Re)Synchronization Jump Width
Valid values are 0 to 127. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NBRP</name>
              <description>Nominal Bit Rate Prescaler
The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NTSEG1</name>
              <description>Nominal Time segment before sample point
Valid values are 1 to 255. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NTSEG2</name>
              <description>Nominal Time segment after sample point
Valid values are 1 to 127. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCC</name>
          <description>timestamp counter configuration</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F0003</resetMask>
          <fields>
            <field>
              <name>TCP</name>
              <description>Timestamp Counter Prescaler
Configures the timestamp and timeout counters time unit in multiples of CAN bit times [1…16]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSS</name>
              <description>timestamp Select
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as “00”</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCV</name>
          <description>timestamp counter value</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TSC</name>
              <description>Timestamp Counter
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).When TSCC.TSS = “01”, the Timestamp Counter is incremented in multiples of CAN bit times [1…16] depending on the configuration of TSCC.TCP.
A wrap around sets interrupt flag IR.TSW. Write access resets the counter to zero. When TSCC.TSS = “10”, TSC reflects the external Timestamp Counter value. A write access has no impact.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOCC</name>
          <description>timeout counter configuration</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0xFFFF0000</resetValue>
          <resetMask>0xFFFF0007</resetMask>
          <fields>
            <field>
              <name>TOP</name>
              <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOS</name>
              <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured by TOCC.TOP and continues down-counting.
When the Timeout Counter is controlled by one of the FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RP</name>
              <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOCV</name>
          <description>timeout counter value</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [1…16] depending on the configuration of TSCC.TCP.
When decremented to zero, interrupt flag IR.TOO is set and the Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.
Note: Byte access: when TOCC.TOS = “00，writing one of the register bytes 3/2/1/0 will preset the Timeout Counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECR</name>
          <description>error counter register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>CEL</name>
              <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the 8-bit Transmit Error Counter TEC or the 7-bit Receive Error Counter REC to be incremented.
The counter is also incremented when the Bus_Off limit is reached. It is not incremented when only RP is set without changing REC. The increment of CEL follows after the increment of REC or TEC.
The counter is reset by read access to CEL. The counter stops at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.
Note: Byte access: Reading byte 2 will reset CEL to zero, reading bytes 3/1/0 has no impact.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RP</name>
              <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REC</name>
              <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TEC</name>
              <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255
Note: When CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSR</name>
          <description>protocol status register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000707</resetValue>
          <resetMask>0x007F7FFF</resetMask>
          <fields>
            <field>
              <name>TDCV</name>
              <description>Transmitter Delay Compensation Value
Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO.
The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PXE</name>
              <description>Protocol Exception Event
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred
Note: Byte access: Reading byte 0 will reset PXE, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RFDF</name>
              <description>Received a CAN FD Message
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received
Note: Byte access: Reading byte 0 will reset RFDF, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RBRS</name>
              <description>BRS flag of last received CAN FD Message
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set
Note: Byte access: Reading byte 0 will reset RBRS, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESI</name>
              <description>ESI flag of last received CAN FD Message
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set
Note: Byte access: Reading byte 0 will reset RESI, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DLEC</name>
              <description>Data Phase Last Error Code
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set.Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with
its BRS flag set has been transferred (reception or transmission) without error.
Note: Byte access: Reading byte 0 will set DLEC to “111”, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BO</name>
              <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EW</name>
              <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EP</name>
              <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACT</name>
              <description>Activity
Monitors the module’s CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter
Note: ACT is set to “00” by a Protocol Exception Event.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEC</name>
              <description>Last Error Code
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to ‘0’when a message has been transferred (reception or transmission) without error.
0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_CAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value ‘1’), but the monitored bus
value was dominant.
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a dominant level (data or identifier bit logical value‘0’), but the monitored bus value was recessive.
 During Bus_Off recovery this status is set each time a sequence of 11 recessive bits has been monitored. This enables the CPU to monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to ‘7’. When the LEC shows the value ‘7’, no CAN bus event was detected since the last CPU read access to the Protocol Status Register.
Note: When a frame in CAN FD format has reached the data phase with BRS flag set, the next CAN event (error or valid frame) will be shown in DLEC instead of LEC. An error in a fixed stuff bit of a CAN FD CRC sequence will be shown as a Form Error, not Stuff Error.
Note: The Bus_Off recovery sequence (see ISO 11898-1:2015) cannot be shortened by setting or resetting CCCR.INIT. If the device goes Bus_Off, it will set CCCR.INIT of its own accord,stopping all bus activities.
 Once CCCR.INIT has been cleared by the CPU, the device will then wait for 129 occurrences of Bus Idle (129 * 11 consecutive recessive bits) before resuming normal operation.
At the end of the Bus_Off recovery sequence, the Error Management Counters will be reset. During the waiting time after the resetting of CCCR.INIT, each time a sequence of 11 recessive bits has been monitored, a Bit0Error code is written to PSR.LEC,
enabling the CPU to readily check up whether the CAN bus is stuck at dominant or continuously disturbed and to monitor the Bus_Off recovery sequence. ECR.REC is used to count these sequences.
Note: Byte access: Reading byte 0 will set LEC to “111”, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TDCR</name>
          <description>transmitter delay compensation</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>TDCO</name>
              <description>Transmitter Delay Compensation SSP Offset
Offset value defining the distance between the measured delay from m_can_tx to m_can_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDCF</name>
              <description>Transmitter Delay Compensation Filter Window Length
Defines the minimum value for the SSP position, dominant edges on m_can_rx that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than TDCO. Valid values are 0 to 127 mtq.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IR</name>
          <description>interrupt register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARA</name>
              <description>Access to Reserved Address
0= No access to reserved address occurred
1= Access to reserved address occurred</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PED</name>
              <description>Protocol Error in Data Phase (Data Bit Time is used)
0= No protocol error in data phase
1= Protocol error in data phase detected (PSR.DLEC ≠ 0,7)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEA</name>
              <description>Protocol Error in Arbitration Phase (Nominal Bit Time is used)
0= No protocol error in arbitration phase
1= Protocol error in arbitration phase detected (PSR.LEC ≠ 0,7)</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDI</name>
              <description>Watchdog Interrupt
0= No Message RAM Watchdog event occurred
1= Message RAM Watchdog event due to missing READY</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BO</name>
              <description>Bus_Off Status
0= Bus_Off status unchanged
1= Bus_Off status changed</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EW</name>
              <description>Warning Status
0= Error_Warning status unchanged
1= Error_Warning status changed</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EP</name>
              <description>Error Passive
0= Error_Passive status unchanged
1= Error_Passive status changed</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELO</name>
              <description>Error Logging Overflow
0= CAN Error Logging Counter did not overflow
1= Overflow of CAN Error Logging Counter occurred</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEU</name>
              <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. Controlled by input signal m_can_aeim_berr[1] generated by an optional external parity / ECC logic attached to the Message RAM.
An uncorrected Message RAM bit error sets CCCR.INIT to ‘1’. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected (e.g. parity logic)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEC</name>
              <description>Bit Error Corrected
Message RAM bit error detected and corrected. Controlled by input signal m_can_aeim_berr[0] generated by an optional external parity / ECC logic attached to the Message RAM.
0= No bit error detected when reading from Message RAM
1= Bit error detected and corrected (e.g. ECC)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRX</name>
              <description>Message stored to Dedicated Rx Buffer
The flag is set whenever a received message has been stored into a dedicated Rx Buffer.
0= No Rx Buffer updated
1= At least one received message stored into an Rx Buffer</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOO</name>
              <description>Timeout Occurred
0= No timeout
1= Timeout reached</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAF</name>
              <description>Message RAM Access Failure
The flag is set, when the Rx Handler
.has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message
storage is aborted and the Rx Handler starts processing of the following message.
.was not able to write a message to the Message RAM. In this case message storage is aborted.
In both cases the FIFO put index is not updated resp. the New Data flag for a dedicated Rx Buffer is not set, a partly stored message is overwritten when the next message is stored to this location.
The flag is also set when the Tx Handler was not able to read a message from the Message RAM in time. In this case message transmission is aborted. In case of a Tx Handler access failure the
M_CAN is switched into Restricted Operation Mode (see Section 3.1.5). To leave Restricted Operation Mode, the Host CPU has to reset CCCR.ASM.
0= No Message RAM access failure occurred
1= Message RAM access failure occurred</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSW</name>
              <description>Timestamp Wraparound
0= No timestamp counter wrap-around
1= Timestamp counter wrapped around</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFL</name>
              <description>Tx Event FIFO Element Lost
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFF</name>
              <description>Tx Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFW</name>
              <description>Tx Event FIFO Watermark Reached
0= Tx Event FIFO fill level below watermark
1= Tx Event FIFO fill level reached watermark</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFN</name>
              <description>Tx Event FIFO New Entry
0= Tx Event FIFO unchanged
1= Tx Handler wrote Tx Event FIFO element</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFE</name>
              <description>Tx FIFO Empty
0= Tx FIFO non-empty
1= Tx FIFO empty</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCF</name>
              <description>Transmission Cancellation Finished
0= No transmission cancellation finished
1= Transmission cancellation finished</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TC</name>
              <description>Transmission Completed
0= No transmission completed
1= Transmission completed</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPM</name>
              <description>High Priority Message
0= No high priority message received
1= High priority message received</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1L</name>
              <description>Rx FIFO 1 Message Lost
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1F</name>
              <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1W</name>
              <description>Rx FIFO 1 Watermark Reached
0= Rx FIFO 1 fill level below watermark
1= Rx FIFO 1 fill level reached watermark</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1N</name>
              <description>Rx FIFO 1 New Message
0= No new message written to Rx FIFO 1
1= New message written to Rx FIFO 1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0L</name>
              <description>Rx FIFO 0 Message Lost
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0F</name>
              <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0W</name>
              <description>Rx FIFO 0 Watermark Reached
0= Rx FIFO 0 fill level below watermark
1= Rx FIFO 0 fill level reached watermark</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0N</name>
              <description>Rx FIFO 0 New Message
0= No new message written to Rx FIFO 0
1= New message written to Rx FIFO 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IE</name>
          <description>interrupt enable</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARAE</name>
              <description>Access to Reserved Address Enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEDE</name>
              <description>Protocol Error in Data Phase Enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEAE</name>
              <description>Protocol Error in Arbitration Phase Enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDIE</name>
              <description>Watchdog Interrupt Enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOE</name>
              <description>Bus_Off Status Interrupt Enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EWE</name>
              <description>Warning Status Interrupt Enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Error Passive Interrupt Enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELOE</name>
              <description>Error Logging Overflow Interrupt Enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEUE</name>
              <description>Bit Error Uncorrected Interrupt Enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BECE</name>
              <description>Bit Error Corrected Interrupt Enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRXE</name>
              <description>Message stored to Dedicated Rx Buffer Interrupt Enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOOE</name>
              <description>Timeout Occurred Interrupt Enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAFE</name>
              <description>Message RAM Access Failure Interrupt Enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSWE</name>
              <description>Timestamp Wraparound Interrupt Enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFLE</name>
              <description>Tx Event FIFO Event Lost Interrupt Enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFFE</name>
              <description>Tx Event FIFO Full Interrupt Enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFWE</name>
              <description>Tx Event FIFO Watermark Reached Interrupt Enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFNE</name>
              <description>Tx Event FIFO New Entry Interrupt Enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFEE</name>
              <description>Tx FIFO Empty Interrupt Enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCFE</name>
              <description>Transmission Cancellation Finished Interrupt Enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCE</name>
              <description>Transmission Completed Interrupt Enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPME</name>
              <description>High Priority Message Interrupt Enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1LE</name>
              <description>Rx FIFO 1 Message Lost Interrupt Enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1FE</name>
              <description>Rx FIFO 1 Full Interrupt Enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1WE</name>
              <description>Rx FIFO 1 Watermark Reached Interrupt Enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1NE</name>
              <description>Rx FIFO 1 New Message Interrupt Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0LE</name>
              <description>Rx FIFO 0 Message Lost Interrupt Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0FE</name>
              <description>Rx FIFO 0 Full Interrupt Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0WE</name>
              <description>Rx FIFO 0 Watermark Reached Interrupt Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0NE</name>
              <description>Rx FIFO 0 New Message Interrupt Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ILS</name>
          <description>interrupt line select</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARAL</name>
              <description>Access to Reserved Address Line</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEDL</name>
              <description>Protocol Error in Data Phase Line</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEAL</name>
              <description>Protocol Error in Arbitration Phase Line</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDIL</name>
              <description>Watchdog Interrupt Line</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOL</name>
              <description>Bus_Off Status Interrupt Line</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EWL</name>
              <description>Warning Status Interrupt Line</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPL</name>
              <description>Error Passive Interrupt Line</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELOL</name>
              <description>Error Logging Overflow Interrupt Line</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEUL</name>
              <description>Bit Error Uncorrected Interrupt Line</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BECL</name>
              <description>Bit Error Corrected Interrupt Line</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRXL</name>
              <description>Message stored to Dedicated Rx Buffer Interrupt Line</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOOL</name>
              <description>Timeout Occurred Interrupt Line</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAFL</name>
              <description>Message RAM Access Failure Interrupt Line</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSWL</name>
              <description>Timestamp Wraparound Interrupt Line</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFLL</name>
              <description>Tx Event FIFO Event Lost Interrupt Line</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFFL</name>
              <description>Tx Event FIFO Full Interrupt Line</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFWL</name>
              <description>Tx Event FIFO Watermark Reached Interrupt Line</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFNL</name>
              <description>Tx Event FIFO New Entry Interrupt Line</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFEL</name>
              <description>Tx FIFO Empty Interrupt Line</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCFL</name>
              <description>Transmission Cancellation Finished Interrupt Line</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCL</name>
              <description>Transmission Completed Interrupt Line</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPML</name>
              <description>High Priority Message Interrupt Line</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1LL</name>
              <description>Rx FIFO 1 Message Lost Interrupt Line</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1FL</name>
              <description>Rx FIFO 1 Full Interrupt Line</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1WL</name>
              <description>Rx FIFO 1 Watermark Reached Interrupt Line</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1NL</name>
              <description>Rx FIFO 1 New Message Interrupt Line</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0LL</name>
              <description>Rx FIFO 0 Message Lost Interrupt Line</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0FL</name>
              <description>Rx FIFO 0 Full Interrupt Line</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0WL</name>
              <description>Rx FIFO 0 Watermark Reached Interrupt Line</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0NL</name>
              <description>Rx FIFO 0 New Message Interrupt Line</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ILE</name>
          <description>interrupt line enable</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>EINT1</name>
              <description>Enable Interrupt Line 1
0= Interrupt line m_can_int1 disabled
1= Interrupt line m_can_int1 enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EINT0</name>
              <description>Enable Interrupt Line 0
0= Interrupt line m_can_int0 disabled
1= Interrupt line m_can_int0 enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GFC</name>
          <description>global filter configuration</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>ANFS</name>
              <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANFE</name>
              <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RRFS</name>
              <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RRFE</name>
              <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIDFC</name>
          <description>standard ID filter configuration</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFC</resetMask>
          <fields>
            <field>
              <name>LSS</name>
              <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
&gt;128= Values greater than 128 are interpreted as 128</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FLSSA</name>
              <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XIDFC</name>
          <description>extended ID filter configuration</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007FFFFC</resetMask>
          <fields>
            <field>
              <name>LSE</name>
              <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
&gt;64= Values greater than 64 are interpreted as 64</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FLESA</name>
              <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XIDAM</name>
          <description>extended id and mask</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x1FFFFFFF</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>EIDM</name>
              <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message ID of a received frame.
 Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all bits set to one the mask is not active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>29</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPMS</name>
          <description>high priority message status</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>FLST</name>
              <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIDX</name>
              <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MSI</name>
              <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIDX</name>
              <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = ‘1’.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NDAT1</name>
          <description>new data1</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ND1</name>
              <description>New Data[31:0]
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective Rx Buffer has been updated from a received frame.
The flags remain set until the Host clears them.A flag is cleared by writing a ’1’ to the corresponding bit position. Writing a ’0’ has no effect. A hard reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NDAT2</name>
          <description>new data2</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ND2</name>
              <description>New Data[63:32]
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective Rx Buffer has been updated from a received frame.
The flags remain set until the Host clears them. A flag is cleared by writing a ’1’ to the corresponding bit position. Writing a ’0’ has no effect. A hard reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0C</name>
          <description>rx fifo 0 configuration</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7FFFFC</resetMask>
          <fields>
            <field>
              <name>F0OM</name>
              <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0WM</name>
              <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
&gt;64= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0S</name>
              <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
&gt;64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0SA</name>
              <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0S</name>
          <description>rx fifo 0 status</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x033F3F7F</resetMask>
          <fields>
            <field>
              <name>RF0L</name>
              <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero
Note: Overwriting the oldest message when RXF0C.F0OM = ‘1’ will not set this flag.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0F</name>
              <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0PI</name>
              <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0GI</name>
              <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0FL</name>
              <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0A</name>
          <description>rx fifo0 acknowledge</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>F0AI</name>
              <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the buffer index of the last element read from Rx FIFO 0 to F0AI.
This will set the Rx FIFO 0 Get Index RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXBC</name>
          <description>rx buffer configuration</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFC</resetMask>
          <fields>
            <field>
              <name>RBSA</name>
              <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).Also used to reference debug messages A,B,C.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1C</name>
          <description>rx fifo1 configuration</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7FFFFC</resetMask>
          <fields>
            <field>
              <name>F1OM</name>
              <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1WM</name>
              <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
&gt;64= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1S</name>
              <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
&gt;64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1SA</name>
              <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1S</name>
          <description>rx fifo1 status</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC33F3F7F</resetMask>
          <fields>
            <field>
              <name>DMS</name>
              <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RF1L</name>
              <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero
Note: Overwriting the oldest message when RXF1C.F1OM = ‘1’ will not set this flag.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1F</name>
              <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1PI</name>
              <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1GI</name>
              <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1FL</name>
              <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1A</name>
          <description>rx fifo 1 acknowledge</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>F1AI</name>
              <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the buffer index of the last element read from Rx FIFO 1 to F1AI.
This will set the Rx FIFO 1 Get Index RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXESC</name>
          <description>rx buffer/fifo element size configuration</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000777</resetMask>
          <fields>
            <field>
              <name>RBDS</name>
              <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1DS</name>
              <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0DS</name>
              <description>Rx FIFO 0 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field
Note: In case the data field size of an accepted CAN frame exceeds the data field size configured for the matching Rx Buffer or Rx FIFO,
only the number of bytes as configured by RXESC are stored to the Rx Buffer resp. Rx FIFO element. The rest of the frame’s data field is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBC</name>
          <description>tx buffer configuration</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7F3FFFFC</resetMask>
          <fields>
            <field>
              <name>TFQM</name>
              <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFQS</name>
              <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
&gt;32= Values greater than 32 are interpreted as 32</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NDTB</name>
              <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
&gt;32= Values greater than 32 are interpreted as 32</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TBSA</name>
              <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).
Note: Be aware that the sum of TFQS and NDTB may be not greater than 32. There is no check for erroneous configurations. The Tx Buffers section in the Message RAM starts with the dedicated Tx Buffers.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXFQS</name>
          <description>tx fifo/queue status</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F1F3F</resetMask>
          <fields>
            <field>
              <name>TFQF</name>
              <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFQPI</name>
              <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFGI</name>
              <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
(TXBC.TFQM = ‘1’).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFFL</name>
              <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when Tx Queue operation is configured (TXBC.TFQM = ‘1’)
Note: In case of mixed configurations where dedicated Tx Buffers are combined with a Tx FIFO or a Tx Queue, the Put and Get Indices indicate the number of the Tx Buffer starting with
the first dedicated Tx Buffers.
Example: For a configuration of 12 dedicated Tx Buffers and a Tx FIFO of 20 Buffers a Put Index of 15 points to the fourth buffer of the Tx FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXESC</name>
          <description>tx buffer element size configuration</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>TBDS</name>
              <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field
Note: In case the data length code DLC of a Tx Buffer element is configured to a value higher than the Tx Buffer data field size TXESC.TBDS, the bytes not defined by the Tx Buffer are transmitted as “0xCC” (padding bytes).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBRP</name>
          <description>tx buffer request pending</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRP</name>
              <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set, a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register TXBRP. In case a transmission has already been started when a cancellation is requested,
this is done at the end of the transmission, regardless whether the transmission was successful or not. The cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signalled via TXBCF
? after successful transmission together with the corresponding TXBTO bit
? when the transmission has not yet been started at the point of cancellation
? when the transmission has been aborted due to lost arbitration
? when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending
Note: TXBRP bits which are set while a Tx scan is in progress are not considered during this particular Tx scan. In case a cancellation is requested for such a Tx Buffer, this Add Request is cancelled immediately, the corresponding TXBRP bit is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBAR</name>
          <description>tx buffer add request</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AR</name>
              <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a ‘1’ will set the corresponding Add Request bit; writing a ‘0’ has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan process has completed.
0= No transmission request added
1= Transmission requested added
Note: If an add request is applied for a Tx Buffer with pending transmission request (corresponding TXBRP bit already set), this add request is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCR</name>
          <description>tx buffer cancellation request</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CR</name>
              <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a ‘1’ will set the corresponding Cancellation Request bit; writing a ‘0’ has no impact.
This enables the Host to set cancellation requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBTO</name>
          <description>tx buffer transmission occurred</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TO</name>
              <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission is requested by writing a ‘1’ to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCF</name>
          <description>tx buffer cancellation finished</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CF</name>
              <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding TXBRP bit is cleared after a cancellation was requested via TXBCR.
In case the corresponding TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a new transmission is requested by writing a ‘1’ to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBTIE</name>
          <description>tx buffer transmission interrupt enable</description>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIE</name>
              <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCIE</name>
          <description>tx buffer cancellation finished interrupt enable</description>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFIE</name>
              <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFC</name>
          <description>tx event fifo configuration</description>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3FFFFC</resetMask>
          <fields>
            <field>
              <name>EFWM</name>
              <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
&gt;32= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFS</name>
              <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
&gt;32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS - 1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFSA</name>
              <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFS</name>
          <description>tx event fifo status</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x031F1F3F</resetMask>
          <fields>
            <field>
              <name>TEFL</name>
              <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFF</name>
              <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFPI</name>
              <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFGI</name>
              <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFFL</name>
              <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFA</name>
          <description>tx event fifo acknowledge</description>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>EFAI</name>
              <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TS_SEL0,TS_SEL1,TS_SEL2,TS_SEL3,TS_SEL4,TS_SEL5,TS_SEL6,TS_SEL7,TS_SEL8,TS_SEL9,TS_SEL10,TS_SEL11,TS_SEL12,TS_SEL13,TS_SEL14,TS_SEL15</dimIndex>
          <name>TS_SEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TS</name>
              <description>Timestamp Word TS
default can save 16 timestamps with 32bit;
if ts64_en is set, then work at 64bit mode, can save 8 timestamps with 01/23/45….</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CREL</name>
          <description>core release register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REL</name>
              <description>Core Release
One digit, BCD-coded</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STEP</name>
              <description>Step of Core Release
One digit, BCD-coded.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SUBSTEP</name>
              <description>Sub-step of Core Release
One digit, BCD-coded</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>YEAR</name>
              <description>Timestamp Year
One digit, BCD-coded. This field is set by generic parameter on
synthesis.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MON</name>
              <description>Timestamp Month
Two digits, BCD-coded. This field is set by generic parameter
on synthesis.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DAY</name>
              <description>Timestamp Day
Two digits, BCD-coded. This field is set by generic parameter
on synthesis.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCFG</name>
          <description>timestamp configuration</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF0F</resetMask>
          <fields>
            <field>
              <name>TBPRE</name>
              <description>Timebase Prescaler
0x00 to 0xFF
The value by which the oscillator frequency is divided for
generating the timebase counter clock. Valid values for the
Timebase Prescaler are 0 to 255. The actual interpretation by
the hardware of this value is such that one more than the value
programmed here is used. Affects only the TSU internal
timebase. When the internal timebase is excluded by synthesis,
TBPRE[7:0] is fixed to 0x00, the Timestamp Prescaler is not
used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN64</name>
              <description>set to use 64bit timestamp.
when enabled, tsu can save up to 8 different timestamps, TS(k) and TS(k+1) are used for one 64bit timestamp, k is 0~7.
TSP can be used to select different one</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCP</name>
              <description>Select Capturing Position
0: Capture Timestamp at EOF
1: Capture Timestamp at SOF</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TBCS</name>
              <description>Timebase Counter Select
When the internal timebase is excluded by synthesis, TBCS is
fixed to ‘1’.
0: Timestamp value captured from internal timebase counter,
 ATB.TB[31:0] is the internal timbase counter
1: Timestamp value captured from input tsu_tbin[31:0],ATB.TB[31:0] is tsu_tbin[31:0]</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSUE</name>
              <description>Timestamp Unit Enable
0: TSU disabled
1: TSU enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSS1</name>
          <description>timestamp status1</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSL</name>
              <description>Timestamp Lost
Each Timestamp register (TS0-TS15) is assigned one bit. The bits are set when the timestamp stored in the related Timestamp register was overwritten before it was read.
Reading a Timestamp register resets the related bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSN</name>
              <description>Timestamp New
Each Timestamp register (TS0-TS15) is assigned one bit. The bits are set when a timestamp was stored in the related
Timestamp register. Reading a Timestamp register resets the related bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSS2</name>
          <description>timestamp status2</description>
          <addressOffset>0x24c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>TSP</name>
              <description>Timestamp Pointer
The Timestamp Pointer is incremented by one each time a timestamp is captured. From its maximum value (3, 7, or 15
depending on number_ts_g), it is incremented to 0.
Value also signalled on output m_can_tsp[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ATB</name>
          <description>actual timebase</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TB</name>
              <description>timebase for timestamp generation 31-0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ATBH</name>
          <description>actual timebase high</description>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TBH</name>
              <description>timebase for timestamp generation 63-32</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GLB_CTL</name>
          <description>global control</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xE0000003</resetMask>
          <fields>
            <field>
              <name>M_CAN_STBY</name>
              <description>m_can standby control</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STBY_CLR_EN</name>
              <description>m_can standby clear control
0:controlled by software by standby bit[bit31]
1:auto clear standby by hardware when rx data is  0</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STBY_POL</name>
              <description>standby polarity selection</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN_SEL</name>
              <description>external timestamp select. each CAN block has 4 timestamp input, this register is used to select one of them as timestame if TSCFG.TBCS is set to 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GLB_STATUS</name>
          <description>global status</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000C</resetMask>
          <fields>
            <field>
              <name>M_CAN_INT1</name>
              <description>m_can interrupt status1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>M_CAN_INT0</name>
              <description>m_can interrupt status0</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>640</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639</dimIndex>
          <name>MESSAGE_BUFF[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>m_can message buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN1</name>
      <description>MCAN1</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0084000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN2</name>
      <description>MCAN2</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0088000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN3</name>
      <description>MCAN3</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf008c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>WDG0</name>
      <description>WDG0</description>
      <groupName>WDOG</groupName>
      <baseAddress>0xf0090000</baseAddress>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>RSTTIME</name>
              <description>The time interval of the reset stage:
0: Clock period x 2^7
1: Clock period x 2^8
2: Clock period x 2^9
3: Clock period x 2^10
4: Clock period x 2^11
5: Clock period x 2^12
6: Clock period x 2^13
7: Clock period x 2^14</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTIME</name>
              <description>The timer interval of the interrupt stage:
0: Clock period x 2^6
1: Clock period x 2^8
2: Clock period x 2^10
3: Clock period x 2^11
4: Clock period x 2^12
5: Clock period x 2^13
6: Clock period x 2^14
7: Clock period x 2^15
8: Clock period x 2^17
9: Clock period x 2^19
10: Clock period x 2^21
11: Clock period x 2^23
12: Clock period x 2^25
13: Clock period x 2^27
14: Clock period x 2^29
15: Clock period x 2^31</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTEN</name>
              <description>Enable or disable the watchdog reset
0: Disable
1: Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Enable or disable the watchdog interrupt
0: Disable
1: Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSEL</name>
              <description>Clock source of timer:
0: EXTCLK
1: PCLK</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Enable or disable the watchdog timer
0: Disable
1: Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Restart</name>
          <description>Restart Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>RESTART</name>
              <description>Write the magic number
ATCWDT200_RESTART_NUM to restart the
watchdog timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WrEn</name>
          <description>Write Protection Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>WEN</name>
              <description>Write the magic code to disable the write
protection of the Control Register and the
Restart Register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>St</name>
          <description>Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>INTEXPIRED</name>
              <description>The status of the watchdog interrupt timer
0: timer is not expired yet
1: timer is expired</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="WDG0">
      <name>WDG1</name>
      <description>WDG1</description>
      <groupName>WDOG</groupName>
      <baseAddress>0xf0094000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="WDG0">
      <name>PWDG</name>
      <description>PWDG</description>
      <groupName>WDOG</groupName>
      <baseAddress>0xf40e8000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MBX0A</name>
      <description>MBX0A</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <description>Command Registers</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXRESET</name>
              <description>Reset TX Fifo and word.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BARCTL</name>
              <description>Bus Access Response Control, when bit 15:14=
00: no bus error will be generated,      no wait for fifo write when fifo full and  no wait for word/fifo read when word message invalid or fifo empty; or when write to word/fifo message will be ignored.
 01: bus error will be generated when: 1, access invalid address; 2, write to ready only addr; 3, write to fulled fifo or valid message; 4, read from a emptied fifo/word message.
10: no error will be generated, but bus will wait when 1, write to fulled fifo/reg message; 2, read from a emptied fifo/reg message; write to word message will overwrite the existing reg value enven word message are still valid; read from invalid word message will read out last read out message data.happen.
11: reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEIE</name>
              <description>Bus Error Interrupt Enable, will enable the interrupt for any bus  error as described in the SR bit 13 to bit 8.
1, enable the bus access error interrupt.
0, disable the bus access error interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFMAIE</name>
              <description>TX FIFO message available interrupt enable.
1, enable the TX FIFO massage available interrupt.
0, disable the TX FIFO message available interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFMEIE</name>
              <description>TX FIFO message empty interrupt enable.
1, enable the TX FIFO massage empty interrupt.
0, disable the TX FIFO message empty interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMAIE</name>
              <description>RX FIFO message available interrupt enable.
1, enable the RX FIFO massage available interrupt.
0, disable the RX FIFO message available interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMFIE</name>
              <description>RX fifo message full interrupt enable.
1, enable the RX fifo message full interrupt.
0, disable the RX fifo message full interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWMEIE</name>
              <description>TX word message empty interrupt enable.
1, enable the TX word massage empty interrupt.
0, disable the TX word message empty interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWMVIE</name>
              <description>RX word message valid interrupt enable.
1, enable the RX word massage valid interrupt.
0, disable the RX word message valid interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <description>Status Registers</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x000000E2</resetValue>
          <resetMask>0xFFFF3FFF</resetMask>
          <fields>
            <field>
              <name>RFVC</name>
              <description>RX FIFO valid message count</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFEC</name>
              <description>TX FIFO empty message word count</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERRRE</name>
              <description>bus Error for read when rx word message are still invalid, this bit is W1C bit.
1, read from word message when the word message are still invalid will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EWTRF</name>
              <description>bus Error for write when tx word message are still valid, this bit is W1C bit.
1, write to word message when the word message are still valid will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRFE</name>
              <description>bus Error for read when rx fifo empty, this bit is W1C bit.
1, read from a empty rx fifo will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EWTFF</name>
              <description>bus Error for write when tx fifo full, this bit is W1C bit.
1, write to a fulled tx fifo will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EAIVA</name>
              <description>bus Error for Accessing Invalid Address; this bit is W1C bit.
1, read and write to invalid address in the bus of this block, will set this bit.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EW2RO</name>
              <description>bus Error for Write to Read Only address; this bit is W1C bit.
1, write to read only address happened in the bus of this block.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFMA</name>
              <description>TX FIFO Message slot available, the 4x32 TX FIFO message buffer to the other core full, will not trigger any interrupt.
1, TXFIFO message buffer has slot available
0, no slot available (fifo full)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFME</name>
              <description>TX FIFO Message Empty, no any data in the message FIFO buffer from other core, will not trigger any interrupt.message from other core.
1, no any message data in TXFIFO from other core.
0, there are some data in the 4x32 TX FIFO from other core yet.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMA</name>
              <description>RX FIFO Message Available, available data in the 4x32 TX FIFO message buffer to the other core, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, no any data in the 4x32 TXFIFO message buffer.
0, there are some data in the  the 4x32 TXFIFO message buffer already.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RFMF</name>
              <description>RX FIFO Message Full, message from other core; will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, the other core had written 4x32 message in the RXFIFO.
0, no 4x32 RX FIFO message from other core yet.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TWME</name>
              <description>TX word message empty, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, means this core had write word message to TXREG.
0, means no valid word message in the TXREG yet.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RWMV</name>
              <description>RX word message valid, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, the other core had written word message in the RXREG.
0, no valid word message yet in the RXREG.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXREG</name>
          <description>Transmit word message to other core.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXREG</name>
              <description>Transmit word message to other core.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXREG</name>
          <description>Receive word message from other core.</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXREG</name>
              <description>Receive word message from other core.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TXFIFO0</dimIndex>
          <name>TXWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFIFO</name>
              <description>TXFIFO for sending message to other core, FIFO size, 4x32
can write one of the word address to push data to the FIFO;
can also use 4x32 burst write from 0x010 to push 4 words to the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>RXFIFO0</dimIndex>
          <name>RXWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFIFO</name>
              <description>RXFIFO for receiving message from other core, FIFO size, 4x32
can read one of the word address to pop data to the FIFO;
can also use 4x32 burst read from 0x020 to read 4 words from the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX0B</name>
      <description>MBX0B</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a4000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX1A</name>
      <description>MBX1A</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a8000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX1B</name>
      <description>MBX1B</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00ac000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PTPC</name>
      <description>PTPC</description>
      <groupName>PTPC</groupName>
      <baseAddress>0xf00b0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3004</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x1000</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>PTPC[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>Ctrl0</name>
            <description>Control Register 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>SUBSEC_DIGITAL_ROLLOVER</name>
                <description>Format for ns counter rollover,
1-digital, overflow time 1000000000/0x3B9ACA00
0-binary, overflow time  0x7FFFFFFF</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_KEEP</name>
                <description>set  will keep capture snap till software read capt_snapl.
If this bit is set, software should read capt_snaph first to avoid wrong result.
If this bit is cleared, capture result will be updated at each capture event</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_POS_EN</name>
                <description>set will use posege of input capture signal to latch timestamp value</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_NEG_EN</name>
                <description>No description available</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>COMP_EN</name>
                <description>set to enable compare, will be cleared by HW when compare event triggered</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UPDATE_TIMER</name>
                <description>update timer with +/- ts_updt, pulse, clear after set</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>INIT_TIMER</name>
                <description>initial timer with ts_updt, pulse, clear after set</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>FINE_COARSE_SEL</name>
                <description>0: coarse update, ns counter add ss_incr[7:0] each clk
1: fine update, ns counter add ss_incr[7:0] each time addend counter overflow</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMER_ENABLE</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ctrl1</name>
            <description>Control Register 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>SS_INCR</name>
                <description>constant value used to add ns counter;
such as for 50MHz timer clock, set it to 8'd20</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>timeh</name>
            <description>timestamp high</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMESTAMP_HIGH</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>timel</name>
            <description>timestamp low</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMESTAMP_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ts_updth</name>
            <description>timestamp update high</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC_UPDATE</name>
                <description>together with ts_updtl, used to initial or update timestamp</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ts_updtl</name>
            <description>timestamp update low</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADD_SUB</name>
                <description>1 for sub; 0 for add, used only at update</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NS_UPDATE</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>31</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>addend</name>
            <description>No description available</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDEND</name>
                <description>used in fine update mode only</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tarh</name>
            <description>No description available</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TARGET_TIME_HIGH</name>
                <description>used for generate compare signal if enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tarl</name>
            <description>No description available</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TARGET_TIME_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>pps_ctrl</name>
            <description>No description available</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>PPS_CTRL</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>capt_snaph</name>
            <description>No description available</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPT_SNAP_HIGH</name>
                <description>take snapshot for input capture signal, at pos or neg or both;
the result can be kept or updated at each event according to cfg0.bit8</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>capt_snapl</name>
            <description>No description available</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPT_SNAP_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>time_sel</name>
          <description>No description available</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>CAN3_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN2_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN1_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN0_TIME_SEL</name>
              <description>set to use ptpc1 for canx
clr to use ptpc0 for canx</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_sts</name>
          <description>No description available</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00070007</resetMask>
          <fields>
            <field>
              <name>COMP_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PPS_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>COMP_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PPS_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_en</name>
          <description>No description available</description>
          <addressOffset>0x2008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00070007</resetMask>
          <fields>
            <field>
              <name>COMP_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ptpc_can_ts_sel</name>
          <description>No description available</description>
          <addressOffset>0x3000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>TSU_TBIN3_SEL</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN2_SEL</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN1_SEL</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN0_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description>CRC</description>
      <groupName>CRC</groupName>
      <baseAddress>0xf00b8000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x200</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>CHN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>pre_set</name>
            <description>&amp;index0 pre set for crc setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>PRE_SET</name>
                <description>0: no pre set
1: CRC32
2: CRC32-AUTOSAR
3: CRC16-CCITT
4: CRC16-XMODEM
5: CRC16-MODBUS
1: CRC32
2: CRC32-autosar
3: CRC16-ccitt
4: CRC16-xmodem
5: CRC16-modbus
6: crc16_dnp
7: crc16_x25
8: crc16_usb
9: crc16_maxim
10: crc16_ibm
11: crc8_maxim
12: crc8_rohc
13: crc8_itu
14: crc8
15: crc5_usb</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>clr</name>
            <description>chn&amp;index0 clear crc result and setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>CLR</name>
                <description>write 1 to clr crc setting and result for its channel.
always read 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>poly</name>
            <description>chn&amp;index0 poly</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POLY</name>
                <description>poly setting</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>init_data</name>
            <description>chn&amp;index0 init_data</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INIT_DATA</name>
                <description>initial data of CRC</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>xorout</name>
            <description>chn&amp;index0 xorout</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>XOROUT</name>
                <description>XOR for CRC result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>misc_setting</name>
            <description>chn&amp;index0 misc_setting</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0101013F</resetMask>
            <fields>
              <field>
                <name>BYTE_REV</name>
                <description>0: no wrap input byte order
1: wrap input byte order</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_OUT</name>
                <description>0: no wrap output bit order
1: wrap output bit order</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_IN</name>
                <description>0: no wrap input bit order
1: wrap input bit order</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POLY_WIDTH</name>
                <description>crc data length</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>data</name>
            <description>chn&amp;index0 data</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>data for crc</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>result</name>
            <description>chn&amp;index0 result</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESULT</name>
                <description>crc result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAMUX</name>
      <description>DMAMUX</description>
      <groupName>DMAMUX</groupName>
      <baseAddress>0xf00c0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>HDMA_MUX0,HDMA_MUX1,HDMA_MUX2,HDMA_MUX3,HDMA_MUX4,HDMA_MUX5,HDMA_MUX6,HDMA_MUX7,XDMA_MUX0,XDMA_MUX1,XDMA_MUX2,XDMA_MUX3,XDMA_MUX4,XDMA_MUX5,XDMA_MUX6,XDMA_MUX7</dimIndex>
          <name>MUXCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>DMA Mux Channel Enable
Enables the channel for DMA Mux. The DMA has separate channel enables/disables, which should be
used to disable or reconfigure a DMA channel.
0b - DMA Mux channel is disabled
1b - DMA Mux channel is enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOURCE</name>
              <description>DMA Channel Source
Specifies which DMA source, if any, is routed to a particular DMA channel. See the "DMA MUX Mapping"</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HDMA</name>
      <description>HDMA</description>
      <groupName>DMA</groupName>
      <baseAddress>0xf00c4000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x13c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IDMisc</name>
          <description>ID Misc</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00008000</resetMask>
          <fields>
            <field>
              <name>IDLE_FLAG</name>
              <description>DMA Idle Flag
0 - DMA is busy
1 - DMA is dile</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMACfg</name>
          <description>DMAC Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>CHAINXFR</name>
              <description>Chain transfer
0x0: Chain transfer is not configured
0x1: Chain transfer is configured</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REQSYNC</name>
              <description>DMA request synchronization. The DMA request synchronization should be configured to avoid signal integrity problems when the request signal is not clocked by the system bus clock, which the DMA control logic operates in. If the request synchronization is not configured, the request signal is sampled directly without synchronization.
0x0: Request synchronization is not configured
0x1: Request synchronization is configured</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATAWIDTH</name>
              <description>AXI bus data width
0x0: 32 bits
0x1: 64 bits
0x2: 128 bits
0x3: 256 bits</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDRWIDTH</name>
              <description>AXI bus address width
0x18: 24 bits
0x19: 25 bits
...
0x40: 64 bits
Others: Invalid</description>
              <bitOffset>17</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CORENUM</name>
              <description>DMA core number
0x0: 1 core
0x1: 2 cores</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSNUM</name>
              <description>AXI bus interface number
0x0: 1 AXI bus
0x1: 2 AXI busses</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REQNUM</name>
              <description>Request/acknowledge pair number
0x0: 0 pair
0x1: 1 pair
0x2: 2 pairs
...
0x10: 16 pairs</description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFODEPTH</name>
              <description>FIFO depth
0x4: 4 entries
0x8: 8 entries
0x10: 16 entries
0x20: 32 entries
Others: Invalid</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHANNELNUM</name>
              <description>Channel number
0x1: 1 channel
0x2: 2 channels
...
0x8: 8 channels
Others: Invalid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMACtrl</name>
          <description>DMAC Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Software reset control. Write 1 to this bit to reset the DMA core and disable all channels.
Note: The software reset may cause the in-completion of AXI transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ChAbort</name>
          <description>Channel Abort Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHABORT</name>
              <description>Write 1 to bit n to abort channel n. The bits should only be set when the corresponding channels are enabled. Otherwise, the writes will be ignored for channels that are not enabled. (N: Number of channels)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntStatus</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>TC</name>
              <description>The terminal count status, one bit per channel. The terminal count status is set when a channel transfer finishes without the abort or error event.
0x0: Channel n has no terminal count status
0x1: Channel n has terminal count status</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>The abort status of channel, one bit per channel. The abort status is set when a channel transfer is aborted.
0x0: Channel n has no abort status
0x1: Channel n has abort status</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERROR</name>
              <description>The error status, one bit per channel. The error status is set when a channel transfer encounters the following error events:
- Bus error
- Unaligned address
- Unaligned transfer width
- Reserved configuration
0x0: Channel n has no error status
0x1: Channel n has error status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ChEN</name>
          <description>Channel Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>Alias of the Enable field of all ChnCtrl registers</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>ch0,ch1,ch2,ch3,ch4,ch5,ch6,ch7</dimIndex>
          <name>CHCTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x40</addressOffset>
          <register>
            <name>Ctrl</name>
            <description>Channel n Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xEFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SRCBUSINFIDX</name>
                <description>Bus interface index that source data is read from
0x0: Data is read from bus interface 0
0x1: Data is read from bus interface</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTBUSINFIDX</name>
                <description>Bus interface index that destination data is written to
0x0: Data is written to bus interface 0
0x1: Data is written to bus interface 1</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIORITY</name>
                <description>Channel priority level
0x0: Lower priority
0x1: Higher priority</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCBURSTSIZE</name>
                <description>Source burst size. This field indicates the number of transfers before DMA channel re-arbitration.
The burst transfer byte number is (SrcBurstSize * SrcWidth).
0x0: 1 transfer
0x1: 2 transfers
0x2: 4 transfers
0x3: 8 transfers
0x4: 16 transfers
0x5: 32 transfers
0x6: 64 transfers
0x7: 128 transfers
0x8: 256 transfers
0x9:512 transfers
0xa: 1024 transfers
0xb-0xf: Reserved, setting this field with a reserved value triggers the error exception
for XDMA, the maximum allowed value is 0xa; for HDMA, the maximum allowed value is 0x7</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCWIDTH</name>
                <description>Source transfer width
0x0: Byte transfer
0x1: Half-word transfer
0x2: Word transfer
0x3: Double word transfer
0x4: Quad word transfer
0x5: Eight word transfer
0x6-x7: Reserved, setting this field with a reserved value triggers the error exception
for XDMA, the maximum allowed value is 0x3, for HDMA, the maximum allowed value is 0x2</description>
                <bitOffset>21</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTWIDTH</name>
                <description>Destination transfer width.
Both the total transfer byte number and the burst transfer byte number should be aligned to the destination transfer width; otherwise the error event will be triggered. For example, destination transfer width should be set as byte transfer if total transfer byte is not aligned to half-word.
See field SrcBurstSize above for the definition of burst transfer byte number and section 3.2.8 for the definition of the total transfer byte number.
0x0: Byte transfer
0x1: Half-word transfer
0x2: Word transfer
0x3: Double word transfer
0x4: Quad word transfer
0x5: Eight word transfer
0x6-x7: Reserved, setting this field with a reserved value triggers the error exception
for XDMA, the maximum allowed value is 0x3, for HDMA, the maximum allowed value is 0x2</description>
                <bitOffset>18</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCMODE</name>
                <description>Source DMA handshake mode
0x0: Normal mode
0x1: Handshake mode</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTMODE</name>
                <description>Destination DMA handshake mode
0x0: Normal mode
0x1: Handshake mode</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCADDRCTRL</name>
                <description>Source address control
0x0: Increment address
0x1: Decrement address
0x2: Fixed address
0x3: Reserved, setting the field with this value triggers the error exception</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTADDRCTRL</name>
                <description>Destination address control
0x0: Increment address
0x1: Decrement address
0x2: Fixed address
0x3: Reserved, setting the field with this value triggers the error exception</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCREQSEL</name>
                <description>Source DMA request select. Select the request/ack handshake pair that the source device is connected to.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTREQSEL</name>
                <description>Destination DMA request select. Select the request/ack handshake pair that the destination device is connected to.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTABTMASK</name>
                <description>Channel abort interrupt mask
0x0: Allow the abort interrupt to be triggered
0x1: Disable the abort interrupt</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTERRMASK</name>
                <description>Channel error interrupt mask
0x0: Allow the error interrupt to be triggered
0x1: Disable the error interrupt</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTTCMASK</name>
                <description>Channel terminal count interrupt mask
0x0: Allow the terminal count interrupt to be triggered
0x1: Disable the terminal count interrupt</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Channel enable bit
0x0: Disable
0x1: Enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TranSize</name>
            <description>Channel n Transfer Size Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRANSIZE</name>
                <description>Total transfer size from source. The total number of transferred bytes is (TranSize * SrcWidth). This register is cleared when the DMA transfer is done.
If a channel is enabled with zero total transfer size, the error event will be triggered and the transfer will be terminated.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SrcAddr</name>
            <description>Channel n Source Address Low Part Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SRCADDRL</name>
                <description>Low part of the source starting address. When the transfer completes, the value of {SrcAddrH,SrcAddrL} is updated to the ending address.
This address must be aligned to the source transfer size; otherwise, an error event will be triggered.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SrcAddrH</name>
            <description>Channel n Source Address High Part Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SRCADDRH</name>
                <description>High part of the source starting address. When the transfer completes, the value of {SrcAddrH,SrcAddrL} is updated to the ending address.
This register exists only when the address bus width is wider than 32 bits.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DstAddr</name>
            <description>Channel n Destination Address Low Part Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DSTADDRL</name>
                <description>Low part of the destination starting address. When the transfer completes, the value of {DstAddrH,DstAddrL} is updated to the ending address.
This address must be aligned to the destination transfer size; otherwise the error event will be triggered.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DstAddrH</name>
            <description>Channel n Destination Address High Part Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DSTADDRH</name>
                <description>High part of the destination starting address. When the transfer completes, the value of {DstAddrH,DstAddrL} is updated to the ending address.
This address must be aligned to the destination transfer size; otherwise the error event will be triggered.
This register exists only when the address bus width is wider than 32 bits.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LLPointer</name>
            <description>Channel n Linked List Pointer Low Part Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFF9</resetMask>
            <fields>
              <field>
                <name>LLPOINTERL</name>
                <description>Low part of the pointer to the next descriptor. The pointer must be double word aligned.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>29</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LLDBUSINFIDX</name>
                <description>Bus interface index that the next descriptor is read from
0x0: The next descriptor is read from bus interface 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LLPointerH</name>
            <description>Channel n Linked List Pointer High Part Register</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LLPOINTERH</name>
                <description>High part of the pointer to the next descriptor.
This register exists only when the address bus width is wider than 32 bits.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="HDMA">
      <name>XDMA</name>
      <description>XDMA</description>
      <groupName>DMA</groupName>
      <baseAddress>0xf3048000</baseAddress>
    </peripheral>
    <peripheral>
      <name>RNG</name>
      <description>RNG</description>
      <groupName>RNG</groupName>
      <baseAddress>0xf00c8000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CMD</name>
          <description>Command Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>Soft Reset, Perform a software reset of the RNG This bit is self-clearing.
0 Do not perform a software reset.
1 Software reset</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRERR</name>
              <description>Clear the Error, clear the errors in the ESR register and the RNG interrupt. This bit is self-clearing.
0 Do not clear the errors and the interrupt.
1 Clear the errors and the interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRINT</name>
              <description>Clear the Interrupt, clear the RNG interrupt if an error is not present. This bit is self-clearing.
0 Do not clear the interrupt.
1 Clear the interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GENSD</name>
              <description>Generate Seed, when both ST and GS triggered, ST first and GS next.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLFCHK</name>
              <description>Self Test, when both ST and GS triggered, ST first and GS next.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MIRQERR</name>
              <description>Mask Interrupt Request for Error</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIRQDN</name>
              <description>Mask Interrupt Request for Done Event, asks the interrupts generated upon the completion of the seed and self-test modes. The status of these jobs can be viewed by:
• Reading the STA and viewing the seed done and the self-test done bits (STA[SDN, STDN]).
• Viewing the RNG_CMD for the generate-seed or the self-test bits (CMD[GS,ST]) being set, indicating that the operation is still taking place.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTRSD</name>
              <description>Auto Reseed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FUFMOD</name>
              <description>FIFO underflow response mode
00 Return all zeros and set the ESR[FUFE].
01 Return all zeros and set the ESR[FUFE].
10 Generate the bus transfer error
11 Generate the interrupt and return all zeros (overrides the CTRL[MASKERR]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCPF</name>
              <description>Self Check Pass Fail</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FUNCERR</name>
              <description>Error was detected, check ESR register for details</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FSIZE</name>
              <description>Fifo Size, it is 5 in this design.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRNNU</name>
              <description>Fifo Level, Indicates the number of random words currently in the output FIFO</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NSDDN</name>
              <description>New seed done.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FSDDN</name>
              <description>1st Seed done
When "1", Indicates that the RNG generated the first seed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCDN</name>
              <description>Self Check Done
Indicates whether Self Test is done or not. Can be cleared by the hardware reset or a new self test is
initiated by setting the CMD[ST].
0 Self test not completed
1 Completed a self test since the last reset.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RSDREQ</name>
              <description>Reseed needed
Indicates that the RNG needs to be reseeded. This is done by setting the CMD[GS], or
automatically if the CTRL[ARS] is set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE</name>
              <description>Idle, the RNG is in the idle mode, and internal clocks are disabled, in this mode, access to the FIFO is allowed. Once the FIFO is empty, the RNGB fills the FIFO and then enters idle mode again.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>when 1, means the RNG engine is busy for seeding or random number generation, self test and so on.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERR</name>
          <description>Error Registers</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF3F</resetMask>
          <fields>
            <field>
              <name>FUFE</name>
              <description>FIFO access error(underflow)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCKERR</name>
              <description>Self-test error
Indicates that the RNG failed the most recent self test. This bit is sticky and can only be reset by a
hardware reset or by writing 1 to the CMD[CE]</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FO2B</name>
          <description>FIFO out to bus/cpu</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FO2B</name>
              <description>SW read the FIFO output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>FO2S0,FO2S1,FO2S2,FO2S3,FO2S4,FO2S5,FO2S6,FO2S7</dimIndex>
          <name>R2SK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FO2S0</name>
              <description>FIFO out to KMAN, will be SDP engine key.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>KEYM</name>
      <description>KEYM</description>
      <groupName>KEYM</groupName>
      <baseAddress>0xf00cc000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x50</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SFK0,SFK1,SFK2,SFK3,SFK4,SFK5,SFK6,SFK7</dimIndex>
          <name>SOFTMKEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>software symmetric key
key will be scambled to 4 variants for software to use, and replicable on same chip.
scramble keys are chip different, and not replicable on different chip
must be write sequencely from 0 - 7, otherwise key value will be treated as all 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SPK0,SPK1,SPK2,SPK3,SPK4,SPK5,SPK6,SPK7</dimIndex>
          <name>SOFTPKEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>software asymmetric key
key is derived from scrambles of fuse private key, software input key, SRK, and system security status.
This key os read once, sencondary read will read out 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEC_KEY_CTL</name>
          <description>secure key generation</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80011117</resetMask>
          <fields>
            <field>
              <name>LOCK_SEC_CTL</name>
              <description>block secure state key setting being changed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SK_VAL</name>
              <description>session key valid
0: session key is all 0's and not usable
1: session key is valid</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SMK_SEL</name>
              <description>software symmetric key selection
0: use origin value in software symmetric key
1: use scramble version of software symmetric key</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMK_SEL</name>
              <description>batt symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FMK_SEL</name>
              <description>fuse symmetric key selection
0: use scramble version of fuse symmetric key
1: use alnertave scramble of fuse symmetric key</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_SEL</name>
              <description>secure symmtric key synthesize setting, key is a XOR of following
bit0: fuse mk, 0: not selected, 1:selected
bit1: zmk from batt, 0: not selected, 1:selected
bit2: software key 0: not selected, 1:selected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NSC_KEY_CTL</name>
          <description>non-secure key generation</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80011117</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC_CTL</name>
              <description>block non-secure state key setting being changed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SK_VAL</name>
              <description>session key valid
0: session key is all 0's and not usable
1: session key is valid</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SMK_SEL</name>
              <description>software symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMK_SEL</name>
              <description>batt symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FMK_SEL</name>
              <description>fuse symmetric key selection
0: use scramble version of fuse symmetric key
1: use origin value in fuse symmetric key</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_SEL</name>
              <description>non-secure symmtric key synthesize setting, key is a XOR of following
bit0: fuse mk, 0: not selected, 1:selected
bit1: zmk from batt, 0: not selected, 1:selected
bit2: software key 0: not selected, 1:selected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RNG</name>
          <description>Random number interface behavior</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>BLOCK_RNG_XOR</name>
              <description>block RNG_XOR bit from changing, if this bit is written to 1, it will hold 1 until next reset
0: RNG_XOR can be changed by software
1: RNG_XOR ignore software change from software</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RNG_XOR</name>
              <description>control how SFK is accepted from random number generator
0: SFK value replaced by random number input
1: SFK value exclusive or with random number input,this help generate random number using 2 rings inside RNG</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>READ_CONTROL</name>
          <description>key read out control</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>BLOCK_PK_READ</name>
              <description>asymmetric key readout control, if this bit is written to 1, it will hold 1 until next reset
0: key can be read out
1: key cannot be read out</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK_SMK_READ</name>
              <description>symmetric key readout control, if this bit is written to 1, it will hold 1 until next reset
0: key can be read out
1: key cannot be read out</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM0</name>
      <description>PWM0</description>
      <groupName>PWM</groupName>
      <baseAddress>0xf0200000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x428</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>unlk</name>
          <description>Shadow registers unlock register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHUNLK</name>
              <description>write 0xB0382607 to unlock the shadow registers of register offset from 0x04 to 0x78,
otherwise the shadow registers can not be written.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sta</name>
          <description>Counter start register</description>
          <alternateGroup>UNION_STA</alternateGroup>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XSTA</name>
              <description>pwm timer counter extended start point, should back to this value after reach xrld</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>pwm timer counter start value
 sta/rld will be loaded from shadow register to work register at main counter reload time, or software write unlk.shunlk</description>
              <bitOffset>4</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sta_hrpwm</name>
          <description>Counter start register</description>
          <alternateGroup>UNION_STA</alternateGroup>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>STA</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rld</name>
          <description>Counter reload register</description>
          <alternateGroup>UNION_RLD</alternateGroup>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XRLD</name>
              <description>timeout counter extended reload point, counter will reload to xsta after reach this point</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLD</name>
              <description>pwm timer counter reload value</description>
              <bitOffset>4</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rld_hrpwm</name>
          <description>Counter reload register</description>
          <alternateGroup>UNION_RLD</alternateGroup>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RLD</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLD_HR</name>
              <description>pwm timer counter reload value at high resolution, only exist if hwpwm is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>CMP[%s]</name>
          <description>no description available</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XCMP</name>
              <description>extended counter compare value</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP</name>
              <description>clock counter compare value, the compare output is 0 at default, set to 1 when compare value meet,
and clr to 0 when timer reload. Software can invert the output by setting chan_cfg.out_polarity.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPHLF</name>
              <description>half clock counter compare value</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPJIT</name>
              <description>jitter counter compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>CMP_HRPWM[%s]</name>
          <description>no description available</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_HR</name>
              <description>high resolution compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>frcmd</name>
          <description>Force output mode register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>FRCMD</name>
              <description>2bit for each PWM output channel (0-7);
00:  force output 0
01:  force output 1
10:  output highz
11:  no force</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>shlk</name>
          <description>Shadow registers lock register</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SHLK</name>
              <description>write 1 to lock all shawdow register, write access is not permitted</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>CHCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>CMPSELEND</name>
              <description>assign the last comparator for this output channel</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPSELBEG</name>
              <description>assign the first comparator for this output channel</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPOL</name>
              <description>output polarity, set to 1 will invert the output</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcr</name>
          <description>Global control register</description>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFDFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAULTI3EN</name>
              <description>1- enable the internal fault input 3</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTI2EN</name>
              <description>1- enable the internal fault input 2</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTI1EN</name>
              <description>1- enable the internal fault input 1</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTI0EN</name>
              <description>1- enable the internal fault input 0</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEBUGFAULT</name>
              <description>1- enable debug mode output protection</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRCPOL</name>
              <description>polarity of input pwm_force,
1- active low
0- active high</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HWSHDWEDG</name>
              <description>When hardware event is selected as shawdow register effective time and the select comparator is configured as input capture mode.
This bit assign its which edge is used as compare shadow register hardware load event.
1- Falling edge
0- Rising edge</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPSHDWSEL</name>
              <description>This bitfield select one of the comparators as hardware event time to load comparator shadow registers</description>
              <bitOffset>19</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTRECEDG</name>
              <description>When hardware load is selected as output fault recover trigger and the selected channel is capture mode.
This bit assign its effective edge of fault recover trigger.
1- Falling edge
0- Rising edge</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTRECHWSEL</name>
              <description>Selec one of the 24 comparators as fault output recover trigger.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTE1EN</name>
              <description>1- enable the external fault input 1</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTE0EN</name>
              <description>1- enable the external fault input 0</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTEXPOL</name>
              <description>external fault polarity
1-active low
0-active high</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLDSYNCEN</name>
              <description>1- pwm timer counter reset to reload value (rld) by synci is enabled</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>1- enable the pwm timer counter
0- stop the pwm timer counter</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTCLR</name>
              <description>1- Write 1 to clear the fault condition. The output will recover if FAULTRECTIME is set to 2b'11.
User should write 1 to this bit after the active FAULT signal de-assert and before it re-assert again.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XRLDSYNCEN</name>
              <description>1- pwm timer extended counter (xcnt) reset to extended reload value (xrld) by synci is enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HR_PWM_EN</name>
              <description>set to enable high resolution pwm, trig_cmp, start/reload register will have different definition.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMERRESET</name>
              <description>set to clear current timer(total 28bit, main counter and tmout_count ). Auto clear</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRCTIME</name>
              <description>This bit field select the force effective time
00:  force immediately
01:  force at main counter reload time
10:  force at FRCSYNCI
11: no force</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SWFRC</name>
              <description>1- write 1 to enable software force, if the frcsrcsel is set to 0, force will take effect</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>shcr</name>
          <description>Shadow register control register</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CNT_UPDATE_RELOAD</name>
              <description>set to update counter working register at reload point, clear to use cnt_update_time as old version.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNT_UPDATE_EDGE</name>
              <description>0 for posedge; 1 for negedge if hardware trigger time is selected for update_time, and selected channel is capture mode, for counter shadow registers</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_UPDATE_EDGE</name>
              <description>0 for posedge; 1 for negedge if hardware trigger time is selected for update_time, and selected channel is capture mode, for FRCMD shadow registers</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRCSHDWSEL</name>
              <description>This bitfield select one of the comparators as hardware event time to load FRCMD shadow registers</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTSHDWSEL</name>
              <description>This bitfield select one of the comparators as hardware event time to load the counter related shadow registers (STA and RLD)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTSHDWUPT</name>
              <description>This bitfield select when the counter related shadow registers (STA and RLD) will be loaded to its work register
00:  after software set shlk bit of shlk register
01:  immediately after the register being modified
10:  after hardware event assert, user can select one of the comparators to generate this hardware event.
       The comparator can be either output compare mode or input capture mode.
11:  after SHSYNCI assert</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHLKEN</name>
              <description>1- enable shadow registers lock feature,
0- disable shadow registers lock, shlk bit will always be 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>CAPPOS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>CAPPOS</name>
              <description>counter value captured at input posedge</description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cnt</name>
          <description>Counter</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XCNT</name>
              <description>current extended counter  value</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNT</name>
              <description>current clock counter  value</description>
              <bitOffset>4</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>CAPNEG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPNEG</name>
              <description>counter value captured at input signal falling edge</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cntcopy</name>
          <description>Counter copy</description>
          <addressOffset>0x1f0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XCNT</name>
              <description>current extended counter  value</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNT</name>
              <description>current clock counter  value</description>
              <bitOffset>4</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>PWMCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>HR_UPDATE_MODE</name>
              <description>0: update the hr value for the first edge at reload point;
1: update the hr value for the first edge at the last edge;
all others will be updated at previous edge
for pair mode, only pwm_cfg 0/2/4/6 are used</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OEN</name>
              <description>PWM output enable
1- output is enabled
0- output is disabled</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRCSHDWUPT</name>
              <description>This bitfield select when the FRCMD shadow register will be loaded to its work register
00:  after software set shlk bit of shlk register
01:  immediately after the register being modified
10:  after hardware event assert, user can select one of the comparators to generate this hardware event.
       The comparator can be either output compare mode or input capture mode.
11:  after SHSYNCI assert</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTMODE</name>
              <description>This bitfield defines the PWM output status when fault condition happen
00:  force output 0
01:  force output 1
1x:  output highz</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULTRECTIME</name>
              <description>This bitfield select when to recover PWM output after fault condition removed.
00:  immediately
01:  after pwm timer counter reload time
10:  after hardware event assert, user can select one of the comparators to generate this hardware event.
       The comparator can be either output compare mode or input capture mode.
11:  after software write faultclr bit in GCR register</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRCSRCSEL</name>
              <description>Select sources for force output
0- force output is enabled when FRCI assert
1- force output is enabled by software write swfrc to 1</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAIR</name>
              <description>1- PWM output is in pair mode. Note the two PWM outputs need to be both set to pair mode.
0- PWM output is in indepandent mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEADAREA</name>
              <description>This bitfield define the PWM pair deadarea length. The unit is 0.5 cycle. The minimum length of deadarea is 1 cycle.
Note: user should configure pair bit and this bitfield before PWM output is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sr</name>
          <description>Status register</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAULTF</name>
              <description>fault condition flag</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>XRLDF</name>
              <description>extended reload flag, this flag set when xcnt count to xrld value or when SYNCI assert</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HALFRLDF</name>
              <description>half reload flag, this flag set when cnt count to rld/2</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RLDF</name>
              <description>reload flag, this flag set when cnt count to rld value or when SYNCI assert</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CMPFX</name>
              <description>comparator output compare or input capture flag</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irqen</name>
          <description>Interrupt request enable register</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAULTIRQE</name>
              <description>fault condition interrupt enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XRLDIRQE</name>
              <description>extended reload flag interrupt enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALFRLDIRQE</name>
              <description>half reload flag interrupt enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLDIRQE</name>
              <description>reload flag interrupt enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIRQEX</name>
              <description>comparator output compare or input capture flag interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dmaen</name>
          <description>DMA request enable register</description>
          <addressOffset>0x22c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAULTEN</name>
              <description>fault condition DMA request enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XRLDEN</name>
              <description>extended reload flag DMA request enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALFRLDEN</name>
              <description>half reload flag DMA request enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLDEN</name>
              <description>reload flag DMA request enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPENX</name>
              <description>comparator output compare or input capture flag DMA request enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>cmpcfg0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>CMPCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>XCNTCMPEN</name>
              <description>This bitfield enable the comparator to compare xcmp with xcnt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPSHDWUPT</name>
              <description>This bitfield select when the comparator shadow register will be loaded to its work register
00:  after software set shlk bit of shlk register
01:  immediately after the register being modified
10:  after hardware event assert, user can select one of the comparators to generate this hardware event.
       The comparator can be either output compare mode or input capture mode.
11:  after SHSYNCI assert</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMODE</name>
              <description>comparator mode
0- output compare mode
1- input capture mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>ANASTS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CALON</name>
              <description>calibration status.
will be set by hardware after setting cal_start.
cleared after calibration finished</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>hrpwm_cfg</name>
          <description>hrpwm config register</description>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CAL_SW_EN</name>
              <description>software calibration enable, internal use only</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_START</name>
              <description>calibration start.
software setting this bit to start calibration process.
each bit for one channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ana_cfg0</name>
          <description>analog config register</description>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010000</resetMask>
          <fields>
            <field>
              <name>CAL_SW_TRIG_H</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="PWM0">
      <name>PWM1</name>
      <description>PWM1</description>
      <groupName>PWM</groupName>
      <baseAddress>0xf0210000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="PWM0">
      <name>PWM2</name>
      <description>PWM2</description>
      <groupName>PWM</groupName>
      <baseAddress>0xf0220000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="PWM0">
      <name>PWM3</name>
      <description>PWM3</description>
      <groupName>PWM</groupName>
      <baseAddress>0xf0230000</baseAddress>
    </peripheral>
    <peripheral>
      <name>HALL0</name>
      <description>HALL0</description>
      <groupName>HALL</groupName>
      <baseAddress>0xf0204000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x88</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>cr</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8001083F</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>1- load ucnt, vcnt, wcnt and tmrcnt into their read registers. Hardware auto-clear; read as 0</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SNAPEN</name>
              <description>1- load ucnt, vcnt, wcnt and tmrcnt into their snap registers when snapi input assert</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCNT</name>
              <description>set to reset all counter and related snapshots</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phcfg</name>
          <description>Phase configure register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLYSEL</name>
              <description>This bit select delay start time:
1- start counting delay after pre-trigger
0- start counting delay after u,v,w toggle</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLYCNT</name>
              <description>delay clock cycles number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>wdgcfg</name>
          <description>Watchdog configure register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDGEN</name>
              <description>1- enable wdog counter</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDGTO</name>
              <description>watch dog timeout value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>uvwcfg</name>
          <description>U,V,W configure register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FFFFFF</resetMask>
          <fields>
            <field>
              <name>PRECNT</name>
              <description>the clock cycle number which the pre flag will set before the next uvw transition</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trgoen</name>
          <description>Trigger output enable register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE00000</resetMask>
          <fields>
            <field>
              <name>WDGEN</name>
              <description>1- enable trigger output when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHUPTEN</name>
              <description>1- enable trigger output when phupt flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHPREEN</name>
              <description>1- enable trigger output when phpre flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHDLYEN</name>
              <description>1- enable trigger output when phdly flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UFEN</name>
              <description>1- enable trigger output when u flag set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VFEN</name>
              <description>1- enable trigger output when v flag set</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WFEN</name>
              <description>1- enable trigger output when w flag set</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>readen</name>
          <description>Read event enable register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE00000</resetMask>
          <fields>
            <field>
              <name>WDGEN</name>
              <description>1-  load counters to their read registers when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHUPTEN</name>
              <description>1-  load counters to their read registers when phupt flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHPREEN</name>
              <description>1-  load counters to their read registers when phpre flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHDLYEN</name>
              <description>1-  load counters to their read registers when phdly flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UFEN</name>
              <description>1-  load counters to their read registers when u flag set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VFEN</name>
              <description>1-  load counters to their read registers when v flag set</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WFEN</name>
              <description>1-  load counters to their read registers when w flag set</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dmaen</name>
          <description>DMA enable register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE00000</resetMask>
          <fields>
            <field>
              <name>WDGEN</name>
              <description>1-  generate dma request when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHUPTEN</name>
              <description>1-  generate dma request when phupt flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHPREEN</name>
              <description>1-  generate dma request when phpre flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHDLYEN</name>
              <description>1-  generate dma request when phdly flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UFEN</name>
              <description>1-  generate dma request when u flag set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VFEN</name>
              <description>1-  generate dma request when v flag set</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WFEN</name>
              <description>1-  generate dma request when w flag set</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sr</name>
          <description>Status register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE00000</resetMask>
          <fields>
            <field>
              <name>WDGF</name>
              <description>watchdog count timeout flag</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHUPTF</name>
              <description>phase update flag, will set when any of u, v, w signal toggle</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHPREF</name>
              <description>phase update pre flag, will set PRECNT cycles before any of u, v, w signal toggle</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHDLYF</name>
              <description>phase update delay flag, will set DLYCNT cycles after any of u, v, w signal toggle or after the phpre flag depands on DLYSEL setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UF</name>
              <description>u flag, will set when u signal toggle</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VF</name>
              <description>v flag, will set when v signal toggle</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WF</name>
              <description>w flag, will set when w signal toggle</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irqen</name>
          <description>Interrupt request enable register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE00000</resetMask>
          <fields>
            <field>
              <name>WDGIE</name>
              <description>1-  generate interrupt request when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHUPTIE</name>
              <description>1-  generate interrupt request when phupt flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHPREIE</name>
              <description>1-  generate interrupt request when phpre flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHDLYIE</name>
              <description>1-  generate interrupt request when phdly flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UFIE</name>
              <description>1-  generate interrupt request when u flag set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VFIE</name>
              <description>1-  generate interrupt request when v flag set</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WFIE</name>
              <description>1-  generate interrupt request when w flag set</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>current,read,snap0,snap1</dimIndex>
          <name>COUNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x30</addressOffset>
          <register>
            <name>w</name>
            <description>W counter</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0FFFFFFF</resetMask>
            <fields>
              <field>
                <name>WCNT</name>
                <description>wcnt counter</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>v</name>
            <description>V counter</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xCFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VCNT</name>
                <description>vcnt counter</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>u</name>
            <description>U counter</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIR</name>
                <description>1- reverse rotation
0- forward rotation</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>USTAT</name>
                <description>this bit indicate U state</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>VSTAT</name>
                <description>this bit indicate V state</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WSTAT</name>
                <description>this bit indicate W state</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>UCNT</name>
                <description>ucnt counter</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tmr</name>
            <description>Timer counter</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER</name>
                <description>32 bit free run timer</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>u,v,w</dimIndex>
          <name>HIS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x70</addressOffset>
          <register>
            <name>his0</name>
            <description>history register 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UHIS0</name>
                <description>copy of ucnt when u signal transition from 0 to 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>his1</name>
            <description>history register 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UHIS1</name>
                <description>copy of ucnt when u signal transition from 1 to 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="HALL0">
      <name>HALL1</name>
      <description>HALL1</description>
      <groupName>HALL</groupName>
      <baseAddress>0xf0214000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HALL0">
      <name>HALL2</name>
      <description>HALL2</description>
      <groupName>HALL</groupName>
      <baseAddress>0xf0224000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HALL0">
      <name>HALL3</name>
      <description>HALL3</description>
      <groupName>HALL</groupName>
      <baseAddress>0xf0234000</baseAddress>
    </peripheral>
    <peripheral>
      <name>QEI0</name>
      <description>QEI0</description>
      <groupName>QEI</groupName>
      <baseAddress>0xf0208000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x80</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>cr</name>
          <description>Control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077F3F</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>1- load phcnt, zcnt, spdcnt and tmrcnt into their read registers. Hardware auto-clear; read as 0</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HRSTSPD</name>
              <description>1- reset spdcnt when H assert</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HRSTPH</name>
              <description>1- reset phcnt when H assert</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HRSTZ</name>
              <description>1- reset zcnt when H assert</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSESPD</name>
              <description>1- pause spdcnt when PAUSE assert</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSEPH</name>
              <description>1- pause phcnt when PAUSE assert</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSEZ</name>
              <description>1- pause zcnt when PAUSE assert</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HRDIR1</name>
              <description>1- HOMEF will set at H rising edge when dir == 1 (negative rotation direction)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HRDIR0</name>
              <description>1- HOMEF will set at H rising edge when dir == 0 (positive rotation direction)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HFDIR1</name>
              <description>1- HOMEF will set at H falling edge when dir == 1 (negative rotation direction)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HFDIR0</name>
              <description>1- HOMEF will set at H falling edge when dir == 1 (positive rotation direction)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAPEN</name>
              <description>1- load phcnt, zcnt, spdcnt and tmrcnt into their snap registers when snapi input assert</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCNT</name>
              <description>1- reset zcnt, spdcnt and tmrcnt to 0. reset phcnt to phidx</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENCTYP</name>
              <description>00-abz; 01-pd; 10-ud; 11-reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phcfg</name>
          <description>Phase configure register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007FFFFF</resetMask>
          <fields>
            <field>
              <name>ZCNTCFG</name>
              <description>1- zcnt will increment when phcnt upcount to phmax, decrement when phcnt downcount to 0
0- zcnt will increment or decrement when Z input assert</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHCALIZ</name>
              <description>1- phcnt will set to phidx when Z input assert</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHMAX</name>
              <description>maximum phcnt number, phcnt will rollover to 0 when it upcount to phmax</description>
              <bitOffset>0</bitOffset>
              <bitWidth>21</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>wdgcfg</name>
          <description>Watchdog configure register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDGEN</name>
              <description>1- enable wdog counter</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDGTO</name>
              <description>watch dog timeout value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phidx</name>
          <description>Phase index register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>PHIDX</name>
              <description>phcnt reset value, phcnt will reset to phidx when phcaliz set to 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>21</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trgoen</name>
          <description>Tigger output enable register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>WDGFEN</name>
              <description>1- enable trigger output when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEFEN</name>
              <description>1- enable trigger output when homef flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPFEN</name>
              <description>1- enable trigger output when poscmpf flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHFEN</name>
              <description>1- enable trigger output when zphf flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>readen</name>
          <description>Read event enable register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>WDGFEN</name>
              <description>1- load counters to their read registers when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEFEN</name>
              <description>1- load counters to their read registers when homef flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPFEN</name>
              <description>1- load counters to their read registers when poscmpf flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHFEN</name>
              <description>1- load counters to their read registers when zphf flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>zcmp</name>
          <description>Z comparator</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZCMP</name>
              <description>zcnt postion compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phcmp</name>
          <description>Phase comparator</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xE01FFFFF</resetMask>
          <fields>
            <field>
              <name>ZCMPDIS</name>
              <description>1- postion compare not include zcnt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCMPDIS</name>
              <description>1- postion compare not include rotation direction</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRCMP</name>
              <description>0- position compare need positive rotation
1- position compare need negative rotation</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHCMP</name>
              <description>phcnt position compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>21</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>spdcmp</name>
          <description>Speed comparator</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPDCMP</name>
              <description>spdcnt position compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dmaen</name>
          <description>DMA request enable register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>WDGFEN</name>
              <description>1- generate dma request when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEFEN</name>
              <description>1- generate dma request when homef flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPFEN</name>
              <description>1- generate dma request when poscmpf flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHFEN</name>
              <description>1- generate dma request when zphf flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sr</name>
          <description>Status register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>WDGF</name>
              <description>watchdog flag</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEF</name>
              <description>home flag</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPF</name>
              <description>postion compare match flag</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHF</name>
              <description>z input flag</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irqen</name>
          <description>Interrupt request register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>WDGIE</name>
              <description>1- generate interrupt when wdg flag set</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOMEIE</name>
              <description>1- generate interrupt when homef flag set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSCMPIE</name>
              <description>1- generate interrupt when poscmpf flag set</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZPHIE</name>
              <description>1- generate interrupt when zphf flag set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>current,read,snap0,snap1</dimIndex>
          <name>COUNT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x30</addressOffset>
          <register>
            <name>z</name>
            <description>Z counter</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ZCNT</name>
                <description>zcnt value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ph</name>
            <description>Phase counter</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x461FFFFF</resetMask>
            <fields>
              <field>
                <name>DIR</name>
                <description>1- reverse rotation
0- forward rotation</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ASTAT</name>
                <description>1- a input is high
0- a input is low</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BSTAT</name>
                <description>1- b input is high
0- b input is low</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PHCNT</name>
                <description>phcnt value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>21</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>spd</name>
            <description>Speed counter</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xEFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIR</name>
                <description>1- reverse rotation
0- forward rotation</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ASTAT</name>
                <description>1- a input is high
0- a input is low</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BSTAT</name>
                <description>1- b input is high
0- b input is low</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPDCNT</name>
                <description>spdcnt value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tmr</name>
            <description>Timer counter</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TMRCNT</name>
                <description>32 bit free run timer</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>spdhis0,spdhis1,spdhis2,spdhis3</dimIndex>
          <name>SPDHIS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPDHIS0</name>
              <description>copy of spdcnt, load from spdcnt after any transition from a = low, b = low</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="QEI0">
      <name>QEI1</name>
      <description>QEI1</description>
      <groupName>QEI</groupName>
      <baseAddress>0xf0218000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="QEI0">
      <name>QEI2</name>
      <description>QEI2</description>
      <groupName>QEI</groupName>
      <baseAddress>0xf0228000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="QEI0">
      <name>QEI3</name>
      <description>QEI3</description>
      <groupName>QEI</groupName>
      <baseAddress>0xf0238000</baseAddress>
    </peripheral>
    <peripheral>
      <name>TRGM0</name>
      <description>TRGM0</description>
      <groupName>TRGM</groupName>
      <baseAddress>0xf020c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x404</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>20</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PWM_IN0,PWM_IN1,PWM_IN2,PWM_IN3,PWM_IN4,PWM_IN5,PWM_IN6,PWM_IN7,TRGM_IN0,TRGM_IN1,TRGM_IN2,TRGM_IN3,TRGM_IN4,TRGM_IN5,TRGM_IN6,TRGM_IN7,TRGM_IN8,TRGM_IN9,TRGM_IN10,TRGM_IN11</dimIndex>
          <name>FILTCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>OUTINV</name>
              <description>1- Filter will invert the output
0- Filter will not invert the output</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>This bitfields defines the filter mode
000-bypass;
100-rapid change mode;
101-delay filter mode;
110-stalbe low mode;
111-stable high mode</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNCEN</name>
              <description>set to enable sychronization input signal with TRGM clock</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTLEN</name>
              <description>This bitfields defines the filter counter length.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>67</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TRGM_OUT0,TRGM_OUT1,TRGM_OUT2,TRGM_OUT3,TRGM_OUT4,TRGM_OUT5,TRGM_OUT6,TRGM_OUT7,TRGM_OUT8,TRGM_OUT9,TRGM_OUT10,TRGM_OUT11,TRGM_OUTX0,TRGM_OUTX1,PWM_SYNCI,PWM_FRCI,PWM_FRCSYNCI,PWM_SHRLDSYNCI,PWM_FAULTI0,PWM_FAULTI1,PWM_FAULTI2,PWM_FAULTI3,PWM_IN8,PWM_IN9,PWM_IN10,PWM_IN11,PWM_IN12,PWM_IN13,PWM_IN14,PWM_IN15,PLA_IN0,PLA_IN1,PLA_IN2,PLA_IN3,PLA_IN4,PLA_IN5,PLA_IN6,PLA_IN7,QEI_A,QEI_B,QEI_Z,QEI_H,QEI_PAUSE,QEI_SNAPI,HALL_U,HALL_V,HALL_W,HALL_SNAPI,ADC0_STRGI,ADC1_STRGI,ADC2_STRGI,rsv51,ADCx_PTRGI0A,ADCx_PTRGI0B,ADCx_PTRGI0C,GPTMRa_SYNCI,GPTMRa_IN2,GPTMRa_IN3,DAC_BUF_TRIG,DAC0_STEP_TRIG,DAC1_STEP_TRIG,CMPx_WIN,CAN_PTPC0_CAP,CAN_PTPC1_CAP,SDFM_EVT0,SDFM_EVT1,SDFM_EVT2,SDFM_EVT3</dimIndex>
          <name>TRGOCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>OUTINV</name>
              <description>1- Invert the output</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FEDG2PEN</name>
              <description>1- The selected input signal falling edge will be convert to an pulse on output.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REDG2PEN</name>
              <description>1- The selected input signal rising edge will be convert to an pulse on output.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGOSEL</name>
              <description>This bitfield selects one of the TRGM inputs as output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>DMACFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>DMASRCSEL</name>
              <description>This field selects one of the DMA requests as the DMA request output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GCR</name>
          <description>General Control Register</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>TRGOPEN</name>
              <description>The bitfield enable the TRGM outputs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="TRGM0">
      <name>TRGM1</name>
      <description>TRGM1</description>
      <groupName>TRGM</groupName>
      <baseAddress>0xf021c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TRGM0">
      <name>TRGM2</name>
      <description>TRGM2</description>
      <groupName>TRGM</groupName>
      <baseAddress>0xf022c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TRGM0">
      <name>TRGM3</name>
      <description>TRGM3</description>
      <groupName>TRGM</groupName>
      <baseAddress>0xf023c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PLA0</name>
      <description>PLA0</description>
      <groupName>PLA</groupName>
      <baseAddress>0xf020e000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x420</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x70</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>CHN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>AOI_16to8_00,AOI_16to8_01,AOI_16to8_02,AOI_16to8_03,AOI_16to8_04,AOI_16to8_05,AOI_16to8_06,AOI_16to8_07</dimIndex>
            <name>AOI_16TO8[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AOI_16TO8_15</name>
                <description>select value for AOI_16to8_15.
0: 0.
1: 1st_filter_out[15].
2: ~1st_filter_out[15].
3: 1</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_14</name>
                <description>select value for AOI_16to8_14.
0: 0.
1: 1st_filter_out[14].
2: ~1st_filter_out[14].
3: 1</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_13</name>
                <description>select value for AOI_16to8_13.
0: 0.
1: 1st_filter_out[13].
2: ~1st_filter_out[13].
3: 1</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_12</name>
                <description>select value for AOI_16to8_12.
0: 0.
1: 1st_filter_out[12].
2: ~1st_filter_out[12].
3: 1</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_11</name>
                <description>select value for AOI_16to8_11.
0: 0.
1: 1st_filter_out[11].
2: ~1st_filter_out[11].
3: 1</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_10</name>
                <description>select value for AOI_16to8_10.
0: 0.
1: 1st_filter_out[10].
2: ~1st_filter_out[10].
3: 1</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_9</name>
                <description>select value for AOI_16to8_9.
0: 0.
1: 1st_filter_out[9].
2: ~1st_filter_out[9].
3: 1</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_8</name>
                <description>select value for AOI_16to8_8.
0: 0.
1: 1st_filter_out[8].
2: ~1st_filter_out[8].
3: 1</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_7</name>
                <description>select value for AOI_16to8_7.
0: 0.
1: 1st_filter_out[7].
2: ~1st_filter_out[7].
3: 1</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_6</name>
                <description>select value for AOI_16to8_6.
0: 0.
1: 1st_filter_out[6].
2: ~1st_filter_out[6].
3: 1</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_5</name>
                <description>select value for AOI_16to8_5.
0: 0.
1: 1st_filter_out[5].
2: ~1st_filter_out[5].
3: 1</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_4</name>
                <description>select value for AOI_16to8_4.
0: 0.
1: 1st_filter_out[4].
2: ~1st_filter_out[4].
3: 1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_3</name>
                <description>select value for AOI_16to8_3.
0: 0.
1: 1st_filter_out[3].
2: ~1st_filter_out[3].
3: 1</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_2</name>
                <description>select value for AOI_16to8_2.
0: 0.
1: 1st_filter_out[2].
2: ~1st_filter_out[2].
3: 1</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_1</name>
                <description>select value for AOI_16to8_1.
0: 0.
1: 1st_filter_out[1].
2: ~1st_filter_out[1].
3: 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_16TO8_0</name>
                <description>select value for AOI_16to8_0.
0: 0.
1: 1st_filter_out[0].
2: ~1st_filter_out[0].
3: 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AOI_8to7_00_01</name>
            <description>CHN&amp;index0 AOI_16to8_00_01 OR logic cfg</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AOI_8TO7_01_7</name>
                <description>select value for AOI_8to7_01_7.
0: 0.
1: 2nd_filter_out[7].
2: ~2nd_filter_out[7].
3: 1</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_01_6</name>
                <description>select value for AOI_8to7_01_6.
0: 0.
1: 2nd_filter_out[6].
2: ~2nd_filter_out[6].
3: 1</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_01_5</name>
                <description>select value for AOI_8to7_01_5.
0: 0.
1: 2nd_filter_out[5].
2: ~2nd_filter_out[5].
3: 1</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_01_4</name>
                <description>select value for AOI_8to7_01_4.
0: 0.
1: 2nd_filter_out[4].
2: ~2nd_filter_out[4].
3: 1</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_01_3</name>
                <description>select value for AOI_8to7_01_3.
0: 0.
1: 2nd_filter_out[3].
2: ~2nd_filter_out[3].
3: 1</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_01_2</name>
                <description>select value for AOI_8to7_01_2.
0: 0.
1: 2nd_filter_out[2].
2: ~2nd_filter_out[2].
3: 1</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_01_1</name>
                <description>select value for AOI_8to7_01_1.
0: 0.
1: 2nd_filter_out[1].
2: ~2nd_filter_out[1].
3: 1</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_01_0</name>
                <description>select value for AOI_8to7_01_0.
0: 0.
1: 2nd_filter_out[0].
2: ~2nd_filter_out[0].
3: 1</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_00_7</name>
                <description>select value for AOI_8to7_00_7.
0: 0.
1: 2nd_filter_out[7].
2: ~2nd_filter_out[7].
3: 1</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_00_6</name>
                <description>select value for AOI_8to7_00_6.
0: 0.
1: 2nd_filter_out[6].
2: ~2nd_filter_out[6].
3: 1</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_00_5</name>
                <description>select value for AOI_8to7_00_5.
0: 0.
1: 2nd_filter_out[5].
2: ~2nd_filter_out[5].
3: 1</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_00_4</name>
                <description>select value for AOI_8to7_00_4.
0: 0.
1: 2nd_filter_out[4].
2: ~2nd_filter_out[4].
3: 1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_00_3</name>
                <description>select value for AOI_8to7_00_3.
0: 0.
1: 2nd_filter_out[3].
2: ~2nd_filter_out[3].
3: 1</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_00_2</name>
                <description>select value for AOI_8to7_00_2.
0: 0.
1: 2nd_filter_out[2].
2: ~2nd_filter_out[2].
3: 1</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_00_1</name>
                <description>select value for AOI_8to7_00_1.
0: 0.
1: 2nd_filter_out[1].
2: ~2nd_filter_out[1].
3: 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_00_0</name>
                <description>select value for AOI_8to7_00_0.
0: 0.
1: 2nd_filter_out[0].
2: ~2nd_filter_out[0].
3: 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AOI_8to7_02_03</name>
            <description>CHN&amp;index0 AOI_16to8_02_03 OR logic cfg</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AOI_8TO7_03_7</name>
                <description>select value for AOI_8to7_03_7.
0: 0.
1: 2nd_filter_out[7].
2: ~2nd_filter_out[7].
3: 1</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_03_6</name>
                <description>select value for AOI_8to7_03_6.
0: 0.
1: 2nd_filter_out[6].
2: ~2nd_filter_out[6].
3: 1</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_03_5</name>
                <description>select value for AOI_8to7_03_5.
0: 0.
1: 2nd_filter_out[5].
2: ~2nd_filter_out[5].
3: 1</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_03_4</name>
                <description>select value for AOI_8to7_03_4.
0: 0.
1: 2nd_filter_out[4].
2: ~2nd_filter_out[4].
3: 1</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_03_3</name>
                <description>select value for AOI_8to7_03_3.
0: 0.
1: 2nd_filter_out[3].
2: ~2nd_filter_out[3].
3: 1</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_03_2</name>
                <description>select value for AOI_8to7_03_2.
0: 0.
1: 2nd_filter_out[2].
2: ~2nd_filter_out[2].
3: 1</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_03_1</name>
                <description>select value for AOI_8to7_03_1.
0: 0.
1: 2nd_filter_out[1].
2: ~2nd_filter_out[1].
3: 1</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_03_0</name>
                <description>select value for AOI_8to7_03_0.
0: 0.
1: 2nd_filter_out[0].
2: ~2nd_filter_out[0].
3: 1</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_02_7</name>
                <description>select value for AOI_8to7_02_7.
0: 0.
1: 2nd_filter_out[7].
2: ~2nd_filter_out[7].
3: 1</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_02_6</name>
                <description>select value for AOI_8to7_02_6.
0: 0.
1: 2nd_filter_out[6].
2: ~2nd_filter_out[6].
3: 1</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_02_5</name>
                <description>select value for AOI_8to7_02_5.
0: 0.
1: 2nd_filter_out[5].
2: ~2nd_filter_out[5].
3: 1</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_02_4</name>
                <description>select value for AOI_8to7_02_4.
0: 0.
1: 2nd_filter_out[4].
2: ~2nd_filter_out[4].
3: 1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_02_3</name>
                <description>select value for AOI_8to7_02_3.
0: 0.
1: 2nd_filter_out[3].
2: ~2nd_filter_out[3].
3: 1</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_02_2</name>
                <description>select value for AOI_8to7_02_2.
0: 0.
1: 2nd_filter_out[2].
2: ~2nd_filter_out[2].
3: 1</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_02_1</name>
                <description>select value for AOI_8to7_02_1.
0: 0.
1: 2nd_filter_out[1].
2: ~2nd_filter_out[1].
3: 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_02_0</name>
                <description>select value for AOI_8to7_02_0.
0: 0.
1: 2nd_filter_out[0].
2: ~2nd_filter_out[0].
3: 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AOI_8to7_04_05</name>
            <description>CHN&amp;index0 AOI_16to8_04_05 OR logic cfg</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AOI_8TO7_05_7</name>
                <description>select value for AOI_8to7_05_7.
0: 0.
1: 2nd_filter_out[7].
2: ~2nd_filter_out[7].
3: 1</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_05_6</name>
                <description>select value for AOI_8to7_05_6.
0: 0.
1: 2nd_filter_out[6].
2: ~2nd_filter_out[6].
3: 1</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_05_5</name>
                <description>select value for AOI_8to7_05_5.
0: 0.
1: 2nd_filter_out[5].
2: ~2nd_filter_out[5].
3: 1</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_05_4</name>
                <description>select value for AOI_8to7_05_4.
0: 0.
1: 2nd_filter_out[4].
2: ~2nd_filter_out[4].
3: 1</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_05_3</name>
                <description>select value for AOI_8to7_05_3.
0: 0.
1: 2nd_filter_out[3].
2: ~2nd_filter_out[3].
3: 1</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_05_2</name>
                <description>select value for AOI_8to7_05_2.
0: 0.
1: 2nd_filter_out[2].
2: ~2nd_filter_out[2].
3: 1</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_05_1</name>
                <description>select value for AOI_8to7_05_1.
0: 0.
1: 2nd_filter_out[1].
2: ~2nd_filter_out[1].
3: 1</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_05_0</name>
                <description>select value for AOI_8to7_05_0.
0: 0.
1: 2nd_filter_out[0].
2: ~2nd_filter_out[0].
3: 1</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_04_7</name>
                <description>select value for AOI_8to7_04_7.
0: 0.
1: 2nd_filter_out[7].
2: ~2nd_filter_out[7].
3: 1</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_04_6</name>
                <description>select value for AOI_8to7_04_6.
0: 0.
1: 2nd_filter_out[6].
2: ~2nd_filter_out[6].
3: 1</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_04_5</name>
                <description>select value for AOI_8to7_04_5.
0: 0.
1: 2nd_filter_out[5].
2: ~2nd_filter_out[5].
3: 1</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_04_4</name>
                <description>select value for AOI_8to7_04_4.
0: 0.
1: 2nd_filter_out[4].
2: ~2nd_filter_out[4].
3: 1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_04_3</name>
                <description>select value for AOI_8to7_04_3.
0: 0.
1: 2nd_filter_out[3].
2: ~2nd_filter_out[3].
3: 1</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_04_2</name>
                <description>select value for AOI_8to7_04_2.
0: 0.
1: 2nd_filter_out[2].
2: ~2nd_filter_out[2].
3: 1</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_04_1</name>
                <description>select value for AOI_8to7_04_1.
0: 0.
1: 2nd_filter_out[1].
2: ~2nd_filter_out[1].
3: 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_04_0</name>
                <description>select value for AOI_8to7_04_0.
0: 0.
1: 2nd_filter_out[0].
2: ~2nd_filter_out[0].
3: 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AOI_8to7_06</name>
            <description>CHN&amp;index0 AOI_16to8_06 OR logic cfg</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>AOI_8TO7_06_7</name>
                <description>select value for AOI_8to7_06_7.
0: 0.
1: 2nd_filter_out[7].
2: ~2nd_filter_out[7].
3: 1</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_06_6</name>
                <description>select value for AOI_8to7_06_6.
0: 0.
1: 2nd_filter_out[6].
2: ~2nd_filter_out[6].
3: 1</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_06_5</name>
                <description>select value for AOI_8to7_06_5.
0: 0.
1: 2nd_filter_out[5].
2: ~2nd_filter_out[5].
3: 1</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_06_4</name>
                <description>select value for AOI_8to7_06_4.
0: 0.
1: 2nd_filter_out[4].
2: ~2nd_filter_out[4].
3: 1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_06_3</name>
                <description>select value for AOI_8to7_06_3.
0: 0.
1: 2nd_filter_out[3].
2: ~2nd_filter_out[3].
3: 1</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_06_2</name>
                <description>select value for AOI_8to7_06_2.
0: 0.
1: 2nd_filter_out[2].
2: ~2nd_filter_out[2].
3: 1</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_06_1</name>
                <description>select value for AOI_8to7_06_1.
0: 0.
1: 2nd_filter_out[1].
2: ~2nd_filter_out[1].
3: 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AOI_8TO7_06_0</name>
                <description>select value for AOI_8to7_06_0.
0: 0.
1: 2nd_filter_out[0].
2: ~2nd_filter_out[0].
3: 1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>SECOND_FILTER_0,SECOND_FILTER_1,SECOND_FILTER_2,SECOND_FILTER_3,SECOND_FILTER_4,SECOND_FILTER_5,SECOND_FILTER_6,SECOND_FILTER_7</dimIndex>
            <name>FILTER_2ND[%s]</name>
            <description>no description available</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF71FF</resetMask>
            <fields>
              <field>
                <name>FILTER_EXT_COUNTER</name>
                <description>filter_ext counter value, cycles for filter or extent by system clock。
0：0*apb_clk_period
1：1*apb_clk_period
2: 2*apb_clk_period
…
65535: 65535*apb_clk_period</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EXT_TYPE</name>
                <description>filter extend type.
0-3：nothing to do.
4： input high level extend.
5： input low level extend.
6： output extend.
7： input pulse extend.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EXT_ENABLE</name>
                <description>filter extend enable.
0. bypass filter extend. all setting in bit31:12 are inactive
1. enable filter extend, all setting in bit31:12 are active.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_SYNC_LEVEL</name>
                <description>synchroniser level.
0: 2 level sync.
1: 3 level sync</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POSE_EDGE_DECT_ENABLE</name>
                <description>pose edge detector enable.
0: disable.
1: enable.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NEGE_EDGE_DECT_ENABLE</name>
                <description>nege edge detector enable.
0: disable.
1: enable.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE_DECT_ENABLE</name>
                <description>edge detector enable.
0: disable. bit6/bit5 setting inactive.
1: enable. bit6/bit5 setting active.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_REVERSE</name>
                <description>reverse sync and edge detector filter's output.
0: not reverse.
1: reverse.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFTWARE_INJECT</name>
                <description>software inject value for sync and edge detector filter.
0: inject low level.
1: inject high level.
2: not inject.
3. inject high level.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC_EDGE_FILTER_ENABLE</name>
                <description>sync and edge detector filter.
0: disable.
1: enable.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>7</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>THIRD_FILTER_0,THIRD_FILTER_1,THIRD_FILTER_2,THIRD_FILTER_3,THIRD_FILTER_4,THIRD_FILTER_5,THIRD_FILTER_6</dimIndex>
            <name>FILTER_3RD[%s]</name>
            <description>no description available</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF71FF</resetMask>
            <fields>
              <field>
                <name>FILTER_EXT_COUNTER</name>
                <description>filter_ext counter value, cycles for filter or extent by system clock。
0：0*apb_clk_period
1：1*apb_clk_period
2: 2*apb_clk_period
…
65535: 65535*apb_clk_period</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EXT_TYPE</name>
                <description>filter extend type.
0-3：nothing to do.
4： input high level extend.
5： input low level extend.
6： output extend.
7： input pulse extend.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EXT_ENABLE</name>
                <description>filter extend enable.
0. bypass filter extend. all setting in bit31:12 are inactive
1. enable filter extend, all setting in bit31:12 are active.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_SYNC_LEVEL</name>
                <description>synchroniser level.
0: 2 level sync.
1: 3 level sync</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POSE_EDGE_DECT_ENABLE</name>
                <description>pose edge detector enable.
0: disable.
1: enable.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NEGE_EDGE_DECT_ENABLE</name>
                <description>nege edge detector enable.
0: disable.
1: enable.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE_DECT_ENABLE</name>
                <description>edge detector enable.
0: disable. bit6/bit5 setting inactive.
1: enable. bit6/bit5 setting active.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_REVERSE</name>
                <description>reverse sync and edge detector filter's output.
0: not reverse.
1: reverse.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFTWARE_INJECT</name>
                <description>software inject value for sync and edge detector filter.
0: inject low level.
1: inject high level.
2: not inject.
3. inject high level.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC_EDGE_FILTER_ENABLE</name>
                <description>sync and edge detector filter.
0: disable.
1: enable.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_FF</name>
            <description>CHN&amp;index0 cfg ff</description>
            <addressOffset>0x6c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0003001F</resetMask>
            <fields>
              <field>
                <name>OSC_LOOP_CLAMP_VALUE</name>
                <description>osc loop clamp value when osc ring active.
0: clamp 0.
1: clamp 1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIS_OSC_LOOP_CLAMP</name>
                <description>disable osc loop clamp.
0: enable osc loop clamp when osc ring active.
1: disable or clean current osc loop clamp.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEL_ADDER_MINUS</name>
                <description>0: select adder when cfg_adder_minus active.
1: select minus when cfg_adder_minus active.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEL_CLK_SOURCE</name>
                <description>cfg_ff clock source.
0: system clock.
1: use 3rd_filter_2 as clock.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEL_CFG_FF_TYPE</name>
                <description>cfg_ff type.
0: DFF.
1: 3rd_filter_0.
2: dual-edge DFF.
3: Trigger FF.
4: JK FF.
5. latch.
6: full adder/minus.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>FRIST_FILTER_PLA_IN_0,FRIST_FILTER_PLA_IN_1,FRIST_FILTER_PLA_IN_2,FRIST_FILTER_PLA_IN_3,FRIST_FILTER_PLA_IN_4,FRIST_FILTER_PLA_IN_5,FRIST_FILTER_PLA_IN_6,FRIST_FILTER_PLA_IN_7</dimIndex>
          <name>FILTER_1ST_PLA_IN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x3c0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF71FF</resetMask>
          <fields>
            <field>
              <name>FILTER_EXT_COUNTER</name>
              <description>filter_ext counter value, cycles for filter or extent by system clock。
0：0*apb_clk_period
1：1*apb_clk_period
2: 2*apb_clk_period
…
65535: 65535*apb_clk_period</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_EXT_TYPE</name>
              <description>filter extend type.
0-3：nothing to do.
4： input high level extend.
5： input low level extend.
6： output extend.
7： input pulse extend.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_EXT_ENABLE</name>
              <description>filter extend enable.
0. bypass filter extend. all setting in bit31:12 are inactive
1. enable filter extend, all setting in bit31:12 are active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_SYNC_LEVEL</name>
              <description>synchroniser level.
0: 2 level sync.
1: 3 level sync</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSE_EDGE_DECT_ENABLE</name>
              <description>pose edge detector enable.
0: disable.
1: enable.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NEGE_EDGE_DECT_ENABLE</name>
              <description>nege edge detector enable.
0: disable.
1: enable.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EDGE_DECT_ENABLE</name>
              <description>edge detector enable.
0: disable. bit6/bit5 setting inactive.
1: enable. bit6/bit5 setting active.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_REVERSE</name>
              <description>reverse sync and edge detector filter's output.
0: not reverse.
1: reverse.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFTWARE_INJECT</name>
              <description>software inject value for sync and edge detector filter.
0: inject low level.
1: inject high level.
2: not inject.
3. inject high level.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_EDGE_FILTER_ENABLE</name>
              <description>sync and edge detector filter.
0: disable.
1: enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>9</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>FRIST_FILTER_PLA_IN_0,FRIST_FILTER_PLA_OUT_0,FRIST_FILTER_PLA_OUT_1,FRIST_FILTER_PLA_OUT_2,FRIST_FILTER_PLA_OUT_3,FRIST_FILTER_PLA_OUT_4,FRIST_FILTER_PLA_OUT_5,FRIST_FILTER_PLA_OUT_6,FRIST_FILTER_PLA_OUT_7</dimIndex>
          <name>FILTER_1ST_PLA_OUT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x3e0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF71FF</resetMask>
          <fields>
            <field>
              <name>FILTER_EXT_COUNTER</name>
              <description>filter_ext counter value, cycles for filter or extent by system clock。
0：0*apb_clk_period
1：1*apb_clk_period
2: 2*apb_clk_period
…
65535: 65535*apb_clk_period</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_EXT_TYPE</name>
              <description>filter extend type.
0-3：nothing to do.
4： input high level extend.
5： input low level extend.
6： output extend.
7： input pulse extend.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_EXT_ENABLE</name>
              <description>filter extend enable.
0. bypass filter extend. all setting in bit31:12 are inactive
1. enable filter extend, all setting in bit31:12 are active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_SYNC_LEVEL</name>
              <description>synchroniser level.
0: 2 level sync.
1: 3 level sync</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSE_EDGE_DECT_ENABLE</name>
              <description>pose edge detector enable.
0: disable.
1: enable.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NEGE_EDGE_DECT_ENABLE</name>
              <description>nege edge detector enable.
0: disable.
1: enable.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EDGE_DECT_ENABLE</name>
              <description>edge detector enable.
0: disable. bit6/bit5 setting inactive.
1: enable. bit6/bit5 setting active.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER_REVERSE</name>
              <description>reverse sync and edge detector filter's output.
0: not reverse.
1: reverse.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFTWARE_INJECT</name>
              <description>software inject value for sync and edge detector filter.
0: inject low level.
1: inject high level.
2: not inject.
3. inject high level.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_EDGE_FILTER_ENABLE</name>
              <description>sync and edge detector filter.
0: disable.
1: enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>CFG_ACTIVE_CHN0,CFG_ACTIVE_CHN1,CFG_ACTIVE_CHN2,CFG_ACTIVE_CHN3,CFG_ACTIVE_CHN4,CFG_ACTIVE_CHN5,CFG_ACTIVE_CHN6,CFG_ACTIVE_CHN7</dimIndex>
          <name>CHN_CFG_ACTIVE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CFG_ACTIVE</name>
              <description>write 0xF00D to enable all setting. Otherwire, all setting inactive.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="PLA0">
      <name>PLA1</name>
      <description>PLA1</description>
      <groupName>PLA</groupName>
      <baseAddress>0xf021e000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SYNT</name>
      <description>SYNT</description>
      <groupName>SYNT</groupName>
      <baseAddress>0xf0240000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x30</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>gcr</name>
          <description>Global control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>CRST</name>
              <description>1- Reset counter</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>1- Enable counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rld</name>
          <description>Counter reload register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RLD</name>
              <description>counter reload value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cnt</name>
          <description>Counter</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>CMP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP</name>
              <description>comparator value, the output will assert when counter count to this value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USB0</name>
      <description>USB0</description>
      <groupName>USB</groupName>
      <baseAddress>0xf2020000</baseAddress>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x1a8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPTIMER0LD</name>
          <description>General Purpose Timer #0 Load Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTLD</name>
              <description>GPTLD
General Purpose Timer Load Value
These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'.
This value represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
NOTE: Max value is 0xFFFFFF or 16.777215 seconds.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER0CTRL</name>
          <description>General Purpose Timer #0 Controller Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC1FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTRUN</name>
              <description>GPTRUN
General Purpose Timer Run
GPTCNT bits are not effected when setting or clearing this bit.
0 - Stop counting
1 - Run</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTRST</name>
              <description>GPTRST
General Purpose Timer Reset
0 - No action
1 - Load counter value from GPTLD bits in n_GPTIMER0LD</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPTMODE</name>
              <description>GPTMODE
General Purpose Timer Mode
In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is
reset by software;
In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the
counter value from GPTLD bits to start again.
0 - One Shot Mode
1 - Repeat Mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTCNT</name>
              <description>GPTCNT
General Purpose Timer Counter.
This field is the count value of the countdown timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER1LD</name>
          <description>General Purpose Timer #1 Load Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTLD</name>
              <description>GPTLD
General Purpose Timer Load Value
These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'.
This value represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
NOTE: Max value is 0xFFFFFF or 16.777215 seconds.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER1CTRL</name>
          <description>General Purpose Timer #1 Controller Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC1FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTRUN</name>
              <description>GPTRUN
General Purpose Timer Run
GPTCNT bits are not effected when setting or clearing this bit.
0 - Stop counting
1 - Run</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTRST</name>
              <description>GPTRST
General Purpose Timer Reset
0 - No action
1 - Load counter value from GPTLD bits in USB_n_GPTIMER1LD</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPTMODE</name>
              <description>GPTMODE
General Purpose Timer Mode
In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is
reset by software. In repeat mode, the timer will count down to zero, generate an interrupt and
automatically reload the counter value from GPTLD bits to start again.
0 - One Shot Mode
1 - Repeat Mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTCNT</name>
              <description>GPTCNT
General Purpose Timer Counter.
This field is the count value of the countdown timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SBUSCFG</name>
          <description>System Bus Config Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>AHBBRST</name>
              <description>AHBBRST
AHB master interface Burst configuration
These bits control AHB master transfer type sequence (or priority).
NOTE: This register overrides n_BURSTSIZE register when its value is not zero.
000 - Incremental burst of unspecified length only
001 - INCR4 burst, then single transfer
010 - INCR8 burst, INCR4 burst, then single transfer
011 - INCR16 burst, INCR8 burst, INCR4 burst, then single transfer
100 - Reserved, don't use
101 - INCR4 burst, then incremental burst of unspecified length
110 - INCR8 burst, INCR4 burst, then incremental burst of unspecified length
111 - INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspecified length</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBCMD</name>
          <description>USB Command Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x00080000</resetValue>
          <resetMask>0x00FFEB7F</resetMask>
          <fields>
            <field>
              <name>ITC</name>
              <description>ITC
Interrupt Threshold Control -Read/Write.
The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts.
ITC contains the maximum interrupt interval measured in micro-frames. Valid values are
shown below.
Value Maximum Interrupt Interval
00000000 - Immediate (no threshold)
00000001 - 1 micro-frame
00000010 - 2 micro-frames
00000100 - 4 micro-frames
00001000 - 8 micro-frames
00010000 - 16 micro-frames
00100000 - 32 micro-frames
01000000 - 64 micro-frames</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_2</name>
              <description>FS_2
Frame List Size - (Read/Write or Read Only). [host mode only]
This field is Read/Write only if Programmable Frame List Flag in the HCCPARAMS registers is set to one.
This field specifies the size of the frame list that controls which bits in the Frame Index Register should be used for the Frame List Current index.
NOTE: This field is made up from USBCMD bits 15, 3 and 2.
Value Meaning
0b000 - 1024 elements (4096 bytes) Default value
0b001 - 512 elements (2048 bytes)
0b010 - 256 elements (1024 bytes)
0b011 - 128 elements (512 bytes)
0b100 - 64 elements (256 bytes)
0b101 - 32 elements (128 bytes)
0b110 - 16 elements (64 bytes)
0b111 - 8 elements (32 bytes)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATDTW</name>
              <description>ATDTW
Add dTD TripWire - Read/Write. [device mode only]
This bit is used as a semaphore to ensure proper addition of a new dTD to an active (primed) endpoint's
linked list. This bit is set and cleared by software.
This bit would also be cleared by hardware when state machine is hazard region for which adding a dTD
to a primed endpoint may go unrecognized.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUTW</name>
              <description>SUTW
Setup TripWire - Read/Write. [device mode only]
This bit is used as a semaphore to ensure that the setup data payload of 8 bytes is extracted from a QH by the DCD without being corrupted.
If the setup lockout mode is off (SLOM bit in USB core register n_USBMODE, see USBMODE ) then
there is a hazard when new setup data arrives while the DCD is copying the setup data payload
from the QH for a previous setup packet. This bit is set and cleared by software.
This bit would also be cleared by hardware when a hazard detected.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASPE</name>
              <description>ASPE
Asynchronous Schedule Park Mode Enable - Read/Write.
If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this bit defaults to a 1h and is R/W.
Otherwise the bit must be a zero and is RO. Software uses this bit to enable or disable Park mode.
When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.
NOTE: ASPE bit reset value: '0b' for OTG controller .</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASP</name>
              <description>ASP
Asynchronous Schedule Park Mode Count - Read/Write.
If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this field defaults to 3h and is R/W. Otherwise it defaults to zero and is Read-Only.
It contains a count of the number of successive transactions the host controller is allowed to
execute from a high-speed queue head on the Asynchronous schedule before continuing traversal of the Asynchronous schedule.
Valid values are 1h to 3h. Software must not write a zero to this bit when Park Mode Enable is a one as this will result in undefined behavior.
This field is set to 3h in all controller core.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IAA</name>
              <description>IAA
Interrupt on Async Advance Doorbell - Read/Write.
This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. Software must write a 1 to this bit to ring the doorbell.
When the host controller has evicted all appropriate cached schedule states,
it sets the Interrupt on Async Advance status bit in the USBSTS register.
If the Interrupt on Sync Advance Enable bit in the USBINTR register is one, then the host controller will assert an interrupt at the next interrupt threshold.
The host controller sets this bit to zero after it has set the Interrupt on Sync Advance status bit in the USBSTS register to one.
Software should not write a one to this bit when the asynchronous  schedule is inactive. Doing so will yield undefined results.
This bit is only used in host mode. Writing a one to this bit when device mode is selected will have undefined results.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASE</name>
              <description>ASE
Asynchronous Schedule Enable - Read/Write. Default 0b.
This bit controls whether the host controller skips processing the Asynchronous Schedule.
Only the host controller uses this bit.
Values Meaning
0 - Do not process the Asynchronous Schedule.
1 - Use the ASYNCLISTADDR register to access the Asynchronous Schedule.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSE</name>
              <description>PSE
Periodic Schedule Enable- Read/Write. Default 0b.
This bit controls whether the host controller skips processing the Periodic Schedule.
Only the host controller uses this bit.
Values Meaning
0 - Do not process the Periodic Schedule
1 - Use the PERIODICLISTBASE register to access the Periodic Schedule.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_1</name>
              <description>FS_1
See description at bit 15</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RST</name>
              <description>RST
Controller Reset (RESET) - Read/Write. Software uses this bit to reset the controller.
This bit is set to zero by the Host/Device Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.
Host operation mode:
When software writes a one to this bit, the Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value.
Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports.
Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero.
Attempting to reset an actively running host controller will result in undefined behavior.
Device operation mode:
When software writes a one to this bit, the Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value.
Writing a one to this bit when the device is in the attached state is not recommended, because the effect on an attached host is undefined.
In order to ensure that the device is not in an attached state before initiating a device controller reset, all primed endpoints should be flushed and the USBCMD Run/Stop bit should be set to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RS</name>
              <description>RS
Run/Stop (RS) - Read/Write. Default 0b. 1=Run. 0=Stop.
Host operation mode:
When set to '1b', the Controller proceeds with the execution of the schedule. The Controller continues execution as long as this bit is set to a one.
When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts.
The HC Halted bit in the status register indicates when the Controller has finished the transaction and has entered the stopped state.
Software should not write a one to this field unless the controller is in the Halted state (that is, HCHalted in the USBSTS register is a one).
Device operation mode:
Writing a one to this bit will cause the controller to enable a pull-up on D+ and initiate an attach event.
This control bit is not directly connected to the pull-up enable, as the pull-up will become disabled upon transitioning into high-speed mode.
Software should use this bit to prevent an attach event before the controller has been properly initialized. Writing a 0 to this will cause a detach event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBSTS</name>
          <description>USB Status Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030DF1FF</resetMask>
          <fields>
            <field>
              <name>TI1</name>
              <description>TI1
General Purpose Timer Interrupt 1(GPTINT1)--R/WC.
This bit is set when the counter in the GPTIMER1CTRL register transitions to zero, writing a one to this
bit will clear it.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TI0</name>
              <description>TI0
General Purpose Timer Interrupt 0(GPTINT0)--R/WC.
This bit is set when the counter in the GPTIMER0CTRL register transitions to zero, writing a one to this
bit clears it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPI</name>
              <description>USB Host Periodic Interrupt – RWC. Default = 0b.
This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction
where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule.
This bit is also set by the Host Controller when a short packet is detected and the packet is on the periodic schedule.
A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UAI</name>
              <description>USB Host Asynchronous Interrupt – RWC. Default = 0b.
This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction
where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set AND the TD was from the asynchronous schedule.
This bit is also set by the Host when a short packet is detected and the packet is on the asynchronous schedule.
A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKI</name>
              <description>NAKI
NAK Interrupt Bit--RO.
This bit is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and
corresponding TX/RX Endpoint NAK Enable bit are set. This bit is automatically cleared by hardware
when all Enabled TX/RX Endpoint NAK bits are cleared.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AS</name>
              <description>AS
Asynchronous Schedule Status - Read Only.
This bit reports the current real status of the Asynchronous Schedule. When set to zero the asynchronous schedule status is disabled and if set to one the status is enabled.
The Host Controller is not required to immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register.
When this bit and the Asynchronous Schedule Enable bit are the same value, the Asynchronous Schedule is either enabled (1) or disabled (0).
Only used in the host operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PS</name>
              <description>PS
Periodic Schedule Status - Read Only.
This bit reports the current real status of the Periodic Schedule. When set to zero the periodic schedule is disabled, and if set to one the status is enabled.
The Host Controller is not required to immediately disable or enable the Periodic Schedule when software transitions the Periodic Schedule Enable bit in the USBCMD register.
When this bit and the Periodic Schedule Enable bit are the same value, the Periodic Schedule is either enabled (1) or disabled (0).
Only used in the host operation mode.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RCL</name>
              <description>RCL
Reclamation - Read Only.
This is a read-only status bit used to detect an empty asynchronous schedule.
Only used in the host operation mode.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HCH</name>
              <description>HCH
HCHaIted - Read Only.
This bit is a zero whenever the Run/Stop bit is a one.
 The Controller sets this bit to one after it has stopped executing because of the Run/Stop bit being set to 0,
 either by software or by the Controller hardware (for example, an internal error).
Only used in the host operation mode.
Default value is '0b' for OTG core .
This is because OTG core is not operating as host in default. Please see CM bit in USB_n_USBMODE
register.
NOTE: HCH bit reset value: '0b' for OTG controller core .</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLI</name>
              <description>SLI
DCSuspend - R/WC.
When a controller enters a suspend state from an active state, this bit will be set to a one. The device controller clears the bit upon exiting from a suspend state.
Only used in device operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRI</name>
              <description>SRI
SOF Received - R/WC.
When the device controller detects a Start Of (micro) Frame, this bit will be set to a one.
When a SOF is extremely late, the device controller will automatically set this bit to indicate that an SOF was expected.
Therefore, this bit will be set roughly every 1ms in device FS mode and every 125ms in HS mode and will be synchronized to the actual SOF that is received.
Because the device controller is initialized to FS before connect, this bit will be set at an interval of 1ms during the prelude to connect and chirp.
In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.
Software writes a 1 to this bit to clear it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>URI</name>
              <description>URI
USB Reset Received - R/WC.
When the device controller detects a USB Reset and enters the default state, this bit will be set to a one.
Software can write a 1 to this bit to clear the USB Reset Received status bit.
Only used in device operation mode.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAI</name>
              <description>AAI
Interrupt on Async Advance - R/WC.
System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule
by writing a one to the Interrupt on Async Advance Doorbell bit in the n_USBCMD register. This status bit indicates the assertion of that interrupt source.
Only used in host operation mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEI</name>
              <description>System Error – RWC. Default = 0b.
In the BVCI implementation of the USBHS core, this bit is not used, and will always be cleared to '0b'.
In the AMBA implementation, this bit will be set to '1b' when an Error response is seen by the master interface (HRESP[1:0]=ERROR)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRI</name>
              <description>FRI
Frame List Rollover - R/WC.
The Host Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to
zero. The exact value at which the rollover occurs depends on the frame list size. For example. If the
frame list size (as programmed in the Frame List Size field of the USB_n_USBCMD register) is 1024, the
Frame Index Register rolls over every time FRINDEX [13] toggles. Similarly, if the size is 512, the Host
Controller sets this bit to a one every time FHINDEX [12] toggles.
Only used in host operation mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCI</name>
              <description>PCI
Port Change Detect - R/WC.
The Host Controller sets this bit to a one when on any port a Connect Status occurs, a Port Enable/Disable Change occurs,
or the Force Port Resume bit is set as the result of a J-K transition on the suspended port.
The Device Controller sets this bit to a one when the port controller enters the full or high-speed operational state.
When the port controller exits the full or high-speed operation states due to Reset or Suspend events,
the notification mechanisms are the USB Reset Received bit and the DCSuspend bits Respectively.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UEI</name>
              <description>UEI
USB Error Interrupt (USBERRINT) - R/WC.
When completion of a USB transaction results in an error condition, this bit is set by the Host/Device Controller.
This bit is set along with the USBINT bit, if the TD on which the error interrupt occurred also had its interrupt on complete (IOC) bit set.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UI</name>
              <description>UI
USB Interrupt (USBINT) - R/WC.
This bit is set by the Host/Device Controller when the cause of an interrupt is a completion of a USB
transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set.
This bit is also set by the Host/Device Controller when a short packet is detected. A short packet is when
the actual number of bytes received was less than the expected number of bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBINTR</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030D01FF</resetMask>
          <fields>
            <field>
              <name>TIE1</name>
              <description>TIE1
General Purpose Timer #1 Interrupt Enable
When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIE0</name>
              <description>TIE0
General Purpose Timer #0 Interrupt Enable
When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPIE</name>
              <description>UPIE
USB Host Periodic Interrupt Enable
When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an
interrupt at the next interrupt threshold.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UAIE</name>
              <description>UAIE
USB Host Asynchronous Interrupt Enable
When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an
interrupt at the next interrupt threshold.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKE</name>
              <description>NAKE
NAK Interrupt Enable
When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLE</name>
              <description>SLE
Sleep Interrupt Enable
When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt.
Only used in device operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRE</name>
              <description>SRE
SOF Received Interrupt Enable
When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>URE</name>
              <description>URE
USB Reset Interrupt Enable
When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in device operation mode.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAE</name>
              <description>AAE
Async Advance Interrupt Enable
When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEE</name>
              <description>SEE
System Error Interrupt Enable
When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRE</name>
              <description>FRE
Frame List Rollover Interrupt Enable
When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCE</name>
              <description>PCE
Port Change Detect Interrupt Enable
When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UEE</name>
              <description>UEE
USB Error Interrupt Enable
When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UE</name>
              <description>UE
USB Interrupt Enable
When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRINDEX</name>
          <description>USB Frame Index Register</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>FRINDEX</name>
              <description>FRINDEX
Frame Index.
The value, in this register, increments at the end of each time frame (micro-frame). Bits [N: 3] are used for the Frame List current index.
This means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index.
The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.
USBCMD [Frame List Size] Number Elements N
In device mode the value is the current frame number of the last frame transmitted. It is not used as an index.
In either mode bits 2:0 indicate the current microframe.
The bit field values description below is represented as (Frame List Size) Number Elements N.
00000000000000 - (1024) 12
00000000000001 - (512) 11
00000000000010 - (256) 10
00000000000011 - (128) 9
00000000000100 - (64) 8
00000000000101 - (32) 7
00000000000110 - (16) 6
00000000000111 - (8) 5</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEVICEADDR</name>
          <description>Device Address Register</description>
          <alternateGroup>UNION_154</alternateGroup>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF000000</resetMask>
          <fields>
            <field>
              <name>USBADR</name>
              <description>USBADR
Device Address.
These bits correspond to the USB device address</description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBADRA</name>
              <description>USBADRA
Device Address Advance. Default=0.
When this bit is '0', any writes to USBADR are instantaneous.
 When this bit is written to a '1' at the same time or before USBADR is written, the write to the USBADR field is staged and held in a hidden register.
After an IN occurs on endpoint 0 and is ACKed, USBADR will be loaded from the holding register.
Hardware will automatically clear this bit on the following conditions:
1) IN is ACKed to endpoint 0. (USBADR is updated from staging register).
2) OUT/SETUP occur to endpoint 0. (USBADR is not updated).
3) Device Reset occurs (USBADR is reset to 0).
NOTE: After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to program the USBADR field.
This mechanism will ensure this specification is met when the DCD can not write of the device address within 2ms from the SET_ADDRESS status phase.
If the DCD writes the USBADR with USBADRA=1 after the SET_ADDRESS data phase (before the prime of the status phase),
the USBADR will be programmed instantly at the correct time and meet the 2ms USB requirement.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERIODICLISTBASE</name>
          <description>Frame List Base Address Register</description>
          <alternateGroup>UNION_154</alternateGroup>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF000</resetMask>
          <fields>
            <field>
              <name>BASEADR</name>
              <description>BASEADR
Base Address (Low).
These bits correspond to memory address signals [31:12], respectively.
Only used by the host controller.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCLISTADDR</name>
          <description>Next Asynch. Address Register</description>
          <alternateGroup>UNION_158</alternateGroup>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFE0</resetMask>
          <fields>
            <field>
              <name>ASYBASE</name>
              <description>ASYBASE
Link Pointer Low (LPL).
These bits correspond to memory address signals [31:5], respectively. This field may only reference a
Queue Head (QH).
Only used by the host controller.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTLISTADDR</name>
          <description>Endpoint List Address Register</description>
          <alternateGroup>UNION_158</alternateGroup>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF800</resetMask>
          <fields>
            <field>
              <name>EPBASE</name>
              <description>EPBASE
Endpoint List Pointer(Low). These bits correspond to memory address signals [31:11], respectively.
This field will reference a list of up to 32 Queue Head (QH) (that is, one queue head per endpoint &amp; direction).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BURSTSIZE</name>
          <description>Programmable Burst Size Register</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TXPBURST</name>
              <description>TXPBURST
Programmable TX Burst Size.
Default value is determined by TXBURST bits in n_HWTXBUF.
This register represents the maximum length of a the burst in 32-bit words while moving data from system
memory to the USB bus.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPBURST</name>
              <description>RXPBURST
Programmable RX Burst Size.
Default value is determined by TXBURST bits in n_HWRXBUF.
This register represents the maximum length of a the burst in 32-bit words while moving data from the
USB bus to system memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXFILLTUNING</name>
          <description>TX FIFO Fill Tuning Register</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F1F7F</resetMask>
          <fields>
            <field>
              <name>TXFIFOTHRES</name>
              <description>TXFIFOTHRES
FIFO Burst Threshold. (Read/Write)
This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus.
The minimum value is 2 and this value should be a low as possible to maximize USB performance.
A higher value can be used in systems with unpredictable latency and/or insufficient bandwidth
where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory.
This value is ignored if the Stream Disable bit in USB_n_USBMODE register is set.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCHHEALTH</name>
              <description>TXSCHHEALTH
Scheduler Health Counter. (Read/Write To Clear)
Table continues on the next page
This register increments when the host controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES
before running out of time to send the packet before the next Start-Of-Frame.
This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH.
Writing to this register will clear the counter and this counter will max. at 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCHOH</name>
              <description>TXSCHOH
Scheduler Overhead. (Read/Write) [Default = 0]
This register adds an additional fixed offset to the schedule time estimator described above as Tff.
As an approximation, the value chosen for this register should limit the number of back-off events captured
in the TXSCHHEALTH to less than 10 per second in a highly utilized bus.
Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization.
The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode.
The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode.
Default value is '08h' for OTG controller core .</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTNAK</name>
          <description>Endpoint NAK Register</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPTN</name>
              <description>EPTN
TX Endpoint NAK - R/WC.
Each TX endpoint has 1 bit in this field. The bit is set when the
device sends a NAK handshake on a received IN token for the corresponding endpoint.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPRN</name>
              <description>EPRN
RX Endpoint NAK - R/WC.
Each RX endpoint has 1 bit in this field. The bit is set when the
device sends a NAK handshake on a received OUT or PING token for the corresponding endpoint.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTNAKEN</name>
          <description>Endpoint NAK Enable Register</description>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPTNE</name>
              <description>EPTNE
TX Endpoint NAK Enable - R/W.
Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this bit is set and the
corresponding TX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPRNE</name>
              <description>EPRNE
RX Endpoint NAK Enable - R/W.
Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this bit is set and the
corresponding RX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PORTSC1</name>
          <description>Port Status &amp; Control</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3DFF1FFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>STS
Serial Transceiver Select
1 Serial Interface Engine is selected
0 Parallel Interface signals is selected
Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals.
When this bit is set '1b', serial interface engine will be used instead of parallel interface signals.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PTW</name>
              <description>PTW
Parallel Transceiver Width
This bit has no effect if serial interface engine is used.
0 - Select the 8-bit UTMI interface [60MHz]
1 - Select the 16-bit UTMI interface [30MHz]</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSPD</name>
              <description>PSPD
Port Speed - Read Only.
This register field indicates the speed at which the port is operating.
00 - Full Speed
01 - Low Speed
10 - High Speed
11 - Undefined</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PFSC</name>
              <description>PFSC
Port Force Full Speed Connect - Read/Write. Default = 0b.
When this bit is set to '1b', the port will be forced to only connect at Full Speed, It disables the chirp
sequence that allows the port to identify itself as High Speed.
0 - Normal operation
1 - Forced to full speed</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHCD</name>
              <description>PHCD
PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write. Default = 0b.
When this bit is set to '1b', the PHY clock is disabled. Reading this bit will indicate the status of the PHY
clock.
NOTE: The PHY clock cannot be disabled if it is being used as the system clock.
In device mode, The PHY can be put into Low Power Suspend when the device is not running (USBCMD
Run/Stop=0b) or the host has signalled suspend (PORTSC1 SUSPEND=1b). PHY Low power suspend
will be cleared automatically when the host initials resume. Before forcing a resume from the device, the
device controller driver must clear this bit.
In host mode, the PHY can be put into Low Power Suspend when the downstream device has been put
into suspend mode or when no downstream device is connected. Low power suspend is completely
under the control of software.
0 - Enable PHY clock
1 - Disable PHY clock</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKOC</name>
              <description>WKOC
Wake on Over-current Enable (WKOC_E) - Read/Write. Default = 0b.
Writing this bit to a one enables the port to be sensitive to over-current conditions as wake-up events.
This field is zero if Port Power(PORTSC1) is zero.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDC</name>
              <description>WKDC
Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write. Default=0b. Writing this bit to a one enables
the port to be sensitive to device disconnects as wake-up events.
This field is zero if Port Power(PORTSC1) is zero or in device mode.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCN</name>
              <description>WKCN
Wake on Connect Enable (WKCNNT_E) - Read/Write. Default=0b.
Writing this bit to a one enables the port to be sensitive to device connects as wake-up events.
This field is zero if Port Power(PORTSC1) is zero or in device mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PTC</name>
              <description>PTC
Port Test Control - Read/Write. Default = 0000b.
Refer to Port Test Mode for the operational model for using these test modes and the USB Specification Revision 2.0, Chapter 7 for details on each test mode.
The FORCE_ENABLE_FS and FORCE ENABLE_LS are extensions to the test mode support specified in the EHCI specification.
Writing the PTC field to any of the FORCE_ENABLE_{HS/FS/LS} values will force the port into the connected and enabled state at the selected speed.
Writing the PTC field back to TEST_MODE_DISABLE will allow the port state machines to progress normally from that point.
NOTE: Low speed operations are not supported as a peripheral device.
Any other value than zero indicates that the port is operating in test mode.
Value Specific Test
0000 - TEST_MODE_DISABLE
0001 - J_STATE
0010 - K_STATE
0011 - SE0 (host) / NAK (device)
0100 - Packet
0101 - FORCE_ENABLE_HS
0110 - FORCE_ENABLE_FS
0111 - FORCE_ENABLE_LS
1000-1111 - Reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PP</name>
              <description>PP
Port Power (PP)-Read/Write or Read Only.
The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:
PPC
PP Operation
0
1b Read Only - Host controller does not have port power control switches. Each port is hard-wired to power.
1
1b/0b - Read/Write. OTG controller requires port power control switches. This bit represents the current setting of the switch (0=off, 1=on).
When power is not available on a port (that is, PP equals a 0), the port is non-functional and will not report attaches, detaches, etc.
When an over-current condition is detected on a powered port and PPC is a one,
the PP bit in each affected port may be transitional by the host controller driver from a one to a zero (removing power from the port).
This feature is implemented in all controller cores (PPC = 1).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LS</name>
              <description>LS
Line Status-Read Only. These bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal
lines.
In host mode, the use of linestate by the host controller driver is not necessary (unlike EHCI), because
the port controller state machine and the port routing manage the connection of LS and FS.
In device mode, the use of linestate by the device controller driver is not necessary.
The encoding of the bits are:
Bits [11:10] Meaning
00 - SE0
01 - K-state
10 - J-state
11 - Undefined</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HSP</name>
              <description>HSP
High-Speed Port - Read Only. Default = 0b.
When the bit is one, the host/device connected to the port is in high-speed mode and if set to zero, the
host/device connected to the port is not in a high-speed mode.
NOTE: HSP is redundant with PSPD(bit 27, 26) but remained for compatibility.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PR</name>
              <description>PR
Port Reset - Read/Write or Read Only. Default = 0b.
In Host Mode: Read/Write. 1=Port is in Reset. 0=Port is not in Reset. Default 0.
When software writes a one to this bit the bus-reset sequence as defined in the USB Specification Revision 2.0 is started.
This bit will automatically change to zero after the reset sequence is complete.
This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the reset duration is timed in the driver.
In Device Mode: This bit is a read only status bit. Device reset from the USB bus is also indicated in the USBSTS register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSP</name>
              <description>SUSP
Suspend - Read/Write or Read Only. Default = 0b.
1=Port in suspend state. 0=Port not in suspend state.
In Host Mode: Read/Write.
Port Enabled Bit and Suspend bit of this register define the port states as follows:
Bits [Port Enabled, Suspend] Port State
0x Disable
10 Enable
11 Suspend
When in suspend state, downstream propagation of data is blocked on this port, except for port reset.
The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1.
In the suspend state, the port is sensitive to resume detection.
Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB.
The host controller will unconditionally set this bit to zero when software sets the Force Port Resume bit to zero. The host controller ignores a write of zero to this bit.
If host software sets this bit to a one when the port is not enabled (that is, Port enabled bit is a zero) the results are undefined.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode: Read Only.
In device mode this bit is a read only status bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FPR</name>
              <description>FPR
Force Port Resume -Read/Write. 1= Resume detected/driven on port. 0=No resume (K-state) detected driven on port. Default = 0.
In Host Mode:
Software sets this bit to one to drive resume signaling. The Host Controller sets this bit to one if a J-to-K transition is detected while the port is in the Suspend state.
When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.
This bit will automatically change to zero after the resume sequence is complete.
This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the resume duration is timed in the driver.
Note that when the Host controller owns the port, the resume sequence follows the defined sequence documented in the USB Specification Revision 2.0.
The resume signaling (Full-speed 'K') is driven on the port as long as this bit remains a one. This bit will remain a one until the port has switched to the high-speed idle.
Writing a zero has no effect because the port controller will time the resume operation, clear the bit the port control state switches to HS or FS idle.
This field is zero if Port Power(PORTSC1) is zero in host mode.
This bit is not-EHCI compatible.
In Device mode:
After the device has been in Suspend State for 5ms or more, software must set this bit to one to drive resume signaling before clearing.
The Device Controller will set this bit to one if a J-to-K transition is detected while the port is in the Suspend state.
The bit will be cleared when the device returns to normal operation.
 Also, when this bit wil be cleared because a K-to-J transition detected, the Port Change Detect bit in the USBSTS register is also set to one.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCC</name>
              <description>OCC
Over-current Change-R/WC. Default=0.
This bit is set '1b' by hardware when there is a change to Over-current Active. Software can clear this bit by writing a one to this bit position.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCA</name>
              <description>OCA
Over-current Active-Read Only. Default 0.
This bit will automatically transition from one to zero when the over current condition is removed.
0 - This port does not have an over-current condition.
1 - This port currently has an over-current condition</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PEC</name>
              <description>PEC
Port Enable/Disable Change-R/WC. 1=Port enabled/disabled status has changed. 0=No change. Default = 0.
In Host Mode:
For the root hub, this bit is set to a one only when a port is disabled due to disconnect on the port or
due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification).
Software clears this by writing a one to it.
This field is zero if Port Power(PORTSC1) is zero.
In Device mode:
The device port is always enabled, so this bit is always '0b'.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE</name>
              <description>PE
Port Enabled/Disabled-Read/Write. 1=Enable. 0=Disable. Default 0.
In Host Mode:
Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field.
Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the host software.
Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller and bus events.
When the port is disabled, (0b) downstream propagation of data is blocked except for reset.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
The device port is always enabled, so this bit is always '1b'.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSC</name>
              <description>CSC
Connect Status Change-R/WC. 1 =Change in Current Connect Status. 0=No change. Default 0.
In Host Mode:
Indicates a change has occurred in the port's Current Connect Status.
The host/device controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change.
For example, the insertion status changes twice before system software has cleared the changed condition,
hub hardware will be 'setting' an already-set bit (that is, the bit will remain set). Software clears this bit by writing a one to it.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
This bit is undefined in device controller mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CCS</name>
              <description>CCS
Current Connect Status-Read Only.
In Host Mode:
1=Device is present on port. 0=No device is present. Default = 0.
This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
1=Attached. 0=Not Attached. Default=0.
A one indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the High Speed Port bit in this register.
A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register.
It does not state the device being disconnected or Suspended.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OTGSC</name>
          <description>On-The-Go Status &amp; control Register</description>
          <addressOffset>0x1a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07070723</resetMask>
          <fields>
            <field>
              <name>ASVIE</name>
              <description>ASVIE
A Session Valid Interrupt Enable - Read/Write.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVVIE</name>
              <description>AVVIE
A VBus Valid Interrupt Enable - Read/Write.
Setting this bit enables the A VBus valid interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDIE</name>
              <description>IDIE
USB ID Interrupt Enable - Read/Write.
Setting this bit enables the USB ID interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASVIS</name>
              <description>ASVIS
A Session Valid Interrupt Status - Read/Write to Clear.
This bit is set when VBus has either risen above or fallen below the A session valid threshold.
Software must write a one to clear this bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVVIS</name>
              <description>AVVIS
A VBus Valid Interrupt Status - Read/Write to Clear.
This bit is set when VBus has either risen above or fallen below the VBus valid threshold on an A device.
Software must write a one to clear this bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDIS</name>
              <description>IDIS
USB ID Interrupt Status - Read/Write.
This bit is set when a change on the ID input has been detected.
Software must write a one to clear this bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASV</name>
              <description>ASV
A Session Valid - Read Only.
Indicates VBus is above the A session valid threshold.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AVV</name>
              <description>AVV
A VBus Valid - Read Only.
Indicates VBus is above the A VBus valid threshold.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>ID
USB ID - Read Only.
0 = A device, 1 = B device</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDPU</name>
              <description>IDPU
ID Pullup - Read/Write
This bit provide control over the ID pull-up resistor; 0 = off, 1 = on [default]. When this bit is 0, the ID input
will not be sampled.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VC</name>
              <description>VC
VBUS Charge - Read/Write.
Setting this bit causes the VBus line to be charged. This is used for VBus pulsing during SRP.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VD</name>
              <description>VD
VBUS_Discharge - Read/Write.
Setting this bit causes VBus to discharge through a resistor.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBMODE</name>
          <description>USB Device Mode Register</description>
          <addressOffset>0x1a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>SDIS</name>
              <description>SDIS
Stream Disable Mode. (0 - Inactive [default]; 1 - Active)
Device Mode: Setting to a '1' disables double priming on both RX and TX for low bandwidth systems.
This mode ensures that when the RX and TX buffers are sufficient to contain an entire packet that the standard double buffering scheme is disabled to prevent overruns/underruns in bandwidth limited systems.
Note: In High Speed Mode, all packets received are responded to with a NYET handshake when stream disable is active.
Host Mode: Setting to a '1' ensures that overruns/underruns of the latency FIFO are eliminated for low bandwidth systems
where the RX and TX buffers are sufficient to contain the entire packet. Enabling stream disable also has the effect of ensuring the TX latency is filled to capacity before the packet is launched onto the USB.
NOTE: Time duration to pre-fill the FIFO becomes significant when stream disable is active. See TXFILLTUNING and TXTTFILLTUNING [MPH Only] to characterize the adjustments needed for
the scheduler when using this feature.
NOTE: The use of this feature substantially limits of the overall USB performance that can be achieved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLOM</name>
              <description>SLOM
Setup Lockout Mode. In device mode, this bit controls behavior of the setup lock mechanism. See Control Endpoint Operation Model .
0 - Setup Lockouts On (default);
1 - Setup Lockouts Off. DCD requires use of Setup Data Buffer Tripwire in USBCMD.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ES</name>
              <description>ES
Endian Select - Read/Write. This bit can change the byte alignment of the transfer buffers to match the
host microprocessor. The bit fields in the microprocessor interface and the data structures are unaffected
by the value of this bit because they are based upon the 32-bit word.
Bit Meaning
0 - Little Endian [Default]
1 - Big Endian</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CM</name>
              <description>CM
Controller Mode - R/WO. Controller mode is defaulted to the proper mode for host only and device only
implementations. For those designs that contain both host &amp; device capability, the controller defaults to
an idle state and needs to be initialized to the desired operating mode after reset. For combination host/
device controllers, this register can only be written once after reset. If it is necessary to switch modes,
software must reset the controller by writing to the RESET bit in the USBCMD register before
reprogramming this register.
For OTG controller core, reset value is '00b'.
00 - Idle [Default for combination host/device]
01 - Reserved
10 - Device Controller [Default for device only controller]
11 - Host Controller [Default for host only controller]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTSETUPSTAT</name>
          <description>Endpoint Setup Status Register</description>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ENDPTSETUPSTAT</name>
              <description>ENDPTSETUPSTAT
Setup Endpoint Status. For every setup transaction that is received, a corresponding bit in this register is set to one.
Software must clear or acknowledge the setup transfer by writing a one to a respective bit after it has read the setup data from Queue head.
The response to a setup packet as in the order of operations and total response time is crucial to limit bus time outs while the setup lock out mechanism is engaged.
This register is only used in device mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTPRIME</name>
          <description>Endpoint Prime Register</description>
          <addressOffset>0x1b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PETB</name>
              <description>PETB
Prime Endpoint Transmit Buffer - R/WS. For each endpoint a corresponding bit is used to request that a
buffer is prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction.
Software should write a one to the corresponding bit when posting a new transfer descriptor to an
endpoint queue head. Hardware automatically uses this bit to begin parsing for a new transfer descriptor
from the queue head and prepare a transmit buffer. Hardware clears this bit when the associated
endpoint(s) is (are) successfully primed.
NOTE: These bits are momentarily set by hardware during hardware re-priming operations when a dTD
is retired, and the dQH is updated.
PETB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERB</name>
              <description>PERB
Prime Endpoint Receive Buffer - R/WS. For each endpoint, a corresponding bit is used to request a buffer prepare for a receive operation for when a USB host initiates a USB OUT transaction.
Software should write a one to the corresponding bit whenever posting a new transfer descriptor to an endpoint queue head.
Hardware automatically uses this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer.
Hardware clears this bit when the associated endpoint(s) is (are) successfully primed.
NOTE: These bits are momentarily set by hardware during hardware re-priming operations when a dTD
is retired, and the dQH is updated.
PERB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTFLUSH</name>
          <description>Endpoint Flush Register</description>
          <addressOffset>0x1b4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FETB</name>
              <description>FETB
Flush Endpoint Transmit Buffer - R/WS. Writing one to a bit(s) in this register causes the associated endpoint(s) to clear any primed buffers.
If a packet is in progress for one of the associated endpoints, then that transfer continues until completion.
Hardware clears this register after the endpoint flush operation is successful.
FETB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FERB</name>
              <description>FERB
Flush Endpoint Receive Buffer - R/WS. Writing one to a bit(s) causes the associated endpoint(s) to clear any primed buffers.
 If a packet is in progress for one of the associated endpoints, then that transfer continues until completion.
Hardware clears this register after the endpoint flush operation is successful.
FERB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTSTAT</name>
          <description>Endpoint Status Register</description>
          <addressOffset>0x1b8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETBR</name>
              <description>ETBR
Endpoint Transmit Buffer Ready -- Read Only. One bit for each endpoint indicates status of the respective endpoint buffer.
This bit is set to one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register.
There is always a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready.
This delay time varies based upon the current USB traffic and the number of bits set in the ENDPRIME register.
Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.
NOTE: These bits are momentarily cleared by hardware during hardware endpoint re-priming operations when a dTD is retired, and the dQH is updated.
ETBR[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERBR</name>
              <description>ERBR
Endpoint Receive Buffer Ready -- Read Only. One bit for each endpoint indicates status of the respective
endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a
corresponding bit in the ENDPRIME register. There is always a delay between setting a bit in the
ENDPRIME register and endpoint indicating ready. This delay time varies based upon the current USB
traffic and the number of bits set in the ENDPRIME register. Buffer ready is cleared by USB reset, by the
USB DMA system, or through the ENDPTFLUSH register.
NOTE: These bits are momentarily cleared by hardware during hardware endpoint re-priming operations
when a dTD is retired, and the dQH is updated.
ERBR[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTCOMPLETE</name>
          <description>Endpoint Complete Register</description>
          <addressOffset>0x1bc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETCE</name>
              <description>ETCE
Endpoint Transmit Complete Event - R/WC. Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status.
If the corresponding IOC bit is set in the Transfer Descriptor, then this bit is set simultaneously with the USBINT . Writing one clears the corresponding bit in this register.
ETCE[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERCE</name>
              <description>ERCE
Endpoint Receive Complete Event - RW/C. Each bit indicates a received event (OUT/SETUP) occurred
and software should read the corresponding endpoint queue to determine the transfer status. If the
corresponding IOC bit is set in the Transfer Descriptor, then this bit is set simultaneously with the
USBINT . Writing one clears the corresponding bit in this register.
ERCE[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>ENDPTCTRL0,ENDPTCTRL1,ENDPTCTRL2,ENDPTCTRL3,ENDPTCTRL4,ENDPTCTRL5,ENDPTCTRL6,ENDPTCTRL7</dimIndex>
          <name>ENDPTCTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00CD00CD</resetMask>
          <fields>
            <field>
              <name>TXE</name>
              <description>TXE
TX Endpoint Enable
0 Disabled [Default]
1 Enabled
An Endpoint should be enabled only after it has been configured.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXR</name>
              <description>TXR
TX Data Toggle Reset (WS)
Write 1 - Reset PID Sequence
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order
to synchronize the data PID's between the Host and device.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXT</name>
              <description>TXT
TX Endpoint Type - Read/Write
00 Control
01 Isochronous
10 Bulk
11 Interrupt</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXS</name>
              <description>TXS
TX Endpoint Stall - Read/Write
0 End Point OK
1 End Point Stalled
This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured
as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared.
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host.
This control will continue to STALL until this bit is either cleared by software or automatically cleared as above for control endpoints.
NOTE: [CONTROL ENDPOINT TYPES ONLY]: there is a slight delay (50 clocks max) between the ENDPTSETUPSTAT begin cleared and hardware continuing to clear this bit.
In most systems, it is unlikely the DCD software will observe this delay. However, should the DCD observe that the stall bit is not set after writing a one to it then follow this procedure:
continually write this stall bit until it is set or until a new setup has been received by checking the associated endptsetupstat Bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXE</name>
              <description>RXE
RX Endpoint Enable
0 Disabled [Default]
1 Enabled
An Endpoint should be enabled only after it has been configured.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXR</name>
              <description>RXR
RX Data Toggle Reset (WS)
Write 1 - Reset PID Sequence
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order
to synchronize the data PID's between the host and device.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXT</name>
              <description>RXT
RX Endpoint Type - Read/Write
00 Control
01 Isochronous
10 Bulk
11 Interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXS</name>
              <description>RXS
RX Endpoint Stall - Read/Write
0 End Point OK. [Default]
1 End Point Stalled
This bit is set automatically upon receipt of a SETUP request if this Endpoint is configured as a Control
Endpointand this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit
is cleared.
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. This
control will continue to STALL until this bit is either cleared by software or automatically cleared as above
for control endpoints.
NOTE: [CONTROL ENDPOINT TYPES ONLY]: there is a slight delay (50 clocks max) between the
ENDPTSETUPSTAT begin cleared and hardware continuing to clear this bit. In most systems, it
is unlikely the DCD software will observe this delay. However, should the DCD observe that the
stall bit is not set after writing a one to it then follow this procedure: continually write this stall bit
until it is set or until a new setup has been received by checking the associated endptsetupstat
Bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OTG_CTRL0</name>
          <description>No description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x020B3F90</resetMask>
          <fields>
            <field>
              <name>OTG_WKDPDMCHG_EN</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTORESUME_EN</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_VBUS_WAKEUP_EN</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_ID_WAKEUP_EN</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_VBUS_SOURCE_SEL</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_UTMI_SUSPENDM_SW</name>
              <description>default 0 for naneng usbphy</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_UTMI_RESET_SW</name>
              <description>default 1 for naneng usbphy</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_WAKEUP_INT_ENABLE</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_POWER_MASK</name>
              <description>No description available</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_OVER_CUR_POL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_OVER_CUR_DIS</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SER_MODE_SUSPEND_EN</name>
              <description>for naneng usbphy, only switch to serial mode when suspend</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CTRL0</name>
          <description>No description available</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x02007007</resetMask>
          <fields>
            <field>
              <name>GPIO_ID_SEL_N</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SESS_VALID_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SESS_VALID_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CTRL1</name>
          <description>No description available</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00100002</resetMask>
          <fields>
            <field>
              <name>UTMI_CFG_RST_N</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_OTG_SUSPENDM</name>
              <description>OTG suspend, not utmi_suspendm</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOP_STATUS</name>
          <description>No description available</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>WAKEUP_INT_STATUS</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_STATUS</name>
          <description>No description available</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x800000F5</resetMask>
          <fields>
            <field>
              <name>UTMI_CLK_VALID</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINE_STATE</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_DISCONNECT</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_SESS_VALID</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTMR0</name>
      <description>GPTMR0</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf3000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>ch0,ch1,ch2,ch3</dimIndex>
          <name>CHANNEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CR</name>
            <description>Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x80007FFF</resetMask>
            <fields>
              <field>
                <name>CNTUPT</name>
                <description>1- update counter to new value as CNTUPTVAL
This bit will be auto cleared after 1 cycle</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CNTRST</name>
                <description>1- reset counter</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCFLW</name>
                <description>1- enable this channel to reset counter to reload(RLD) together with its previous channel.
This bit is not valid for channel 0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCIFEN</name>
                <description>1- SYNCI is valid on its falling edge</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCIREN</name>
                <description>1- SYNCI is valid on its rising edge</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CEN</name>
                <description>1- counter enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPINIT</name>
                <description>Output compare initial poliarity
1- The channel output initial level is high
0- The channel output initial level is low
User should set this bit before set CMPEN to 1.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPEN</name>
                <description>1- Enable the channel output compare function. The output signal can be generated per comparator (CMPx) settings.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMASEL</name>
                <description>select one of DMA request:
00- CMP0 flag
01- CMP1 flag
10- Input signal toggle captured
11- RLD flag, counter reload;</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAEN</name>
                <description>1- enable dma</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWSYNCIEN</name>
                <description>1- enable software sync. When this bit is set, counter will reset to RLD when swsynct bit is set</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBGPAUSE</name>
                <description>1- counter will pause if chip is in debug mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPMODE</name>
                <description>This bitfield define the input capture mode
100:  width measure mode, timer will calculate the input signal period and duty cycle
011:  capture at both rising edge and falling edge
010:  capture at falling edge
001:  capture at rising edge
000:  No capture</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>CMP0,CMP1</dimIndex>
            <name>CMP[%s]</name>
            <description>no description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFF0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CMP</name>
                <description>compare value 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RLD</name>
            <description>Reload register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RLD</name>
                <description>reload value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNTUPTVAL</name>
            <description>Counter update value register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTUPTVAL</name>
                <description>counter will be set to this value when software write cntupt bit in CR</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPPOS</name>
            <description>Capture rising edge register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPPOS</name>
                <description>This register contains the counter value captured at input signal rising edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPNEG</name>
            <description>Capture falling edge register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPNEG</name>
                <description>This register contains the counter value captured at input signal falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPPRD</name>
            <description>PWM period measure register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPPRD</name>
                <description>This register contains the input signal period when channel is configured to input capture measure mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPDTY</name>
            <description>PWM duty cycle measure register</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MEAS_HIGH</name>
                <description>This register contains the input signal duty cycle when channel is configured to input capture measure mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNT</name>
            <description>Counter</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>32 bit counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>SR</name>
          <description>Status register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3CMP1F</name>
              <description>channel 3 compare value 1 match flag</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3CMP0F</name>
              <description>channel 3 compare value 1 match flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3CAPF</name>
              <description>channel 3 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3RLDF</name>
              <description>channel 3 counter reload flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CMP1F</name>
              <description>channel 2 compare value 1 match flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CMP0F</name>
              <description>channel 2 compare value 1 match flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CAPF</name>
              <description>channel 2 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2RLDF</name>
              <description>channel 2 counter reload flag</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CMP1F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CMP0F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CAPF</name>
              <description>channel 1 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1RLDF</name>
              <description>channel 1 counter reload flag</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CMP1F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CMP0F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CAPF</name>
              <description>channel 1 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0RLDF</name>
              <description>channel 1 counter reload flag</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQEN</name>
          <description>Interrupt request enable register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3CMP1EN</name>
              <description>1- generate interrupt request when ch3cmp1f flag is set</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3CMP0EN</name>
              <description>1- generate interrupt request when ch3cmp0f flag is set</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3CAPEN</name>
              <description>1- generate interrupt request when ch3capf flag is set</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3RLDEN</name>
              <description>1- generate interrupt request when ch3rldf flag is set</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CMP1EN</name>
              <description>1- generate interrupt request when ch2cmp1f flag is set</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CMP0EN</name>
              <description>1- generate interrupt request when ch2cmp0f flag is set</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CAPEN</name>
              <description>1- generate interrupt request when ch2capf flag is set</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2RLDEN</name>
              <description>1- generate interrupt request when ch2rldf flag is set</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CMP1EN</name>
              <description>1- generate interrupt request when ch1cmp1f flag is set</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CMP0EN</name>
              <description>1- generate interrupt request when ch1cmp0f flag is set</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CAPEN</name>
              <description>1- generate interrupt request when ch1capf flag is set</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1RLDEN</name>
              <description>1- generate interrupt request when ch1rldf flag is set</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CMP1EN</name>
              <description>1- generate interrupt request when ch0cmp1f flag is set</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CMP0EN</name>
              <description>1- generate interrupt request when ch0cmp0f flag is set</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CAPEN</name>
              <description>1- generate interrupt request when ch0capf flag is set</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0RLDEN</name>
              <description>1- generate interrupt request when ch0rldf flag is set</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GCR</name>
          <description>Global control register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>SWSYNCT</name>
              <description>set this bitfield to trigger software counter sync event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR1</name>
      <description>GPTMR1</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf3004000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR2</name>
      <description>GPTMR2</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf3008000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR3</name>
      <description>GPTMR3</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf300c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>PTMR</name>
      <description>PTMR</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf40e0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C0</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf3020000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x30</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>Cfg</name>
          <description>Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOSIZE</name>
              <description>FIFO Size:
0: 2 bytes
1: 4 bytes
2: 8 bytes
3: 16 bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntEn</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPL</name>
              <description>Set to enable the Completion Interrupt.
Master: interrupts when a transaction is issued from this master and completed without losing the bus arbitration.
Slave: interrupts when a transaction addressing the controller is completed.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTERECV</name>
              <description>Set to enable the Byte Receive Interrupt.
Interrupts when a byte of data is received
Auto-ACK will be disabled if this interrupt is enabled, that is, the software needs to ACK/NACK the received byte manually.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTETRANS</name>
              <description>Set to enable the Byte Transmit Interrupt.
Interrupts when a byte of data is transmitted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>Set to enable the START Condition Interrupt.
Interrupts when a START condition/repeated START condition is detected.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Set to enable the STOP Condition Interrupt
Interrupts when a STOP condition is detected.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ARBLOSE</name>
              <description>Set to enable the Arbitration Lose Interrupt.
Master: interrupts when the controller loses the bus arbitration
Slave: not available in this mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRHIT</name>
              <description>Set to enable the Address Hit Interrupt.
Master: interrupts when the addressed slave returned an ACK.
Slave: interrupts when the controller is addressed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOHALF</name>
              <description>Set to enable the FIFO Half Interrupt.
Receiver: Interrupts when the FIFO is half-empty, i.e, there is &gt;= 1/2 entries in the FIFO.
Transmitter: Interrupts when the FIFO is half-empty, i.e. there is &lt;= 1/2 entries in the FIFO.
This interrupt depends on the transaction direction; don’t enable this interrupt unless the transfer direction is determined, otherwise unintended interrupts may be triggered.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOFULL</name>
              <description>Set to enable the FIFO Full Interrupt.
Interrupts when the FIFO is full.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOEMPTY</name>
              <description>Set to enabled the FIFO Empty Interrupt
Interrupts when the FIFO is empty.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Status</name>
          <description>Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINESDA</name>
              <description>Indicates the current status of the SDA line on the bus
1: high
0: low</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LINESCL</name>
              <description>Indicates the current status of the SCL line on the bus
1: high
0: low</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GENCALL</name>
              <description>Indicates that the address of the current transaction is a general call address:
1: General call
0: Not general call</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSBUSY</name>
              <description>Indicates that the bus is busy
The bus is busy when a START condition is on bus and it ends when a STOP condition is seen on bus
1: Busy
0: Not busy</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK</name>
              <description>Indicates the type of the last received/transmitted acknowledgement bit:
1: ACK
0: NACK</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMPL</name>
              <description>Transaction Completion
Master: Indicates that a transaction has been issued from this master and completed without losing the bus arbitration
Slave: Indicates that a transaction addressing the controller has been completed. This status bit must be cleared to receive the next transaction; otherwise, the next incoming transaction will be blocked.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BYTERECV</name>
              <description>Indicates that a byte of data has been received.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BYTETRANS</name>
              <description>Indicates that a byte of data has been transmitted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>START</name>
              <description>Indicates that a START Condition or a repeated START condition has been transmitted/received.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Indicates that a STOP Condition has been transmitted/received.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ARBLOSE</name>
              <description>Indicates that the controller has lost the bus arbitration.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADDRHIT</name>
              <description>Master: indicates that a slave has responded to the transaction.
Slave: indicates that a transaction is targeting the controller (including the General Call).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOHALF</name>
              <description>Transmitter: Indicates that the FIFO is half-empty.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFOFULL</name>
              <description>Indicates that the FIFO is full.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFOEMPTY</name>
              <description>Indicates that the FIFO is empty.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Addr</name>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The slave address.
For 7-bit addressing mode, the most significant 3 bits are ignored and only the least-significant 7 bits of Addr are valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Data</name>
          <description>Data Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Write this register to put one byte of data to the FIFO.
Read this register to get one byte of data from the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Ctrl</name>
          <description>Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00001E00</resetValue>
          <resetMask>0x000F9FFF</resetMask>
          <fields>
            <field>
              <name>PHASE_START</name>
              <description>Enable this bit to send a START condition at the beginning of transaction.
Master mode only.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_ADDR</name>
              <description>Enable this bit to send the address after START condition.
Master mode only.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_DATA</name>
              <description>Enable this bit to send the data after Address phase.
Master mode only.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_STOP</name>
              <description>Enable this bit to send a STOP condition at the end of a transaction.
Master mode only.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIR</name>
              <description>Transaction direction
Master: Set this bit to determine the direction for the next transaction.
0: Transmitter
1: Receiver
Slave: The direction of the last received transaction.
0: Receiver
1: Transmitter</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATACNT</name>
              <description>Data counts in bytes.
Master: The number of bytes to transmit/receive. 0 means max length. DataCnt will be decreased by one for each byte transmitted/received.
Slave: the meaning of DataCnt depends on the DMA mode:
If DMA is not enabled, DataCnt is the number of bytes transmitted/received from the bus master. It is reset to 0 when the controller is addressed and then increased by one for each byte of data transmitted/received.
If DMA is enabled, DataCnt is the number of bytes to transmit/receive. It will not be reset to 0 when the slave is addressed and it will be decreased by one for each byte of data transmitted/received.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cmd</name>
          <description>Command Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>Write this register with the following values to perform the corresponding actions:
0x0: no action
0x1: issue a data transaction (Master only)
0x2: respond with an ACK to the received byte
0x3: respond with a NACK to the received byte
0x4: clear the FIFO
0x5: reset the I2C controller (abort current transaction, set the SDA and SCL line to the open-drain mode, reset the Status Register and the Interrupt Enable Register, and empty the FIFO)
When issuing a data transaction by writing 0x1 to this register, the CMD field stays at 0x1 for the duration of the entire transaction, and it is only cleared to 0x0 after when the transaction has completed or when the controller loses the arbitration.
Note: No transaction will be issued by the controller when all phases (Start, Address, Data and Stop) are disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Setup</name>
          <description>Setup Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x05252100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_SUDAT</name>
              <description>T_SUDAT defines the data setup time before releasing the SCL.
Setup time = (2 * tpclk) + (2 + T_SP + T_SUDAT) * tpclk* (TPM+1)
tpclk = PCLK period
TPM = The multiplier value in Timing Parameter Multiplier Register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SP</name>
              <description>T_SP defines the pulse width of spikes that must be suppressed by the input filter.
Pulse width = T_SP * tpclk* (TPM+1)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HDDAT</name>
              <description>T_HDDAT defines the data hold time after SCL goes LOW
Hold time = (2 * tpclk) + (2 + T_SP + T_HDDAT) * tpclk* (TPM+1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SCLRADIO</name>
              <description>The LOW period of the generated SCL clock is defined by the combination of T_SCLRatio and T_SCLHi values. When T_SCLRatio = 0, the LOW period is equal to HIGH period. When T_SCLRatio = 1, the LOW period is roughly two times of HIGH period.
SCL LOW period = (2 * tpclk) + (2 + T_SP + T_SCLHi * ratio) * tpclk * (TPM+1)
1: ratio = 2
0: ratio = 1
This field is only valid when the controller is in the master mode.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SCLHI</name>
              <description>The HIGH period of generated SCL clock is defined by T_SCLHi.
SCL HIGH period = (2 * tpclk) + (2 + T_SP + T_SCLHi) * tpclk* (TPM+1)
The T_SCLHi value must be greater than T_SP and T_HDDAT values.
This field is only valid when the controller is in the master mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAEN</name>
              <description>Enable the direct memory access mode data transfer.
1: Enable
0: Disable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER</name>
              <description>Configure this device as a master or a slave.
1: Master mode
0: Slave mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRESSING</name>
              <description>I2C addressing mode:
1: 10-bit addressing mode
0: 7-bit addressing mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IICEN</name>
              <description>Enable the I2C controller.
1: Enable
0: Disable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TPM</name>
          <description>I2C Timing Paramater Multiplier</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPM</name>
              <description>A multiplication value for I2C timing parameters. All the timing parameters in the Setup Register are multiplied by (TPM+1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C1</name>
      <description>I2C1</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf3024000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C2</name>
      <description>I2C2</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf3028000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C3</name>
      <description>I2C3</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf302c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LIN0</name>
      <description>LIN0</description>
      <groupName>LIN</groupName>
      <baseAddress>0xf3030000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>data_byte0,data_byte1,data_byte2,data_byte3,data_byte4,data_byte5,data_byte6,data_byte7</dimIndex>
          <name>DATABYTE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DATA_BYTE</name>
              <description>data byte</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>control</name>
          <description>control register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>STOP</name>
              <description>slave only. Write 1 when the Host determin do not response to the data request according to a unkown ID</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SLEEP</name>
              <description>The bit is used by the LIN core to determine whether the LIN bus is in sleep mode or not. Set this bit after sending or receiving a Sleep Mode frame or if a bus idle timeout interrupt is requested or if after a wakeup request there is no response from the master and a timeout is signaled. The bit will be automatically reset by the LIN core.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMIT</name>
              <description>1: transmit operation 0: receive operation</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_ACK</name>
              <description>slave only. Write 1 after handling a data request interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_INT</name>
              <description>write 1 to reset the int bit in the status register and the interrupt request output of LIN</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RESET_ERROR</name>
              <description>assert 1 to reset the error bits in status register and error register. A read access to this bit delivers always the value 0</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKEUP_REQ</name>
              <description>wakeup request. Assert to terminate the Sleep mode of the LIN bus. The bit will be reset by core</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START_REQ</name>
              <description>master only. Set by host controller of a LIN master to start the LIN transmission. The core will reset the bit after the transmission is finished or an error is occurred</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>state</name>
          <description>state register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>LIN_ACTIVE</name>
              <description>The bit indicates whether the LIN bus is active or not</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUS_IDLE_TV</name>
              <description>slave only. This bit is set by LIN core if bit sleep  is not set and no bus activity is detected for 4s</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABORTED</name>
              <description>slave only. This bit is set by LIN core slave if a transmission is aborted after the bneginning of the data field due to a timeout or bit error.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_REQ</name>
              <description>slave only. Sets after receiving the identifier and requests an interrupt to the host controller.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INT</name>
              <description>set when request an interrupt. Reset by reset_int</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERROR</name>
              <description>set when detecte an error, clear by reset_error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WAKEUP</name>
              <description>set when transmitting a wakeup signal or when received a wakeup signal. Clear when reset_error bit is 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>COMPLETE</name>
              <description>set after a transmission has been successful finished and it will reset at the start of a transmission.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>error</name>
          <description>error register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>PARITY_ERROR</name>
              <description>slave only. identifier parity error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>timeout error. The master detects a timeout error if it is expecting data from the bus but no slave does respond. The slave detects a timeout error if it is requesting a data acknowledge to the host controller. The slave detects a timeout if it has transmitted a wakeup signal and it detects no sync field within 150ms</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHK_ERROR</name>
              <description>checksum error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERROR</name>
              <description>bit error</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>data_len</name>
          <description>data lenth register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000008F</resetMask>
          <fields>
            <field>
              <name>ENH_CHECK</name>
              <description>1:enhence check mode</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_LENGTH</name>
              <description>data length</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>baudrate_ctl_low</name>
          <description>baudrate control low register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>BT_DIV_LOW</name>
              <description>bit div register 7:0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>bardrate_ctl_high</name>
          <description>baudrate control high register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PRESCL</name>
              <description>prescl register</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BT_MUL</name>
              <description>bt_mul register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BT_DIV_HIGH</name>
              <description>bit div register 8</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>id</name>
          <description>id register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>id register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tv</name>
          <description>timeout control register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000040</resetValue>
          <resetMask>0x000000CF</resetMask>
          <fields>
            <field>
              <name>INITIAL_MODE</name>
              <description>initial_mode</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>master_mode</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_INACTIVITY_TIME</name>
              <description>slave only. LIN bus idle timeout register： 00-4s  01-6s  10-8s  11-10s</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WUP_REPEAT_TIME</name>
              <description>slave only. wakeup repeat interval time  00-180ms  01-200ms 10-220ms 11-240ms</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LIN0">
      <name>LIN1</name>
      <description>LIN1</description>
      <groupName>LIN</groupName>
      <baseAddress>0xf3034000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LIN0">
      <name>LIN2</name>
      <description>LIN2</description>
      <groupName>LIN</groupName>
      <baseAddress>0xf3038000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LIN0">
      <name>LIN3</name>
      <description>LIN3</description>
      <groupName>LIN</groupName>
      <baseAddress>0xf303c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SDP</name>
      <description>SDP</description>
      <groupName>SDP</groupName>
      <baseAddress>0xf304c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x60</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SDPCR</name>
          <description>SDP control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xFFFE0101</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>soft reset.
Write 1 then 0, to reset the SDP block.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKGAT</name>
              <description>Clock Gate for the SDP main logic.
Write to 1 will clock gate for most logic of the SDP block, dynamic power saving when not use SDP block.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIPDIS</name>
              <description>Cipher Disable, read the info, whether the CIPHER features is besing disable in this chip or not.
1, Cipher is disabled in this chip.
0, Cipher is enabled in this chip.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HASDIS</name>
              <description>HASH Disable, read the info, whether the HASH features is besing disable in this chip or not.
1, HASH is disabled in this chip.
0, HASH is enabled in this chip.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CIPHEN</name>
              <description>Cipher Enablement, controlled by SW.
1, Cipher is Enabled.
0, Cipher is Disabled.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASHEN</name>
              <description>HASH Enablement, controlled by SW.
1, HASH is Enabled.
0, HASH is Disabled.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCPEN</name>
              <description>Memory Copy Enablement, controlled by SW.
1, Memory copy is Enabled.
0, Memory copy is Disabled.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFEN</name>
              <description>Constant Fill to memory, controlled by SW.
1, Constant fill is Enabled.
0, Constant fill is Disabled.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRPDI</name>
              <description>Decryption Disable bit, Write to 1 to disable the decryption.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSTPKT0IRQ</name>
              <description>Test purpose for interrupt when Packet counter reachs "0", but CHAIN=1 in the current packet.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDSCEN</name>
              <description>when set to "1", the 1st data packet descriptor loacted in the register(CMDPTR, NPKTPTR, ...)
when set to "0", the 1st data packet descriptor loacted in the memeory(pointed by CMDPTR)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enablement, controlled by SW.
1, SDP interrupt is enabled.
0, SDP interrupt is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODCTRL</name>
          <description>Mod control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF7FF</resetMask>
          <fields>
            <field>
              <name>AESALG</name>
              <description>AES algorithem selection.
0x0 = AES 128;
0x1 = AES 256;
0x8 = SM4；
Others, reserved.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESMOD</name>
              <description>AES mode selection.
0x0 = ECB;
0x1 = CBC;
Others, reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESKS</name>
              <description>AES Key Selection.
These regisgers are being used to select the AES key that stored in the 16x128 key ram of the SDP, or select the key from the OTP. Detail as following:
0x00: key from the 16x128, this is the key read address, valid for AES128; AES256 will use 128 bit from this address and 128 bit key from next address as 256 bit AES key.
0x01: key from the 16x128, this is the key read address, valid for AES128, not valid for AES286.
....
0x0E: key from the 16x128, this is the key read address, valid for AES128; AES256 will use 128 from this add and 128 from next add for the AES key.
0x0F: key from the 16x128, this is the key read address, valid for AES128, not valid for AES286.
0x20: kman_sk0[127:0] from the key manager for AES128; AES256 will use kman_sk0[255:0] as AES key.
0x21: kman_sk0[255:128] from the key manager for AES128; not valid for AES256.
0x22: kman_sk1[127:0] from the key manager for AES128; AES256 will use kman_sk1[255:0] as AES key.
0x23: kman_sk1[255:128] from the key manager for AES128; not valid for AES256.
0x24: kman_sk2[127:0] from the key manager for AES128; AES256 will use kman_sk2[255:0] as AES key.
0x25: kman_sk2[255:128] from the key manager for AES128; not valid for AES256.
0x26: kman_sk3[127:0] from the key manager for AES128; AES256 will use kman_sk3[255:0] as AES key.
0x27: kman_sk3[255:128] from the key manager for AES128; not valid for AES256.
0x30: exip0_key[127:0] from OTP for AES128; AES256 will use exip0_key[255:0] as AES key.
0x31: exip0_key[255:128] from OTP for AES128; not valid for AES256.
0x32: exip1_key[127:0] from OTP for AES128; AES256 will use exip1_key[255:0] as AES key.
0x33: exip1_key[255:128] from OTP for AES128; not valid for AES256.
Other values, reserved.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESDIR</name>
              <description>AES direction
1x1, AES Decryption
1x0, AES Encryption.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASALG</name>
              <description>HASH Algorithem selection.
0x0 SHA1 —
0x1 CRC32 —
0x2 SHA256 —</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASCHK</name>
              <description>HASH Check Enable Bit.
1x1, HASH check need, hash result will compare with the HASHRSLT 0-7 registers;
1x0, HASH check is not enabled, HASHRSLT0-7 store the HASH result.
For SHA1, will use HASHRSLT0-3 words, and HASH 256 will use HASH0-7 words.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASOUT</name>
              <description>When hashing is enabled, this bit controls the input or output data of the AES engine is hashed.
0 INPUT HASH
1 OUTPUT HASH</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DINSWP</name>
              <description>Decide whether the SDP byteswaps the input data (big-endian data);
When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUTSWP</name>
              <description>Decide whether the SDP byteswaps the output data (big-endian data); When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEYSWP</name>
              <description>Decide whether the SDP byteswaps the Key (big-endian data).
When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTCNT</name>
          <description>packet counter registers.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTVAL</name>
              <description>This read-only field shows the current (instantaneous) value of the packet counter</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNTINCR</name>
              <description>The value written to this field is added to the spacket count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Registers</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>packet tag.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>interrupt Request, requested when error happen, or when packet processing done, packet counter reach to zero.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CHN1PKT0</name>
              <description>the chain buffer "chain" bit is "1", while packet counter is "0", now, waiting for new buffer data.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AESBSY</name>
              <description>AES Busy</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HASBSY</name>
              <description>Hashing Busy</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PKTCNT0</name>
              <description>Packet Counter registers reachs to ZERO now.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PKTDON</name>
              <description>Packet processing done, will trigger this itnerrrupt when the "PKTINT" bit set in the packet control word.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRSET</name>
              <description>Working mode setup error.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRPKT</name>
              <description>Packet head access error, or status update error.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRSRC</name>
              <description>Source Buffer Access Error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRDST</name>
              <description>Destination Buffer Error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRHAS</name>
              <description>Hashing Check Error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRCHAIN</name>
              <description>buffer chain error happen when packet's CHAIN bit=0, but the Packet counter is still not zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEYADDR</name>
          <description>Key Address</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INDEX</name>
              <description>To write a key to the SDP KEY RAM, the software must first write the desired key index/subword to this register.
Key index pointer. The valid indices are 0-[number_keys].
In the SDP, there is a 16x128 key ram can store 16 AES128 keys or 8 AES 256 Keys; this index is for addressing the 16 128-bit key addresses.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUBWRD</name>
              <description>Key subword pointer. The valid indices are 0-3. After each write to the key data register, this field
increments; To write a key, the software must first write the desired key index/subword to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEYDAT</name>
          <description>Key Data</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEYDAT</name>
              <description>This register provides the write access to the key/key subword specified by the key index register.
Writing this location updates the selected subword for the key located at the index
specified by the key index register. The write also triggers the SUBWORD field of the
KEY register to increment to the next higher word in the key</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>CIPHIV0,CIPHIV1,CIPHIV2,CIPHIV3</dimIndex>
          <name>CIPHIV[%s]</name>
          <description>no description available</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CIPHIV</name>
              <description>cipher initialization vector.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>HASWRD0,HASWRD1,HASWRD2,HASWRD3,HASWRD4,HASWRD5,HASWRD6,HASWRD7</dimIndex>
          <name>HASWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASWRD</name>
              <description>Hash Data Word x - HASH result bit; will store the expected hash result bit if hash check enabled; when hash check is not enabled,  the hash engine will store the final hash result[31:0] here.
If CRC mode enabled, this work store the CRC expected result if the check enabled, or store the final calcuated CRC result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDPTR</name>
          <description>Command Pointer</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMDPTR</name>
              <description>current command addresses the register points to the multiword
descriptor that is to be executed (or is currently being executed)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPKTPTR</name>
          <description>Next Packet Address Pointer</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NPKTPTR</name>
              <description>Next Packet Address Pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTCTL</name>
          <description>Packet Control Registers</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTTAG</name>
              <description>packet tag</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIPHIV</name>
              <description>Load Initial Vector for the AES in this packet.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASFNL</name>
              <description>Hash Termination packet</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASINI</name>
              <description>Hash Initialization packat</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAIN</name>
              <description>whether the next command pointer register must be loaded into the channel's current descriptor
pointer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRSEMA</name>
              <description>whether the channel's semaphore must be decremented at the end of the current operation.
When the semaphore reaches a value of zero, no more operations are issued from the channel.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PKTINT</name>
              <description>Reflects whether the channel must issue an interrupt upon the completion of the packet</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTSRC</name>
          <description>Packet Memory Source Address</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTSRC</name>
              <description>Packet Memory Source Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTDST</name>
          <description>Packet Memory Destination Address</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTDST</name>
              <description>Packet Memory Destination Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTBUF</name>
          <description>Packet buffer size.</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTBUF</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYSCTL</name>
      <description>SYSCTL</description>
      <groupName>SYSCTL</groupName>
      <baseAddress>0xf4000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>134</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>cpu0,cpx0,rsv2,rsv3,rsv4,rsv5,rsv6,rsv7,cpu1,cpx1,rsv10,rsv11,rsv12,rsv13,rsv14,rsv15,rsv16,rsv17,rsv18,rsv19,rsv20,pow_cpu0,pow_cpu1,rst_soc,rst_cpu0,rst_cpu1,rsv26,rsv27,rsv28,rsv29,rsv30,rsv31,clk_src_xtal,clk_src_pll0,clk_src_clk0_pll0,clk_src_clk1_pll0,clk_src_clk2_pll0,clk_src_pll1,clk_src_clk0_pll1,clk_src_clk1_pll1,clk_src_pll2,clk_src_clk0_pll2,clk_src_clk1_pll2,clk_src_pll0_ref,clk_src_pll1_ref,clk_src_pll2_ref,rsv46,rsv47,rsv48,rsv49,rsv50,rsv51,rsv52,rsv53,rsv54,rsv55,rsv56,rsv57,rsv58,rsv59,rsv60,rsv61,rsv62,rsv63,clk_top_cpu0,clk_top_mct0,clk_top_mct1,clk_top_xpi0,clk_top_tmr0,clk_top_tmr1,clk_top_tmr2,clk_top_tmr3,clk_top_urt0,clk_top_urt1,clk_top_urt2,clk_top_urt3,clk_top_urt4,clk_top_urt5,clk_top_urt6,clk_top_urt7,clk_top_i2c0,clk_top_i2c1,clk_top_i2c2,clk_top_i2c3,clk_top_spi0,clk_top_spi1,clk_top_spi2,clk_top_spi3,clk_top_can0,clk_top_can1,clk_top_can2,clk_top_can3,clk_top_ptpc,clk_top_ana0,clk_top_ana1,clk_top_ana2,clk_top_ana3,clk_top_ana4,clk_top_ref0,clk_top_ref1,clk_top_lin0,clk_top_lin1,clk_top_lin2,clk_top_lin3,rsv104,rsv105,rsv106,rsv107,rsv108,rsv109,rsv110,rsv111,rsv112,rsv113,rsv114,rsv115,rsv116,rsv117,rsv118,rsv119,rsv120,rsv121,rsv122,rsv123,rsv124,rsv125,rsv126,rsv127,clk_top_adc0,clk_top_adc1,clk_top_adc2,clk_top_dac0,clk_top_dac1,rsv133,rsv134,rsv135,rsv136,rsv137,rsv138,rsv139,rsv140,rsv141,rsv142,rsv143,rsv144,rsv145,rsv146,rsv147,rsv148,rsv149,rsv150,rsv151,rsv152,rsv153,rsv154,rsv155,rsv156,rsv157,rsv158,rsv159,rsv160,rsv161,rsv162,rsv163,rsv164,rsv165,rsv166,rsv167,rsv168,rsv169,rsv170,rsv171,rsv172,rsv173,rsv174,rsv175,rsv176,rsv177,rsv178,rsv179,rsv180,rsv181,rsv182,rsv183,rsv184,rsv185,rsv186,rsv187,rsv188,rsv189,rsv190,rsv191,rsv192,rsv193,rsv194,rsv195,rsv196,rsv197,rsv198,rsv199,rsv200,rsv201,rsv202,rsv203,rsv204,rsv205,rsv206,rsv207,rsv208,rsv209,rsv210,rsv211,rsv212,rsv213,rsv214,rsv215,rsv216,rsv217,rsv218,rsv219,rsv220,rsv221,rsv222,rsv223,rsv224,rsv225,rsv226,rsv227,rsv228,rsv229,rsv230,rsv231,rsv232,rsv233,rsv234,rsv235,rsv236,rsv237,rsv238,rsv239,rsv240,rsv241,rsv242,rsv243,rsv244,rsv245,rsv246,rsv247,rsv248,rsv249,rsv250,rsv251,rsv252,rsv253,rsv254,rsv255,ahbp,axis,axic,lmm0,mct0,lmm1,mct1,rom0,ram0,i2c0,i2c1,i2c2,i2c3,tmr0,tmr1,tmr2,tmr3,gpio,adc0,adc1,adc2,dac0,dac1,acmp,spi0,spi1,spi2,spi3,sdm0,urt0,urt1,urt2,urt3,urt4,urt5,urt6,urt7,lin0,lin1,lin2,lin3,ptpc,can0,can1,can2,can3,wdg0,wdg1,mbx0,mbx1,crc0,mot0,mot1,mot2,mot3,synt,xpi0,hdma,xdma,kman,sdp0,rng0,tsns,usb0,ref0,ref1</dimIndex>
          <name>RESOURCE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0000003</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any nodes
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: no change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODE</name>
              <description>resource work mode
0:auto turn on and off as system required(recommended)
1:always on
2:always off
3:reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>link0,link1,link2</dimIndex>
          <name>GROUP0[%s]</name>
          <description>no description available</description>
          <addressOffset>0x800</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Group setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: peripheral is not needed
1: periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Group setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: add periphera into this group，periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Group setting</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: delete periphera in this group，periphera is not needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Group setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: toggle the result that whether periphera is needed before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>link0,link1,link2</dimIndex>
          <name>GROUP1[%s]</name>
          <description>no description available</description>
          <addressOffset>0x840</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Group setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: peripheral is not needed
1: periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Group setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: add periphera into this group，periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Group setting</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: delete periphera in this group，periphera is not needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Group setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: toggle the result that whether periphera is needed before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>cpu0,cpu1</dimIndex>
          <name>AFFILIATE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x900</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
bit0: cpu0 depends on group0
bit1: cpu0 depends on group1
bit2: cpu0 depends on group2
bit3: cpu0 depends on group3</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0，each bit represents a group
0: no effect
1: the group is assigned to CPU0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
0: no effect
1: the group is not assigned to CPU0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Affiliate of Group</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
0: no effect
1: toggle the result that whether the group is assigned to CPU0 before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>cpu0,cpu1</dimIndex>
          <name>RETENTION[%s]</name>
          <description>no description available</description>
          <addressOffset>0x920</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Retention Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
bit00: soc_mem is kept on while cpu0 stop
bit01: soc_ctx is kept on while cpu0 stop
bit02: cpu0_mem is kept on while cpu0 stop
bit03: cpu0_ctx is kept on while cpu0 stop
bit04: cpu1_mem is kept on while cpu0 stop
bit05: cpu1_ctx is kept on while cpu0 stop
bit06: xtal_hold is kept on while cpu0 stop
bit07: pll0_hold is kept on while cpu0 stop
bit08: pll1_hold is kept on while cpu0 stop
bit09: pll2_hold is kept on while cpu0 stop</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Retention Control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: keep</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Retention Control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: no keep</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Retention Control</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: toggle the result that whether the resource is kept on while CPU0 stop before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>cpu0,cpu1</dimIndex>
          <name>POWER[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <register>
            <name>status</name>
            <description>Power Setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xC0001100</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag represents power cycle happened from last clear of this bit
0: power domain did not edurance power cycle since last clear of this bit
1: power domain enduranced power cycle since last clear of this bit</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLAG_WAKE</name>
                <description>flag represents wakeup power cycle happened from last clear of this bit
0: power domain did not edurance wakeup power cycle since last clear of this bit
1: power domain enduranced wakeup power cycle since last clear of this bit</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LF_DISABLE</name>
                <description>low fanout power switch disable
0: low fanout power switches are turned on
1: low fanout power switches are truned off</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LF_ACK</name>
                <description>low fanout power switch feedback
0: low fanout power switches are turned on
1: low fanout power switches are truned off</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>lf_wait</name>
            <description>Power Setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000255</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>WAIT</name>
                <description>wait time for low fan out power switch turn on, default value is 255
0: 0 clock cycle
1: 1 clock cycles
. . .
clock cycles count on 24MHz</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>off_wait</name>
            <description>Power Setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000015</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>WAIT</name>
                <description>wait time for power switch turn off, default value is 15
0: 0 clock cycle
1: 1 clock cycles
. . .
clock cycles count on 24MHz</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>soc,cpu0,cpu1</dimIndex>
          <name>RESET[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1400</addressOffset>
          <register>
            <name>control</name>
            <description>Reset Setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xC0000011</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag represents reset happened from last clear of this bit
0: domain did not edurance reset cycle since last clear of this bit
1:  domain enduranced reset cycle since last clear of this bit</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLAG_WAKE</name>
                <description>flag represents wakeup reset happened from last clear of this bit
0: domain did not edurance wakeup reset cycle since last clear of this bit
1:  domain enduranced wakeup reset cycle since last clear of this bit</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HOLD</name>
                <description>perform reset and hold in reset, until ths bit cleared by software
0: reset is released for function
1: reset is assert and hold</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET</name>
                <description>perform reset and release imediately
0: reset is released
1 reset is asserted and will release automatically</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>config</name>
            <description>Reset Setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00643203</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>PRE_WAIT</name>
                <description>wait cycle numbers before assert reset
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RSTCLK_NUM</name>
                <description>reset clock number(must be even number)
0: 0 cycle
1: 0 cycles
2: 2 cycles
3: 2 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POST_WAIT</name>
                <description>time guard band for  reset release
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>counter</name>
            <description>Reset Setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000003</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>self clear trigger counter, reset triggered when counter value is 1, write 0 will cancel reset
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>1</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_cpu0</dimIndex>
          <name>CLOCK_CPU[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD0FF07FF</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUB1_DIV</name>
              <description>ahb bus divider, the bus clock is generated by cpu_clock/div
0: divider by 1
1: divider by 2
…</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUB0_DIV</name>
              <description>axi bus divider, the bus clock is generated by cpu_clock/div
0: divider by 1
1: divider by 2
…</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux in clock component
0:osc0_clk0
1:pll0_clk0
2:pll0_clk1
3:pll0_clk2
4:pll1_clk0
5:pll1_clk1
6:pll2_clk0
7:pll2_clk1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV</name>
              <description>clock divider
0: divider by 1
1: divider by 2
2: divider by 3
. . .
255: divider by 256</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>39</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_mct0,clk_top_mct1,clk_top_xpi0,clk_top_tmr0,clk_top_tmr1,clk_top_tmr2,clk_top_tmr3,clk_top_urt0,clk_top_urt1,clk_top_urt2,clk_top_urt3,clk_top_urt4,clk_top_urt5,clk_top_urt6,clk_top_urt7,clk_top_i2c0,clk_top_i2c1,clk_top_i2c2,clk_top_i2c3,clk_top_spi0,clk_top_spi1,clk_top_spi2,clk_top_spi3,clk_top_can0,clk_top_can1,clk_top_can2,clk_top_can3,clk_top_ptpc,clk_top_ana0,clk_top_ana1,clk_top_ana2,clk_top_ana3,clk_top_ana4,clk_top_ref0,clk_top_ref1,clk_top_lin0,clk_top_lin1,clk_top_lin2,clk_top_lin3</dimIndex>
          <name>CLOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD00007FF</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux in clock component
0:osc0_clk0
1:pll0_clk0
2:pll0_clk1
3:pll0_clk2
4:pll1_clk0
5:pll1_clk1
6:pll2_clk0
7:pll2_clk1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV</name>
              <description>clock divider
0: divider by 1
1: divider by 2
2: divider by 3
. . .
255: divider by 256</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>3</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_adc0,clk_top_adc1,clk_top_adc2</dimIndex>
          <name>ADCCLK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD0000100</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux
0: ana clock N
1: ahb clock</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_dac0,clk_top_dac1</dimIndex>
          <name>DACCLK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c0c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD0000100</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux
0: ana clock N
1: ahb clock</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>global00</name>
          <description>Clock senario</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>MUX</name>
              <description>global clock override request
bit0: override to preset0
bit1: override to preset1
bit2: override to preset2
bit3: override to preset3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>slice0,slice1,slice2,slice3</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2400</addressOffset>
          <register>
            <name>control</name>
            <description>Clock measure and monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x89FFD7FF</resetMask>
            <fields>
              <field>
                <name>VALID</name>
                <description>result is ready for read
0: not ready
1: result is ready</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV_BUSY</name>
                <description>divider is applying new setting</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OUTEN</name>
                <description>enable clock output</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV</name>
                <description>output divider</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HIGH</name>
                <description>clock frequency higher than upper limit</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOW</name>
                <description>clock frequency lower than lower limit</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>START</name>
                <description>start measurement</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>work mode,
0: register value will be compared to measurement
1: upper and lower value will be recordered in register</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACCURACY</name>
                <description>measurement accuracy,
0: resolution is 1kHz
1: resolution is 1Hz</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REFERENCE</name>
                <description>reference clock selection,
0: 32k
1: 24M</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SELECTION</name>
                <description>clock measurement selection
  0: clk_32k
  1: clk_irc24m
  2: clk_xtal_24m
  3: clk_usb0_phy
  8: clk0_osc0
  9: clk0_pll0
 10: clk1_pll0
 11: clk2_pll0
 12: clk0_pll1
 13: clk1_pll1
 14: clk0_pll2
 15: clk1_pll2
128: clk_top_cpu0
129: clk_top_mct0
130: clk_top_mct1
131: clk_top_xpi0
132: clk_top_tmr0
133: clk_top_tmr1
134: clk_top_tmr2
135: clk_top_tmr3
136: clk_top_urt0
137: clk_top_urt1
138: clk_top_urt2
139: clk_top_urt3
140: clk_top_urt4
141: clk_top_urt5
142: clk_top_urt6
143: clk_top_urt7
144: clk_top_i2c0
145: clk_top_i2c1
146: clk_top_i2c2
147: clk_top_i2c3
148: clk_top_spi0
149: clk_top_spi1
150: clk_top_spi2
151: clk_top_spi3
152: clk_top_can0
153: clk_top_can1
154: clk_top_can2
155: clk_top_can3
156: clk_top_ptpc
157: clk_top_ana0
158: clk_top_ana1
159: clk_top_ana2
160: clk_top_ana3
161: clk_top_ana4
162: clk_top_ref0
163: clk_top_ref1
164: clk_top_lin0
165: clk_top_lin1
166: clk_top_lin2
167: clk_top_lin3</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>current</name>
            <description>Clock measure result</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>self updating measure result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>low_limit</name>
            <description>Clock lower limit</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>lower frequency</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>high_limit</name>
            <description>Clock upper limit</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>upper frequency</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x400</dimIncrement>
          <dimIndex>cpu0,cpu1</dimIndex>
          <name>CPU[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2800</addressOffset>
          <register>
            <name>LP</name>
            <description>CPU0 LP control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00001000</resetValue>
            <resetMask>0xFF013703</resetMask>
            <fields>
              <field>
                <name>WAKE_CNT</name>
                <description>CPU0 wake up counter, counter satuated at 255, write 0x00 to clear</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HALT</name>
                <description>halt request for CPU0,
0: CPU0 will start to execute after reset or receive wakeup request
1: CPU0 will not start after reset, or wakeup after WFI</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WAKE</name>
                <description>CPU0 is waking up
0: CPU0 wake up not asserted
1: CPU0 wake up asserted</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXEC</name>
                <description>CPU0 is executing
0: CPU0 is not executing
1: CPU0 is executing</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WAKE_FLAG</name>
                <description>CPU0 wakeup flag, indicate a wakeup event got active, write 1 to clear this bit
0: CPU0 wakeup not happened
1: CPU0 wake up happened</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEEP_FLAG</name>
                <description>CPU0 sleep flag, indicate a sleep event got active, write 1 to clear this bit
0: CPU0 sleep not happened
1: CPU0 sleep happened</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_FLAG</name>
                <description>CPU0 reset flag, indicate a reset event got active, write 1 to clear this bit
0: CPU0 reset not happened
1: CPU0 reset happened</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Low power mode, system behavior after WFI
00: CPU clock stop after WFI
01: System enter low power mode after WFI
10: Keep running after WFI
11: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>CPU0 Lock GPR</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000002</resetValue>
            <resetMask>0x0000FFFE</resetMask>
            <fields>
              <field>
                <name>GPR</name>
                <description>Lock bit for CPU_DATA0 to CPU_DATA13, once set, this bit will not clear untile next reset</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock bit for CPU_LOCK</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>14</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>GPR0,GPR1,GPR2,GPR3,GPR4,GPR5,GPR6,GPR7,GPR8,GPR9,GPR10,GPR11,GPR12,GPR13</dimIndex>
            <name>GPR[%s]</name>
            <description>no description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPR</name>
                <description>register for software to handle resume, can save resume address or status</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>STATUS0,STATUS1,STATUS2,STATUS3</dimIndex>
            <name>WAKEUP_STATUS[%s]</name>
            <description>no description available</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STATUS</name>
                <description>IRQ values</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>ENABLE0,ENABLE1,ENABLE2,ENABLE3</dimIndex>
            <name>WAKEUP_ENABLE[%s]</name>
            <description>no description available</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>IRQ wakeup enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>IOC</name>
      <description>IOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf4040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xf40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>488</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>pa00,pa01,pa02,pa03,pa04,pa05,pa06,pa07,pa08,pa09,pa10,pa11,pa12,pa13,pa14,pa15,pa16,pa17,pa18,pa19,pa20,pa21,pa22,pa23,pa24,pa25,pa26,pa27,pa28,pa29,pa30,pa31,pb00,pb01,pb02,pb03,pb04,pb05,pb06,pb07,pb08,pb09,pb10,pb11,pb12,pb13,pb14,pb15,pb16,pb17,pb18,pb19,pb20,pb21,pb22,pb23,pb24,pb25,pb26,pb27,pb28,pb29,pb30,pb31,pc00,pc01,pc02,pc03,pc04,pc05,pc06,pc07,pc08,pc09,pc10,pc11,pc12,pc13,pc14,pc15,pc16,pc17,pc18,pc19,pc20,pc21,pc22,pc23,pc24,pc25,pc26,pc27,rsv92,rsv93,rsv94,rsv95,rsv96,rsv97,rsv98,rsv99,rsv100,rsv101,rsv102,rsv103,rsv104,rsv105,rsv106,rsv107,rsv108,rsv109,rsv110,rsv111,rsv112,rsv113,rsv114,rsv115,rsv116,rsv117,rsv118,rsv119,rsv120,rsv121,rsv122,rsv123,rsv124,rsv125,rsv126,rsv127,rsv128,rsv129,rsv130,rsv131,rsv132,rsv133,rsv134,rsv135,rsv136,rsv137,rsv138,rsv139,rsv140,rsv141,rsv142,rsv143,rsv144,rsv145,rsv146,rsv147,rsv148,rsv149,rsv150,rsv151,rsv152,rsv153,rsv154,rsv155,rsv156,rsv157,rsv158,rsv159,rsv160,rsv161,rsv162,rsv163,rsv164,rsv165,rsv166,rsv167,rsv168,rsv169,rsv170,rsv171,rsv172,rsv173,rsv174,rsv175,rsv176,rsv177,rsv178,rsv179,rsv180,rsv181,rsv182,rsv183,rsv184,rsv185,rsv186,rsv187,rsv188,rsv189,rsv190,rsv191,rsv192,rsv193,rsv194,rsv195,rsv196,rsv197,rsv198,rsv199,rsv200,rsv201,rsv202,rsv203,rsv204,rsv205,rsv206,rsv207,rsv208,rsv209,rsv210,rsv211,rsv212,rsv213,rsv214,rsv215,rsv216,rsv217,rsv218,rsv219,rsv220,rsv221,rsv222,rsv223,rsv224,rsv225,rsv226,rsv227,rsv228,rsv229,rsv230,rsv231,rsv232,rsv233,rsv234,rsv235,rsv236,rsv237,rsv238,rsv239,rsv240,rsv241,rsv242,rsv243,rsv244,rsv245,rsv246,rsv247,rsv248,rsv249,rsv250,rsv251,rsv252,rsv253,rsv254,rsv255,rsv256,rsv257,rsv258,rsv259,rsv260,rsv261,rsv262,rsv263,rsv264,rsv265,rsv266,rsv267,rsv268,rsv269,rsv270,rsv271,rsv272,rsv273,rsv274,rsv275,rsv276,rsv277,rsv278,rsv279,rsv280,rsv281,rsv282,rsv283,rsv284,rsv285,rsv286,rsv287,rsv288,rsv289,rsv290,rsv291,rsv292,rsv293,rsv294,rsv295,rsv296,rsv297,rsv298,rsv299,rsv300,rsv301,rsv302,rsv303,rsv304,rsv305,rsv306,rsv307,rsv308,rsv309,rsv310,rsv311,rsv312,rsv313,rsv314,rsv315,rsv316,rsv317,rsv318,rsv319,rsv320,rsv321,rsv322,rsv323,rsv324,rsv325,rsv326,rsv327,rsv328,rsv329,rsv330,rsv331,rsv332,rsv333,rsv334,rsv335,rsv336,rsv337,rsv338,rsv339,rsv340,rsv341,rsv342,rsv343,rsv344,rsv345,rsv346,rsv347,rsv348,rsv349,rsv350,rsv351,rsv352,rsv353,rsv354,rsv355,rsv356,rsv357,rsv358,rsv359,rsv360,rsv361,rsv362,rsv363,rsv364,rsv365,rsv366,rsv367,rsv368,rsv369,rsv370,rsv371,rsv372,rsv373,rsv374,rsv375,rsv376,rsv377,rsv378,rsv379,rsv380,rsv381,rsv382,rsv383,rsv384,rsv385,rsv386,rsv387,rsv388,rsv389,rsv390,rsv391,rsv392,rsv393,rsv394,rsv395,rsv396,rsv397,rsv398,rsv399,rsv400,rsv401,rsv402,rsv403,rsv404,rsv405,rsv406,rsv407,rsv408,rsv409,rsv410,rsv411,rsv412,rsv413,rsv414,rsv415,px00,px01,px02,px03,px04,px05,px06,px07,rsv424,rsv425,rsv426,rsv427,rsv428,rsv429,rsv430,rsv431,rsv432,rsv433,rsv434,rsv435,rsv436,rsv437,rsv438,rsv439,rsv440,rsv441,rsv442,rsv443,rsv444,rsv445,rsv446,rsv447,py00,py01,py02,py03,py04,py05,py06,py07,rsv456,rsv457,rsv458,rsv459,rsv460,rsv461,rsv462,rsv463,rsv464,rsv465,rsv466,rsv467,rsv468,rsv469,rsv470,rsv471,rsv472,rsv473,rsv474,rsv475,rsv476,rsv477,rsv478,rsv479,pz00,pz01,pz02,pz03,pz04,pz05,pz06,pz07</dimIndex>
          <name>PAD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>FUNC_CTL</name>
            <description>ALT SELECT</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0001011F</resetMask>
            <fields>
              <field>
                <name>LOOP_BACK</name>
                <description>force input on
0: disable
1: enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ANALOG</name>
                <description>select analog pin in pad
0: disable
1: enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ALT_SELECT</name>
                <description>alt select
0: ALT0
1: ALT1
…
31:ALT31</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PAD_CTL</name>
            <description>PAD SETTINGS</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x01010056</resetValue>
            <resetMask>0x01370177</resetMask>
            <fields>
              <field>
                <name>HYS</name>
                <description>schmitt trigger enable
0: disable
1: enable</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRS</name>
                <description>select pull up/down internal resistance strength:
For pull down, only have 100 Kohm resistance
For pull up:
00: 100 KOhm
01: 47 KOhm
10: 22 KOhm
11: 22 KOhm</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PS</name>
                <description>pull select
0: pull down
1: pull up</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PE</name>
                <description>pull enable
0: pull disable
1: pull enable</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>KE</name>
                <description>keeper capability enable
0: keeper disable
1: keeper enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD</name>
                <description>open drain
0: open drain disable
1: open drain enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SR</name>
                <description>slew rate
0: Slow slew rate
1: Fast slew rate</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPD</name>
                <description>additional 2-bit slew rate to select IO cell operation frequency range with reduced switching noise
00: Slow frequency slew rate(50Mhz)
01: Medium frequency slew rate(100 Mhz)
10: Fast frequency slew rate(150 Mhz)
11: Max frequency slew rate(200Mhz)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DS</name>
                <description>drive strength
1.8V Mode:
000: 260 Ohm
001: 260 Ohm
010: 130 Ohm
011: 88 Ohm
100: 65 Ohm
101: 52 Ohm
110: 43 Ohm
111: 37 Ohm
3.3V Mode:
000: 157 Ohm
001: 157 Ohm
010: 78 Ohm
011: 53 Ohm
100: 39 Ohm
101: 32 Ohm
110: 26 Ohm
111: 23 Ohm</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="IOC">
      <name>PIOC</name>
      <description>PIOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf40d8000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="IOC">
      <name>BIOC</name>
      <description>BIOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf5010000</baseAddress>
    </peripheral>
    <peripheral>
      <name>OTPSHW</name>
      <description>OTPSHW</description>
      <groupName>OTP</groupName>
      <baseAddress>0xf4080000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xc08</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>128</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SHADOW000,SHADOW001,SHADOW002,SHADOW003,SHADOW004,SHADOW005,SHADOW006,SHADOW007,SHADOW008,SHADOW009,SHADOW010,SHADOW011,SHADOW012,SHADOW013,SHADOW014,SHADOW015,SHADOW016,SHADOW017,SHADOW018,SHADOW019,SHADOW020,SHADOW021,SHADOW022,SHADOW023,SHADOW024,SHADOW025,SHADOW026,SHADOW027,SHADOW028,SHADOW029,SHADOW030,SHADOW031,SHADOW032,SHADOW033,SHADOW034,SHADOW035,SHADOW036,SHADOW037,SHADOW038,SHADOW039,SHADOW040,SHADOW041,SHADOW042,SHADOW043,SHADOW044,SHADOW045,SHADOW046,SHADOW047,SHADOW048,SHADOW049,SHADOW050,SHADOW051,SHADOW052,SHADOW053,SHADOW054,SHADOW055,SHADOW056,SHADOW057,SHADOW058,SHADOW059,SHADOW060,SHADOW061,SHADOW062,SHADOW063,SHADOW064,SHADOW065,SHADOW066,SHADOW067,SHADOW068,SHADOW069,SHADOW070,SHADOW071,SHADOW072,SHADOW073,SHADOW074,SHADOW075,SHADOW076,SHADOW077,SHADOW078,SHADOW079,SHADOW080,SHADOW081,SHADOW082,SHADOW083,SHADOW084,SHADOW085,SHADOW086,SHADOW087,SHADOW088,SHADOW089,SHADOW090,SHADOW091,SHADOW092,SHADOW093,SHADOW094,SHADOW095,SHADOW096,SHADOW097,SHADOW098,SHADOW099,SHADOW100,SHADOW101,SHADOW102,SHADOW103,SHADOW104,SHADOW105,SHADOW106,SHADOW107,SHADOW108,SHADOW109,SHADOW110,SHADOW111,SHADOW112,SHADOW113,SHADOW114,SHADOW115,SHADOW116,SHADOW117,SHADOW118,SHADOW119,SHADOW120,SHADOW121,SHADOW122,SHADOW123,SHADOW124,SHADOW125,SHADOW126,SHADOW127</dimIndex>
          <name>SHADOW[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW</name>
              <description>shadow register of fuse for pmic area
for PMIC, index valid for 0-15, for SOC index valid for 16-128</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOCK00,LOCK01,LOCK02,LOCK03,LOCK04,LOCK05,LOCK06,LOCK07</dimIndex>
          <name>SHADOW_LOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock for pmic part shadow registers, 2 bits per 32 bit word, lock behavior is different between different fuse types
00: not locked
01: soft locked
10: not locked, and cannot lock in furture
11: double locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>128</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>FUSE000,FUSE001,FUSE002,FUSE003,FUSE004,FUSE005,FUSE006,FUSE007,FUSE008,FUSE009,FUSE010,FUSE011,FUSE012,FUSE013,FUSE014,FUSE015,FUSE016,FUSE017,FUSE018,FUSE019,FUSE020,FUSE021,FUSE022,FUSE023,FUSE024,FUSE025,FUSE026,FUSE027,FUSE028,FUSE029,FUSE030,FUSE031,FUSE032,FUSE033,FUSE034,FUSE035,FUSE036,FUSE037,FUSE038,FUSE039,FUSE040,FUSE041,FUSE042,FUSE043,FUSE044,FUSE045,FUSE046,FUSE047,FUSE048,FUSE049,FUSE050,FUSE051,FUSE052,FUSE053,FUSE054,FUSE055,FUSE056,FUSE057,FUSE058,FUSE059,FUSE060,FUSE061,FUSE062,FUSE063,FUSE064,FUSE065,FUSE066,FUSE067,FUSE068,FUSE069,FUSE070,FUSE071,FUSE072,FUSE073,FUSE074,FUSE075,FUSE076,FUSE077,FUSE078,FUSE079,FUSE080,FUSE081,FUSE082,FUSE083,FUSE084,FUSE085,FUSE086,FUSE087,FUSE088,FUSE089,FUSE090,FUSE091,FUSE092,FUSE093,FUSE094,FUSE095,FUSE096,FUSE097,FUSE098,FUSE099,FUSE100,FUSE101,FUSE102,FUSE103,FUSE104,FUSE105,FUSE106,FUSE107,FUSE108,FUSE109,FUSE110,FUSE111,FUSE112,FUSE113,FUSE114,FUSE115,FUSE116,FUSE117,FUSE118,FUSE119,FUSE120,FUSE121,FUSE122,FUSE123,FUSE124,FUSE125,FUSE126,FUSE127</dimIndex>
          <name>FUSE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUSE</name>
              <description>fuse array, valid in PMIC part only
read operation will read out value in fuse array
write operation will update fuse array value(please make sure fuse is unlocked and  2.5V power is ready)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOCK00,LOCK01,LOCK02,LOCK03,LOCK04,LOCK05,LOCK06,LOCK07</dimIndex>
          <name>FUSE_LOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock for fuse array, 2 bits per 32 bit word, lock behavior is different between different fuse types
00: not locked
01: soft locked
10: not locked, and cannot lock in furture
11: double locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLOCK</name>
          <description>UNLOCK</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>unlock word for fuse array operation
write "OPEN" to unlock fuse array, write any other value will lock write to fuse.
Please make sure 24M crystal is running and 2.5V LDO working properly</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <description>DATA</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data register for non-blocking access
this register hold dat read from fuse array or data to by programmed to fuse array</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDR</name>
          <description>ADDR</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>word address to be read or write</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>CMD</description>
          <addressOffset>0x80c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>command to access fure array
"BLOW" will update fuse word at ADDR to value hold in DATA
"READ" will fetch fuse value in at ADDR to DATA register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD_REQ</name>
          <description>LOAD Request</description>
          <addressOffset>0xa00</addressOffset>
          <size>32</size>
          <resetValue>0x00000007</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>REQUEST</name>
              <description>reload request for 4 regions
bit0: region0
bit1: region1
bit2: region2
bit3: region3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD_COMP</name>
          <description>LOAD complete</description>
          <addressOffset>0xa04</addressOffset>
          <size>32</size>
          <resetValue>0x00000007</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>COMPLETE</name>
              <description>reload complete sign for 4 regions
bit0: region 0
bit1: region1
bit2: region2
bit3: region3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOAD_REGION0,LOAD_REGION1,LOAD_REGION2,LOAD_REGION3</dimIndex>
          <name>REGION[%s]</name>
          <description>no description available</description>
          <addressOffset>0xa20</addressOffset>
          <size>32</size>
          <resetValue>0x00000800</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>STOP</name>
              <description>stop address of load region, fuse word at end address will NOT be reloaded
region0: fixed at 8
region1: fixed at 16
region2: fixed at 0,
region3: usrer configurable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>start address of load region,  fuse word at start address will be reloaded
region0: fixed at 0
region1: fixed at 8
region2: fixed at 16,
region3: usrer configurable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_FLAG</name>
          <description>interrupt flag</description>
          <addressOffset>0xc00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>WRITE</name>
              <description>fuse write flag, write 1 to clear
0: fuse is not written or writing
1: value in DATA register is programmed into fuse</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ</name>
              <description>fuse read flag, write 1 to clear
0: fuse is not read or reading
1: fuse value is put in DATA register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOAD</name>
              <description>fuse load flag, write 1 to clear
0: fuse is not loaded or loading
1: fuse loaded</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>interrupt enable</description>
          <addressOffset>0xc04</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>WRITE</name>
              <description>fuse write interrupt enable
0: fuse write interrupt is not enable
1: fuse write interrupt is enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ</name>
              <description>fuse read interrupt enable
0: fuse read interrupt is not enable
1: fuse read interrupt is enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOAD</name>
              <description>fuse load interrupt enable
0: fuse load interrupt is not enable
1: fuse load interrupt is enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="OTPSHW">
      <name>OTP</name>
      <description>OTP</description>
      <groupName>OTP</groupName>
      <baseAddress>0xf40c8000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PPOR</name>
      <description>PPOR</description>
      <groupName>PPOR</groupName>
      <baseAddress>0xf40c0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RESET_FLAG</name>
          <description>flag indicate reset source</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>reset reason of last hard reset, write 1 to clear each bit
0: brownout
1: temperature(not available)
2: resetpin(not available)
4: debug reset
5: jtag reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2
19: watch dog 3
20: pmic watch dog
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_STATUS</name>
          <description>reset source status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>current status of reset sources
0: brownout
1: temperature(not available)
2: resetpin(not available)
4: debug reset
5: jtag reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2
19: watch dog 3
20: pmic watch dog
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_HOLD</name>
          <description>reset hold attribute</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>hold arrtibute, when set, SOC keep in reset status until reset source release, or, reset will be released after SOC enter reset status
0: brownout
1: temperature(not available)
2: resetpin(not available)
4: debug reset
5: jtag reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2
19: watch dog 3
20: pmic watch dog
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_ENABLE</name>
          <description>reset source enable</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>enable of reset sources
0: brownout
1: temperature(not available)
2: resetpin(not available)
4: debug reset
5: jtag reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2
19: watch dog 3
20: pmic watch dog
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_HOT</name>
          <description>reset type triggered by reset</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TYPE</name>
              <description>reset type of reset sources, 0 for cold/warm reset, all system control setting cleared including clock, ioc; 1 for hot reset, system control, ioc setting kept, peripheral setting cleared.
0: brownout
1: temperature(not available)
2: resetpin(not available)
4: debug reset
5: jtag reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2
19: watch dog 3
20: pmic watch dog
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_COLD</name>
          <description>reset type attribute</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>perform cold or warm reset of chip, 0 for warm reset, fuse value and debug connection preserved; 1 for cold reset, fuse value reloaded and debug connection corrupted.  This bit is ignored when hot reset selected
0: brownout
1: temperature(not available)
2: resetpin(not available)
4: debug reset
5: jtag reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2
19: watch dog 3
20: pmic watch dog
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SOFTWARE_RESET</name>
          <description>Software reset counter</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>counter decrease in 24MHz and stop at 0, trigger reset when value reach 2, software can write 0 to cancel reset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PCFG</name>
      <description>PCFG</description>
      <groupName>PCFG</groupName>
      <baseAddress>0xf40c4000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x70</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BANDGAP</name>
          <description>BANGGAP control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00101010</resetValue>
          <resetMask>0x831F1F1F</resetMask>
          <fields>
            <field>
              <name>VBG_TRIMMED</name>
              <description>Bandgap trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: bandgap is not trimmed
1: bandgap is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOWPOWER_MODE</name>
              <description>Banggap work in low power mode, banggap function limited
0: banggap works in normal mode
1: banggap works in low power mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_SAVE</name>
              <description>Banggap work in power save mode, banggap function normally
0: banggap works in high performance mode
1: banggap works in power saving mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_1P0_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P65_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P50_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDO1P1</name>
          <description>1V LDO config</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0000044C</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>VOLT</name>
              <description>LDO output voltage in mV,  value valid through 700-1320, , step 20mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1320mV.
700: 700mV
720: 720mV
. . .
1320:1320mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDO2P5</name>
          <description>2.5V LDO config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x000009C4</resetValue>
          <resetMask>0x10010FFF</resetMask>
          <fields>
            <field>
              <name>READY</name>
              <description>Ready flag, will set 1ms after enabled or voltage change
0: LDO is not ready for use
1: LDO is ready</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>LDO enable
0: turn off LDO
1: turn on LDO</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VOLT</name>
              <description>LDO output voltage in mV,  value valid through 2125-2900, step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 2900mV.
2125: 2125mV
2150: 2150mV
. . .
2900:2900mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_MODE</name>
          <description>DCDC mode select</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0001047E</resetValue>
          <resetMask>0x10070FFF</resetMask>
          <fields>
            <field>
              <name>READY</name>
              <description>Ready flag
0: DCDC is applying new change
1: DCDC is ready</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODE</name>
              <description>DCDC work mode
XX0: turn off
001: basic mode
011: generic mode
101: automatic mode
111: expert mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VOLT</name>
              <description>DCDC voltage in mV in normal mode,  value valid through 600-1375, , step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1375mV.
600: 600mV
625: 625mV
. . .
1375:1375mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_LPMODE</name>
          <description>DCDC low power mode</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000384</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>STBY_VOLT</name>
              <description>DCDC voltage in mV in standby mode,  ,  value valid through 600-1375, , step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1375mV.
600: 600mV
625: 625mV
. . .
1375:1375mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_PROT</name>
          <description>DCDC protection</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x11818191</resetMask>
          <fields>
            <field>
              <name>ILIMIT_LP</name>
              <description>over current setting for low power mode
0:250mA
1:200mA</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLOAD_LP</name>
              <description>over current in low power mode
0: current is below setting
1: overcurrent happened in low power mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_POWER_LOSS</name>
              <description>disable power loss protection
0: power loss protection enabled, DCDC shuts down when power loss
1: power loss protection disabled, DCDC try working after power voltage drop</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_LOSS_FLAG</name>
              <description>power loss
0: input power is good
1: input power is too low</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_OVERVOLTAGE</name>
              <description>output over voltage protection
0: protection enabled, DCDC will shut down is output voltage is unexpected high
1: protection disabled, DCDC continue to adjust output voltage</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERVOLT_FLAG</name>
              <description>output over voltage flag
0: output is normal
1: output is unexpected high</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_SHORT</name>
              <description>disable output short circuit protection
0: short circuits protection enabled, DCDC shut down if short circuit on output detected
1: short circuit protection disabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHORT_CURRENT</name>
              <description>short circuit current setting
0: 2.0A,
1: 1.3A</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHORT_FLAG</name>
              <description>short circuit flag
0: current is within limit
1: short circuits detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_CURRENT</name>
          <description>DCDC current estimation</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000811F</resetMask>
          <fields>
            <field>
              <name>ESTI_EN</name>
              <description>enable current measure</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Current level valid
0: data is invalid
1: data is valid</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEVEL</name>
              <description>DCDC current level, current level is num * 50mA</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_ADVMODE</name>
          <description>DCDC advance setting</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x03120040</resetValue>
          <resetMask>0x073F006F</resetMask>
          <fields>
            <field>
              <name>EN_RCSCALE</name>
              <description>Enable RC scale</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_C</name>
              <description>Loop C number</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_R</name>
              <description>Loop R number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_FF_DET</name>
              <description>enable feed forward detect
0: feed forward detect is disabled
1: feed forward detect is enabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_FF_LOOP</name>
              <description>enable feed forward loop
0: feed forward loop is disabled
1: feed forward loop is enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DCM_EXIT</name>
              <description>avoid over voltage
0: stay in DCM mode when voltage excess
1: change to CCM mode when voltage excess</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_SKIP</name>
              <description>enable skip on narrow pulse
0: do not skip narrow pulse
1: skip narrow pulse</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_IDLE</name>
              <description>enable skip when voltage is higher than threshold
0: do not skip
1: skip if voltage is excess</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DCM</name>
              <description>DCM mode
0: CCM mode
1: DCM mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_ADVPARAM</name>
          <description>DCDC advance parameter</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00006E1C</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>MIN_DUT</name>
              <description>minimum duty cycle</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_DUT</name>
              <description>maximum duty cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_MISC</name>
          <description>DCDC misc parameter</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00070100</resetValue>
          <resetMask>0x13170317</resetMask>
          <fields>
            <field>
              <name>EN_HYST</name>
              <description>hysteres enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_SIGN</name>
              <description>hysteres sign</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_THRS</name>
              <description>hysteres threshold</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RC_SCALE</name>
              <description>Loop RC scale threshold</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_FF</name>
              <description>Loop feed forward number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OL_THRE</name>
              <description>overload for threshold for lod power mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OL_HYST</name>
              <description>current hysteres range
0: 12.5mV
1: 25mV</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY</name>
              <description>enable delay
0: delay disabled,
1: delay enabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>clock selection
0: select DCDC internal oscillator
1: select RC24M oscillator</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_STEP</name>
              <description>enable stepping in voltage change
0: stepping disabled,
1: steping enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_DEBUG</name>
          <description>DCDC Debug</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00005DBF</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>UPDATE_TIME</name>
              <description>DCDC voltage change time in 24M clock cycles, default value is 1mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_START_TIME</name>
          <description>DCDC ramp time</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0001193F</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>START_TIME</name>
              <description>Start delay for DCDC to turn on, in 24M clock cycles, default value is 3mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_RESUME_TIME</name>
          <description>DCDC resume time</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00008C9F</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>RESUME_TIME</name>
              <description>Resume delay for DCDC to recover from low power mode, in 24M clock cycles, default value is 1.5mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POWER_TRAP</name>
          <description>SOC power trap</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80010001</resetMask>
          <fields>
            <field>
              <name>TRIGGERED</name>
              <description>Low power trap status, thit bit will set when power related low power flow triggered, write 1 to clear this flag.
0: low power trap is not triggered
1: low power trap triggered</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RETENTION</name>
              <description>DCDC enter standby mode, which will reduce voltage for memory content retention
0: Shutdown DCDC
1: reduce DCDC voltage</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRAP</name>
              <description>Enable trap of SOC power supply, trap is used to hold SOC in low power mode for DCDC to enter further low power mode, this bit will self-clear when power related low pwer flow triggered
0: trap not enabled, pmic side low power function disabled
1: trap enabled, STOP operation leads to PMIC low power flow if SOC is not retentioned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKE_CAUSE</name>
          <description>Wake up source</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAUSE</name>
              <description>wake up cause, each bit represents one wake up source, write 1 to clear the register bit
0: wake up source is not active during last wakeup
1: wake up source is active furing last wakeup
bit 0: pmic_enable
bit 1: debug wakeup
bit 4: fuse interrupt
bit 7: UART interrupt
bit 8: TMR interrupt
bit 9: WDG interrupt
bit10: GPIO in PMIC interrupt
bit11: Security monitor interrupt
bit12: Security in PMIC event
bit16: Security violation in BATT
bit17: GPIO in BATT interrupt
bit18: BATT Button interrupt
bit19: RTC alarm interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKE_MASK</name>
          <description>Wake up mask</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>mask for wake up sources, each bit represents one wakeup source
0: allow source to wake up system
1: disallow source to wakeup system
bit 0: pmic_enable
bit 1: debug wakeup
bit 4: fuse interrupt
bit 7: UART interrupt
bit 8: TMR interrupt
bit 9: WDG interrupt
bit10: GPIO in PMIC interrupt
bit11: Security monitor interrupt
bit12: Security in PMIC event
bit16: Security violation in BATT
bit17: GPIO in BATT interrupt
bit18: BATT Button interrupt
bit19: RTC alarm interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCG_CTRL</name>
          <description>Clock gate control in PMIC</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCG</name>
              <description>control whether clock being gated during PMIC low power flow, 2 bits for each peripheral
00,01: reserved
10: clock is always off
11: clock is always on
bit0-1: fuse
bit6-7:gpio
bit8-9:ioc
bit10-11: timer
bit12-13:wdog
bit14-15:uart
bit16-17:debug</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBUG_STOP</name>
          <description>Debug stop config</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>CPU1</name>
              <description>Stop peripheral when CPU1 enter debug mode
0: peripheral keep running when CPU1 in debug mode
1: peripheral enter debug mode when CPU1 enter debug</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU0</name>
              <description>Stop peripheral when CPU0 enter debug mode
0: peripheral keep running when CPU0 in debug mode
1: peripheral enter debug mode when CPU0 enter debug</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RC24M</name>
          <description>RC 24M config</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000310</resetValue>
          <resetMask>0x8000071F</resetMask>
          <fields>
            <field>
              <name>RC_TRIMMED</name>
              <description>RC24M trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: RC is not trimmed
1: RC is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_C</name>
              <description>Coarse trim for RC24M, bigger value means faster</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_F</name>
              <description>Fine trim for RC24M, bigger value means faster</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RC24M_TRACK</name>
          <description>RC 24M track mode</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010011</resetMask>
          <fields>
            <field>
              <name>SEL24M</name>
              <description>Select track reference
0: select 32K as reference
1: select 24M XTAL as reference</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RETURN</name>
              <description>Retrun default value when XTAL loss
0: remain last tracking value
1: switch to default value</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRACK</name>
              <description>track mode
0: RC24M free running
1: track RC24M to external XTAL</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRACK_TARGET</name>
          <description>RC 24M track target</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRE_DIV</name>
              <description>Divider for reference source</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TARGET</name>
              <description>Target frequency multiplier of divided source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>RC 24M track status</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0011871F</resetMask>
          <fields>
            <field>
              <name>SEL32K</name>
              <description>track is using XTAL32K
0: track is not using XTAL32K
1: track is using XTAL32K</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEL24M</name>
              <description>track is using XTAL24M
0: track is not using XTAL24M
1: track is using XTAL24M</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EN_TRIM</name>
              <description>default value takes effect
0: default value is invalid
1: default value is valid</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIM_C</name>
              <description>default coarse trim value</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIM_F</name>
              <description>default fine trim value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PSEC</name>
      <description>PSEC</description>
      <groupName>PSEC</groupName>
      <baseAddress>0xf40cc000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECURE_STATE</name>
          <description>Secure state</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000300F0</resetMask>
          <fields>
            <field>
              <name>ALLOW_NSC</name>
              <description>Non-secure state allow
0: system is not healthy to enter non-secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter non-secure state</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALLOW_SEC</name>
              <description>Secure state allow
0: system is not healthy to enter secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter secure state</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_FAIL</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in fail state
1: secure state is in fail state</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_NSC</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in non-secure state
1: secure state is in non-secure state</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_SEC</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in secure state
1: secure state is in secure state</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_INS</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in inspect state
1: secure state is in inspect state</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_STATE_CONFIG</name>
          <description>secure state configuration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000009</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Lock bit of allow restart setting, once locked, lock bit itself and configuration register will keep value until next reset
0: not locked, register can be modified
1: register locked, write access to the register is ignored</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALLOW_RESTART</name>
              <description>allow secure state restart from fail state
0: restart is not allowed, only hardware reset can recover secure state
1: software is allowed to switch to inspect state from fail state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VIOLATION_CONFIG</name>
          <description>Security violation config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESCALATE_CONFIG</name>
          <description>Escalate behavior on security event</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVENT</name>
          <description>Event and escalate status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF000C</resetMask>
          <fields>
            <field>
              <name>EVENT</name>
              <description>local event statue, each bit represents one security event</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_ESC_NSC</name>
              <description>PMIC is escalating non-secure event</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_ESC_SEC</name>
              <description>PMIC is escalting secure event</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFECYCLE</name>
          <description>Lifecycle</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>LIFECYCLE</name>
              <description>lifecycle status,
bit7: lifecycle_debate,
bit6: lifecycle_scribe,
bit5: lifecycle_no_ret,
bit4: lifecycle_return,
bit3: lifecycle_secure,
bit2: lifecycle_nonsec,
bit1: lifecycle_create,
bit0: lifecycle_unknow</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMON</name>
      <description>PMON</description>
      <groupName>PMON</groupName>
      <baseAddress>0xf40d0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>glitch0,glitch1,clock0,clock1</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Glitch and clock monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000011</resetMask>
            <fields>
              <field>
                <name>ACTIVE</name>
                <description>select glitch works in active mode or passve mode.
0: passive mode, depends on power glitch destroy DFF value
1: active mode, check glitch by DFF chain</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable glitch detector
0: detector disabled
1: detector enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Glitch and clock monitor status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag for glitch detected, write 1 to clear this flag
0: glitch not detected
1: glitch detected</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>IRQ_FLAG</name>
          <description>No description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>interrupt flag, each bit represents for one monitor, write 1 to clear interrupt flag
0: no monitor interrupt
1: monitor interrupt happened</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ_ENABLE</name>
          <description>No description available</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>interrupt enable, each bit represents for one monitor
0: monitor interrupt disabled
1: monitor interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PGPR</name>
      <description>PGPR</description>
      <groupName>PGPR</groupName>
      <baseAddress>0xf40d4000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PMIC_GPR00</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR01</name>
          <description>Generic control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR02</name>
          <description>Generic control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR03</name>
          <description>Generic control</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR04</name>
          <description>Generic control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR05</name>
          <description>Generic control</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR06</name>
          <description>Generic control</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR07</name>
          <description>Generic control</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR08</name>
          <description>Generic control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR09</name>
          <description>Generic control</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR10</name>
          <description>Generic control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR11</name>
          <description>Generic control</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR12</name>
          <description>Generic control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR13</name>
          <description>Generic control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR14</name>
          <description>Generic control</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR15</name>
          <description>Generic control</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PLLCTLV2</name>
      <description>PLLCTLV2</description>
      <groupName>PLLCTLV2</groupName>
      <baseAddress>0xf4100000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x200</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>XTAL</name>
          <description>OSC configuration</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0xB00FFFFF</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Busy flag
0: Oscillator is working or shutdown
1: Oscillator is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESPONSE</name>
              <description>Crystal oscillator status
0: Oscillator is not stable
1: Oscillator is stable for use</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Crystal oscillator enable status
0: Oscillator is off
1: Oscillator is on</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RAMP_TIME</name>
              <description>Rampup time of XTAL oscillator in cycles of RC24M clock
0: 0 cycle
1: 1 cycle
2: 2 cycle
1048575: 1048575 cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>pll0,pll1,pll2</dimIndex>
          <name>PLL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x80</addressOffset>
          <register>
            <name>MFI</name>
            <description>PLL0 multiple register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000010</resetValue>
            <resetMask>0xB000007F</resetMask>
            <fields>
              <field>
                <name>BUSY</name>
                <description>Busy flag
0: PLL is stable or shutdown
1: PLL is changing status</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>PLL status
0: PLL is not stable
1: PLL is stable for use</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>PLL enable status
0: PLL is off
1: PLL is on</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MFI</name>
                <description>loop back divider of PLL, support from 13 to 42, f=fref*(mfi + mfn/mfd)
0-15: invalid
16: divide by 16
17: divide by17
. . .
42: divide by 42
43~:invalid</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MFN</name>
            <description>PLL0 fraction numerator register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x09896800</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>MFN</name>
                <description>Numeratorof fractional part,f=fref*(mfi + mfn/mfd). This field supports changing while running.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MFD</name>
            <description>PLL0 fraction demoninator register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x0E4E1C00</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>MFD</name>
                <description>Demoninator of fraction part,f=fref*(mfi + mfn/mfd).  This field should not be changed during PLL enabled.  If changed, change will take efftect when PLL re-enabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SS_STEP</name>
            <description>PLL0 spread spectrum step register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>STEP</name>
                <description>Step of spread spectrum modulator.
This register should not be changed during PLL and spread spectrum enabled.  If changed, new value will take effect when PLL disabled or spread spectrum disabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SS_STOP</name>
            <description>PLL0 spread spectrum stop register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>STOP</name>
                <description>Stop point of spread spectrum modulator
This register should not be changed during PLL and spread spectrum enabled.  If changed, new value will take effect when PLL disabled or spread spectrum disabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>PLL0 confguration register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000101</resetMask>
            <fields>
              <field>
                <name>SPREAD</name>
                <description>Enable spread spectrum function.  This field supports changing during PLL running.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REFSEL</name>
                <description>Select reference clock, This filed support changing while running, but application must take frequency error and jitter into consideration.  And if MFN changed before reference switch, application need make sure time is enough for MFN updating.
0: XTAL24M
1: IRC24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCKTIME</name>
            <description>PLL0 lock time register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x000009C4</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>LOCKTIME</name>
                <description>Lock time of PLL in 24M clock cycles, typical value is 2500.  If MFI changed during PLL startup, PLL lock time may be longer than this setting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STEPTIME</name>
            <description>PLL0 step time register</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x000009C4</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>STEPTIME</name>
                <description>Step time for MFI on-the-fly change in 24M clock cycles, typical value is 2500.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADVANCED</name>
            <description>PLL0 advance configuration register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x11000000</resetMask>
            <fields>
              <field>
                <name>SLOW</name>
                <description>Use slow lock flow, PLL lock expendite is disabled.  This mode might be stabler. And software need config LOCKTIME field accordingly.
0: fast lock enabled, lock time is 100us
1: fast lock disabled, lock time is 400us</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DITHER</name>
                <description>Enable dither function</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>3</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>DIV0,DIV1,DIV2</dimIndex>
            <name>DIV[%s]</name>
            <description>no description available</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xB000003F</resetMask>
            <fields>
              <field>
                <name>BUSY</name>
                <description>Busy flag
0: divider is working
1: divider is changing status</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>Divider response status
0: Divider is not stable
1: Divider is stable for use</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Divider enable status
0: Divider is off
1: Divider is on</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIV</name>
                <description>Divider factor, divider factor is DIV/5 + 1
0: divide by 1
1: divide by 1.2
2: divide by 1.4
. . .
63: divide by 13.6</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TSNS</name>
      <description>TSNS</description>
      <groupName>TSNS</groupName>
      <baseAddress>0xf4104000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>T</name>
          <description>Temperature</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Signed number of temperature in 256 x celsius degree</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TMAX</name>
          <description>Maximum Temperature</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0xFF800000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>maximum temperature ever found</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TMIN</name>
          <description>Minimum Temperature</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x007FFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>minimum temperature ever found</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AGE</name>
          <description>Sample age</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AGE</name>
              <description>age of T register in 24MHz clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>indicate value in T is valid or not
0: not valid
1:valid</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIGGER</name>
              <description>Software trigger for sensing in trigger mode, trigger will be ignored if in sensing or other mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONFIG</name>
          <description>Configuration</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00600300</resetValue>
          <resetMask>0xC3FF0713</resetMask>
          <fields>
            <field>
              <name>IRQ_EN</name>
              <description>Enable interrupt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RST_EN</name>
              <description>Enable reset</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_MIN_EN</name>
              <description>Enable compare for minimum temperature</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_MAX_EN</name>
              <description>Enable compare for maximum temperature</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPEED</name>
              <description>cycles of a progressive step in 24M clock, valid from 24-255, default 96
24: 24 cycle for a step
25: 25 cycle for a step
26: 26 cycle for a step
...
255: 255 cycle for a step</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVERAGE</name>
              <description>Average time, default in 3
0: measure and return
1: twice and average
2: 4 times and average
. . .
7: 128 times and average</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>continuous mode that keep sampling temperature peridically
0: trigger mode
1: continuous mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASYNC</name>
              <description>Acynchronous mode, this mode can work without clock, only available function ios compare to certain ADC value
0: active mode
1: Async mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable temperature
0: disable, temperature sensor is shut down
1: enable. Temperature sensor enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VALIDITY</name>
          <description>Sample validity</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x016E3600</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALIDITY</name>
              <description>time for temperature values to expire in 24M clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLAG</name>
          <description>Temperature flag</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00330001</resetMask>
          <fields>
            <field>
              <name>RECORD_MIN_CLR</name>
              <description>Clear minimum recorder of temerature, write 1 to clear</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RECORD_MAX_CLR</name>
              <description>Clear maximum recorder of temerature, write 1 to clear</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDER_TEMP</name>
              <description>Clear under temperature status, write 1 to clear</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVER_TEMP</name>
              <description>Clear over temperature status, write 1 to clear</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>IRQ flag, write 1 to clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPPER_LIM_IRQ</name>
          <description>Maximum temperature to interrupt</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Maximum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOWER_LIM_IRQ</name>
          <description>Minimum temperature to interrupt</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Minimum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPPER_LIM_RST</name>
          <description>Maximum temperature to reset</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Maximum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOWER_LIM_RST</name>
          <description>Minimum temperature to reset</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Minimum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNC</name>
          <description>Configuration in asynchronous mode</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x010107FF</resetMask>
          <fields>
            <field>
              <name>ASYNC_TYPE</name>
              <description>Compare hotter than or colder than in asynchoronous mode
0: hotter than
1: colder than</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Polarity of internal comparator</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE</name>
              <description>Value of async mode to compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADVAN</name>
          <description>Advance configuration</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03010003</resetMask>
          <fields>
            <field>
              <name>ASYNC_IRQ</name>
              <description>interrupt status of asynchronous mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE_IRQ</name>
              <description>interrupt status of active mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SAMPLING</name>
              <description>temperature sampling is working</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NEG_ONLY</name>
              <description>use negative compare polarity only</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_ONLY</name>
              <description>use positive compare polarity only</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BACC</name>
      <description>BACC</description>
      <groupName>BACC</groupName>
      <baseAddress>0xf5000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Access timing for access</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3000FFFF</resetMask>
          <fields>
            <field>
              <name>FAST_WRITE</name>
              <description>Use fast write
0: Write normally
1: boost write</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_READ</name>
              <description>Use fast read
0: Read normally
1: boost read</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMING</name>
              <description>Time in APB clock cycles, for battery timing penerate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRE_TIME</name>
          <description>Timing gap before rising edge</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>PRE_RATIO</name>
              <description>Ratio of guard band before rising edge
0: 0
1: 1/32768 of low level width
2: 1/16384 of low level width
14: 1/4 of low level width
15: 1/2 of low level width</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRE_OFFSET</name>
              <description>guard band before rising edge
this value will be added to ratio number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POST_TIME</name>
          <description>Timing gap after rising edge</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>POST_RATIO</name>
              <description>Ratio of guard band after rising edge
0: 0
1: 1/32768 of high level width
2: 1/16384 of high level width
14: 1/4 of high level width
15: 1/2 of high level width</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POST_OFFSET</name>
              <description>guard band after rising edge
this value will be added to ratio number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BPOR</name>
      <description>BPOR</description>
      <groupName>BPOR</groupName>
      <baseAddress>0xf5004000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>POR_CAUSE</name>
          <description>Power on cause</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>CAUSE</name>
              <description>Power on cause, each bit represnts one cause, write 1 to clear each bit
bit0: wakeup button
bit1: security violation
bit2: RTC alarm 0
bit3: RTC alarm 1
bit4: GPIO</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POR_SELECT</name>
          <description>Power on select</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>SELECT</name>
              <description>Power on cause select, each bit represnts one cause, value 1 enables corresponding cause
bit0: wakeup button
bit1: security violation
bit2: RTC alarm 0
bit3: RTC alarm 1
bit4: GPIO</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POR_CONFIG</name>
          <description>Power on reset config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RETENTION</name>
              <description>retention battery domain setting
0: battery reset on reset pin reset happen
1: battery domain retention when reset pin reset happen</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POR_CONTROL</name>
          <description>Power down control</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Chip power down counter, counter decreasing if value is not 0, power down of chip happens on counter value is 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BCFG</name>
      <description>BCFG</description>
      <groupName>BCFG</groupName>
      <baseAddress>0xf5008000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>VBG_CFG</name>
          <description>Bandgap config</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x831F1F1F</resetMask>
          <fields>
            <field>
              <name>VBG_TRIMMED</name>
              <description>Bandgap trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: bandgap is not trimmed
1: bandgap is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_MODE</name>
              <description>Bandgap works in low power  mode
0: not in low power mode
1: bandgap work in low power mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_SAVE</name>
              <description>Bandgap works in power save mode
0: not in power save mode
1: bandgap work in power save mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_1P0</name>
              <description>Bandgap 1.0V output trim</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P65</name>
              <description>Bandgap 0.65V output trim</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P50</name>
              <description>Bandgap 0.50V output trim</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRC32K_CFG</name>
          <description>On-chip 32k oscillator config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80C001FF</resetMask>
          <fields>
            <field>
              <name>IRC_TRIMMED</name>
              <description>IRC32K trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: irc is not trimmed
1: irc is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEX7_TRIM</name>
              <description>IRC32K bit 7</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEX6_TRIM</name>
              <description>IRC32K bit 6</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_TRIM</name>
              <description>capacitor trim bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XTAL32K_CFG</name>
          <description>XTAL 32K config</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001313</resetMask>
          <fields>
            <field>
              <name>HYST_EN</name>
              <description>crystal 32k hysteres enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GMSEL</name>
              <description>crystal 32k gm selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG</name>
              <description>crystal 32k config</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMP</name>
              <description>crystal 32k amplifier</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CFG</name>
          <description>Clock config</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x10010010</resetMask>
          <fields>
            <field>
              <name>XTAL_SEL</name>
              <description>crystal selected</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>KEEP_IRC</name>
              <description>force irc32k run</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_XTAL</name>
              <description>force switch to crystal</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BUTN</name>
      <description>BUTN</description>
      <groupName>BUTN</groupName>
      <baseAddress>0xf500c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xc</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BTN_STATUS</name>
          <description>Button status</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x77770FFF</resetMask>
          <fields>
            <field>
              <name>XWCLICK</name>
              <description>wake button click status when power button held, write 1 to clear flag
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WCLICK</name>
              <description>wake button click status, write 1 to clear flag
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XPCLICK</name>
              <description>power button click status when wake button held, write 1 to clear flag
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLICK</name>
              <description>power button click status, write 1 to clear flag
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBTN</name>
              <description>Dual button press status, write 1 to clear flag
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WBTN</name>
              <description>Wake button press status, write 1 to clear flag
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PBTN</name>
              <description>Power button press status, write 1 to clear flag
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BTN_IRQ_MASK</name>
          <description>Button interrupt mask</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x77770FFF</resetMask>
          <fields>
            <field>
              <name>XWCLICK</name>
              <description>wake button click status when power button held interrupt enable
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WCLICK</name>
              <description>wake button click interrupt enable
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XPCLICK</name>
              <description>power button click status when wake button held interrupt enable
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLICK</name>
              <description>power button click interrupt enable
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBTN</name>
              <description>Dual button press interrupt enable
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WBTN</name>
              <description>Wake button press interrupt enable
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PBTN</name>
              <description>Power button press interrupt enable
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LED_INTENSE</name>
          <description>Debounce setting</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F000F</resetMask>
          <fields>
            <field>
              <name>RLED</name>
              <description>Rbutton brightness 0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLED</name>
              <description>Pbutton brightness 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BGPR</name>
      <description>BGPR</description>
      <groupName>BGPR</groupName>
      <baseAddress>0xf5018000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>GPR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BSEC</name>
      <description>BSEC</description>
      <groupName>BSEC</groupName>
      <baseAddress>0xf5040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECURE_STATE</name>
          <description>Secure state</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003000F</resetMask>
          <fields>
            <field>
              <name>ALLOW_NSC</name>
              <description>Non-secure state allow
0: system is not healthy to enter non-secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter non-secure state</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALLOW_SEC</name>
              <description>Secure state allow
0: system is not healthy to enter secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter secure state</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_FAIL</name>
              <description>BATT secure state one hot indicator
0: secure state is not in fail state
1: secure state is in fail state</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_NSC</name>
              <description>BATT secure state one hot indicator
0: secure state is not in non-secure state
1: secure state is in non-secure state</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_SEC</name>
              <description>BATT secure state one hot indicator
0: secure state is not in secure state
1: secure state is in secure state</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_INS</name>
              <description>BATT secure state one hot indicator
0: secure state is not in inspect state
1: secure state is in inspect state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_STATE_CONFIG</name>
          <description>secure state configuration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000009</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Lock bit of allow restart setting, once locked, lock bit itself and configuration register will keep value until next reset
0: not locked, register can be modified
1: register locked, write access to the register is ignored</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALLOW_RESTART</name>
              <description>allow secure state restart from fail state
0: restart is not allowed, only hardware reset can recover secure state
1: software is allowed to switch to inspect state from fail state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VIOLATION_CONFIG</name>
          <description>Security violation config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESCALATE_CONFIG</name>
          <description>Escalate behavior on security event</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVENT</name>
          <description>Event and escalate status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>EVENT</name>
              <description>local event statue, each bit represents one security event</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_ESC_NSC</name>
              <description>BATT is escalating non-secure event</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_ESC_SEC</name>
              <description>BATT is escalting ssecure event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC</description>
      <groupName>RTC</groupName>
      <baseAddress>0xf5044000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECOND</name>
          <description>Second counter</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SECOND</name>
              <description>second counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SUBSEC</name>
          <description>Sub-second counter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBSEC</name>
              <description>sub second counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEC_SNAP</name>
          <description>Second counter snap shot</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC_SNAP</name>
              <description>second snap shot, write to take snap shot</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SUB_SNAP</name>
          <description>Sub-second counter snap shot</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUB_SNAP</name>
              <description>sub second snap shot, write to take snap shot</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM0</name>
          <description>RTC alarm0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALARM</name>
              <description>Alarm time for second counter, on each alarm match, alarm increase ALARM0_INC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM0_INC</name>
          <description>Alarm0 incremental</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCREASE</name>
              <description>adder when ARLAM0 happen, helps to create periodical alarm</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM1</name>
          <description>RTC alarm1</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALARM</name>
              <description>Alarm time for second counter, on each alarm match, alarm increase ALARM0_INC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM1_INC</name>
          <description>Alarm1 incremental</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCREASE</name>
              <description>adder when ARLAM0 happen, helps to create periodical alarm</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM_FLAG</name>
          <description>RTC alarm flag</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>alarm1 happen</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM0</name>
              <description>alarm0 happen</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM_EN</name>
          <description>RTC alarm enable</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>ENABLE1</name>
              <description>alarm1 mask
0: alarm1 disabled
1: alarm1 enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE0</name>
              <description>alarm0 mask
0: alarm0 disabled
1: alarm0 enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BKEY</name>
      <description>BKEY</description>
      <groupName>BKEY</groupName>
      <baseAddress>0xf5048000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>KEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
            <name>DATA[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>security key data</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>KEY0,KEY1</dimIndex>
          <name>ECC[%s]</name>
          <description>no description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>WLOCK</name>
              <description>write lock to key0
0: write enable
1: write ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLOCK</name>
              <description>read lock to key0
0: key read enable
1: key always read as 0</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC</name>
              <description>Parity check bits for key0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SELECT</name>
          <description>Key selection</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SELECT</name>
              <description>select key, key0 treated as secure key, in non-scure mode, only key1 can be selected
0: select key0 in secure mode, key1 in non-secure mode
1: select key1 in secure or nonsecure mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BMON</name>
      <description>BMON</description>
      <groupName>BMON</groupName>
      <baseAddress>0xf504c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>glitch0,clock0</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Glitch and clock monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000011</resetMask>
            <fields>
              <field>
                <name>ACTIVE</name>
                <description>select glitch works in active mode or passve mode.
0: passive mode, depends on power glitch destroy DFF value
1: active mode, check glitch by DFF chain</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable glitch detector
0: detector disabled
1: detector enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Glitch and clock monitor status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag for glitch detected, write 1 to clear this flag
0: glitch not detected
1: glitch detected</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TAMP</name>
      <description>TAMP</description>
      <groupName>TAMP</groupName>
      <baseAddress>0xf5050000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x88</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>tamp0,tamp1,tamp2,tamp3</dimIndex>
          <name>TAMP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Tamper n control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x801F03F7</resetMask>
            <fields>
              <field>
                <name>LOCK</name>
                <description>lock tamper setting
0: tamper setting can be changed
1: tamper setting will last to next battery domain power cycle</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS</name>
                <description>bypass tamper violation filter
0: filter applied
1: filter not used</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER</name>
                <description>filter length
0: 1 cycle
1: 2 cycle
15: 65526 cycle</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>VALUE</name>
                <description>pin value for passive tamper</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPEED</name>
                <description>tamper speed selection, (2^SPEED) changes per second
0: 1 shift per second
1: 2 shifts per second
. . .
15: 32768 shifts per second</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RECOVER</name>
                <description>tamper will recover itself if tamper LFSR goes wrong
0: tamper will not recover
1: tamper will recover</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE</name>
                <description>select active or passive tamper
0: passive tamper
1: active tamper</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable tamper
0: tamper disableed
1: tamper enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POLY</name>
            <description>Tamper n Polynomial of LFSR</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POLY</name>
                <description>tamper LFSR polyminal, this is a write once register, once write content is locked, and readout value is "1"</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LFSR</name>
            <description>Tamper n LFSR shift register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LFSR</name>
                <description>LFSR for active tamper, write only register, always read 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>TAMP_FLAG</name>
          <description>Tamper flag</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>tamper flag, each bit represents one tamper pin, write 1 to clear the flag
Note, clear can only be cleared when tamper disappeared</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ_EN</name>
          <description>Tamper interrupt enable</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000FFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock bit for IRQ enable
0: enable bits can be changed
1: enable bits hold until next battery domain power cycle</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ_EN</name>
              <description>interrupt enable, each bit represents one tamper pin
0: interrupt disabled
1: interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MONO</name>
      <description>MONO</description>
      <groupName>MONO</groupName>
      <baseAddress>0xf5054000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MONOL</name>
          <description>Low part of monotonic counter</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>low part of monotonica counter, write to this counter will cause counter increase by 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONOH</name>
          <description>High part of monotonic counter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPOCH</name>
              <description>Fuse value for high part of monotonica</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER</name>
              <description>high part of monotonica counter, write to this counter will cause counter increase by 1 if low part overflow</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
