<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Serial Flash (serial-flash)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Serial Flash (serial-flash)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__board__libs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Serial Flash</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p >In addition to the APIs for reading and writting to memory at runtime, this library also provides support for informing programming tools about the external memory so it can be be written at the same time as internal flash. </p>
<p >This support can be enabled by defining CY_ENABLE_XIP_PROGRAM while building the application. With this define in place, code will be generated in the .cy_sflash_user_data &amp; .cy_toc_part2 sections. These sections must be provided by the linker script for the application. One the application has been built, these locations can be read by programming tools (eg: Cypress Programmer, OpenOCD, pyOCD) to know that there is a memory device attached and how to program it. </p><dl class="section note"><dt>Note</dt><dd>This support is not compatible with the PSoCâ„¢ 64 series of devices.</dd></dl>
<h1><a class="anchor" id="section_resource_usage"></a>
DMA Resource Usage</h1>
<p >This library uses fixed DMA (Datawire or DW) resources and supports DMA only for the following devices. DMA is not supported for other devices and the functions <a class="el" href="group__group__board__libs.html#ga869d6c8e2b93215608161fb889675b82">cy_serial_flash_qspi_read_async()</a> and <a class="el" href="group__group__board__libs.html#ga49c497643b74f2e9071e27266836f45d">cy_serial_flash_qspi_abort_read()</a> will return <a class="el" href="group__group__board__libs.html#gabe7c8c3af5cdc0f9640b70402f543dd7">CY_RSLT_SERIAL_FLASH_ERR_UNSUPPORTED</a> error and <a class="el" href="group__group__board__libs.html#ga181056affe774bccde023137e1e01f3a">cy_serial_flash_qspi_set_dma_interrupt_priority()</a> will simply return doing nothing.</p><ul>
<li>CY8C6xx4, CY8C6xx5, CY8C6xx8, CY8C6xxA, CYB06xx5, CYB06xxA, CYS06xxA: <b>DW1, Channel 23</b></li>
<li>CY8C6xx6, CY8C6xx7, CYB06xx7: <b>DW1, Channel 15</b> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabe7c8c3af5cdc0f9640b70402f543dd7"><td class="memItemLeft" align="right" valign="top"><a id="gabe7c8c3af5cdc0f9640b70402f543dd7" name="gabe7c8c3af5cdc0f9640b70402f543dd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_RSLT_SERIAL_FLASH_ERR_UNSUPPORTED</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_FLASH, 1))</td></tr>
<tr class="memdesc:gabe7c8c3af5cdc0f9640b70402f543dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function or operation is not supported on the target or the memory. <br /></td></tr>
<tr class="separator:gabe7c8c3af5cdc0f9640b70402f543dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e3c8199504eb76df66c793488e01e8"><td class="memItemLeft" align="right" valign="top"><a id="ga21e3c8199504eb76df66c793488e01e8" name="ga21e3c8199504eb76df66c793488e01e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_RSLT_SERIAL_FLASH_ERR_BAD_PARAM</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_FLASH, 2))</td></tr>
<tr class="memdesc:ga21e3c8199504eb76df66c793488e01e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters passed to a function are invalid. <br /></td></tr>
<tr class="separator:ga21e3c8199504eb76df66c793488e01e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41875c99fa454d69ec187e772234ce44"><td class="memItemLeft" align="right" valign="top"><a id="ga41875c99fa454d69ec187e772234ce44" name="ga41875c99fa454d69ec187e772234ce44"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_RSLT_SERIAL_FLASH_ERR_READ_BUSY</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_FLASH, 3))</td></tr>
<tr class="memdesc:ga41875c99fa454d69ec187e772234ce44"><td class="mdescLeft">&#160;</td><td class="mdescRight">A previously initiated read operation is not yet complete. <br /></td></tr>
<tr class="separator:ga41875c99fa454d69ec187e772234ce44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63374cfb508c830f53f25682c183b610"><td class="memItemLeft" align="right" valign="top"><a id="ga63374cfb508c830f53f25682c183b610" name="ga63374cfb508c830f53f25682c183b610"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_RSLT_SERIAL_FLASH_ERR_DMA</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_FLASH, 4))</td></tr>
<tr class="memdesc:ga63374cfb508c830f53f25682c183b610"><td class="mdescLeft">&#160;</td><td class="mdescRight">A DMA error occurred during read transfer. <br /></td></tr>
<tr class="separator:ga63374cfb508c830f53f25682c183b610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga959a08da14d528096cf8ebbfb48c5da4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga959a08da14d528096cf8ebbfb48c5da4">CY_RSLT_SERIAL_FLASH_ERR_QSPI_BUSY</a>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_FLASH, 5))</td></tr>
<tr class="memdesc:ga959a08da14d528096cf8ebbfb48c5da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read abort failed.  <a href="group__group__board__libs.html#ga959a08da14d528096cf8ebbfb48c5da4">More...</a><br /></td></tr>
<tr class="separator:ga959a08da14d528096cf8ebbfb48c5da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93bd4d9c9082ff732c56c1a6657abc32"><td class="memItemLeft" align="right" valign="top"><a id="ga93bd4d9c9082ff732c56c1a6657abc32" name="ga93bd4d9c9082ff732c56c1a6657abc32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_SERIAL_FLASH_QSPI_THREAD_SAFE</b></td></tr>
<tr class="memdesc:ga93bd4d9c9082ff732c56c1a6657abc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables thread-safety for use with multi-threaded RTOS environment. <br /></td></tr>
<tr class="separator:ga93bd4d9c9082ff732c56c1a6657abc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa528d15ff15325aaec05e5a548856a19"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gaa528d15ff15325aaec05e5a548856a19">cy_serial_flash_qspi_read_complete_callback_t</a>) (cy_rslt_t operation_status, void *callback_arg)</td></tr>
<tr class="memdesc:gaa528d15ff15325aaec05e5a548856a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback pointer to use with <a class="el" href="group__group__board__libs.html#ga869d6c8e2b93215608161fb889675b82">cy_serial_flash_qspi_read_async()</a>.  <a href="group__group__board__libs.html#gaa528d15ff15325aaec05e5a548856a19">More...</a><br /></td></tr>
<tr class="separator:gaa528d15ff15325aaec05e5a548856a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa9c587684b8b629a0fde56e786400d82"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gaa9c587684b8b629a0fde56e786400d82">cy_serial_flash_qspi_init</a> (const cy_stc_smif_mem_config_t *mem_config, cyhal_gpio_t io0, cyhal_gpio_t io1, cyhal_gpio_t io2, cyhal_gpio_t io3, cyhal_gpio_t io4, cyhal_gpio_t io5, cyhal_gpio_t io6, cyhal_gpio_t io7, cyhal_gpio_t sclk, cyhal_gpio_t ssel, uint32_t hz)</td></tr>
<tr class="memdesc:gaa9c587684b8b629a0fde56e786400d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the serial flash memory.  <a href="group__group__board__libs.html#gaa9c587684b8b629a0fde56e786400d82">More...</a><br /></td></tr>
<tr class="separator:gaa9c587684b8b629a0fde56e786400d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4914a8bff25287d43c661d6cd68fbfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gac4914a8bff25287d43c661d6cd68fbfd">cy_serial_flash_qspi_deinit</a> (void)</td></tr>
<tr class="memdesc:gac4914a8bff25287d43c661d6cd68fbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the serial flash memory.  <a href="group__group__board__libs.html#gac4914a8bff25287d43c661d6cd68fbfd">More...</a><br /></td></tr>
<tr class="separator:gac4914a8bff25287d43c661d6cd68fbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9bff94b0c4ba30b11de9f64a0e4980"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga7b9bff94b0c4ba30b11de9f64a0e4980">cy_serial_flash_qspi_get_size</a> (void)</td></tr>
<tr class="memdesc:ga7b9bff94b0c4ba30b11de9f64a0e4980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the serial flash memory in bytes.  <a href="group__group__board__libs.html#ga7b9bff94b0c4ba30b11de9f64a0e4980">More...</a><br /></td></tr>
<tr class="separator:ga7b9bff94b0c4ba30b11de9f64a0e4980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaad29bc13d3a4cd243830980b21c274"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gacaad29bc13d3a4cd243830980b21c274">cy_serial_flash_qspi_get_erase_size</a> (uint32_t addr)</td></tr>
<tr class="memdesc:gacaad29bc13d3a4cd243830980b21c274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the erase sector to which the given address belongs.  <a href="group__group__board__libs.html#gacaad29bc13d3a4cd243830980b21c274">More...</a><br /></td></tr>
<tr class="separator:gacaad29bc13d3a4cd243830980b21c274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4219e6b1182c0c75704581b6cacc37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga3b4219e6b1182c0c75704581b6cacc37">cy_serial_flash_qspi_get_prog_size</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga3b4219e6b1182c0c75704581b6cacc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page size for programming of the sector to which the given address belongs.  <a href="group__group__board__libs.html#ga3b4219e6b1182c0c75704581b6cacc37">More...</a><br /></td></tr>
<tr class="separator:ga3b4219e6b1182c0c75704581b6cacc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aec27b28a9ce3205ce16e12c4d576b0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga1aec27b28a9ce3205ce16e12c4d576b0">cy_serial_flash_get_sector_start_address</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga1aec27b28a9ce3205ce16e12c4d576b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to calculate the starting address of an erase sector to which the given address belongs.  <a href="group__group__board__libs.html#ga1aec27b28a9ce3205ce16e12c4d576b0">More...</a><br /></td></tr>
<tr class="separator:ga1aec27b28a9ce3205ce16e12c4d576b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b700333be27d3f22dbf2b7a273e7f1e"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga8b700333be27d3f22dbf2b7a273e7f1e">cy_serial_flash_qspi_read</a> (uint32_t addr, size_t length, uint8_t *buf)</td></tr>
<tr class="memdesc:ga8b700333be27d3f22dbf2b7a273e7f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the serial flash memory.  <a href="group__group__board__libs.html#ga8b700333be27d3f22dbf2b7a273e7f1e">More...</a><br /></td></tr>
<tr class="separator:ga8b700333be27d3f22dbf2b7a273e7f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869d6c8e2b93215608161fb889675b82"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga869d6c8e2b93215608161fb889675b82">cy_serial_flash_qspi_read_async</a> (uint32_t addr, size_t length, uint8_t *buf, <a class="el" href="group__group__board__libs.html#gaa528d15ff15325aaec05e5a548856a19">cy_serial_flash_qspi_read_complete_callback_t</a> callback, void *callback_arg)</td></tr>
<tr class="memdesc:ga869d6c8e2b93215608161fb889675b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the serial flash memory.  <a href="group__group__board__libs.html#ga869d6c8e2b93215608161fb889675b82">More...</a><br /></td></tr>
<tr class="separator:ga869d6c8e2b93215608161fb889675b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c497643b74f2e9071e27266836f45d"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga49c497643b74f2e9071e27266836f45d">cy_serial_flash_qspi_abort_read</a> (void)</td></tr>
<tr class="memdesc:ga49c497643b74f2e9071e27266836f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts an ongoing asynchronous read initiated by calling <a class="el" href="group__group__board__libs.html#ga869d6c8e2b93215608161fb889675b82">cy_serial_flash_qspi_read_async()</a>.  <a href="group__group__board__libs.html#ga49c497643b74f2e9071e27266836f45d">More...</a><br /></td></tr>
<tr class="separator:ga49c497643b74f2e9071e27266836f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e5444e256507f0bc5d112d6741621a"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gab7e5444e256507f0bc5d112d6741621a">cy_serial_flash_qspi_write</a> (uint32_t addr, size_t length, const uint8_t *buf)</td></tr>
<tr class="memdesc:gab7e5444e256507f0bc5d112d6741621a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data to the serial flash memory.  <a href="group__group__board__libs.html#gab7e5444e256507f0bc5d112d6741621a">More...</a><br /></td></tr>
<tr class="separator:gab7e5444e256507f0bc5d112d6741621a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c8380588bc01b6a8320b23bc172649"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga41c8380588bc01b6a8320b23bc172649">cy_serial_flash_qspi_erase</a> (uint32_t addr, size_t length)</td></tr>
<tr class="memdesc:ga41c8380588bc01b6a8320b23bc172649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the serial flash memory, uses chip erase command when addr = 0 and length = flash_size otherwise uses sector erase command.  <a href="group__group__board__libs.html#ga41c8380588bc01b6a8320b23bc172649">More...</a><br /></td></tr>
<tr class="separator:ga41c8380588bc01b6a8320b23bc172649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56772d2543b7b7f2c17ed9ddb9db941e"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga56772d2543b7b7f2c17ed9ddb9db941e">cy_serial_flash_qspi_enable_xip</a> (bool enable)</td></tr>
<tr class="memdesc:ga56772d2543b7b7f2c17ed9ddb9db941e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables Execute-in-Place (memory mapped) mode on the MCU.  <a href="group__group__board__libs.html#ga56772d2543b7b7f2c17ed9ddb9db941e">More...</a><br /></td></tr>
<tr class="separator:ga56772d2543b7b7f2c17ed9ddb9db941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818e617f0abbff49f43ee1254d7bc35c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga818e617f0abbff49f43ee1254d7bc35c">cy_serial_flash_qspi_set_interrupt_priority</a> (uint8_t priority)</td></tr>
<tr class="memdesc:ga818e617f0abbff49f43ee1254d7bc35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes QSPI interrupt priority.  <a href="group__group__board__libs.html#ga818e617f0abbff49f43ee1254d7bc35c">More...</a><br /></td></tr>
<tr class="separator:ga818e617f0abbff49f43ee1254d7bc35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181056affe774bccde023137e1e01f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga181056affe774bccde023137e1e01f3a">cy_serial_flash_qspi_set_dma_interrupt_priority</a> (uint8_t priority)</td></tr>
<tr class="memdesc:ga181056affe774bccde023137e1e01f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the DMA interrupt priority.  <a href="group__group__board__libs.html#ga181056affe774bccde023137e1e01f3a">More...</a><br /></td></tr>
<tr class="separator:ga181056affe774bccde023137e1e01f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga959a08da14d528096cf8ebbfb48c5da4" name="ga959a08da14d528096cf8ebbfb48c5da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga959a08da14d528096cf8ebbfb48c5da4">&#9670;&nbsp;</a></span>CY_RSLT_SERIAL_FLASH_ERR_QSPI_BUSY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CY_RSLT_SERIAL_FLASH_ERR_QSPI_BUSY&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_FLASH, 5))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read abort failed. </p>
<p >QSPI block is busy. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa528d15ff15325aaec05e5a548856a19" name="gaa528d15ff15325aaec05e5a548856a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa528d15ff15325aaec05e5a548856a19">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_read_complete_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* cy_serial_flash_qspi_read_complete_callback_t) (cy_rslt_t operation_status, void *callback_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback pointer to use with <a class="el" href="group__group__board__libs.html#ga869d6c8e2b93215608161fb889675b82">cy_serial_flash_qspi_read_async()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation_status</td><td>Status of the read operation </td></tr>
    <tr><td class="paramname">callback_arg</td><td>Pointer to be passed back to the callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa9c587684b8b629a0fde56e786400d82" name="gaa9c587684b8b629a0fde56e786400d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9c587684b8b629a0fde56e786400d82">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_init </td>
          <td>(</td>
          <td class="paramtype">const cy_stc_smif_mem_config_t *&#160;</td>
          <td class="paramname"><em>mem_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>sclk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>ssel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the serial flash memory. </p>
<p >This function accepts up to 8 I/Os. Number of I/Os depend on the type of memory interface. Pass NC when an I/O is unused. Single SPI - (io0, io1) or (io2, io3) or (io4, io5) or (io6, io7) Dual SPI - (io0, io1) or (io2, io3) or (io4, io5) or (io6, io7) Quad SPI - (io0, io1, io2, io3) or (io4, io5, io6, io7) Octal SPI - All 8 I/Os are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_config</td><td>Memory configuration to be used for initializing </td></tr>
    <tr><td class="paramname">io0</td><td>Data/IO pin 0 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io1</td><td>Data/IO pin 1 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io2</td><td>Data/IO pin 2 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io3</td><td>Data/IO pin 3 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io4</td><td>Data/IO pin 4 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io5</td><td>Data/IO pin 5 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io6</td><td>Data/IO pin 6 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io7</td><td>Data/IO pin 7 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">sclk</td><td>Clock pin connected to the memory </td></tr>
    <tr><td class="paramname">ssel</td><td>Slave select pin connected to the memory </td></tr>
    <tr><td class="paramname">hz</td><td>Clock frequency to be used with the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the initialization was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="gac4914a8bff25287d43c661d6cd68fbfd" name="gac4914a8bff25287d43c661d6cd68fbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4914a8bff25287d43c661d6cd68fbfd">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_serial_flash_qspi_deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the serial flash memory. </p>
<p >Before calling this function, ensure that an ongoing asynchronous read operation is either completed or successfully aborted. Async read is started by calling <a class="el" href="group__group__board__libs.html#ga869d6c8e2b93215608161fb889675b82">cy_serial_flash_qspi_read_async()</a> and aborted by calling <a class="el" href="group__group__board__libs.html#ga49c497643b74f2e9071e27266836f45d">cy_serial_flash_qspi_abort_read()</a>. </p>

</div>
</div>
<a id="ga7b9bff94b0c4ba30b11de9f64a0e4980" name="ga7b9bff94b0c4ba30b11de9f64a0e4980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b9bff94b0c4ba30b11de9f64a0e4980">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cy_serial_flash_qspi_get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the serial flash memory in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Memory size in bytes. </dd></dl>

</div>
</div>
<a id="gacaad29bc13d3a4cd243830980b21c274" name="gacaad29bc13d3a4cd243830980b21c274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaad29bc13d3a4cd243830980b21c274">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_get_erase_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cy_serial_flash_qspi_get_erase_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the erase sector to which the given address belongs. </p>
<p >Address is used only for a memory with hybrid sector size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address that belongs to the sector for which size is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Erase sector size in bytes. </dd></dl>

</div>
</div>
<a id="ga3b4219e6b1182c0c75704581b6cacc37" name="ga3b4219e6b1182c0c75704581b6cacc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4219e6b1182c0c75704581b6cacc37">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_get_prog_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cy_serial_flash_qspi_get_prog_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the page size for programming of the sector to which the given address belongs. </p>
<p >Address is used only for a memory with hybrid sector size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address that belongs to the sector for which size is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Page size in bytes. </dd></dl>

</div>
</div>
<a id="ga1aec27b28a9ce3205ce16e12c4d576b0" name="ga1aec27b28a9ce3205ce16e12c4d576b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aec27b28a9ce3205ce16e12c4d576b0">&#9670;&nbsp;</a></span>cy_serial_flash_get_sector_start_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t cy_serial_flash_get_sector_start_address </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to calculate the starting address of an erase sector to which the given address belongs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address in the sector for which the starting address is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Starting address of the sector </dd></dl>

</div>
</div>
<a id="ga8b700333be27d3f22dbf2b7a273e7f1e" name="ga8b700333be27d3f22dbf2b7a273e7f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b700333be27d3f22dbf2b7a273e7f1e">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the serial flash memory. </p>
<p >This is a blocking function. Returns error if (addr + length) exceeds the flash size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Starting address to read from </td></tr>
    <tr><td class="paramname">length</td><td>Number of data bytes to read </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to the buffer to store the data read from the memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the read was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga869d6c8e2b93215608161fb889675b82" name="ga869d6c8e2b93215608161fb889675b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga869d6c8e2b93215608161fb889675b82">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_read_async </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#gaa528d15ff15325aaec05e5a548856a19">cy_serial_flash_qspi_read_complete_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the serial flash memory. </p>
<p >This is a non-blocking function. Returns error if (addr + length) exceeds the flash size. Uses fixed DMA (DW) instance and channel for transferring the data from QSPI RX FIFO to the user-provided buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Starting address to read from </td></tr>
    <tr><td class="paramname">length</td><td>Number of data bytes to read </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to the buffer to store the data read from the memory </td></tr>
    <tr><td class="paramname">callback</td><td>Pointer to the callback function to be called after the read operation is complete. Callback is invoked from the DMA ISR. </td></tr>
    <tr><td class="paramname">callback_arg</td><td>Pointer to the argument to be passed to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the read was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga49c497643b74f2e9071e27266836f45d" name="ga49c497643b74f2e9071e27266836f45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c497643b74f2e9071e27266836f45d">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_abort_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_abort_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts an ongoing asynchronous read initiated by calling <a class="el" href="group__group__board__libs.html#ga869d6c8e2b93215608161fb889675b82">cy_serial_flash_qspi_read_async()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the abort was successful, an error code if the QSPI block is still busy after a timeout. </dd></dl>

</div>
</div>
<a id="gab7e5444e256507f0bc5d112d6741621a" name="gab7e5444e256507f0bc5d112d6741621a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7e5444e256507f0bc5d112d6741621a">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the data to the serial flash memory. </p>
<p >The program area must have been erased prior to calling this API using <a class="el" href="group__group__board__libs.html#ga41c8380588bc01b6a8320b23bc172649">cy_serial_flash_qspi_erase()</a> This is a blocking function. Returns error if (addr + length) exceeds the flash size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Starting address to write to </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to write </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to the buffer storing the data to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the write was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga41c8380588bc01b6a8320b23bc172649" name="ga41c8380588bc01b6a8320b23bc172649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c8380588bc01b6a8320b23bc172649">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_erase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the serial flash memory, uses chip erase command when addr = 0 and length = flash_size otherwise uses sector erase command. </p>
<p >This is a blocking function. Returns error if addr or (addr + length) is not aligned to the sector size or if (addr + length) exceeds the flash size. For memories with hybrid sectors, returns error if the end address (=addr + length) is not aligned to the size of the sector in which the end address is located. Call <a class="el" href="group__group__board__libs.html#ga7b9bff94b0c4ba30b11de9f64a0e4980">cy_serial_flash_qspi_get_size()</a> to get the flash size and call <a class="el" href="group__group__board__libs.html#gacaad29bc13d3a4cd243830980b21c274">cy_serial_flash_qspi_get_erase_size()</a> to get the size of an erase sector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Starting address to begin erasing </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the erase was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga56772d2543b7b7f2c17ed9ddb9db941e" name="ga56772d2543b7b7f2c17ed9ddb9db941e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56772d2543b7b7f2c17ed9ddb9db941e">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_enable_xip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_enable_xip </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables Execute-in-Place (memory mapped) mode on the MCU. </p>
<p >This function does not send any command to the serial flash. This may not be supported on all the targets in which case CY_RSLT_SERIAL_FLASH_ERR_UNSUPPORTED is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true: XIP mode is set, false: normal mode is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the operation was successful. CY_RSLT_SERIAL_FLASH_ERR_UNSUPPORTED if the target does not support XIP. </dd></dl>

</div>
</div>
<a id="ga818e617f0abbff49f43ee1254d7bc35c" name="ga818e617f0abbff49f43ee1254d7bc35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga818e617f0abbff49f43ee1254d7bc35c">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_set_interrupt_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_serial_flash_qspi_set_interrupt_priority </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes QSPI interrupt priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>interrupt priority to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga181056affe774bccde023137e1e01f3a" name="ga181056affe774bccde023137e1e01f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga181056affe774bccde023137e1e01f3a">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_set_dma_interrupt_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_serial_flash_qspi_set_dma_interrupt_priority </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the DMA interrupt priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>interrupt priority to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Serial Flash (serial-flash)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
